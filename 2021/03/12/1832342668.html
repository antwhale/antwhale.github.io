<!DOCTYPE html>
<html lang="zh-Hans">

<head>
  <meta name="generator" content="Hexo 5.4.0">
  <meta charset="utf-8">
  

  <meta http-equiv="x-dns-prefetch-control" content="on">
  <link rel="dns-prefetch" href="https://cdn.jsdelivr.net">
  <link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin>

  <meta name="renderer" content="webkit">
  <meta name="force-rendering" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  <meta name="HandheldFriendly" content="True">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <title>SpringBoot单元测试 - BLOG | CAYZLH</title>

  
    <meta name="description" content="一、 单元测试的概念概念： 单元测试（unit testing），是指对软件中的最小可测试单元进行检查和验证。在Java中单元测试的最小单元是类。 单元测试是开发者编写的一小段代码，用于检验被测代码的一个很小的、很明确的功能是否正确。执行单元测试，就是为了证明这 段代码的行为和我们期望是否一致。  单元测试引用： 众所周知，通过spring initialize创建的Spring Boot项目会在">
<meta property="og:type" content="article">
<meta property="og:title" content="SpringBoot单元测试">
<meta property="og:url" content="https://www.cayzlh.com/2021/03/12/1832342668.html">
<meta property="og:site_name" content="BLOG | CAYZLH">
<meta property="og:description" content="一、 单元测试的概念概念： 单元测试（unit testing），是指对软件中的最小可测试单元进行检查和验证。在Java中单元测试的最小单元是类。 单元测试是开发者编写的一小段代码，用于检验被测代码的一个很小的、很明确的功能是否正确。执行单元测试，就是为了证明这 段代码的行为和我们期望是否一致。  单元测试引用： 众所周知，通过spring initialize创建的Spring Boot项目会在">
<meta property="og:locale">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/cayzlh/git-img-repository@master/2021/03/14044716155290871615529087504.jpg">
<meta property="og:image" content="https://7.dusays.com/2021/03/12/208e02005c0b7.png">
<meta property="og:image" content="https://7.dusays.com/2021/03/12/23696982579aa.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/cayzlh/git-img-repository@master/2021/03/14044716155290871615529087678.jpg">
<meta property="og:image" content="https://7.dusays.com/2021/03/12/8ca41b998aaab.png">
<meta property="og:image" content="https://7.dusays.com/2021/03/12/b9128a7d66811.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/cayzlh/git-img-repository@master/2021/03/14044716155290871615529087979.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/cayzlh/git-img-repository@master/2021/03/14044816155290881615529088115.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/cayzlh/git-img-repository@master/2021/03/14044816155290881615529088185.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/cayzlh/git-img-repository@master/2021/03/14044816155290881615529088275.jpg">
<meta property="og:image" content="https://7.dusays.com/2021/03/12/fb189913d88c3.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/cayzlh/git-img-repository@master/2021/03/14044816155290881615529088535.jpg">
<meta property="article:published_time" content="2021-03-12T06:02:10.000Z">
<meta property="article:modified_time" content="2021-03-12T06:34:53.864Z">
<meta property="article:author" content="🐳Ant丶">
<meta property="article:tag" content="转载">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/cayzlh/git-img-repository@master/2021/03/14044716155290871615529087504.jpg">
  
  

  <!-- feed -->
  
    <link rel="alternate" href="/blog/atom.xml" title="BLOG | CAYZLH" type="application/atom+xml">
  

  
    
<link rel="stylesheet" href="/blog/css/main.css">

  

  
</head>

<body>
  


  <div class="l_body" id="start">
    <aside class="l_left">
    

<header class="header">
  <div class="logo-wrap">
  
  
    <a class="title" href="/blog/">
      BLOG | CAYZLH
    </a>
  
</div>

  <nav class="menu dis-select"><a class="nav-item active" href="/blog/">Blog</a></nav>
</header>

<div class="widgets">
  
    
      
      
<div class="widget-wrap" id="toc"><div class="widget-header h4 dis-select"><span class="name">TOC</span></div><div class="widget-body fs14 post"><div class="doc-tree active"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-text">一、 单元测试的概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5%EF%BC%9A"><span class="toc-text">概念：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E5%BC%95%E7%94%A8%EF%BC%9A"><span class="toc-text">单元测试引用：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-text">二、单元测试的作用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%99%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E7%9A%84%E4%B8%A4%E4%B8%AA%E5%8A%A8%E6%9C%BA%EF%BC%9A"><span class="toc-text">写单元测试的两个动机：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81Spring-Boot%E5%BC%95%E5%85%A5%E7%9A%84MockMvc%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-text">三、Spring Boot引入的MockMvc的概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81Service%E5%B1%82%E7%9A%84%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95"><span class="toc-text">四、Service层的单元测试</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81Controller%E5%B1%82%E7%9A%84%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95"><span class="toc-text">五、Controller层的单元测试</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E6%96%AD%E8%A8%80%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-text">六、断言的概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E6%96%B0%E6%96%AD%E8%A8%80assertThat%E4%BD%BF%E7%94%A8"><span class="toc-text">七、新断言assertThat使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AB%E3%80%81Postman%E4%B8%8ESpring-Boot-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">八、Postman与Spring Boot 单元测试的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B9%9D%E3%80%81Postman%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95"><span class="toc-text">九、Postman基本用法</span></a></li></ol></div></div></div>

    
  
</div>


    </aside>
    <div class="l_main">
      

      


  <div class="bread-nav fs12">
  
    
    <div id="breadcrumb">
      <a class="cap breadcrumb" href="/">Home</a>
      <span class="sep"></span>
      <a class="cap breadcrumb" href="/">Blog</a>
      
        <span class="sep"></span>
        <a class="cap breadcrumb-link" href="/blog/categories/Spring/">Spring</a>
      
    </div>
    <div id="post-meta">
      Posted on&nbsp;<time datetime="2021-03-12T06:02:10.000Z">2021-03-12</time>
    </div>
  
  </div>


<article class="content md post">
<h1 class="article-title"><span>SpringBoot单元测试</span></h1>
<h2 id="一、-单元测试的概念"><a href="#一、-单元测试的概念" class="headerlink" title="一、 单元测试的概念"></a>一、 单元测试的概念</h2><h3 id="概念："><a href="#概念：" class="headerlink" title="概念："></a><strong>概念：</strong></h3><ol>
<li>单元测试（unit testing），是指对软件中的最小可测试单元进行检查和验证。在Java中单元测试的最小单元是类。</li>
<li>单元测试是开发者编写的一小段代码，用于检验被测代码的一个很小的、很明确的功能是否正确。执行单元测试，就是为了证明这 段代码的行为和我们期望是否一致。</li>
</ol>
<h3 id="单元测试引用："><a href="#单元测试引用：" class="headerlink" title="单元测试引用："></a><strong>单元测试引用：</strong></h3><ol>
<li>众所周知，通过spring initialize创建的Spring Boot项目会在Maven中自动携带很多starter依赖：</li>
</ol>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/cayzlh/git-img-repository@master/2021/03/14044716155290871615529087504.jpg" alt="图片"></p>
<p>其中包含了一个名为<code>spring-boot-starter-test</code>的依赖，本文是围绕这个依赖展开。</p>
<ol>
<li>Spring Boot中引入单元测试很简单，添加如下依赖（即<code>spring-boot-starter-test</code>依赖）：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;spring-boot-starter-test&lt;&#x2F;artifactId&gt;</span><br><span class="line">  &lt;scope&gt;test&lt;&#x2F;scope&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<ol>
<li>spring-boot-starter-test有如下几个库：</li>
</ol>
<p><code>spring-boot-starter-test</code>UML图：</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://7.dusays.com/2021/03/12/208e02005c0b7.png" alt="image-20210312142854430"></p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://7.dusays.com/2021/03/12/23696982579aa.png" alt="image-20210312142907488"></p>
<h2 id="二、单元测试的作用"><a href="#二、单元测试的作用" class="headerlink" title="二、单元测试的作用"></a>二、单元测试的作用</h2><p>在没有接触单元测试之前我们是怎么做测试的？一般有两个方法：</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/cayzlh/git-img-repository@master/2021/03/14044716155290871615529087678.jpg" alt="图片"></p>
<p>在时间允许的情况下，编写单元测试是程序员对代码的自测，这是对自己代码的负责。</p>
<h3 id="写单元测试的两个动机："><a href="#写单元测试的两个动机：" class="headerlink" title="写单元测试的两个动机："></a><strong>写单元测试的两个动机：</strong></h3><ol>
<li>保证或验证实现功能。</li>
<li>保护已经实现的功能不被破坏。</li>
</ol>
<h2 id="三、Spring-Boot引入的MockMvc的概念"><a href="#三、Spring-Boot引入的MockMvc的概念" class="headerlink" title="三、Spring Boot引入的MockMvc的概念"></a>三、Spring Boot引入的MockMvc的概念</h2><ol>
<li>什么是Mock?</li>
</ol>
<p>在面向对象的程序设计中，模拟对象（英语：mock object）是以可控的方式模拟真实对象行为的假对象。在编程过程中，通常通过模拟一些输入数据，来验证程序是否达到预期结果。</p>
<ol>
<li>为什么使用Mock对象？</li>
</ol>
<p>使用模拟对象，可以模拟复杂的、真实的对象行为。如果在单元测试中无法使用真实对象，可采用模拟对象进行替代。</p>
<ol>
<li>MockMvc的概念</li>
</ol>
<p>MockMvc是由spring-test包提供，实现了对Http请求的模拟，能够直接使用网络的形式，转换到Controller的调用，使得测试速度快、不依赖网络环境。同时提供了一套验证的工具，结果的验证十分方便。</p>
<p>接口MockMvcBuilder，提供一个唯一的build方法，用来构造MockMvc。主要有两个实现：StandaloneMockMvcBuilder和DefaultMockMvcBuilder。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://7.dusays.com/2021/03/12/8ca41b998aaab.png" alt="image-20210312142923082"></p>
<ol>
<li>MockMVC的基本步骤</li>
</ol>
<p>(1) mockMvc.perform执行一个请求。(2) MockMvcRequestBuilders.get(“XXX”)构造一个请求。(3) ResultActions.param添加请求传值 (4) ResultActions.accept()设置返回类型 (5) ResultActions.andExpect添加执行完成后的断言。(6) ResultActions.andDo添加一个结果处理器，表示要对结果做点什么事情，比如处使用print()输出整个响应结果信息。(7) ResultActions.andReturn表示执行完成后返回相应的结果。</p>
<h2 id="四、Service层的单元测试"><a href="#四、Service层的单元测试" class="headerlink" title="四、Service层的单元测试"></a>四、Service层的单元测试</h2><p><strong>第一步：</strong> Spring Boot中单元测试类写在src/test/java目录下，你可以手动创建具体测试类，也可以通过IDEA自动创建测试类，如下图：（注：点选并打开相应代码界面，再点击菜单栏的Navigate）</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://7.dusays.com/2021/03/12/b9128a7d66811.png" alt="image-20210312140744322"></p>
<p><strong>第二步：</strong> 按照第一步的方法，点击测试后，出现<strong>图一</strong> 的对话框（如果想要测试的类已经存在测试类了会被列出来，也可以重新创建一个新的测试类），点击”Create New Test…”会弹出<strong>图二</strong> 的对话框，可以选择是否生成setUp以及要测试的成员方法等：</p>
<p>图一</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/cayzlh/git-img-repository@master/2021/03/14044716155290871615529087979.jpg" alt="图片"></p>
<p>图二</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/cayzlh/git-img-repository@master/2021/03/14044816155290881615529088115.jpg" alt="图片"></p>
<p><strong>第三步：</strong> 至此Service层的测试类就创建好了，测试类自动生成到了src/test/java目录下<strong>项目的同级目录中</strong> ，如下图：</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/cayzlh/git-img-repository@master/2021/03/14044816155290881615529088185.jpg" alt="图片"></p>
<p>Service层测试代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@SpringBootTest</span><br><span class="line">@RunWith(SpringRunner.class)</span><br><span class="line">public class XXXServiceTest &#123;</span><br><span class="line">@Resource</span><br><span class="line">private XXXService XXXService;</span><br><span class="line">@Test</span><br><span class="line">public void conflictTime() &#123;</span><br><span class="line">        DateTimeFormatter dtf &#x3D; DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd&quot;);</span><br><span class="line">        LocalDate start &#x3D; LocalDate.parse(&quot;2020-10-26&quot;, dtf);</span><br><span class="line">        LocalDate end &#x3D; LocalDate.parse(&quot;2020-10-31&quot;, dtf);</span><br><span class="line">        Integer integer &#x3D; XXXService.ConflictTime(&quot;10000001&quot;, start, end);</span><br><span class="line">        Assert.assertThat(integer, Matchers.notNullValue());&#x2F;&#x2F;assertThat断言后面介绍</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注解解释：</strong></p>
<p><code>@SpringBootTest</code>：获取启动类，加载配置，寻找主配置启动类（被 @SpringBootApplication 注解的） <code>@RunWith(SpringRunner.class)</code>：让JUnit运行Spring的测试环境,获得Spring环境的上下文的支持</p>
<h2 id="五、Controller层的单元测试"><a href="#五、Controller层的单元测试" class="headerlink" title="五、Controller层的单元测试"></a>五、Controller层的单元测试</h2><p>创建测试类步骤见第四部分，此处略。</p>
<p>第四部分只是针对Service层做了测试，但是咱么也需要对Controller层（API）做测试，这时候就用到MockMvc了，它使得你无需启动项目工程就能测试这些接口</p>
<p>MockMvc实现了对Http请求的模拟，能够直接使用网络的形式，转换到Controller的调用，这样可以使得测试速度快、不依赖网络环境，而且提供了一套验证的工具，这样可以使得请求的验证统一而且很方便。</p>
<p>Controller层部分的代码将分为三个代码块讲解，里面有看不懂的代码先不要着急哦😄，会在第五部分结尾处给大家汇总解答的，大家要坚持看到最后哟！😁</p>
<p><strong>代码块一：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@SpringBootTest</span><br><span class="line">@RunWith(SpringRunner.class)</span><br><span class="line">@AutoConfigureMockMvc</span><br><span class="line">public class DfTaskRecordControllerTest &#123;</span><br><span class="line">@Autowired</span><br><span class="line">private MockMvc mockMvc;</span><br><span class="line">@Before</span><br><span class="line">public void setUp() throws Exception &#123;</span><br><span class="line">       System.out.println(&quot;---------------start---------------&quot;);</span><br><span class="line">       save();</span><br><span class="line">get();</span><br><span class="line">       System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;end&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>注解解释：</strong></p>
<p><code>@SpringBootTest</code>&gt;：获取启动类，加载配置，寻找主配置启动类（被 @SpringBootApplication 注解的）</p>
<p><code>@RunWith(SpringRunner.class)</code>&gt;：让JUnit运行Spring的测试环境,获得Spring环境的上下文的支持 <code>@AutoConfigureMockMvc</code>：用于自动配置MockMvc,配置后MockMvc类可以直接注入,相当于new MockMvc <code>@Before</code>:初始化方法 ,对于每一个测试方法都要执行一次</p>
<p><strong>代码块二：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">@Transactional</span><br><span class="line">@Rollback()</span><br><span class="line">public void save() throws Exception &#123;</span><br><span class="line">        String json&quot;&#123;……&#125;&quot;;</span><br><span class="line">&#x2F;&#x2F;执行一个RequestBuilder请求，会自动执行SpringMVC的流程并映射到相应的控制器执行处理；</span><br><span class="line">        mockMvc.perform(MockMvcRequestBuilders</span><br><span class="line">                .post(&quot;&#x2F;XXX&#x2F;save&quot;)</span><br><span class="line">                .content(json.getBytes()) &#x2F;&#x2F;传json参数</span><br><span class="line">                .accept(MediaType.APPLICATION_JSON)</span><br><span class="line">                .contentType(MediaType.APPLICATION_JSON_VALUE)</span><br><span class="line">                .header(&quot;Authorization&quot;,&quot;Bearer ********-****-****-****-************&quot;)</span><br><span class="line">        )</span><br><span class="line">                .andExpect(MockMvcResultMatchers.status().isOk())</span><br><span class="line">                .andDo(print());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>注解解释：</strong></p>
<p><code>@Transactional</code>:开启事务功能</p>
<p><code>@Rollback()</code>: 事务回滚,默认是true</p>
<p><strong>代码块三：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void get() throws Exception&#123;</span><br><span class="line">        ResultActions resultActions &#x3D; mockMvc.perform(MockMvcRequestBuilders</span><br><span class="line">                .get(&quot;&#x2F;XXX&#x2F;get&quot;)</span><br><span class="line">                .param(&quot;id&quot;, &quot;**********&quot;)</span><br><span class="line">                .header(&quot;Authorization&quot;, &quot;Bearer ********-****-****-****-************&quot;)</span><br><span class="line">        );</span><br><span class="line">        resultActions.andReturn().getResponse().setCharacterEncoding(&quot;UTF-8&quot;);</span><br><span class="line">        resultActions.andExpect(MockMvcResultMatchers.status().isOk()).andDo(print());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>/get</code>运行结果如下：</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/cayzlh/git-img-repository@master/2021/03/14044816155290881615529088275.jpg" alt="图片"></p>
<p><strong>现在将上面的一些琐碎的知识点汇总一下：</strong></p>
<p><code>1. mockMvc.perform</code>：执行一个请求</p>
<p><code>2. MockMvcRequestBuilders.get(“/XXX/get”)</code>：构造一个请求，Post请求使用.post方法</p>
<p><code>3. contentType(MediaType.APPLICATION_JSON_VALUE)</code>：代表发送端发送的数据格式是application/json;charset=UTF-8</p>
<p><code>4. accept(MediaType.APPLICATION_JSON)</code>：代表客户端希望接受的数据类型为application/json;charset=UTF-8</p>
<p><code>5. header(“Authorization”,“Bearer XXXX”)</code>：代表在报文头添加一些必须的信息，这里添加的是token</p>
<p><code>6. ResultActions.andExpect</code>：添加执行完成后的断言</p>
<p><code>7. ResultActions.andExpect(MockMvcResultMatchers.status().isOk())</code>：方法看请求的状态响应码是否为200如果不是则抛异常，测试不通过</p>
<p><code>8. ResultActions.andDo</code>：添加一个结果处理器，表示要对结果做点什么事情，比如此处使用print()：输出整个响应结果信息</p>
<h2 id="六、断言的概念"><a href="#六、断言的概念" class="headerlink" title="六、断言的概念"></a>六、断言的概念</h2><ol>
<li>断言（assert），是编程术语，表示为一些布尔表达式，程序员相信在程序中的某个特定点该表达式值为真。可以在任何时候启用和禁用断言验证，因此可以在测试时启用断言而在部署时禁用断言。</li>
<li>使用断言是判断一个函数或对象的一个方法所产生的结果是否符合你期望那个结果。</li>
</ol>
<h2 id="七、新断言assertThat使用"><a href="#七、新断言assertThat使用" class="headerlink" title="七、新断言assertThat使用"></a>七、新断言assertThat使用</h2><p>JUnit 4.4 结合 Hamcrest 提供了一个全新的断言语法——assertThat。程序员可以只使用 assertThat 一个断言语句，结合 Hamcrest 提供的匹配符，就可以表达全部的测试思想。</p>
<p><strong>assertThat 的优点：</strong></p>
<p><strong>优点 1：</strong> 以前 JUnit 提供了很多的 assertion 语句，如：assertEquals，assertNotSame，assertFalse，assertTrue，assertNotNull，assertNull 等，现在有了 JUnit 4.4，一条 assertThat 即可以替代所有的 assertion 语句，这样可以在所有的单元测试中只使用一个断言方法，使得编写测试用例变得简单，代码风格变得统一，测试代码也更容易维护。</p>
<p><strong>优点 2：</strong> assertThat 使用了 Hamcrest 的 Matcher 匹配符，用户可以使用匹配符规定的匹配准则精确的指定一些想设定满足的条件，具有很强的易读性，而且使用起来更加灵活。</p>
<p><strong>优点 3：</strong> assertThat 不再像 assertEquals 那样，使用比较难懂的“谓宾主”语法模式（如：assertEquals(3, x);），相反，assertThat 使用了类似于“主谓宾”的易读语法模式（如：assertThat(x,is(3));），使得代码更加直观、易读。</p>
<p><strong>assertThat 的基本语法如下：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">assertThat( [value], [matcher statement] );</span><br></pre></td></tr></table></figure>

<p><strong>value</strong> ：接下来想要测试的变量值；<strong>matcher statement</strong> ：使用 Hamcrest 匹配符来表达的对前面变量所期望的值的声明，如果 value 值与 matcher statement 所表达的期望值相符，则测试成功，否则测试失败。</p>
<h2 id="八、Postman与Spring-Boot-单元测试的区别"><a href="#八、Postman与Spring-Boot-单元测试的区别" class="headerlink" title="八、Postman与Spring Boot 单元测试的区别"></a>八、Postman与Spring Boot 单元测试的区别</h2><ol>
<li>Spring Boot的单元测试主要针对方法层面，可以测试Service层这类非对外暴露的接口的类中方法，并且可一次性批量测试多个方法、支持事务回滚。</li>
<li>Postman针对接口进行http测试，我平时这个比较多，创建的测试接口可保存、分类。</li>
</ol>
<h2 id="九、Postman基本用法"><a href="#九、Postman基本用法" class="headerlink" title="九、Postman基本用法"></a>九、Postman基本用法</h2><p>Postman是一款功能强大的网页调试与发送网页HTTP请求的工具。Postman能够发送任何类型的HTTP请求(GET, HEAD, POST,PUT..)，附带任何数量的参数和HTTP headers。支持不同的认证机制（basic, digest,OAuth），接收到的响应语法高亮（HTML，JSON或XML）。</p>
<p><strong>安装Postman</strong></p>
<p>官方网站：</p>
<p><a target="_blank" rel="external nofollow noopener noreferrer" href="https://www.getpostman.com/apps">https://www.getpostman.com/apps</a></p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://7.dusays.com/2021/03/12/fb189913d88c3.png" alt="image-20210312140706367"></p>
<p>安装后，Postman是介样婶儿滴~~😊</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/cayzlh/git-img-repository@master/2021/03/14044816155290881615529088535.jpg" alt="图片"></p>


<div class="article-footer fs14"><section id="license"><div class="header"><span>License</span></div><div class="body"><p>本文采用 <a target="_blank" rel="external nofollow noopener noreferrer" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">署名-非商业性使用-相同方式共享 4.0 国际</a> 许可协议，转载请注明出处。</p>
</div></section></div>

</article>

<div class="related-wrap" id="read-next"><section class="header cap theme"><span>READ NEXT</span></section><section class="body"><div class="post-title h2"><a href="/blog/2021/01/05/d2d07489.html">《Elasticsearch权威指南》-基础入门</a></div></section></div>


<div class="related-wrap" id="related-posts">
    <section class="header">
      <div class="title cap theme">Related Posts</div>
    </section>
    <section class="body">
    <div class="related-posts"><a class="item" href="/blog/2020/03/23/26b455b4.html" title="Mybatis中用到的几种设计模式"><div class="img"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/cayzlh/git-img-repository@master/uPic/c32qrf.jpg"></div><span class="title">Mybatis中用到的几种设计模式</span><span class="excerpt">虽然我们都知道有26个设计模式，但是大多停留在概念层面，真实开发中很少遇到，Mybatis源码中使用了大量的设计模式，阅读源码并观察设计模式在其中的应用，能够更深入的理解设计模式。</span></a><a class="item" href="/blog/2020/01/24/25302edf.html" title="IOC之bean的实例化策略：InstantiationStrategy"><div class="img"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://gitee.com/cayzlh/img-repo/raw/master/2020/05/27/15395929815414_38Okah_ZrNViV.jpg"></div><span class="title">IOC之bean的实例化策略：InstantiationStrategy</span><span class="excerpt">Spring Bean的实例化策略：InstantiationStrategy</span></a><a class="item" href="/blog/2020/01/24/fcc18cc7.html" title="IOC之分析BeanWrapper"><div class="img"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/cayzlh/git-img-repository@master/2020/05/27/15393305208552_Zt9ZVl_ocP6l0.jpg"></div><span class="title">IOC之分析BeanWrapper</span><span class="excerpt">分析Spring的BeanWrapper</span></a><a class="item" href="/blog/2020/01/24/10825e64.html" title="IOC之自定义类型转换器"><div class="img"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/cdn-x/placeholder@1.0.1/cover/76b86c0226ffd.svg"></div><span class="title">IOC之自定义类型转换器</span><span class="excerpt">Spring自定义转换类型</span></a><a class="item" href="/blog/2020/03/31/741621cd.html" title="Spring面向切面编程（知识梳理）"><div class="img"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/cayzlh/git-img-repository@master/uPic/20191118210559319.png"></div><span class="title">Spring面向切面编程（知识梳理）</span><span class="excerpt">阅读Spring官方文档，梳理一下SpringAOP知识点</span></a></div></section></div>





      
<footer class="page-footer fs12"><hr><div><p>All articles in this blog are licensed under <a target="_blank" rel="external nofollow noopener noreferrer" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</p>
<p>This site was deployed by <a href="https://www.cayzlh.com/blog/">@🐳Ant丶</a> using <a target="_blank" rel="external nofollow noopener noreferrer" href="https://github.com/xaoxuu/hexo-theme-stellar/tree/1.1.0">Stellar</a>.</p>
</div></footer>

      <div class="float-panel mobile-only" style="display:none">
  <button type="button" class="sidebar-toggle mobile" onclick="sidebar.toggle()">
    <svg class="icon" viewbox="0 0 1228 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2849"><path d="M0 0m97.390199 0l973.901995 0q97.390199 0 97.390199 97.390199l0 0q0 97.390199-97.390199 97.3902l-973.901995 0q-97.390199 0-97.390199-97.3902l0 0q0-97.390199 97.390199-97.390199Z" p-id="2850"/><path d="M0 389.560798m97.390199 0l973.901995 0q97.390199 0 97.390199 97.390199l0 0q0 97.390199-97.390199 97.3902l-973.901995 0q-97.390199 0-97.390199-97.3902l0 0q0-97.390199 97.390199-97.390199Z" p-id="2851"/><path d="M0 779.121596m97.390199 0l973.901995 0q97.390199 0 97.390199 97.390199l0 0q0 97.390199-97.390199 97.390199l-973.901995 0q-97.390199 0-97.390199-97.390199l0 0q0-97.390199 97.390199-97.390199Z" p-id="2852"/></svg>
  </button>
</div>

    </div>
  </div>
  <div class="scripts">
    <script type="text/javascript">
  stellar = {
    // 懒加载 css https://github.com/filamentgroup/loadCSS
    loadCSS: (href, before, media, attributes) => {
      var doc = window.document;
      var ss = doc.createElement("link");
      var ref;
      if (before) {
        ref = before;
      } else {
        var refs = (doc.body || doc.getElementsByTagName("head")[0]).childNodes;
        ref = refs[refs.length - 1];
      }
      var sheets = doc.styleSheets;
      if (attributes) {
        for (var attributeName in attributes) {
          if (attributes.hasOwnProperty(attributeName)) {
            ss.setAttribute(attributeName, attributes[attributeName]);
          }
        }
      }
      ss.rel = "stylesheet";
      ss.href = href;
      ss.media = "only x";
      function ready(cb) {
        if (doc.body) {
          return cb();
        }
        setTimeout(function () {
          ready(cb);
        });
      }
      ready(function () {
        ref.parentNode.insertBefore(ss, before ? ref : ref.nextSibling);
      });
      var onloadcssdefined = function (cb) {
        var resolvedHref = ss.href;
        var i = sheets.length;
        while (i--) {
          if (sheets[i].href === resolvedHref) {
            return cb();
          }
        }
        setTimeout(function () {
          onloadcssdefined(cb);
        });
      };
      function loadCB() {
        if (ss.addEventListener) {
          ss.removeEventListener("load", loadCB);
        }
        ss.media = media || "all";
      }
      if (ss.addEventListener) {
        ss.addEventListener("load", loadCB);
      }
      ss.onloadcssdefined = onloadcssdefined;
      onloadcssdefined(loadCB);
      return ss;
    },

    // 从 butterfly 和 volantis 获得灵感
    loadScript: (src, opt) => new Promise((resolve, reject) => {
      var script = document.createElement('script')
      script.src = src
      if (opt) {
        for (let key of Object.keys(opt)) {
          script[key] = opt[key]
        }
      } else {
        // 默认异步，如果需要同步，第二个参数传入 {} 即可
        script.async = true
      }
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    }),

    // https://github.com/jerryc127/hexo-theme-butterfly
    jQuery: (fn) => {
      if (typeof jQuery === 'undefined') {
        stellar.loadScript(stellar.plugins.jQuery).then(fn)
      } else {
        fn()
      }
    }
  };
  stellar.github = 'https://github.com/xaoxuu/hexo-theme-stellar/tree/1.1.0';
  stellar.config = {
    date_suffix: {
      just: 'Just',
      min: 'minutes ago',
      hour: 'hours ago',
      day: 'days ago',
      month: 'months ago',
    },
  };

  // required plugins (only load if needs)
  stellar.plugins = {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js',
    sitesjs: '/blog/js/plugins/sites.js',
    friendsjs: '/blog/js/plugins/friends.js',
  };

  // optional plugins
  if ('true' == 'true') {
    stellar.plugins.lazyload = Object.assign({"enable":true,"js":"https://cdn.jsdelivr.net/npm/vanilla-lazyload@17.3.1/dist/lazyload.min.js","transition":"blur"});
  }
  if ('true' == 'true') {
    stellar.plugins.swiper = Object.assign({"enable":true,"css":"https://unpkg.com/swiper/swiper-bundle.min.css","js":"https://unpkg.com/swiper/swiper-bundle.min.js"});
  }
  if ('' == 'true') {
    stellar.plugins.scrollreveal = Object.assign({"enable":null,"js":"https://cdn.jsdelivr.net/npm/scrollreveal@4.0.9/dist/scrollreveal.min.js","distance":"8px","duration":500,"interval":100,"scale":1});
  }
  if ('true' == 'true') {
    stellar.plugins.preload = Object.assign({"enable":true,"service":"flying_pages","instant_page":"https://cdn.jsdelivr.net/gh/volantis-x/cdn-volantis@4.1.2/js/instant_page.js","flying_pages":"https://cdn.jsdelivr.net/gh/gijo-varghese/flying-pages@2.1.2/flying-pages.min.js"});
  }
</script>

<!-- required -->

  
<script src="/blog/js/main.js" async></script>



<!-- optional -->



<!-- inject -->


  </div>
</body>
</html>
