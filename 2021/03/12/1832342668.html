<!DOCTYPE html><html lang="[&quot;zh-Hans&quot;,&quot;en&quot;,&quot;default&quot;]"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="SpringBoot单元测试"><meta name="keywords" content="转载"><meta name="author" content="🐳Ant丶"><meta name="copyright" content="🐳Ant丶"><title>SpringBoot单元测试 | BLOG | CAYZLH</title><link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/cayzlh/psychic-potato@master/logo/favicon.ico"><link rel="stylesheet" href="/blog/css/index.css?version=1.9.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://www.google-analytics.com"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-129095667-1', 'auto');
ga('send', 'pageview');</script><meta name="google-site-verification" content="VrcbMTVpFGlHkIERHBt753dAtXKF4qirjnDweuXSRJw"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://v1.hitokoto.cn/?encode=js&amp;charset=utf-8&amp;select=.footer_custom_text" defer></script><script>var GLOBAL_CONFIG = { 
  root: '/blog/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  hexoVersion: '5.4.0'
} </script><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/blog/atom.xml" title="BLOG | CAYZLH" type="application/atom+xml">
</head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-text">一、 单元测试的概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5%EF%BC%9A"><span class="toc-text">概念：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E5%BC%95%E7%94%A8%EF%BC%9A"><span class="toc-text">单元测试引用：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-text">二、单元测试的作用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%99%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E7%9A%84%E4%B8%A4%E4%B8%AA%E5%8A%A8%E6%9C%BA%EF%BC%9A"><span class="toc-text">写单元测试的两个动机：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81Spring-Boot%E5%BC%95%E5%85%A5%E7%9A%84MockMvc%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-text">三、Spring Boot引入的MockMvc的概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81Service%E5%B1%82%E7%9A%84%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95"><span class="toc-text">四、Service层的单元测试</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81Controller%E5%B1%82%E7%9A%84%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95"><span class="toc-text">五、Controller层的单元测试</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E6%96%AD%E8%A8%80%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-text">六、断言的概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E6%96%B0%E6%96%AD%E8%A8%80assertThat%E4%BD%BF%E7%94%A8"><span class="toc-text">七、新断言assertThat使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AB%E3%80%81Postman%E4%B8%8ESpring-Boot-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">八、Postman与Spring Boot 单元测试的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B9%9D%E3%80%81Postman%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95"><span class="toc-text">九、Postman基本用法</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://cdn.jsdelivr.net/gh/cayzlh/psychic-potato@master/image/IMG_4207.JPG"></div><div class="author-info__name text-center">🐳Ant丶</div><div class="author-info__description text-center">CODE IS POETRY</div><div class="follow-button"><a target="_blank" rel="external nofollow noopener noreferrer" href="https://telegram.me/Q2F5emxo">contact me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/blog/archives"><span class="pull-left">文章</span><span class="pull-right">98</span></a><!--if site.tags.length--><!--  a(href=url_for(config.tag_dir)).author-info-articles__tags.article-meta--><!--    span.pull-left= _p('sidebar.tags')--><!--    span.pull-right= site.tags.length--><!--if site.categories.length--><!--  a(href=url_for(config.category_dir)).author-info-articles__categories.article-meta--><!--    span.pull-left= _p('sidebar.categories')--><!--    span.pull-right= site.categories.length--><a class="author-info-articles__categories article-meta" href="/blog/categories/%E4%B9%A6%E7%B1%8D/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8B/"><span class="pull-left">《深入理解Java虚拟机》</span><span class="pull-right">√</span></a><a class="author-info-articles__categories article-meta" href="/blog/categories/%E4%B9%A6%E7%B1%8D/%E3%80%8AMyBatis%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95%E3%80%8B/"><span class="pull-left">《MyBatis技术内幕》</span><span class="pull-right">√</span></a><a class="author-info-articles__categories article-meta" href="/blog/categories/Java/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"><span class="pull-left">Java设计模式</span><span class="pull-right">√</span></a></div></div></div><div id="content-outer"><div class="no-bg" id="top-container"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/blog/">BLOG | CAYZLH</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> 搜索</span></a></span></div><div id="post-info"><div id="post-title">SpringBoot单元测试</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-03-12</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/blog/categories/Spring/">Spring</a><div class="post-meta-wordcount"><span>字数总计: </span><span class="word-count">2.5k</span><span class="post-meta__separator">|</span><span>阅读时长: 8 分钟</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h2 id="一、-单元测试的概念"><a href="#一、-单元测试的概念" class="headerlink" title="一、 单元测试的概念"></a>一、 单元测试的概念</h2><h3 id="概念："><a href="#概念：" class="headerlink" title="概念："></a><strong>概念：</strong></h3><ol>
<li>单元测试（unit testing），是指对软件中的最小可测试单元进行检查和验证。在Java中单元测试的最小单元是类。</li>
<li>单元测试是开发者编写的一小段代码，用于检验被测代码的一个很小的、很明确的功能是否正确。执行单元测试，就是为了证明这 段代码的行为和我们期望是否一致。</li>
</ol>
<h3 id="单元测试引用："><a href="#单元测试引用：" class="headerlink" title="单元测试引用："></a><strong>单元测试引用：</strong></h3><ol>
<li>众所周知，通过spring initialize创建的Spring Boot项目会在Maven中自动携带很多starter依赖：</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/cayzlh/git-img-repository@master/2021/03/14044716155290871615529087504.jpg" alt="图片"></p>
<p>其中包含了一个名为<code>spring-boot-starter-test</code>的依赖，本文是围绕这个依赖展开。</p>
<ol>
<li>Spring Boot中引入单元测试很简单，添加如下依赖（即<code>spring-boot-starter-test</code>依赖）：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;spring-boot-starter-test&lt;&#x2F;artifactId&gt;</span><br><span class="line">  &lt;scope&gt;test&lt;&#x2F;scope&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<ol>
<li>spring-boot-starter-test有如下几个库：</li>
</ol>
<p><code>spring-boot-starter-test</code>UML图：</p>
<p><img src="https://7.dusays.com/2021/03/12/208e02005c0b7.png" alt="image-20210312142854430"></p>
<p><img src="https://7.dusays.com/2021/03/12/23696982579aa.png" alt="image-20210312142907488"></p>
<h2 id="二、单元测试的作用"><a href="#二、单元测试的作用" class="headerlink" title="二、单元测试的作用"></a>二、单元测试的作用</h2><p>在没有接触单元测试之前我们是怎么做测试的？一般有两个方法：</p>
<p><img src="https://cdn.jsdelivr.net/gh/cayzlh/git-img-repository@master/2021/03/14044716155290871615529087678.jpg" alt="图片"></p>
<p>在时间允许的情况下，编写单元测试是程序员对代码的自测，这是对自己代码的负责。</p>
<h3 id="写单元测试的两个动机："><a href="#写单元测试的两个动机：" class="headerlink" title="写单元测试的两个动机："></a><strong>写单元测试的两个动机：</strong></h3><ol>
<li>保证或验证实现功能。</li>
<li>保护已经实现的功能不被破坏。</li>
</ol>
<h2 id="三、Spring-Boot引入的MockMvc的概念"><a href="#三、Spring-Boot引入的MockMvc的概念" class="headerlink" title="三、Spring Boot引入的MockMvc的概念"></a>三、Spring Boot引入的MockMvc的概念</h2><ol>
<li>什么是Mock?</li>
</ol>
<p>在面向对象的程序设计中，模拟对象（英语：mock object）是以可控的方式模拟真实对象行为的假对象。在编程过程中，通常通过模拟一些输入数据，来验证程序是否达到预期结果。</p>
<ol>
<li>为什么使用Mock对象？</li>
</ol>
<p>使用模拟对象，可以模拟复杂的、真实的对象行为。如果在单元测试中无法使用真实对象，可采用模拟对象进行替代。</p>
<ol>
<li>MockMvc的概念</li>
</ol>
<p>MockMvc是由spring-test包提供，实现了对Http请求的模拟，能够直接使用网络的形式，转换到Controller的调用，使得测试速度快、不依赖网络环境。同时提供了一套验证的工具，结果的验证十分方便。</p>
<p>接口MockMvcBuilder，提供一个唯一的build方法，用来构造MockMvc。主要有两个实现：StandaloneMockMvcBuilder和DefaultMockMvcBuilder。</p>
<p><img src="https://7.dusays.com/2021/03/12/8ca41b998aaab.png" alt="image-20210312142923082"></p>
<ol>
<li>MockMVC的基本步骤</li>
</ol>
<p>(1) mockMvc.perform执行一个请求。(2) MockMvcRequestBuilders.get(“XXX”)构造一个请求。(3) ResultActions.param添加请求传值 (4) ResultActions.accept()设置返回类型 (5) ResultActions.andExpect添加执行完成后的断言。(6) ResultActions.andDo添加一个结果处理器，表示要对结果做点什么事情，比如处使用print()输出整个响应结果信息。(7) ResultActions.andReturn表示执行完成后返回相应的结果。</p>
<h2 id="四、Service层的单元测试"><a href="#四、Service层的单元测试" class="headerlink" title="四、Service层的单元测试"></a>四、Service层的单元测试</h2><p><strong>第一步：</strong> Spring Boot中单元测试类写在src/test/java目录下，你可以手动创建具体测试类，也可以通过IDEA自动创建测试类，如下图：（注：点选并打开相应代码界面，再点击菜单栏的Navigate）</p>
<p><img src="https://7.dusays.com/2021/03/12/b9128a7d66811.png" alt="image-20210312140744322"></p>
<p><strong>第二步：</strong> 按照第一步的方法，点击测试后，出现<strong>图一</strong> 的对话框（如果想要测试的类已经存在测试类了会被列出来，也可以重新创建一个新的测试类），点击”Create New Test…”会弹出<strong>图二</strong> 的对话框，可以选择是否生成setUp以及要测试的成员方法等：</p>
<p>图一</p>
<p><img src="https://cdn.jsdelivr.net/gh/cayzlh/git-img-repository@master/2021/03/14044716155290871615529087979.jpg" alt="图片"></p>
<p>图二</p>
<p><img src="https://cdn.jsdelivr.net/gh/cayzlh/git-img-repository@master/2021/03/14044816155290881615529088115.jpg" alt="图片"></p>
<p><strong>第三步：</strong> 至此Service层的测试类就创建好了，测试类自动生成到了src/test/java目录下<strong>项目的同级目录中</strong> ，如下图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/cayzlh/git-img-repository@master/2021/03/14044816155290881615529088185.jpg" alt="图片"></p>
<p>Service层测试代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@SpringBootTest</span><br><span class="line">@RunWith(SpringRunner.class)</span><br><span class="line">public class XXXServiceTest &#123;</span><br><span class="line">@Resource</span><br><span class="line">private XXXService XXXService;</span><br><span class="line">@Test</span><br><span class="line">public void conflictTime() &#123;</span><br><span class="line">        DateTimeFormatter dtf &#x3D; DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd&quot;);</span><br><span class="line">        LocalDate start &#x3D; LocalDate.parse(&quot;2020-10-26&quot;, dtf);</span><br><span class="line">        LocalDate end &#x3D; LocalDate.parse(&quot;2020-10-31&quot;, dtf);</span><br><span class="line">        Integer integer &#x3D; XXXService.ConflictTime(&quot;10000001&quot;, start, end);</span><br><span class="line">        Assert.assertThat(integer, Matchers.notNullValue());&#x2F;&#x2F;assertThat断言后面介绍</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注解解释：</strong></p>
<p><code>@SpringBootTest</code>：获取启动类，加载配置，寻找主配置启动类（被 @SpringBootApplication 注解的） <code>@RunWith(SpringRunner.class)</code>：让JUnit运行Spring的测试环境,获得Spring环境的上下文的支持</p>
<h2 id="五、Controller层的单元测试"><a href="#五、Controller层的单元测试" class="headerlink" title="五、Controller层的单元测试"></a>五、Controller层的单元测试</h2><p>创建测试类步骤见第四部分，此处略。</p>
<p>第四部分只是针对Service层做了测试，但是咱么也需要对Controller层（API）做测试，这时候就用到MockMvc了，它使得你无需启动项目工程就能测试这些接口</p>
<p>MockMvc实现了对Http请求的模拟，能够直接使用网络的形式，转换到Controller的调用，这样可以使得测试速度快、不依赖网络环境，而且提供了一套验证的工具，这样可以使得请求的验证统一而且很方便。</p>
<p>Controller层部分的代码将分为三个代码块讲解，里面有看不懂的代码先不要着急哦😄，会在第五部分结尾处给大家汇总解答的，大家要坚持看到最后哟！😁</p>
<p><strong>代码块一：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@SpringBootTest</span><br><span class="line">@RunWith(SpringRunner.class)</span><br><span class="line">@AutoConfigureMockMvc</span><br><span class="line">public class DfTaskRecordControllerTest &#123;</span><br><span class="line">@Autowired</span><br><span class="line">private MockMvc mockMvc;</span><br><span class="line">@Before</span><br><span class="line">public void setUp() throws Exception &#123;</span><br><span class="line">       System.out.println(&quot;---------------start---------------&quot;);</span><br><span class="line">       save();</span><br><span class="line">get();</span><br><span class="line">       System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;end&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>注解解释：</strong></p>
<p><code>@SpringBootTest</code>&gt;：获取启动类，加载配置，寻找主配置启动类（被 @SpringBootApplication 注解的）</p>
<p><code>@RunWith(SpringRunner.class)</code>&gt;：让JUnit运行Spring的测试环境,获得Spring环境的上下文的支持 <code>@AutoConfigureMockMvc</code>：用于自动配置MockMvc,配置后MockMvc类可以直接注入,相当于new MockMvc <code>@Before</code>:初始化方法 ,对于每一个测试方法都要执行一次</p>
<p><strong>代码块二：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">@Transactional</span><br><span class="line">@Rollback()</span><br><span class="line">public void save() throws Exception &#123;</span><br><span class="line">        String json&quot;&#123;……&#125;&quot;;</span><br><span class="line">&#x2F;&#x2F;执行一个RequestBuilder请求，会自动执行SpringMVC的流程并映射到相应的控制器执行处理；</span><br><span class="line">        mockMvc.perform(MockMvcRequestBuilders</span><br><span class="line">                .post(&quot;&#x2F;XXX&#x2F;save&quot;)</span><br><span class="line">                .content(json.getBytes()) &#x2F;&#x2F;传json参数</span><br><span class="line">                .accept(MediaType.APPLICATION_JSON)</span><br><span class="line">                .contentType(MediaType.APPLICATION_JSON_VALUE)</span><br><span class="line">                .header(&quot;Authorization&quot;,&quot;Bearer ********-****-****-****-************&quot;)</span><br><span class="line">        )</span><br><span class="line">                .andExpect(MockMvcResultMatchers.status().isOk())</span><br><span class="line">                .andDo(print());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>注解解释：</strong></p>
<p><code>@Transactional</code>:开启事务功能</p>
<p><code>@Rollback()</code>: 事务回滚,默认是true</p>
<p><strong>代码块三：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void get() throws Exception&#123;</span><br><span class="line">        ResultActions resultActions &#x3D; mockMvc.perform(MockMvcRequestBuilders</span><br><span class="line">                .get(&quot;&#x2F;XXX&#x2F;get&quot;)</span><br><span class="line">                .param(&quot;id&quot;, &quot;**********&quot;)</span><br><span class="line">                .header(&quot;Authorization&quot;, &quot;Bearer ********-****-****-****-************&quot;)</span><br><span class="line">        );</span><br><span class="line">        resultActions.andReturn().getResponse().setCharacterEncoding(&quot;UTF-8&quot;);</span><br><span class="line">        resultActions.andExpect(MockMvcResultMatchers.status().isOk()).andDo(print());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>/get</code>运行结果如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/cayzlh/git-img-repository@master/2021/03/14044816155290881615529088275.jpg" alt="图片"></p>
<p><strong>现在将上面的一些琐碎的知识点汇总一下：</strong></p>
<p><code>1. mockMvc.perform</code>：执行一个请求</p>
<p><code>2. MockMvcRequestBuilders.get(“/XXX/get”)</code>：构造一个请求，Post请求使用.post方法</p>
<p><code>3. contentType(MediaType.APPLICATION_JSON_VALUE)</code>：代表发送端发送的数据格式是application/json;charset=UTF-8</p>
<p><code>4. accept(MediaType.APPLICATION_JSON)</code>：代表客户端希望接受的数据类型为application/json;charset=UTF-8</p>
<p><code>5. header(“Authorization”,“Bearer XXXX”)</code>：代表在报文头添加一些必须的信息，这里添加的是token</p>
<p><code>6. ResultActions.andExpect</code>：添加执行完成后的断言</p>
<p><code>7. ResultActions.andExpect(MockMvcResultMatchers.status().isOk())</code>：方法看请求的状态响应码是否为200如果不是则抛异常，测试不通过</p>
<p><code>8. ResultActions.andDo</code>：添加一个结果处理器，表示要对结果做点什么事情，比如此处使用print()：输出整个响应结果信息</p>
<h2 id="六、断言的概念"><a href="#六、断言的概念" class="headerlink" title="六、断言的概念"></a>六、断言的概念</h2><ol>
<li>断言（assert），是编程术语，表示为一些布尔表达式，程序员相信在程序中的某个特定点该表达式值为真。可以在任何时候启用和禁用断言验证，因此可以在测试时启用断言而在部署时禁用断言。</li>
<li>使用断言是判断一个函数或对象的一个方法所产生的结果是否符合你期望那个结果。</li>
</ol>
<h2 id="七、新断言assertThat使用"><a href="#七、新断言assertThat使用" class="headerlink" title="七、新断言assertThat使用"></a>七、新断言assertThat使用</h2><p>JUnit 4.4 结合 Hamcrest 提供了一个全新的断言语法——assertThat。程序员可以只使用 assertThat 一个断言语句，结合 Hamcrest 提供的匹配符，就可以表达全部的测试思想。</p>
<p><strong>assertThat 的优点：</strong></p>
<p><strong>优点 1：</strong> 以前 JUnit 提供了很多的 assertion 语句，如：assertEquals，assertNotSame，assertFalse，assertTrue，assertNotNull，assertNull 等，现在有了 JUnit 4.4，一条 assertThat 即可以替代所有的 assertion 语句，这样可以在所有的单元测试中只使用一个断言方法，使得编写测试用例变得简单，代码风格变得统一，测试代码也更容易维护。</p>
<p><strong>优点 2：</strong> assertThat 使用了 Hamcrest 的 Matcher 匹配符，用户可以使用匹配符规定的匹配准则精确的指定一些想设定满足的条件，具有很强的易读性，而且使用起来更加灵活。</p>
<p><strong>优点 3：</strong> assertThat 不再像 assertEquals 那样，使用比较难懂的“谓宾主”语法模式（如：assertEquals(3, x);），相反，assertThat 使用了类似于“主谓宾”的易读语法模式（如：assertThat(x,is(3));），使得代码更加直观、易读。</p>
<p><strong>assertThat 的基本语法如下：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">assertThat( [value], [matcher statement] );</span><br></pre></td></tr></table></figure>

<p><strong>value</strong> ：接下来想要测试的变量值；<strong>matcher statement</strong> ：使用 Hamcrest 匹配符来表达的对前面变量所期望的值的声明，如果 value 值与 matcher statement 所表达的期望值相符，则测试成功，否则测试失败。</p>
<h2 id="八、Postman与Spring-Boot-单元测试的区别"><a href="#八、Postman与Spring-Boot-单元测试的区别" class="headerlink" title="八、Postman与Spring Boot 单元测试的区别"></a>八、Postman与Spring Boot 单元测试的区别</h2><ol>
<li>Spring Boot的单元测试主要针对方法层面，可以测试Service层这类非对外暴露的接口的类中方法，并且可一次性批量测试多个方法、支持事务回滚。</li>
<li>Postman针对接口进行http测试，我平时这个比较多，创建的测试接口可保存、分类。</li>
</ol>
<h2 id="九、Postman基本用法"><a href="#九、Postman基本用法" class="headerlink" title="九、Postman基本用法"></a>九、Postman基本用法</h2><p>Postman是一款功能强大的网页调试与发送网页HTTP请求的工具。Postman能够发送任何类型的HTTP请求(GET, HEAD, POST,PUT..)，附带任何数量的参数和HTTP headers。支持不同的认证机制（basic, digest,OAuth），接收到的响应语法高亮（HTML，JSON或XML）。</p>
<p><strong>安装Postman</strong></p>
<p>官方网站：</p>
<p><a target="_blank" rel="external nofollow noopener noreferrer" href="https://www.getpostman.com/apps">https://www.getpostman.com/apps</a></p>
<p><img src="https://7.dusays.com/2021/03/12/fb189913d88c3.png" alt="image-20210312140706367"></p>
<p>安装后，Postman是介样婶儿滴~~😊</p>
<p><img src="https://cdn.jsdelivr.net/gh/cayzlh/git-img-repository@master/2021/03/14044816155290881615529088535.jpg" alt="图片"></p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined" rel="external nofollow noopener noreferrer" target="_blank">🐳Ant丶</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://www.cayzlh.com/2021/03/12/1832342668.html">https://www.cayzlh.com/2021/03/12/1832342668.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a target="_blank" rel="external nofollow noopener noreferrer" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://www.cayzlh.com">BLOG | CAYZLH</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/blog/tags/%E8%BD%AC%E8%BD%BD/">转载</a></div><nav id="pagination"><div class="next-post pull-right"><a href="/blog/2021/01/05/d2d07489.html"><span>《Elasticsearch权威指南》-基础入门</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="footer_custom_text">hitokoto</div><div class="copyright">🐳Ant丶 &copy;2019 - 2021</div><div class="icp"><a><span>粤ICP备20058712号</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/blog/js/utils.js?version=1.9.0"></script><script src="/blog/js/fancybox.js?version=1.9.0"></script><script src="/blog/js/sidebar.js?version=1.9.0"></script><script src="/blog/js/copy.js?version=1.9.0"></script><script src="/blog/js/fireworks.js?version=1.9.0"></script><script src="/blog/js/transition.js?version=1.9.0"></script><script src="/blog/js/scroll.js?version=1.9.0"></script><script src="/blog/js/head.js?version=1.9.0"></script><script src="/blog/js/search/local-search.js"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>Powered by</span> <a target="_blank" rel="external nofollow noopener noreferrer" href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>