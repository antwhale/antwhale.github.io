<!DOCTYPE html>
<html lang="zh-CN">

<head>
  <meta name="generator" content="Hexo 5.4.0">
  <meta charset="utf-8">
  

  <meta http-equiv="x-dns-prefetch-control" content="on">
  <link rel="dns-prefetch" href="https://cdn.jsdelivr.net">
  <link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin>

  <meta name="renderer" content="webkit">
  <meta name="force-rendering" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  <meta name="HandheldFriendly" content="True">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <title>Mybatis技术内幕：基础支持层——反射模块 - CAYZLH</title>

  
  <meta name="description" content="MyBatis基础支持层位于 Mybatis 整体架构的最底层，支撑着 Mybatis 的核心处理层，是整个框架的基石。基础支持层中封装了多个较为通用的、独立的模块，不仅仅为 Mybatis 提供基础支撑，也可以在合适的场景中直接复用。


这篇介绍MyBatis的反射模块

反射工具箱Myb...">

  <!-- feed -->
  
    <link rel="alternate" href="/atom.xml" title="CAYZLH" type="application/atom+xml">
  

  
    
<link rel="stylesheet" href="/css/main.css">

  

  
    
      <meta name="msapplication-TileColor" content="#2d89ef">
    
      <meta name="msapplication-config" content="/assets/favicon/browserconfig.xml">
    
      <meta name="theme-color" content="#ffffff">
    
      <link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/cayzlh/psychic-potato@master/logo/favicon.ico">
    
      <link rel="icon" type="image/png" href="https://cdn.jsdelivr.net/gh/cayzlh/psychic-potato@master/logo/favicon-192x192.png" sizes="192x192">
    
      <link rel="apple-touch-icon" sizes="180x180" href="https://cdn.jsdelivr.net/gh/cayzlh/psychic-potato@master/logo/apple-touch-icon.png">
    
  
</head>

<body>
  


  <div class="l_body" id="start">
    <aside class="l_left">
    

<header class="header">
  <div class="logo-wrap">
  
    <a class="avatar" href="/">
      
        <img no-lazy class="bg" src="https://cdn.jsdelivr.net/gh/cdn-x/placeholder@1.0.2/avatar/round/rainbow64@3x.webp" onerror="javascript:this.classList.add('error');this.src='https://cdn.jsdelivr.net/gh/cayzlh/git-img-repository@master/2021/04/16084216181285221618128522255.svg';">
      
      <img no-lazy class="avatar" src="https://cdn.jsdelivr.net/gh/cayzlh/psychic-potato@master/image/IMG_4207.JPG" onerror="javascript:this.classList.add('error');this.src='https://cdn.jsdelivr.net/gh/cayzlh/git-img-repository@master/2021/04/16084216181285221618128522255.svg';">
    </a>
  
  
    <a class="title" href="/">
      CAYZLH
    </a>
  
</div>

  <nav class="menu dis-select"><a class="nav-item" href="/">文章</a><a class="nav-item active" href="/wiki/">文档</a><a class="nav-item" href="/talking/">动态</a><a class="nav-item" href="/about/">更多</a></nav>
</header>

<div class="widgets">
  
    
      
      
<div class="widget-wrap" id="toc"><div class="widget-header h4 dis-select"><span class="name">本文目录</span></div><div class="widget-body fs14 wiki"><div class="doc-tree"><a class="doc-tree-link" href="/wiki/mybatis_technology_insider/index.html"><span class="toc-text">Mybatis技术内幕</span></a></div><div class="doc-tree"><a class="doc-tree-link" href="/wiki/mybatis_technology_insider/part1.html"><span class="toc-text">MyBatis快速入门</span></a></div><div class="doc-tree"><a class="doc-tree-link" href="/wiki/mybatis_technology_insider/part2.html"><span class="toc-text">基础支持层——解析器模块</span></a></div><div class="doc-tree active"><a class="doc-tree-link active" href="/wiki/mybatis_technology_insider/part3.html"><span class="toc-text">基础支持层——反射模块</span></a><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84%E5%B7%A5%E5%85%B7%E7%AE%B1"><span class="toc-text">反射工具箱</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Reflector-amp-ReflectorFactory"><span class="toc-text">Reflector &amp; ReflectorFactory</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TypeParameterResolver"><span class="toc-text">TypeParameterResolver</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ObjectFactory"><span class="toc-text">ObjectFactory</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Property%E5%B7%A5%E5%85%B7%E7%B1%BB"><span class="toc-text">Property工具类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#MetaClass"><span class="toc-text">MetaClass</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ObjectWrapper"><span class="toc-text">ObjectWrapper</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#MetaObject"><span class="toc-text">MetaObject</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-text">类型转换</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#TypeHandler"><span class="toc-text">TypeHandler</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TypeHandlerRegistry"><span class="toc-text">TypeHandlerRegistry</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TypeAliasRegistry"><span class="toc-text">TypeAliasRegistry</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E8%80%83"><span class="toc-text">参考</span></a></li></ol></div><div class="doc-tree"><a class="doc-tree-link" href="/wiki/mybatis_technology_insider/part4.html"><span class="toc-text">基础支持层——日志模块</span></a></div><div class="doc-tree"><a class="doc-tree-link" href="/wiki/mybatis_technology_insider/part5.html"><span class="toc-text">基础支持层——资源加载</span></a></div><div class="doc-tree"><a class="doc-tree-link" href="/wiki/mybatis_technology_insider/part6.html"><span class="toc-text">基础支持层——DataSource</span></a></div><div class="doc-tree"><a class="doc-tree-link" href="/wiki/mybatis_technology_insider/part7.html"><span class="toc-text">基础支持层——Transaction</span></a></div><div class="doc-tree"><a class="doc-tree-link" href="/wiki/mybatis_technology_insider/part8.html"><span class="toc-text">基础支持层——binding模块</span></a></div><div class="doc-tree"><a class="doc-tree-link" href="/wiki/mybatis_technology_insider/part9.html"><span class="toc-text">基础支持层——缓存模块</span></a></div><div class="doc-tree"><a class="doc-tree-link" href="/wiki/mybatis_technology_insider/part10.html"><span class="toc-text">核心处理层-MyBatis初始化</span></a></div><div class="doc-tree"><a class="doc-tree-link" href="/wiki/mybatis_technology_insider/part11.html"><span class="toc-text">核心处理层-SqlNode&SqlSource</span></a></div></div></div>

    
  
    
      
      
  
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
      <div class="widget-wrap" id="related">
        <div class="widget-header h4 dis-select">
          <span class="name">更多读书笔记</span>
        </div>
        <div class="widget-body fs14">
          
            
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
          
            
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
                <div class="post-title">
                  <a href="/wiki/understanding_jvm/index.html">
                    深入理解Java虚拟机
                  </a>
                </div>
              
            
          
            
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
                <div class="post-title">
                  <a href="/wiki/how_to_reading/index.html">
                    《如何阅读一本书》
                  </a>
                </div>
              
            
          
        </div>
      </div>
    
  


    
  
</div>
<footer class="footer"><div class="social-wrap dis-select"><a class="social" href="https://github.com/cayzlh" target="_blank" rel="external nofollow noopener noreferrer"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/cdn-x/placeholder@1.0.1/social/08a41b181ce68.svg"></a><a class="social" href="https://telegram.me/Q2F5emxo" target="_blank" rel="external nofollow noopener noreferrer"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/cayzlh/psychic-potato@master/image/guanyuwomen.svg"></a><a class="social" href="/about/#comments" rel="noopener noreferrer"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/cdn-x/placeholder@1.0.1/social/942ebbf1a4b91.svg"></a></div></footer>

    </aside>
    <div class="l_main">
      

      

  
  
  <div class="bread-nav fs12">
  
    
    <div id="breadcrumb">
      <a class="cap breadcrumb" href="/">主页</a>
      <span class="sep"></span>
      
        <a class="cap breadcrumb" href="/wiki/">文档</a>
      
      
        <span class="sep"></span>
        <a class="cap breadcrumb" href="/wiki/categories/reading/index.html">读书笔记</a>
      
      
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        <span class="sep"></span>
        <a class="cap breadcrumb" href="/wiki/mybatis_technology_insider/index.html">Mybatis技术内幕</a>
      
    </div>
    <div id="post-meta">
      更新于&nbsp;<time datetime="2021-04-11T07:59:08.718Z">2021-04-11</time>
    </div>
  
  </div>


  <article class="content md wiki">
  <h1 class="article-title"><span>基础支持层——反射模块</span></h1>
  <p>MyBatis基础支持层位于 Mybatis 整体架构的最底层，支撑着 Mybatis 的核心处理层，是整个框架的基石。基础支持层中封装了多个较为通用的、独立的模块，不仅仅为 Mybatis 提供基础支撑，也可以在合适的场景中直接复用。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://gitee.com/cayzlh/img-repo/raw/master/2020/06/09/2_c5SKkm-20200609160003190_wDXqrk.png" alt="整体架构"></p>
<blockquote>
<p>这篇介绍MyBatis的反射模块</p>
</blockquote>
<h3 id="反射工具箱"><a href="#反射工具箱" class="headerlink" title="反射工具箱"></a>反射工具箱</h3><p>Mybatis 在进行参数处理、结果映射等操作时，会涉及大量的反射操作。Java 中的反射虽然功能强大，但是代码编写起来比较复杂且容易出错，为了简化反射操作的相关代码，Mybatis 提供了专门的反射模块，该模块位于 <code>org.apache.ibatis.reflection</code> 包中，它对常见的反射操作做了进一步封装，提供了更加简洁方便的反射 API。</p>
<h4 id="Reflector-amp-ReflectorFactory"><a href="#Reflector-amp-ReflectorFactory" class="headerlink" title="Reflector &amp; ReflectorFactory"></a>Reflector &amp; ReflectorFactory</h4><p>Reflector是MyBatis中反射模块的基础，每隔Reflector对象都对应一个类，在Reflector中缓存了反射操作需要使用的累的元信息。</p>
<p>Reflector中各个字段的含义如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Private Class &lt;?&gt; type; <span class="comment">//对应的 C1 ass 类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//可读属性的名称集合，可读属性就是存在相应 getter 方法的属性，初始值为空数组</span></span><br><span class="line"><span class="keyword">private</span> String I readablepropertynames= EMPTY STRING ARRAY</span><br><span class="line"></span><br><span class="line"><span class="comment">//可写属性的名称集合，可写属性就是存在相应 setter 方法的属性，初始值为空数组</span></span><br><span class="line"><span class="keyword">private</span> String  [writeablepropertynames EMPTY STRING ARRAY;</span><br><span class="line"><span class="comment">//记录了属性相应的 setter 方法，key 是属性名称，value 是 Invoker 对象，它是对 setter 方法对应 </span></span><br><span class="line"><span class="comment">// Me thod 对象的封装，后面会详细介绍</span></span><br><span class="line"><span class="keyword">private</span> Map &lt;String, Invoker&gt; setmethods =<span class="keyword">new</span> Hashmap &lt;String, Invoker&gt;  ();</span><br><span class="line"></span><br><span class="line"><span class="comment">//属性相应的 getter 方法集合，key 是属性名称，value 也是 Invoker 对象</span></span><br><span class="line"><span class="keyword">private</span> Map &lt;String, Invoker&gt; getmethods =<span class="keyword">new</span> Hashmap &lt;String, Invoker&gt; ();</span><br><span class="line"></span><br><span class="line"><span class="comment">//记录了属性相应的 setter 方法的参数值类型，key 是属性名称，value 是 setter 方法的参数类型</span></span><br><span class="line"><span class="keyword">private</span> Map &lt;String, Class &lt;?&gt;&gt; settypes =<span class="keyword">new</span> Hashmap &lt;string, Class &lt;?&gt;&gt; ();</span><br><span class="line"></span><br><span class="line"><span class="comment">//记录了属性相应的 getter 方法的返回值类型，key 是属性名称，value 是 getter 方法的返回值类型 </span></span><br><span class="line"><span class="keyword">private</span> Map &lt;string, Class &lt;?&gt;&gt; gettypes=<span class="keyword">new</span> Hashmap &lt;string, Class &lt;?&gt;&gt; ();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Constructor &lt;?&gt; <span class="keyword">default</span> Constructor; <span class="comment">//记录了默认构造方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//记录了所有属性名称的集合</span></span><br><span class="line"><span class="keyword">private</span> Map &lt;string, String&gt; caseinsensitivepropertymap-<span class="keyword">new</span> Hashmap &lt;String, String&gt; ();</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在Reflector的构造方法中会解析制定的Class对象，并填充上述集合。具体如下：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Reflector</span><span class="params">(Class&lt;?&gt; clazz)</span> </span>&#123;</span><br><span class="line">  type = clazz; <span class="comment">// 初始化type字段</span></span><br><span class="line">  <span class="comment">// 查找clazz的默认构造方法，具体实现是通过反射遍历所有构造方法</span></span><br><span class="line">  addDefaultConstructor(clazz);</span><br><span class="line">  addGetMethods(clazz); <span class="comment">// 处理clazz中的getter方法，填充getMethods集合和getTypes集合</span></span><br><span class="line">  addSetMethods(clazz); <span class="comment">// 处理clazz中的setter方法，填充setMethods集合和setTypes集合</span></span><br><span class="line">  addFields(clazz); <span class="comment">// 处理没有getter/setter方法的字段</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 根据getMethods/setMethods集合，初始化可读/写属性的名称集合</span></span><br><span class="line">  readablePropertyNames = getMethods.keySet().toArray(<span class="keyword">new</span> String[<span class="number">0</span>]);</span><br><span class="line">  writablePropertyNames = setMethods.keySet().toArray(<span class="keyword">new</span> String[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 初始化caseInsensitivePropertyMap集合，其中记录了所有大写格式的属性名称</span></span><br><span class="line">  <span class="keyword">for</span> (String propName : readablePropertyNames) &#123;</span><br><span class="line">    caseInsensitivePropertyMap.put(</span><br><span class="line">      propName.toUpperCase(Locale.ENGLISH), propName);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (String propName : writablePropertyNames) &#123;</span><br><span class="line">    caseInsensitivePropertyMap.put(</span><br><span class="line">      propName.toUpperCase(Locale.ENGLISH), propName);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Reflector.Addgetmethodso()</code>方法主要负责解析类中定义的 <code>getter</code> 方法，<code>Reflector. addSetMethods()</code>方法负责解析类中定义的 <code>setter</code> 方法，两者的逻辑类似。</p>
<p><code>Reflector. Addgetmethods()</code> 方法有如下三个核心步骤。</p>
<ol>
<li><p>首先，调用Reflector.getClassMethods()方法获取当前类及其父类中定义的所有方法的唯一签名以及响应的Method对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Method[] getClassMethods(Class&lt;?&gt; clazz) &#123;</span><br><span class="line">  <span class="comment">// 用于记录制定类中定义的全部方法的唯一签名以及对应的Method对象</span></span><br><span class="line">  Map&lt;String, Method&gt; uniqueMethods = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">  Class&lt;?&gt; currentClass = clazz;</span><br><span class="line">  <span class="keyword">while</span> (currentClass != <span class="keyword">null</span> &amp;&amp; currentClass != Object.class) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录currentClass这个类中定义的全部方法</span></span><br><span class="line">    addUniqueMethods(uniqueMethods, currentClass.getDeclaredMethods());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// we also need to look for interface methods -</span></span><br><span class="line">    <span class="comment">// because the class may be abstract</span></span><br><span class="line">    <span class="comment">// 记录接口中定义的方法</span></span><br><span class="line">    Class&lt;?&gt;[] interfaces = currentClass.getInterfaces();</span><br><span class="line">    <span class="keyword">for</span> (Class&lt;?&gt; anInterface : interfaces) &#123;</span><br><span class="line">      addUniqueMethods(uniqueMethods, anInterface.getMethods());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取父类，继续while循环</span></span><br><span class="line">    currentClass = currentClass.getSuperclass();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Collection&lt;Method&gt; methods = uniqueMethods.values();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> methods.toArray(<span class="keyword">new</span> Method[<span class="number">0</span>]);<span class="comment">// 转换成Methods数组返回</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>然后，按照JavaBean的规范，从Reflector.getClassMethods()方法返回的Method数组中查找该类中定义的getter方法，将其记录到<code>conflictingGetters</code>集合中。<code>conflictingGetters</code>集合的key为属性名称，value是该属性对应的getter方法的集合。</p>
</li>
<li><p>当子类覆盖了父类的getter方法且返回值发生变化时，在步骤1中就会产生两个签名不同的方法。</p>
</li>
</ol>
<h4 id="TypeParameterResolver"><a href="#TypeParameterResolver" class="headerlink" title="TypeParameterResolver"></a>TypeParameterResolver</h4><p>在开 始介绍 TypeParameterResolver之前，先简 单 介绍 一下Type接口的基础 知识 。Type是所有类 型的父接口，它 有四个 子接口和一个 实 现 类 ，如图所示。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://gitee.com/cayzlh/img-repo/raw/master/2020/06/06/image-20200606160310736_88u4tj.png" alt="image-20200606160310736"></p>
<p>下面来 看这 些子接口和子类 所代表的类 型。</p>
<ul>
<li><p><strong>Class</strong>比较 常见 ，它 表示的是原始类 型。</p>
<p>Class类 的对 象表示JVM中的一个 类 或接口， 每个 Java类 在JVM里都表现 为 一个 Class对 象。</p>
<p>在程序中可以通过 “<strong>类名.class</strong>”、“**对象.getClass()<strong>”或是“</strong>Class.forName(“类 名”)**”等方式获 取Class对 象。</p>
<p>数 组 也被映射为 Class对 象，所有元素类 型相同且维 数 相同的数 组 都共享同一个 Class对 象。</p>
</li>
<li><p><strong>ParameterizedType</strong> 表示的是参 数 化类 型，例如 List<string>、 Map&lt;Integer，String&gt;、 Service<user>这 种 带 有泛型的类 型。</user></string></p>
<p>ParameterizedType接口中常用的方法有三个 ，分别 是:</p>
<ul>
<li><code>Type getRawType()</code>—–返回参 数 化类 型中的原始类 型，例如List<strin>的原始类 型为 List。</strin></li>
<li><code>Type[] getActualTypeArguments()</code>—–获 取参 数 化类 型的类 型变 量或是实 际 类 型列 表，例如Map&lt;Integer，String&gt;的实 际 泛型列表Integer和 String。需要注意的是， 该 列表的元素类 型都是Type,也就是说 ，可能存在多层 嵌套的情况 。</li>
<li><code>Type getOwnerType()</code>—–返回是类 型所属 的类 型，例如存在A<t>类 ，其中定义 了 内 部类 InnerA<i>，则 InnerA<i>属 的类 型为 A<t>，如果是顶 层 类 型则 返回null。 这 种 关 系比较 常见 的示例是Map&lt;K，V&gt;接口与 Map.Entry&lt;K，V&gt;接口，Map&lt;K，V&gt; 接 口 是Map&lt;K,V&gt;接口的所有者。</t></i></i></t></li>
</ul>
</li>
<li><p><code>TypeVariable</code>表示的是类 型变 量，它 用来 反映在JVM编 译 该 泛型前的信息。</p>
<p>例如List<t> 中的T就是类 型变 量，它 在编 译 时 需被转 换 为 一个 具体 的类 型后才能正常使用。</t></p>
<p>该 接口中常用的方法有三个 ，分别 是:</p>
<ul>
<li><p><code>Type[] getBounds()</code>—–获 取类 型变 量的上边 界，如果未明确 声 明上边 界则 默认 为 Object。 </p>
<p>例如 class Test<k extends person>中 K 的上界就是 Person。</k></p>
</li>
<li><p> <code>D getGenericDeclaration()</code>—–获 取声 明该 类 型变 量的原始类 型，例 如 class Test<k extends person> 中 的原始类 型是 Test。</k></p>
</li>
<li><p><code>String getName()</code>— 获 取在源码 中定义 时 的名字，上例中为 K。</p>
</li>
</ul>
</li>
<li><p><code>GenericArrayType</code> 表示的是数 组 类 型且组 成元素是 ParameterizedType 或 TypeVariable。 </p>
<p>例如 List<string>或T[]。该 接口只有 Type getGenericComponentType()—个 方法，它 返回数 组 的组 成元素。</string></p>
</li>
<li><p><code>WildcardType</code> 表示的是通配符泛型，例如<code>? extends Number</code> 和<code>? uper Integer</code>。</p>
<p>WildcardType接口有两 个 方法，分别 是:</p>
<ul>
<li><code>Type[] getUpperBounds()</code>—-返回泛型变 量的上界。 </li>
<li> <code>Type[] getLowerBounds()</code>—- 返回泛型变 量的下界。</li>
</ul>
</li>
</ul>
<p> 回到对 <code>TypeParameterResolve</code>，它 是一个 工具类 ，提供了一系列静 态 方法来 解析指定类 中的字段、方法返回值 或方法参 数 的类 型。TypeParameterResolver中各个 静 态 方法之间 的调 用关 系大致如下图 所示，为 保持清 晰 ，其中递 归 调 用没 有表现 出来 ，在后面 的代码 分析过 程中会 进 行强调 。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://gitee.com/cayzlh/img-repo/raw/master/2020/06/06/image-20200606162023961_yxCRz4.png" alt="image-20200606162023961"></p>
<p><code>TypeParameterResolver</code> 中 通 过 <code>resolveFieldType()</code>方 法 、 <code>resolveRetumType()</code>方 法 、 <code>resolveParamTypes()</code>方法分别 解析字段类 型、方法返回值 类 型和方法参 数 列表中各个 参 数 的类 型。 这 三个 方法的逻 辑 基本类 似，这 里以resolveFieldType()方法为 例进 行介绍 ，<code>TypeParameterResolver.resolveFieldType()</code>方法的具体 实 现 如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> The field type as &#123;<span class="doctag">@link</span> Type&#125;. If it has type parameters in the declaration,</span></span><br><span class="line"><span class="comment">   *         they will be resolved to the actual runtime &#123;<span class="doctag">@link</span> Type&#125;s.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Type <span class="title">resolveFieldType</span><span class="params">(Field field, Type srcType)</span> </span>&#123;</span><br><span class="line">  Type fieldType = field.getGenericType();</span><br><span class="line">  Class&lt;?&gt; declaringClass = field.getDeclaringClass();</span><br><span class="line">  <span class="keyword">return</span> resolveType(fieldType, srcType, declaringClass);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述三个 方法都会 调 用<code>resolveType()</code>方法，该 方法会 根据其第一个 参 数 的 类 型，即 字段、方法返回值 或方法参 数 的类 型，选 择 合适的方法进 行解析。<code>resolveType()</code>方法的 第二个 参 数 表示查 找 该 字段、返回值 或方法参 数 的起始位置。第三个 参 数 则 表示该 字段、方法 定义 所在的类 。<code>TypeParameterResolver.resolveType()</code>方法代码 如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Type <span class="title">resolveType</span><span class="params">(Type type, Type srcType, Class&lt;?&gt; declaringClass)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (type <span class="keyword">instanceof</span> TypeVariable) &#123;</span><br><span class="line">    <span class="comment">// 解析TypeVariable类型</span></span><br><span class="line">    <span class="keyword">return</span> resolveTypeVar((TypeVariable&lt;?&gt;) type, srcType, declaringClass);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type <span class="keyword">instanceof</span> ParameterizedType) &#123;</span><br><span class="line">    <span class="comment">// 解析ParameterizedType类型</span></span><br><span class="line">    <span class="keyword">return</span> resolveParameterizedType((ParameterizedType) type, srcType, declaringClass);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type <span class="keyword">instanceof</span> GenericArrayType) &#123;</span><br><span class="line">    <span class="comment">// 解析genericArrayType类型</span></span><br><span class="line">    <span class="keyword">return</span> resolveGenericArrayType((GenericArrayType) type, srcType, declaringClass);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> type; <span class="comment">// class类型</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 字段、返回值 、参 数 不可能直接定义 成WildcardType类 型，但可以嵌套在别 的类 型中</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了便于理解，通过一个示例分析<code>resolveType</code>方法， 假设有三个类 ClassA、SubClassA、TestType，代码如下：</p>
<p><code>ClassA</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassA</span> &lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123; </span><br><span class="line">  <span class="keyword">protected</span> Map&lt;K, V&gt; map;</span><br><span class="line">	<span class="comment">// ••• map 的 getter/setter 方 法 (略 )</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>SubClassA</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubClassA</span> &lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">ClassA</span>&lt;<span class="title">T</span>,<span class="title">T</span>&gt; </span>&#123; </span><br><span class="line">  <span class="comment">// ...... </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>TestType</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestType</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  SubClassA&lt;Long&gt; sa = <span class="keyword">new</span> SubClassA();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchFieldException </span>&#123;</span><br><span class="line">    Field f = ClassA.class.getDeclaredField(<span class="string">&quot;map&quot;</span>);</span><br><span class="line">    System.out.println(f.getGenericType());</span><br><span class="line">    System.out.println(f.getGenericType() <span class="keyword">instanceof</span> ParameterizedType);</span><br><span class="line">    <span class="comment">// 输出：</span></span><br><span class="line">    <span class="comment">// java.util.Map&lt;K, V&gt;</span></span><br><span class="line">    <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析SubA&lt;Long&gt;(ParameterizedType类 型)中的map字段，注意:ParameterizedTypelmpl是</span></span><br><span class="line">    <span class="comment">// 在 sun.reflect.generics.reflectiveObjects 包下的 ParameterizedType接口实 现</span></span><br><span class="line"></span><br><span class="line">    Type type = TypeParameterResolver.resolveFieldType(</span><br><span class="line">      f, ParameterizedTypelmpl.make(SubClassA.class, </span><br><span class="line">                                    <span class="keyword">new</span> Type[]&#123;Long.class&#125;, TestType.class));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//也可以使用下面的方式生成上述ParameterizedType对 象，</span></span><br><span class="line">    <span class="comment">// 并 调 用 TypeParameterResolver.resolveFieldType ()方 法 :</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// TypeParameterResolver.resolveFieldType(f,</span></span><br><span class="line">    <span class="comment">// TestType.class.getDeclaredField(&quot;sa&quot;).getGenericType());</span></span><br><span class="line">    System.out.println(type.getClass());</span><br><span class="line">    <span class="comment">// 输 出 :class TypeParameterResolver$ParameterizedTypelmpl</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注意，TypeParameterResolver$ParameterizedTypeImpl是ParameterizedType接口的实 现 </span></span><br><span class="line">    ParameterizedType p = (ParameterizedType) type; </span><br><span class="line">    System.out.println(p.getRawType());</span><br><span class="line">    <span class="comment">// 输 出 :interface java.util.Map</span></span><br><span class="line"></span><br><span class="line">    System.out.println(p.getOwnerType());</span><br><span class="line">    <span class="comment">// 输 出:null</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Type t : p .getActualTypeArguments()) &#123;</span><br><span class="line">      System.out.println(t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//输 出:</span></span><br><span class="line">    <span class="comment">// class java.lang.Long</span></span><br><span class="line">    <span class="comment">// class java.lang.Long</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据前面的Type接口的介绍，上例中ClassA.map字段声明的类型Map&lt;K,V&gt;是ParamelerizedType类型，resolveType()方法回调用resolvParameterizedType()方法进行解析。</p>
<p>首先介绍resolveParameterizedType()方法的参数：</p>
<ul>
<li>第一个参数是待解析的ParameterizedType类型</li>
<li>第二个参数是解析操作的起始类型</li>
<li>第三个参数为定义该字段或方法的类的Class对象</li>
</ul>
<p>在该示例中第一个参数是Map&lt;K,V&gt;对应的ParameterizedType对象，第二个参数是TypeTest.SubA<long>对应的ParameterizedType对象，第三个参数是ClassA（声明map字段的类）相应的Class对象。</long></p>
<p><strong>继续分析<code>scanSuperTypes()</code>方法</strong>，该方法回递归整个继承结构并完成类型变量的解析。在该示例之中，第一个参数K对应的TypeVariable对象，第二个参数是TypeText.SubA<long>对应的ParameterizedType对象，第三个参数是ClassA（声明map字段的类）对应的Class对象，第四个参数是SubClassA对应的Class对象，第五个参数是Class&lt;T,T&gt;对应的ParameterizedType对象。</long></p>
<p><code>scanSuperTypes()</code>方法的具体实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Type <span class="title">scanSuperTypes</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  TypeVariable&lt;?&gt; typeVar, Type srcType, </span></span></span><br><span class="line"><span class="function"><span class="params">  Class&lt;?&gt; declaringClass, Class&lt;?&gt; clazz, Type superclass)</span> </span>&#123;</span><br><span class="line">    Type result = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (superclass <span class="keyword">instanceof</span> ParameterizedType) &#123;</span><br><span class="line">      ParameterizedType parentAsType = (ParameterizedType) superclass;</span><br><span class="line">      Class&lt;?&gt; parentAsClass = (Class&lt;?&gt;) parentAsType.getRawType();</span><br><span class="line">      <span class="keyword">if</span> (declaringClass == parentAsClass) &#123;</span><br><span class="line">        Type[] typeArgs = parentAsType.getActualTypeArguments();</span><br><span class="line">        TypeVariable&lt;?&gt;[] declaredTypeVars = </span><br><span class="line">          declaringClass.getTypeParameters();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; declaredTypeVars.length; i++) &#123;</span><br><span class="line">          <span class="keyword">if</span> (declaredTypeVars[i] == typeVar) &#123;</span><br><span class="line">            <span class="keyword">if</span> (typeArgs[i] <span class="keyword">instanceof</span> TypeVariable) &#123;</span><br><span class="line">              TypeVariable&lt;?&gt;[] typeParams = clazz.getTypeParameters();</span><br><span class="line">              <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; typeParams.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (typeParams[j] == typeArgs[i]) &#123;</span><br><span class="line">                  <span class="keyword">if</span> (srcType <span class="keyword">instanceof</span> ParameterizedType) &#123;</span><br><span class="line">                    result = ((ParameterizedType) srcType).getActualTypeArguments()[j];</span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              result = typeArgs[i];</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (declaringClass.isAssignableFrom(parentAsClass)) &#123;</span><br><span class="line">        result = resolveTypeVar(typeVar, parentAsType, declaringClass);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (superclass <span class="keyword">instanceof</span> Class) &#123;</span><br><span class="line">      <span class="keyword">if</span> (declaringClass.isAssignableFrom((Class&lt;?&gt;) superclass)) &#123;</span><br><span class="line">        result = resolveTypeVar(typeVar, superclass, declaringClass);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>下图展示了scanSuperTypes()方法解析类型变量的核心逻辑。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://gitee.com/cayzlh/img-repo/raw/master/2020/06/07/image-20200607094904927_ZT0Sxt.png" alt="image-20200607094904927"></p>
<h4 id="ObjectFactory"><a href="#ObjectFactory" class="headerlink" title="ObjectFactory"></a>ObjectFactory</h4><p>MyBatis中很多模块会使用到ObjectFactory接口，该接口提供了多个create()方法的重载，通过这些create()方法可以创建指定类型的对象。ObjectFactory的定义如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ObjectFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Sets configuration properties.</span></span><br><span class="line"><span class="comment">   * 设置配置信息</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> properties configuration properties</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">setProperties</span><span class="params">(Properties properties)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Creates a new object with default constructor. </span></span><br><span class="line"><span class="comment">   * 通过无参构造器创建指定类的对象</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> type Object type</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  &lt;T&gt; <span class="function">T <span class="title">create</span><span class="params">(Class&lt;T&gt; type)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Creates a new object with the specified constructor and params.</span></span><br><span class="line"><span class="comment">   * 根据参数列表，从指定类型中选择合适的构造器创建对象</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> type Object type</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> constructorArgTypes Constructor argument types</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> constructorArgs Constructor argument values</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  &lt;T&gt; <span class="function">T <span class="title">create</span><span class="params">(Class&lt;T&gt; type, List&lt;Class&lt;?&gt;&gt; constructorArgTypes, List&lt;Object&gt; constructorArgs)</span></span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Returns true if this object can have a set of other objects.</span></span><br><span class="line"><span class="comment">   * It&#x27;s main purpose is to support non-java.util.Collection objects like Scala collections.</span></span><br><span class="line"><span class="comment">   * 检测指定类型是否为集合类型，主要处理java.util.Collectiopn及其子类</span></span><br><span class="line"><span class="comment">   * </span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> type Object type</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> whether it is a collection or not</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@since</span> 3.1.0</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  &lt;T&gt; <span class="function"><span class="keyword">boolean</span> <span class="title">isCollection</span><span class="params">(Class&lt;T&gt; type)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>DefaultObjectFactory</code>是<code>MyBatis</code>提供的<code>ObjectFactory</code>接口的唯一实 现 ，它 是一个 反射工厂 ， 其 <code>create()</code>方法通过 调 用 <code>instantiateClass()</code>方法实 现 。</p>
<p><code>DefaultObjectFactory.instantiateClass()</code>方法会 根据传 入的参 数 列表选 择 合适的构 造函数 实 例化对 象，具体 实 现 如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span>  &lt;T&gt; <span class="function">T <span class="title">instantiateClass</span><span class="params">(Class&lt;T&gt; type, List&lt;Class&lt;?&gt;&gt; constructorArgTypes, List&lt;Object&gt; constructorArgs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      Constructor&lt;T&gt; constructor;</span><br><span class="line">      <span class="keyword">if</span> (constructorArgTypes == <span class="keyword">null</span> || constructorArgs == <span class="keyword">null</span>) &#123;</span><br><span class="line">        constructor = type.getDeclaredConstructor();</span><br><span class="line">        <span class="keyword">if</span> (!constructor.isAccessible()) &#123;</span><br><span class="line">          constructor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> constructor.newInstance();</span><br><span class="line">      &#125;</span><br><span class="line">      constructor = type.getDeclaredConstructor(constructorArgTypes.toArray(<span class="keyword">new</span> Class[constructorArgTypes.size()]));</span><br><span class="line">      <span class="keyword">if</span> (!constructor.isAccessible()) &#123;</span><br><span class="line">        constructor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> constructor.newInstance(constructorArgs.toArray(<span class="keyword">new</span> Object[constructorArgs.size()]));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      StringBuilder argTypes = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">      <span class="keyword">if</span> (constructorArgTypes != <span class="keyword">null</span> &amp;&amp; !constructorArgTypes.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Class&lt;?&gt; argType : constructorArgTypes) &#123;</span><br><span class="line">          argTypes.append(argType.getSimpleName());</span><br><span class="line">          argTypes.append(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        argTypes.deleteCharAt(argTypes.length() - <span class="number">1</span>); <span class="comment">// remove trailing ,</span></span><br><span class="line">      &#125;</span><br><span class="line">      StringBuilder argValues = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">      <span class="keyword">if</span> (constructorArgs != <span class="keyword">null</span> &amp;&amp; !constructorArgs.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Object argValue : constructorArgs) &#123;</span><br><span class="line">          argValues.append(String.valueOf(argValue));</span><br><span class="line">          argValues.append(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        argValues.deleteCharAt(argValues.length() - <span class="number">1</span>); <span class="comment">// remove trailing ,</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> ReflectionException(<span class="string">&quot;Error instantiating &quot;</span> + type + <span class="string">&quot; with invalid types (&quot;</span> + argTypes + <span class="string">&quot;) or values (&quot;</span> + argValues + <span class="string">&quot;). Cause: &quot;</span> + e, e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>除了使用MyBatis提供的<code>DefaultObjectFactory</code>实现，还可以在mybatis-config.xml配置文件中指定自定义的ObjectFactory接口实现累， 从而实现功能上的扩展。</p>
<h4 id="Property工具类"><a href="#Property工具类" class="headerlink" title="Property工具类"></a>Property工具类</h4><p><code>org.apache.ibatis.reflection.property</code> 包下，提供了 PropertyCopier、PropertyNamer、PropertyTokenizer 三个属性相关的工具类。</p>
<p><strong>PropertyTokenizer</strong></p>
<p>在使用MyBatis的过程中，经常会碰到一些属性表达式，例如，在查询用户（User）的订单（Order）的结果集如下表所示：</p>
<table>
<thead>
<tr>
<th>user_name</th>
<th>order</th>
<th>item1</th>
<th>item2</th>
<th>…</th>
</tr>
</thead>
<tbody><tr>
<td>Mary</td>
<td>124640</td>
<td>iPhone 8 plus</td>
<td>MacBook Pro</td>
<td>…</td>
</tr>
<tr>
<td>Lisa</td>
<td>46546</td>
<td>iPhone 11 Pro</td>
<td>Mac Pro</td>
<td>…</td>
</tr>
<tr>
<td>…</td>
<td>…</td>
<td>…</td>
<td>…</td>
<td>…</td>
</tr>
</tbody></table>
<p>对象模型如下：</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://gitee.com/cayzlh/img-repo/raw/master/2020/06/07/image-20200607100948201_0zx3nS.png" alt="image-20200607100948201"></p>
<p>假设现在需要将结果集中的<code>item1</code>列雨用户第一个订单（Order）的第一条目（Item）的名称映射，<code>item2</code>与用户第一个订单的（Order）的第二条目（Item）的名称映射（这里仅仅是一个示例，在实际生产中很少这样的设计），我们可以得到下面的映射规则：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;rm4testProTool&quot;</span> <span class="attr">type</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;orders[0].items[0].name&quot;</span> <span class="attr">column</span>=<span class="string">&quot;iteml&quot;</span> /&gt;</span> </span><br><span class="line">	<span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;orders[0].items[1].name&quot;</span> <span class="attr">column</span>=<span class="string">&quot;item2&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在上面的例子中，<code>orders[0].items[0].name</code>这种由<code> .</code>和<code>[]</code>组成的表达式是由<code>PropertyTokenizer</code>进行解析的。以下是此类的源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PropertyTokenizer</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">PropertyTokenizer</span>&gt; </span>&#123;</span><br><span class="line">  <span class="comment">// 当前表达式的名称</span></span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 当前表达式的索引名</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> String indexedName;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 索引下标</span></span><br><span class="line">  <span class="keyword">private</span> String index;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 子表达式</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> String children;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">PropertyTokenizer</span><span class="params">(String fullname)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 查找 . 的位置</span></span><br><span class="line">    <span class="keyword">int</span> delim = fullname.indexOf(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (delim &gt; -<span class="number">1</span>) &#123;</span><br><span class="line">      <span class="comment">// 初始化 name</span></span><br><span class="line">      name = fullname.substring(<span class="number">0</span>, delim);</span><br><span class="line">      <span class="comment">// 初始化children</span></span><br><span class="line">      children = fullname.substring(delim + <span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      name = fullname;</span><br><span class="line">      children = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 初始化indexname</span></span><br><span class="line">    indexedName = name;</span><br><span class="line">    delim = name.indexOf(<span class="string">&#x27;[&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (delim &gt; -<span class="number">1</span>) &#123;</span><br><span class="line">      <span class="comment">// 初始化index</span></span><br><span class="line">      index = name.substring(delim + <span class="number">1</span>, name.length() - <span class="number">1</span>);</span><br><span class="line">      name = name.substring(<span class="number">0</span>, delim);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> index;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getIndexedName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> indexedName;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getChildren</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> children;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> children != <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// next方法中会创建PropertyTokenizer对象并解析children字段记录的子表达式</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> PropertyTokenizer <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> PropertyTokenizer(children);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">&quot;Remove is not supported, as it has no meaning in the context of properties.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>PropertyTokenizer</code>继承了<code>Iterator</code>接口，它可以迭代处理嵌套多层表达式。</p>
<p><code>next()</code>方法中会创建<code>PropertyTokenizer</code>对象并解析<code>children</code>字段记录的子表达式。</p>
<p>继续使用订单示例进行说明，描述解析属性表达式<code>orders[0].items[0].name</code>的迭代过程：</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://gitee.com/cayzlh/img-repo/raw/master/2020/06/07/image-20200607102830771_hVgxny.png" alt="image-20200607102830771"></p>
<p><strong>PropertyNamer</strong></p>
<p><code>PropertyNamer</code>是另一个工具类，提供了下列静态方法帮助完成方法名到属性名的转换，以及多种检测操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">PropertyNamer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">PropertyNamer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Prevent Instantiation of Static Class</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将方法名转换成属性名</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">methodToProperty</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (name.startsWith(<span class="string">&quot;is&quot;</span>)) &#123;</span><br><span class="line">      name = name.substring(<span class="number">2</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (name.startsWith(<span class="string">&quot;get&quot;</span>) || name.startsWith(<span class="string">&quot;set&quot;</span>)) &#123;</span><br><span class="line">      name = name.substring(<span class="number">3</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> ReflectionException(<span class="string">&quot;Error parsing property name &#x27;&quot;</span> + name + <span class="string">&quot;&#x27;.  Didn&#x27;t start with &#x27;is&#x27;, &#x27;get&#x27; or &#x27;set&#x27;.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (name.length() == <span class="number">1</span> || (name.length() &gt; <span class="number">1</span> &amp;&amp; !Character.isUpperCase(name.charAt(<span class="number">1</span>)))) &#123;</span><br><span class="line">      name = name.substring(<span class="number">0</span>, <span class="number">1</span>).toLowerCase(Locale.ENGLISH) + name.substring(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isProperty</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> name.startsWith(<span class="string">&quot;get&quot;</span>) || name.startsWith(<span class="string">&quot;set&quot;</span>) || name.startsWith(<span class="string">&quot;is&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isGetter</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> name.startsWith(<span class="string">&quot;get&quot;</span>) || name.startsWith(<span class="string">&quot;is&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isSetter</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> name.startsWith(<span class="string">&quot;set&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>PropertyCopier</strong></p>
<p><code>PropertyCopier</code>是一个属性拷贝的工具类，核心方法是<code>copyBeanProperties()</code>方法，主要实现相同类型的两个对象之间的属性值拷贝，具体如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">PropertyCopier</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">PropertyCopier</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Prevent Instantiation of Static Class</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">copyBeanProperties</span><span class="params">(Class&lt;?&gt; type, Object sourceBean, Object destinationBean)</span> </span>&#123;</span><br><span class="line">    Class&lt;?&gt; parent = type;</span><br><span class="line">    <span class="keyword">while</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">final</span> Field[] fields = parent.getDeclaredFields();</span><br><span class="line">      <span class="keyword">for</span>(Field field : fields) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">          field.set(destinationBean, field.get(sourceBean));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">          <span class="comment">// Nothing useful to do, will only fail on final fields, which will be ignored.</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 继续拷贝父类中定义的字段</span></span><br><span class="line">      parent = parent.getSuperclass();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="MetaClass"><a href="#MetaClass" class="headerlink" title="MetaClass"></a>MetaClass</h4><p><code>org.apache.ibatis.reflection.MetaClass</code> ，类的元数据，基于 Reflector 和 PropertyTokenizer ，提供对指定类的各种骚操作。实现了对复杂的属性表达式的解析，并实现了获取指定属性描述信息的功能。</p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MetaClass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 用于缓存Reflector对象</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ReflectorFactory reflectorFactory;</span><br><span class="line">  <span class="comment">// 创建MetaClass时会指定一个类，该Reflector对象会用于记录该类相关的元信息</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Reflector reflector;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// MetaClass的构造方法是使用private修饰的</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">MetaClass</span><span class="params">(Class&lt;?&gt; type, ReflectorFactory reflectorFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.reflectorFactory = reflectorFactory;</span><br><span class="line">    <span class="comment">// 创建Reflector对象</span></span><br><span class="line">    <span class="keyword">this</span>.reflector = reflectorFactory.findForClass(type);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 使用静态方法创建MetaClass对象</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> MetaClass <span class="title">forClass</span><span class="params">(Class&lt;?&gt; type, ReflectorFactory reflectorFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MetaClass(type, reflectorFactory);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> MetaClass <span class="title">metaClassForProperty</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    Class&lt;?&gt; propType = reflector.getGetterType(name);</span><br><span class="line">    <span class="keyword">return</span> MetaClass.forClass(propType, reflectorFactory);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">findProperty</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 委托给buildProperty()方法实现</span></span><br><span class="line">    StringBuilder prop = buildProperty(name, <span class="keyword">new</span> StringBuilder());</span><br><span class="line">    <span class="keyword">return</span> prop.length() &gt; <span class="number">0</span> ? prop.toString() : <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">findProperty</span><span class="params">(String name, <span class="keyword">boolean</span> useCamelCaseMapping)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (useCamelCaseMapping) &#123;</span><br><span class="line">      name = name.replace(<span class="string">&quot;_&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> findProperty(name);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> String[] getGetterNames() &#123;</span><br><span class="line">    <span class="keyword">return</span> reflector.getGetablePropertyNames();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> String[] getSetterNames() &#123;</span><br><span class="line">    <span class="keyword">return</span> reflector.getSetablePropertyNames();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> Class&lt;?&gt; getSetterType(String name) &#123;</span><br><span class="line">    PropertyTokenizer prop = <span class="keyword">new</span> PropertyTokenizer(name);</span><br><span class="line">    <span class="keyword">if</span> (prop.hasNext()) &#123;</span><br><span class="line">      MetaClass metaProp = metaClassForProperty(prop.getName());</span><br><span class="line">      <span class="keyword">return</span> metaProp.getSetterType(prop.getChildren());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> reflector.getSetterType(prop.getName());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> Class&lt;?&gt; getGetterType(String name) &#123;</span><br><span class="line">    PropertyTokenizer prop = <span class="keyword">new</span> PropertyTokenizer(name);</span><br><span class="line">    <span class="keyword">if</span> (prop.hasNext()) &#123;</span><br><span class="line">      MetaClass metaProp = metaClassForProperty(prop);</span><br><span class="line">      <span class="keyword">return</span> metaProp.getGetterType(prop.getChildren());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// issue #506. Resolve the type inside a Collection Object</span></span><br><span class="line">    <span class="keyword">return</span> getGetterType(prop);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> MetaClass <span class="title">metaClassForProperty</span><span class="params">(PropertyTokenizer prop)</span> </span>&#123;</span><br><span class="line">    Class&lt;?&gt; propType = getGetterType(prop);</span><br><span class="line">    <span class="keyword">return</span> MetaClass.forClass(propType, reflectorFactory);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Class&lt;?&gt; getGetterType(PropertyTokenizer prop) &#123;</span><br><span class="line">    Class&lt;?&gt; type = reflector.getGetterType(prop.getName());</span><br><span class="line">    <span class="keyword">if</span> (prop.getIndex() != <span class="keyword">null</span> &amp;&amp; Collection.class.isAssignableFrom(type)) &#123;</span><br><span class="line">      Type returnType = getGenericGetterType(prop.getName());</span><br><span class="line">      <span class="keyword">if</span> (returnType <span class="keyword">instanceof</span> ParameterizedType) &#123;</span><br><span class="line">        Type[] actualTypeArguments = ((ParameterizedType) returnType).getActualTypeArguments();</span><br><span class="line">        <span class="keyword">if</span> (actualTypeArguments != <span class="keyword">null</span> &amp;&amp; actualTypeArguments.length == <span class="number">1</span>) &#123;</span><br><span class="line">          returnType = actualTypeArguments[<span class="number">0</span>];</span><br><span class="line">          <span class="keyword">if</span> (returnType <span class="keyword">instanceof</span> Class) &#123;</span><br><span class="line">            type = (Class&lt;?&gt;) returnType;</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (returnType <span class="keyword">instanceof</span> ParameterizedType) &#123;</span><br><span class="line">            type = (Class&lt;?&gt;) ((ParameterizedType) returnType).getRawType();</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> type;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> Type <span class="title">getGenericGetterType</span><span class="params">(String propertyName)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      Invoker invoker = reflector.getGetInvoker(propertyName);</span><br><span class="line">      <span class="keyword">if</span> (invoker <span class="keyword">instanceof</span> MethodInvoker) &#123;</span><br><span class="line">        Field _method = MethodInvoker.class.getDeclaredField(<span class="string">&quot;method&quot;</span>);</span><br><span class="line">        _method.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        Method method = (Method) _method.get(invoker);</span><br><span class="line">        <span class="keyword">return</span> TypeParameterResolver.resolveReturnType(method, reflector.getType());</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (invoker <span class="keyword">instanceof</span> GetFieldInvoker) &#123;</span><br><span class="line">        Field _field = GetFieldInvoker.class.getDeclaredField(<span class="string">&quot;field&quot;</span>);</span><br><span class="line">        _field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        Field field = (Field) _field.get(invoker);</span><br><span class="line">        <span class="keyword">return</span> TypeParameterResolver.resolveFieldType(field, reflector.getType());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchFieldException e) &#123;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasSetter</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    PropertyTokenizer prop = <span class="keyword">new</span> PropertyTokenizer(name);</span><br><span class="line">    <span class="keyword">if</span> (prop.hasNext()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (reflector.hasSetter(prop.getName())) &#123;</span><br><span class="line">        MetaClass metaProp = metaClassForProperty(prop.getName());</span><br><span class="line">        <span class="keyword">return</span> metaProp.hasSetter(prop.getChildren());</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> reflector.hasSetter(prop.getName());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断指定属性是否有 getting 方法</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasGetter</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    PropertyTokenizer prop = <span class="keyword">new</span> PropertyTokenizer(name);</span><br><span class="line">    <span class="keyword">if</span> (prop.hasNext()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (reflector.hasGetter(prop.getName())) &#123;</span><br><span class="line">        MetaClass metaProp = metaClassForProperty(prop);</span><br><span class="line">        <span class="keyword">return</span> metaProp.hasGetter(prop.getChildren());</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> reflector.hasGetter(prop.getName());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Invoker <span class="title">getGetInvoker</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> reflector.getGetInvoker(name);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Invoker <span class="title">getSetInvoker</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> reflector.getSetInvoker(name);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> StringBuilder <span class="title">buildProperty</span><span class="params">(String name, StringBuilder builder)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 解析属性表达式</span></span><br><span class="line">    PropertyTokenizer prop = <span class="keyword">new</span> PropertyTokenizer(name);</span><br><span class="line">    <span class="keyword">if</span> (prop.hasNext()) &#123; <span class="comment">// 是否还有子表达式</span></span><br><span class="line">      <span class="comment">// 查找Propertytokenizer.name对应的属性</span></span><br><span class="line">      String propertyName = reflector.findPropertyName(prop.getName());</span><br><span class="line">      <span class="keyword">if</span> (propertyName != <span class="keyword">null</span>) &#123;</span><br><span class="line">        builder.append(propertyName);</span><br><span class="line">        builder.append(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">        <span class="comment">// 为该属性创建对应的MetaClass对象</span></span><br><span class="line">        MetaClass metaProp = metaClassForProperty(propertyName);</span><br><span class="line">        <span class="comment">// 递归解析children字段，将解析结果添加到builder中保存</span></span><br><span class="line">        metaProp.buildProperty(prop.getChildren(), builder);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 递归出口</span></span><br><span class="line">      String propertyName = reflector.findPropertyName(name);</span><br><span class="line">      <span class="keyword">if</span> (propertyName != <span class="keyword">null</span>) &#123;</span><br><span class="line">        builder.append(propertyName);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> builder;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasDefaultConstructor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> reflector.hasDefaultConstructor();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>MetaClass中比较重要的是findProperty()，它是通过调用MetaClass.buildProperty()方法实现的， 二buildProperty()方法会通过PropertyTokenizer解析复杂的属性表达式</strong></li>
</ul>
<h4 id="ObjectWrapper"><a href="#ObjectWrapper" class="headerlink" title="ObjectWrapper"></a>ObjectWrapper</h4><p><code>MetaClass</code>是Mybatis对类级别的元信息的封装和处理，下面来看MyBatis对对象级别的元信息的处理。<code>ObjectWrapper</code>接口是对对象的包装，抽象了对象的属性信息，它定义了一系列查询对象属性信息的方法，以及更新属性的方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ObjectWrapper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果ObjectWrapper中封装的是普通的Bean对象，则调用相应属性的相应getter方法，</span></span><br><span class="line">  <span class="comment">// 如果封装的是集合类，则获取指定key或下标对应的value值</span></span><br><span class="line">  <span class="function">Object <span class="title">get</span><span class="params">(PropertyTokenizer prop)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果ObjectWrapper中封装的是普通的Bean对象，则调用相应的setter方法</span></span><br><span class="line">  <span class="comment">// 如果封装的是集合类，则设置指定key或下标对应的value值</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(PropertyTokenizer prop, Object value)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 查找属性表达式指定的属性，第二个参数表示是否忽略属性表达式中的下划线</span></span><br><span class="line">  <span class="function">String <span class="title">findProperty</span><span class="params">(String name, <span class="keyword">boolean</span> useCamelCaseMapping)</span></span>;</span><br><span class="line"></span><br><span class="line">  String[] getGetterNames();</span><br><span class="line"></span><br><span class="line">  String[] getSetterNames();</span><br><span class="line"></span><br><span class="line">  Class&lt;?&gt; getSetterType(String name);</span><br><span class="line"></span><br><span class="line">  Class&lt;?&gt; getGetterType(String name);</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">hasSetter</span><span class="params">(String name)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">hasGetter</span><span class="params">(String name)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 为属性表达式的属性创建相应的MetaObject对象</span></span><br><span class="line">  <span class="function">MetaObject <span class="title">instantiatePropertyValue</span><span class="params">(String name, PropertyTokenizer prop, ObjectFactory objectFactory)</span></span>;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">isCollection</span><span class="params">()</span></span>;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(Object element)</span></span>;</span><br><span class="line">  </span><br><span class="line">  &lt;E&gt; <span class="function"><span class="keyword">void</span> <span class="title">addAll</span><span class="params">(List&lt;E&gt; element)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ObjectWrapperFactory负责创建ObjectWrapper对象。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://gitee.com/cayzlh/img-repo/raw/master/2020/06/07/image-20200607105809062_CxBOIT.png" alt="image-20200607105809062"></p>
<p><code>DefaultObjectWrapperFactory</code>实 现 了 <code>ObjectWrapperFactory</code>接口，但它 实 现 的 <code>getWrapperFor()</code> 方法始终 抛出异 常，<code>hasWrapperFor()</code>方法始终 返回false，所以该 实 现 实 际 上是不可用的。但是 与 ObjectFactory 类 似，我们 可以在 mybatis-config.xml 中配置自定义 的 ObjectWrapperFactory 实 现 类 进 行扩 展，在后面介绍 MyBatis初始化时 还 会 提到该 扩 展点。</p>
<p><code>BaseWrapper</code>是一个实现了<code>ObjectWrapper</code>接口的抽象类，其中封装了<code>MetaObject</code>对象，并提供了三个方勇的方法提供其子类使用：</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://gitee.com/cayzlh/img-repo/raw/master/2020/06/07/image-20200607110710849_oIM782.png" alt="image-20200607110710849"></p>
<p>BaseWrapper,resolveCollection()方法会 调 用 MetaObject.get Value()方法，它 会 解析属 性表达 式并 获 取指定的属 性。</p>
<p>BaseWrapper.getCollectionValue()方法和 setCollectionValue()方法会 解析属 性表达 式的索引 信息，然后获 取/设 置对 应 项 。</p>
<h4 id="MetaObject"><a href="#MetaObject" class="headerlink" title="MetaObject"></a>MetaObject</h4><p><code>org.apache.ibatis.reflection.MetaObject</code> ，对象元数据，提供了对象的属性值的获得和设置等等方法。 可以理解成，对 BaseWrapper 操作的进一步<strong>增强</strong>。</p>
<blockquote>
<p>ObjectWrapper提供了获取/设置对象中指定的属性值、检测getter/setter等常用功能，但是ObjectWrapper只是这些功能的最后一站，我们省略了对属性表达式解析过程的介绍，而该解析过程是在MetaObject中实现的。</p>
</blockquote>
<p><strong>MetaObject</strong>中字段的含义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 原始JavaBean对象</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Object originalObject;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上文介绍的ObjectWrapper对象，其中封装了originalObject对象</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ObjectWrapper objectWrapper;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 负责实例化originalObject的工厂对象</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ObjectFactory objectFactory;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 负责创建ObjectWrapper的工厂对象</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ObjectWrapperFactory objectWrapperFactory;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于创建并缓存Reflector对象的工厂对象</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReflectorFactory reflectorFactory;</span><br></pre></td></tr></table></figure>

<p><strong>MetaObject的构造方法</strong>会根据传入的原始对象的类型以及ObjectFactory工厂的实现， 创建相应的ObjectWrapper对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">MetaObject</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  Object object, ObjectFactory objectFactory, ObjectWrapperFactory objectWrapperFactory, ReflectorFactory reflectorFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.originalObject = object;</span><br><span class="line">    <span class="keyword">this</span>.objectFactory = objectFactory;</span><br><span class="line">    <span class="keyword">this</span>.objectWrapperFactory = objectWrapperFactory;</span><br><span class="line">    <span class="keyword">this</span>.reflectorFactory = reflectorFactory;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (object <span class="keyword">instanceof</span> ObjectWrapper) &#123;</span><br><span class="line">      <span class="keyword">this</span>.objectWrapper = (ObjectWrapper) object;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (objectWrapperFactory.hasWrapperFor(object)) &#123;</span><br><span class="line">      <span class="keyword">this</span>.objectWrapper = objectWrapperFactory.getWrapperFor(<span class="keyword">this</span>, object);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (object <span class="keyword">instanceof</span> Map) &#123;</span><br><span class="line">      <span class="keyword">this</span>.objectWrapper = <span class="keyword">new</span> MapWrapper(<span class="keyword">this</span>, (Map) object);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (object <span class="keyword">instanceof</span> Collection) &#123;</span><br><span class="line">      <span class="keyword">this</span>.objectWrapper = <span class="keyword">new</span> CollectionWrapper(<span class="keyword">this</span>, (Collection) object);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.objectWrapper = <span class="keyword">new</span> BeanWrapper(<span class="keyword">this</span>, object);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>MetaObject和ObjectWrapper中关于类级别的方法，例如hasGetter()、hasSetter()、findProperty()等方法，都是直接调用MetaClass的对应方法实现的。</p>
<p>其他方法都是关于对象级别的方法，这些方法都是与ObjectWrapper配合实现，例如MetaObject.getValue()/setValue()方法。</p>
<p>以下是getValue()的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getValue</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    PropertyTokenizer prop = <span class="keyword">new</span> PropertyTokenizer(name);</span><br><span class="line">    <span class="keyword">if</span> (prop.hasNext()) &#123;</span><br><span class="line">      <span class="comment">// 根据PropertyTokenizer解析后指定的属性，创建相应的MetaObject对象</span></span><br><span class="line">      MetaObject metaValue = metaObjectForProperty(prop.getIndexedName());</span><br><span class="line">      <span class="keyword">if</span> (metaValue == SystemMetaObject.NULL_META_OBJECT) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> metaValue.getValue(prop.getChildren());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> objectWrapper.get(prop);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><p>JDBC数据类型与Java语言中的数据类型并不是完全对应的，所以在PreparedStatement为SQL语句绑定参数时，需要从Java类型转换成JDBC类型，而从结果集获取数据的时候，则需要从JDBC类型转换成Java类型。</p>
<p>MyBatis使用类型转换处理器完车过了上述两种转换。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://gitee.com/cayzlh/img-repo/raw/master/2020/06/07/image-20200607224820211_lIdG1a.png" alt="image-20200607224820211"></p>
<blockquote>
<p>在 MyBatis中使用JdbcType这 个 枚举 类 型代表JDBC中的数 据类 型，该 枚举 类 型中定义 了 TYPE_CODE字段，记 录 了 JDBC类 型在java.sql.Types中相应 的常量 编 码 ，并 通过 一个 静 态 集合codeLookup (HashMap&lt;Integer，JdbcType&gt;类 型)维 护 了常量编 码 与JdbcType之间的对应关系。</p>
</blockquote>
<h4 id="TypeHandler"><a href="#TypeHandler" class="headerlink" title="TypeHandler"></a>TypeHandler</h4><p>MyBatis中所有的类 型转 换 器都继 承了 TypeHandler接口，在 TypeHandler接口中定义 了如 下四个 方法，这 四个 方法分为 两 类 :setParameter()方法负 责 将 数 据由JdbcType类 型转 换 成Java 类 型:<code>getResult()</code>方法及其重载 负 责 将 数 据由Java类 型转 换 成JdbcType类 型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TypeHandler</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//在通过 PreparedStatement为 SQL语 句绑 定参 数 时 ，会 将 数 据由JdbcType类 型转 换 成Java类 型</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">setParameter</span><span class="params">(PreparedStatement ps, <span class="keyword">int</span> i, T parameter, JdbcType jdbcType)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line">  </span><br><span class="line"><span class="comment">//从 ResultSet中获 取数 据时 会 调 用此方法，会 将 数 据由Java类 型转 换 成JdbcType类 型</span></span><br><span class="line">  <span class="function">T <span class="title">getResult</span><span class="params">(ResultSet rs, String columnName)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">T <span class="title">getResult</span><span class="params">(ResultSet rs, <span class="keyword">int</span> columnIndex)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">T <span class="title">getResult</span><span class="params">(CallableStatement cs, <span class="keyword">int</span> columnIndex)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了方便用户自定义TypeHandler实现，MyBatis提供了BaseTypeHandler这个抽象类，它实现了TypeHandler接口，并继承了TypeReference抽象类，其继承结构如下：</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://gitee.com/cayzlh/img-repo/raw/master/2020/06/07/image-20200607225857225_4Xvffn.png" alt="image-20200607225857225"></p>
<p>在BaseTypeHandler中实现了<code>TypeHandler.setParameter()</code>方法和<code>TypeHandler.getResult()</code>方法，具体实现如下。需要注意的是，这两个方法对于非空数据的处理都交给了子类实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseTypeHandler</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">TypeReference</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">TypeHandler</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span> Configuration configuration;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setConfiguration</span><span class="params">(Configuration c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.configuration = c;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setParameter</span><span class="params">(PreparedStatement ps, <span class="keyword">int</span> i, T parameter, JdbcType jdbcType)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (parameter == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (jdbcType == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> TypeException(<span class="string">&quot;JDBC requires that the JdbcType must be specified for all nullable parameters.&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        ps.setNull(i, jdbcType.TYPE_CODE);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> TypeException(<span class="string">&quot;Error setting null for parameter #&quot;</span> + i + <span class="string">&quot; with JdbcType &quot;</span> + jdbcType + <span class="string">&quot; . &quot;</span> +</span><br><span class="line">                <span class="string">&quot;Try setting a different JdbcType for this parameter or a different jdbcTypeForNull configuration property. &quot;</span> +</span><br><span class="line">                <span class="string">&quot;Cause: &quot;</span> + e, e);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        setNonNullParameter(ps, i, parameter, jdbcType);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> TypeException(<span class="string">&quot;Error setting non null for parameter #&quot;</span> + i + <span class="string">&quot; with JdbcType &quot;</span> + jdbcType + <span class="string">&quot; . &quot;</span> +</span><br><span class="line">                <span class="string">&quot;Try setting a different JdbcType for this parameter or a different configuration property. &quot;</span> +</span><br><span class="line">                <span class="string">&quot;Cause: &quot;</span> + e, e);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> T <span class="title">getResult</span><span class="params">(ResultSet rs, String columnName)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    T result;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      result = getNullableResult(rs, columnName);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> ResultMapException(<span class="string">&quot;Error attempting to get column &#x27;&quot;</span> + columnName + <span class="string">&quot;&#x27; from result set.  Cause: &quot;</span> + e, e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (rs.wasNull()) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> T <span class="title">getResult</span><span class="params">(ResultSet rs, <span class="keyword">int</span> columnIndex)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    T result;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      result = getNullableResult(rs, columnIndex);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> ResultMapException(<span class="string">&quot;Error attempting to get column #&quot;</span> + columnIndex+ <span class="string">&quot; from result set.  Cause: &quot;</span> + e, e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (rs.wasNull()) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> T <span class="title">getResult</span><span class="params">(CallableStatement cs, <span class="keyword">int</span> columnIndex)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    T result;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      result = getNullableResult(cs, columnIndex);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> ResultMapException(<span class="string">&quot;Error attempting to get column #&quot;</span> + columnIndex+ <span class="string">&quot; from callable statement.  Cause: &quot;</span> + e, e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (cs.wasNull()) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">setNonNullParameter</span><span class="params">(PreparedStatement ps, <span class="keyword">int</span> i, T parameter, JdbcType jdbcType)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> T <span class="title">getNullableResult</span><span class="params">(ResultSet rs, String columnName)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> T <span class="title">getNullableResult</span><span class="params">(ResultSet rs, <span class="keyword">int</span> columnIndex)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> T <span class="title">getNullableResult</span><span class="params">(CallableStatement cs, <span class="keyword">int</span> columnIndex)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一般情况下， TypeHandler用于完成单个参数以及单个列值的类型转换， 如果存在多列值转换成一个Java对象的需求，应该优先考虑在使用映射文件中定义合适的映射规则（<resultmap>）完成映射。</resultmap></p>
<h4 id="TypeHandlerRegistry"><a href="#TypeHandlerRegistry" class="headerlink" title="TypeHandlerRegistry"></a>TypeHandlerRegistry</h4><p>介绍完TypeHandler接口及其功能之后，MyBatis如何管理众多的TypeHanlder接口实现，如何知道何时使用哪个TypeHandler接口实现完成转换呢？</p>
<p>这个工作是由TypeHandlerRegistry完成的，在MyBatis初始化过程中，会为所有已知的TypeHanlder创建对象，并实现注册到TypeHandlerRegistry中， 由TypeHandlerRegistry负责管理这些TypeHandler对象。</p>
<p><strong>TypeHandlerRegistry</strong>中核心字段的含义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 记录JdbcType与TypeHandler之间的对应关系，其中JdbcType是一个枚举类型，它定义对应的JDBC类型</span></span><br><span class="line"><span class="comment">// 该集合主要用于从结果集读取数据时，将数据从Jdbc类型转换成Java类型</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;JdbcType, TypeHandler&lt;?&gt;&gt; JDBC_TYPE_HANDLER_MAP = </span><br><span class="line">  <span class="keyword">new</span> EnumMap&lt;JdbcType, TypeHandler&lt;?&gt;&gt;(JdbcType.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 记录了Java类型向指定JdbcType转换时，需要使用的TypeHandler对象。</span></span><br><span class="line"><span class="comment">// 例如Java类型中的String可能转换成数据库的char、varchar等多种类型，所以存在一对多关系</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Type, Map&lt;JdbcType, TypeHandler&lt;?&gt;&gt;&gt; TYPE_HANDLER_MAP = </span><br><span class="line">  <span class="keyword">new</span> ConcurrentHashMap&lt;Type, Map&lt;JdbcType, TypeHandler&lt;?&gt;&gt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 记录了全部TypeHandler的类型以及该类型相应的TypeHandler对象</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> TypeHandler&lt;Object&gt; UNKNOWN_TYPE_HANDLER = </span><br><span class="line">  <span class="keyword">new</span> UnknownTypeHandler(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 空TypeHandler集合的标识</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Class&lt;?&gt;, TypeHandler&lt;?&gt;&gt; ALL_TYPE_HANDLERS_MAP = </span><br><span class="line">  <span class="keyword">new</span> HashMap&lt;Class&lt;?&gt;, TypeHandler&lt;?&gt;&gt;();</span><br></pre></td></tr></table></figure>

<p><strong>1. 注册TypeHandler对象</strong></p>
<p>TypeHandlerRegistry.register()方法实 现 了注册 TypeHandler对 象的功能，该 注册 过 程会 向上 述四个 集合中添加TypeHandler对 象。register()方法有多个 重载 ，这 些重载 之间 的调 用关 系如图 。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://gitee.com/cayzlh/img-repo/raw/master/2020/06/07/image-20200607231443963_Zd5zVS.png" alt="image-20200607231443963"></p>
<p>从 上图中可以看出，多数 register()方法最终 会 调 用重载(4) 完成注册 功能，先来看该方法的实现，其三个 参 数 分别 指定了 TypeHandler能够 处 理的Java类 型、Jdbc类 型以及 TypeHandler对 象。</p>
<p>重载(4)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(Type javaType, JdbcType jdbcType, TypeHandler&lt;?&gt; handler)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (javaType != <span class="keyword">null</span>) &#123;<span class="comment">// 检测是否明确指定了TypeHanlder能够处理的Java类型</span></span><br><span class="line">    <span class="comment">// 获取指定java类型在TYPE_HANDLER_MAP集合中对应TypeHanlder集合</span></span><br><span class="line">    Map&lt;JdbcType, TypeHandler&lt;?&gt;&gt; map = TYPE_HANDLER_MAP.get(javaType);</span><br><span class="line">    <span class="keyword">if</span> (map == <span class="keyword">null</span> || map == NULL_TYPE_HANDLER_MAP) &#123;</span><br><span class="line">      <span class="comment">// 创建新的TypeHandler集合，并添加到TYPE_HANDLER_MAP中</span></span><br><span class="line">      map = <span class="keyword">new</span> HashMap&lt;JdbcType, TypeHandler&lt;?&gt;&gt;();</span><br><span class="line">      TYPE_HANDLER_MAP.put(javaType, map);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将TypeHandler对象注册到并添加到TYPE_HANDLER_MAP中</span></span><br><span class="line">    map.put(jdbcType, handler);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 向ALL_TYPE_HANDLERS_MAP集合注册TypeHandler类型和对应的TypeHanlder对象</span></span><br><span class="line">  ALL_TYPE_HANDLERS_MAP.put(handler.getClass(), handler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在(1)〜(3)这 三个 <code>register()</code>方法重载 中会 尝 试 读 取<code>TypeHandler</code>类 中定义 的<code>@MappedTypes</code> 注解和<code>@MappedJdbcTypes</code>注解，<code>@MappedTypes</code>注解用于指明该 <code>TypeHandler</code>实 现 类 能够 处 理 的Java类 型的集合，<code>@MappedJdbcTypes</code>注解用于指明该 <code>TypeHandler</code>实 现 类 能够 处 理的JDBC 类 型集合。<code>register()</code>方法的重载(1)〜(3)的具体 实 现 如下:</p>
<p>重载(1)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Only handler type</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(Class&lt;?&gt; typeHandlerClass)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">boolean</span> mappedTypeFound = <span class="keyword">false</span>;</span><br><span class="line">  MappedTypes mappedTypes = typeHandlerClass.getAnnotation(MappedTypes.class);</span><br><span class="line">  <span class="keyword">if</span> (mappedTypes != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (Class&lt;?&gt; javaTypeClass : mappedTypes.value()) &#123;</span><br><span class="line">      register(javaTypeClass, typeHandlerClass);</span><br><span class="line">      mappedTypeFound = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!mappedTypeFound) &#123;</span><br><span class="line">    register(getInstance(<span class="keyword">null</span>, typeHandlerClass));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重载(2)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">register</span><span class="params">(TypeHandler&lt;T&gt; typeHandler)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">boolean</span> mappedTypeFound = <span class="keyword">false</span>;</span><br><span class="line">  MappedTypes mappedTypes = typeHandler.getClass().getAnnotation(MappedTypes.class);</span><br><span class="line">  <span class="keyword">if</span> (mappedTypes != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (Class&lt;?&gt; handledType : mappedTypes.value()) &#123;</span><br><span class="line">      register(handledType, typeHandler);</span><br><span class="line">      mappedTypeFound = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// @since 3.1.0 - try to auto-discover the mapped type</span></span><br><span class="line">  <span class="keyword">if</span> (!mappedTypeFound &amp;&amp; typeHandler <span class="keyword">instanceof</span> TypeReference) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      TypeReference&lt;T&gt; typeReference = (TypeReference&lt;T&gt;) typeHandler;</span><br><span class="line">      register(typeReference.getRawType(), typeHandler);</span><br><span class="line">      mappedTypeFound = <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">      <span class="comment">// maybe users define the TypeReference with a different type and are not assignable, so just ignore it</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!mappedTypeFound) &#123;</span><br><span class="line">    register((Class&lt;T&gt;) <span class="keyword">null</span>, typeHandler);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重载(3)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">register</span><span class="params">(Type javaType, TypeHandler&lt;? extends T&gt; typeHandler)</span> </span>&#123;</span><br><span class="line">  MappedJdbcTypes mappedJdbcTypes = typeHandler.getClass().getAnnotation(MappedJdbcTypes.class);</span><br><span class="line">  <span class="keyword">if</span> (mappedJdbcTypes != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (JdbcType handledJdbcType : mappedJdbcTypes.value()) &#123;</span><br><span class="line">      register(javaType, handledJdbcType, typeHandler);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mappedJdbcTypes.includeNullJdbcType()) &#123;</span><br><span class="line">      register(javaType, <span class="keyword">null</span>, typeHandler);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    register(javaType, <span class="keyword">null</span>, typeHandler);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上 述 全 部 的 <code>register()</code>方 法 重 载 都 是 在 向 <code>TYPE_HANDLER_MAP</code>集 合 和 <code>ALL_TYPE_HANDLERS_MAP</code> 集合注册 <code>TypeHandler</code> 对 象，而重载(5)是向 <code>JDBC_TYPE_HANDLER_MAP</code> 集合注册 <code>TypeHandler</code>对 象，其具体 实 现 如下:</p>
<p>重载(5)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(JdbcType jdbcType, TypeHandler&lt;?&gt; handler)</span> </span>&#123;</span><br><span class="line">  JDBC_TYPE_HANDLER_MAP.put(jdbcType, handler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>TypeHandlerRegistry</code>除了提供注册 单 个 <code>TypeHandler的register()</code>重载 ，还 可以扫 描整个 包下 的<code>TypeHandler</code>接口实 现 类 ，并 将 完成这 些<code>TypeHandler</code>实 现 类 的注册 。</p>
<p>重载(6)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(String packageName)</span> </span>&#123;</span><br><span class="line">  ResolverUtil&lt;Class&lt;?&gt;&gt; resolverUtil = <span class="keyword">new</span> ResolverUtil&lt;Class&lt;?&gt;&gt;();</span><br><span class="line">  <span class="comment">// 查找指定包下的接口实现类</span></span><br><span class="line">  resolverUtil.find(<span class="keyword">new</span> ResolverUtil.IsA(TypeHandler.class), packageName);</span><br><span class="line">  Set&lt;Class&lt;? extends Class&lt;?&gt;&gt;&gt; handlerSet = resolverUtil.getClasses();</span><br><span class="line">  <span class="keyword">for</span> (Class&lt;?&gt; type : handlerSet) &#123;</span><br><span class="line">    <span class="comment">//Ignore inner classes and interfaces (including package-info.java) and abstract classes</span></span><br><span class="line">    <span class="keyword">if</span> (!type.isAnonymousClass() &amp;&amp; !type.isInterface() &amp;&amp; !Modifier.isAbstract(type.getModifiers())) &#123;</span><br><span class="line">      register(type);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2. 查找TypeHandler</strong></p>
<p><code>TypeHandlerRegistry</code>提供了查 找 <code>TypeHandler</code>对 象的功能。<code>TypeHandlerRegistry.getTypeHandler()</code>方法实 现 了从 上述四个 集合中获 取对 应 <code>TypeHandler</code>对 象的功能。TypeHandlerRegistry.getTypeHandler()方法有多个 重载 ，这 些重 载 之间 的关 系如下图所示。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://gitee.com/cayzlh/img-repo/raw/master/2020/06/08/image-20200608163219733_jqTbhc.png" alt="image-20200608163219733"></p>
<p>经 过 一系列类 型转 换 之后，<code>TypeHandlerRegistry.getTypeHandler()</code>方法的多个 重载 都会 调 用 <code>TypeHandlerRegistry.getTypeHandle(Type, JdbcType)</code>这 个 重载 方法，它 会 根据指定的 Java 类 型和 JdbcType类 型查 找 相应 的TypeHandler对 象。</p>
<h4 id="TypeAliasRegistry"><a href="#TypeAliasRegistry" class="headerlink" title="TypeAliasRegistry"></a>TypeAliasRegistry</h4><p>在编 写 SQL语 句时 ，使用别 名可以方便理解以及维 护 ，例如表名或列名很 长 时 ，我们 一般 会 为 其设 计 易懂 易维 护 的别 名。MyBatis将 SQL语 句中别 名的概 念进 行了延伸和扩 展，MyBatis 可以为 一个 类 添加一个 别 名，之后就可以通过 别 名引用该 类 。</p>
<p><code>MyBatis</code>通过 <code>TypeAliasRegistry</code>类 完成别 名注册 和管理的功能，<code>TypeAliasRegistry</code>的结 构 比 较 简 单 ，它 通过 <code>TYPE_ALIASES</code>字段(<code>Map&lt;String，Class&lt;?&gt;&gt;</code>类 型)管理别 名与 Java类 型之间 的对 应 关 系，通过 <code>TypeAHasRegistiy.registerAlias()</code>方法完成注册 别 名，该 方法的具体 实 现 如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerAlias</span><span class="params">(String alias, Class&lt;?&gt; value)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (alias == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> TypeException(<span class="string">&quot;The parameter alias cannot be null&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将别名转换成小写</span></span><br><span class="line">  String key = alias.toLowerCase(Locale.ENGLISH);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 检测别名是否存在</span></span><br><span class="line">  <span class="keyword">if</span> (TYPE_ALIASES.containsKey(key) </span><br><span class="line">      &amp;&amp; TYPE_ALIASES.get(key) != <span class="keyword">null</span> </span><br><span class="line">      &amp;&amp; !TYPE_ALIASES.get(key).equals(value)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> TypeException(<span class="string">&quot;...&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  TYPE_ALIASES.put(key, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在 <code>TypeAliasRegistry</code>的构 造方法中，默认 为 Java的基本类 型及其数 组 类 型、基本类 型的封 装 类 及其数组类型、Date、BigDecimal、Biglnteger、Map、HashMap、List、ArrayList、Collection、 Iterator、ResultSet等类 型添加了别名。</p>
</blockquote>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><p><strong>《MyBatis技术内幕》</strong></p>
</li>
<li><p>部分图片来源——<strong>《MyBatis技术内幕》</strong></p>
</li>
</ul>

  


  </article>
  
<div class="related-wrap" id="read-next"><section class="header cap theme"><span>接下来阅读</span></section><section class="body"><div class="post-title h2"><a href="/wiki/mybatis_technology_insider/part4.html">基础支持层——日志模块</a></div><div class="post-title fs14"><a href="/wiki/mybatis_technology_insider/part2.html">上一篇：基础支持层——解析器模块</a></div></section></div>

  




      
<footer class="page-footer fs12" style="text-align: center;"><hr><div><p><a href="https://www.cayzlh.com/">🐳Ant丶</a> ©️ 2017-2021</p>
<p><a target="_blank" rel="external nofollow noopener noreferrer" href="https://beian.miit.gov.cn/">粤ICP备20058712号</a></p>
</div></footer>

      <div class="float-panel mobile-only" style="display:none">
  <button type="button" class="sidebar-toggle mobile" onclick="sidebar.toggle()">
    <svg class="icon" viewbox="0 0 1228 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2849"><path d="M0 0m97.390199 0l973.901995 0q97.390199 0 97.390199 97.390199l0 0q0 97.390199-97.390199 97.3902l-973.901995 0q-97.390199 0-97.390199-97.3902l0 0q0-97.390199 97.390199-97.390199Z" p-id="2850"/><path d="M0 389.560798m97.390199 0l973.901995 0q97.390199 0 97.390199 97.390199l0 0q0 97.390199-97.390199 97.3902l-973.901995 0q-97.390199 0-97.390199-97.3902l0 0q0-97.390199 97.390199-97.390199Z" p-id="2851"/><path d="M0 779.121596m97.390199 0l973.901995 0q97.390199 0 97.390199 97.390199l0 0q0 97.390199-97.390199 97.390199l-973.901995 0q-97.390199 0-97.390199-97.390199l0 0q0-97.390199 97.390199-97.390199Z" p-id="2852"/></svg>
  </button>
</div>

    </div>
  </div>
  <div class="scripts">
    <script type="text/javascript">
  stellar = {
    // 懒加载 css https://github.com/filamentgroup/loadCSS
    loadCSS: (href, before, media, attributes) => {
      var doc = window.document;
      var ss = doc.createElement("link");
      var ref;
      if (before) {
        ref = before;
      } else {
        var refs = (doc.body || doc.getElementsByTagName("head")[0]).childNodes;
        ref = refs[refs.length - 1];
      }
      var sheets = doc.styleSheets;
      if (attributes) {
        for (var attributeName in attributes) {
          if (attributes.hasOwnProperty(attributeName)) {
            ss.setAttribute(attributeName, attributes[attributeName]);
          }
        }
      }
      ss.rel = "stylesheet";
      ss.href = href;
      ss.media = "only x";
      function ready(cb) {
        if (doc.body) {
          return cb();
        }
        setTimeout(function () {
          ready(cb);
        });
      }
      ready(function () {
        ref.parentNode.insertBefore(ss, before ? ref : ref.nextSibling);
      });
      var onloadcssdefined = function (cb) {
        var resolvedHref = ss.href;
        var i = sheets.length;
        while (i--) {
          if (sheets[i].href === resolvedHref) {
            return cb();
          }
        }
        setTimeout(function () {
          onloadcssdefined(cb);
        });
      };
      function loadCB() {
        if (ss.addEventListener) {
          ss.removeEventListener("load", loadCB);
        }
        ss.media = media || "all";
      }
      if (ss.addEventListener) {
        ss.addEventListener("load", loadCB);
      }
      ss.onloadcssdefined = onloadcssdefined;
      onloadcssdefined(loadCB);
      return ss;
    },

    // 从 butterfly 和 volantis 获得灵感
    loadScript: (src, opt) => new Promise((resolve, reject) => {
      var script = document.createElement('script')
      script.src = src
      if (opt) {
        for (let key of Object.keys(opt)) {
          script[key] = opt[key]
        }
      } else {
        // 默认异步，如果需要同步，第二个参数传入 {} 即可
        script.async = true
      }
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    }),

    // https://github.com/jerryc127/hexo-theme-butterfly
    jQuery: (fn) => {
      if (typeof jQuery === 'undefined') {
        stellar.loadScript(stellar.plugins.jQuery).then(fn)
      } else {
        fn()
      }
    }
  };
  stellar.github = 'https://github.com/xaoxuu/hexo-theme-stellar/tree/1.1.0';
  stellar.config = {
    date_suffix: {
      just: '刚刚',
      min: '分钟前',
      hour: '小时前',
      day: '天前',
      month: '个月前',
    },
  };

  // required plugins (only load if needs)
  stellar.plugins = {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js',
    sitesjs: '/js/plugins/sites.js',
    friendsjs: '/js/plugins/friends.js',
  };

  // optional plugins
  if ('true' == 'true') {
    stellar.plugins.lazyload = Object.assign({"enable":true,"js":"https://cdn.jsdelivr.net/npm/vanilla-lazyload@17.3.1/dist/lazyload.min.js","transition":"blur"});
  }
  if ('true' == 'true') {
    stellar.plugins.swiper = Object.assign({"enable":true,"css":"https://unpkg.com/swiper/swiper-bundle.min.css","js":"https://unpkg.com/swiper/swiper-bundle.min.js"});
  }
  if ('' == 'true') {
    stellar.plugins.scrollreveal = Object.assign({"enable":null,"js":"https://cdn.jsdelivr.net/npm/scrollreveal@4.0.9/dist/scrollreveal.min.js","distance":"8px","duration":500,"interval":100,"scale":1});
  }
  if ('true' == 'true') {
    stellar.plugins.preload = Object.assign({"enable":true,"service":"flying_pages","instant_page":"https://cdn.jsdelivr.net/gh/volantis-x/cdn-volantis@4.1.2/js/instant_page.js","flying_pages":"https://cdn.jsdelivr.net/gh/gijo-varghese/flying-pages@2.1.2/flying-pages.min.js"});
  }
</script>

<!-- required -->

  
<script src="/js/main.js" async></script>



<!-- optional -->

  <script>
  function utterances(){
    if(!document.getElementById("utterances"))return;
    setTimeout(function() {
      var checkUtterances = setInterval(function () {
        var el = document.getElementById("utterances");
        if (!el) return
        clearInterval(checkUtterances)
        try {
          el.innerHTML="";
        } catch (error) {}
        var script = document.createElement('script');
        script.src = 'https://utteranc.es/client.js';
        const keys = ['repo', 'issue-term', 'issue-number', 'theme', 'label', 'crossorigin'];
        keys.forEach((key, i) => {
          if (el.attributes[key] && el.attributes[key].value) {
            script.setAttribute(key, el.attributes[key].value);
          }
        });
        el.appendChild(script);
       }, 200)
    });
  }
  utterances();
</script>




<!-- inject -->


  </div>
</body>
</html>
