<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>HomeBrew换源</title>
      <link href="post/20210402/"/>
      <url>post/20210402/</url>
      
        <content type="html"><![CDATA[<h3 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h3><p>想安装<code>yarn</code>，于是执行：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">brew install yarn</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Error: </span><br><span class="line">  homebrew-core is a shallow <span class="built_in">clone</span>.</span><br><span class="line">  homebrew-cask is a shallow <span class="built_in">clone</span>.</span><br><span class="line">To `brew update`, first run:</span><br><span class="line">  git -C /usr/<span class="built_in">local</span>/Homebrew/Library/Taps/homebrew/homebrew-core fetch --unshallow</span><br><span class="line">  git -C /usr/<span class="built_in">local</span>/Homebrew/Library/Taps/homebrew/homebrew-cask fetch --unshallow</span><br><span class="line">This restriction has been made on GitHub<span class="string">&#x27;s request because updating shallow</span></span><br><span class="line"><span class="string">clones is an extremely expensive operation due to the tree layout and traffic of</span></span><br><span class="line"><span class="string">Homebrew/homebrew-core and Homebrew/homebrew-cask. We don&#x27;</span>t <span class="keyword">do</span> this <span class="keyword">for</span> you</span><br><span class="line">automatically to avoid repeatedly performing an expensive unshallow operation <span class="keyword">in</span></span><br><span class="line">CI systems (<span class="built_in">which</span> should instead be fixed to not use shallow clones). Sorry <span class="keyword">for</span></span><br><span class="line">the inconvenience!</span><br></pre></td></tr></table></figure><p>按照提示执行：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git -C /usr/<span class="built_in">local</span>/Homebrew/Library/Taps/homebrew/homebrew-core fetch --unshallow</span><br></pre></td></tr></table></figure><p>接着提示：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fatal: 无法访问 <span class="string">&#x27;https://github.com/Homebrew/homebrew-core/&#x27;</span>：</span><br><span class="line">Failed to connect to github.com port 443: Operation timed out</span><br></pre></td></tr></table></figure><p><code>github</code>的访问被神秘力量拒绝了，操作超时。</p><h3 id="换源"><a href="#换源" class="headerlink" title="换源"></a>换源</h3><blockquote><p>为解决这个问题，决定换源。<a href="https://mirrors.ustc.edu.cn/help/">USTC Mirror 帮助文档</a></p></blockquote><h4 id="替换Homebrew-Core-源"><a href="#替换Homebrew-Core-源" class="headerlink" title="替换Homebrew Core 源"></a>替换Homebrew Core 源</h4><p>替换 USTC 镜像：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> <span class="string">&quot;<span class="subst">$(brew --repo)</span>/Library/Taps/homebrew/homebrew-core&quot;</span></span><br><span class="line">git remote set-url origin https://mirrors.ustc.edu.cn/homebrew-core.git</span><br></pre></td></tr></table></figure><p>重置为官方地址：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> <span class="string">&quot;<span class="subst">$(brew --repo)</span>/Library/Taps/homebrew/homebrew-core&quot;</span></span><br><span class="line">git remote set-url origin https://github.com/Homebrew/homebrew-core</span><br></pre></td></tr></table></figure><h4 id="替换Homebrew-Cask-源"><a href="#替换Homebrew-Cask-源" class="headerlink" title="替换Homebrew Cask 源"></a>替换Homebrew Cask 源</h4><p>替换USTC镜像：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> <span class="string">&quot;<span class="subst">$(brew --repo)</span>&quot;</span>/Library/Taps/homebrew/homebrew-cask</span><br><span class="line">git remote set-url origin https://mirrors.ustc.edu.cn/homebrew-cask.git</span><br></pre></td></tr></table></figure><p>重置为官方源：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> <span class="string">&quot;<span class="subst">$(brew --repo)</span>&quot;</span>/Library/Taps/homebrew/homebrew-cask</span><br><span class="line">git remote set-url origin https://github.com/Homebrew/homebrew-cask</span><br></pre></td></tr></table></figure><h4 id="替换Homebrew-Cask-Versions-源"><a href="#替换Homebrew-Cask-Versions-源" class="headerlink" title="替换Homebrew Cask Versions 源"></a>替换Homebrew Cask Versions 源</h4><p>替换为 USTC 镜像：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> <span class="string">&quot;<span class="subst">$(brew --repo)</span>&quot;</span>/Library/Taps/homebrew/homebrew-cask-versions</span><br><span class="line">git remote set-url origin https://mirrors.ustc.edu.cn/homebrew-cask-versions.git</span><br></pre></td></tr></table></figure><p>重置为官方地址：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> <span class="string">&quot;<span class="subst">$(brew --repo)</span>&quot;</span>/Library/Taps/homebrew/homebrew-cask-versions</span><br><span class="line">git remote set-url origin https://github.com/Homebrew/homebrew-cask-versions.git</span><br></pre></td></tr></table></figure><h4 id="替换Homebrew-Bottles-源"><a href="#替换Homebrew-Bottles-源" class="headerlink" title="替换Homebrew Bottles 源"></a>替换Homebrew Bottles 源</h4><p>说明：<code>Homebrew</code> 预编译二进制软件包</p><p>在运行 brew 前设置环境变量 <code>HOMEBREW_BOTTLE_DOMAIN</code> ，值为 <code>https://mirrors.ustc.edu.cn/homebrew-bottles</code> 。</p><p><strong>对于bash用户</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;export HOMEBREW_BOTTLE_DOMAIN=https://mirrors.ustc.edu.cn/homebrew-bottles&#x27;</span> &gt;&gt; ~/.bash_profile</span><br><span class="line"><span class="built_in">source</span> ~/.bash_profile</span><br></pre></td></tr></table></figure><p><strong>对于zsh用户</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;export HOMEBREW_BOTTLE_DOMAIN=https://mirrors.ustc.edu.cn/homebrew-bottles&#x27;</span> &gt;&gt; ~/.zshrc</span><br><span class="line"><span class="built_in">source</span> ~/.zshrc</span><br></pre></td></tr></table></figure><hr><p>搞定。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="https://mirrors.ustc.edu.cn/help/homebrew-bottles.html#">Homebrew Bottles 源使用帮助</a></li><li><a href="https://mirrors.ustc.edu.cn/help/homebrew-core.git.html">Homebrew Core 源使用帮助</a></li><li><a href="https://mirrors.ustc.edu.cn/help/homebrew-cask.git.html">Homebrew Cask 源使用帮助</a></li><li><a href="https://mirrors.ustc.edu.cn/help/homebrew-cask-versions.git.html">Homebrew Cask Versions 源使用帮助</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 笔记本 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> macOS </tag>
            
            <tag> HomeBrew </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>哭</title>
      <link href="post/20210318/"/>
      <url>post/20210318/</url>
      
        <content type="html"><![CDATA[<p>上世纪六十年代，我上小学三年级的时候，学校里组织我们去参观一个苦难展览，我们在老师的引领下放声大哭。为了能让老师看到我的表现，我舍不得擦去脸上的泪水。我看到有几位同学悄悄地将唾沫抹到脸上冒充泪水。我还看到在一片真哭假哭的同学之间，有一位同学，脸上没有一滴泪，嘴巴里没有一点声音，也没有用手掩面。他睁着大眼看着我们，眼睛里流露出惊讶或者是困惑的神情。事后，我向老师报告了这位同学的行为。为此，学校给了这位同学一个警告处分。</p><p>多年之后，当我因自己的告密向老师忏悔时，老师说，那天来找他说这件事的，有十几个同学。这位同学十几年前就已去世，每当想起他，我就深感歉疚。这件事让我悟到一个道理，那就是：</p><p>“当众人都哭时，应该允许有的人不哭。当哭成为一种表演时，更应该允许有的人不哭。”</p><hr><ul><li><strong>作者：</strong>莫言</li></ul>]]></content>
      
      
      <categories>
          
          <category> 碎碎念 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 每日一文 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>maven安装本地jar包</title>
      <link href="post/2021031501/"/>
      <url>post/2021031501/</url>
      
        <content type="html"><![CDATA[<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mvn install:install-file -Dfile=[jar file path] -DgroupId=[groupId] -DartifactId=[artifactId] -Dversion=[version] -Dpackaging=jar</span><br></pre></td></tr></table></figure><p><strong>说明：</strong></p><ul><li><code>[jar file path]</code>：jar包的位置</li><li><code>[groupId]</code>：groupid</li><li><code>[artifactId] </code>：artifactId</li><li><code>[version]</code>：版本号</li></ul>]]></content>
      
      
      <categories>
          
          <category> 笔记本 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Maven </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二月二，龙抬头</title>
      <link href="post/20210314/"/>
      <url>post/20210314/</url>
      
        <content type="html"><![CDATA[<blockquote><p>2021年3月14日，周日，<strong>19℃~28℃</strong> 多云</p></blockquote><h2 id="踏青"><a href="#踏青" class="headerlink" title="踏青"></a>踏青</h2><p>今天天气不错，适合踏青。</p><p>大早上带着小粽去公园玩耍。</p><p><img src="https://7.dusays.com/2021/03/14/c57b7d84eaf49.png" alt="image-20210314173616329"></p><p>玩泡泡，非常开心。</p><h3 id="西贝筱面村"><a href="#西贝筱面村" class="headerlink" title="西贝筱面村"></a>西贝筱面村</h3><p>中午，在西贝解决了一顿，第一次不需要排队就吃上这家店。</p><p><img src="https://7.dusays.com/2021/03/14/5797d5a915feb.png" alt="image-20210314173201748"></p><p>一家老小都吃的很满足。</p><h2 id="理发"><a href="#理发" class="headerlink" title="理发"></a>理发</h2><blockquote><p>二月二龙抬头，“做6事3不做”，沾龙气，农村老传统</p></blockquote><p>其中之一的剪头发，当然也要撑着这个机会把小粽的头发给理了。</p><p>二月二可谓“中国传统理发日”， 民谚云“二月二剃龙头，一年都有精神头”。</p><p>清代《帝京岁时纪胜》中写，清代男子薙发（薙同“剃”），但正月有不动刀的“禁忌”，因此，一到“二月二”，皆“于是日栉薙，盖取‘龙抬头’之意”。</p><p>借龙抬头之吉时，孩子“剃喜头”，健康长大，出人头地，大人“剃龙头”，辞旧迎新，鸿运当头。</p><p><img src="https://7.dusays.com/2021/03/14/99877695b38e9.png" alt="image-20210314174838807"></p><h3 id="附"><a href="#附" class="headerlink" title="附"></a>附</h3><p>在元宵节过后，民间有一个重要节日，也就是“二月二龙抬头”，南方人将其称为踏青节，北方人称为青龙节。古人认为，这一天过后万物开始复苏，开始了春耕的时候，龙王也会苏醒，来到人间降雨，从而让万物得到滋润，开始了春暖花开的季节。</p><p><strong>传说二月二这天是尧王的诞辰，百姓们都会庆祝这一天，从而祈祷降雨，希望庄稼能够丰收。而在客家人眼里，二月二是土地公的诞辰，这一天要为其“暖寿”，村民们还要筹钱购买祭品，为土地公祭祀。</strong></p><p>“龙抬头”起源于伏羲时期，每年二月二这天都会亲自耕田，百姓们也会进行效仿，到了周武王时，更是将其制定为国策，让文武百官们都要在这一天亲耕，做好榜样力量。</p><p>唐代时对其更为重视，皇宫内会举办挑刺活动，在容器里栽种蔬菜，并将名字写下来压在背后，让官员猜测，中了皇帝会有奖励。而在元代时，二月二被称作“尹青龙”，这一天百姓们都会出门挑水，后来才正式和“龙抬头”关联起来。</p><p><strong>有人问，为何要将“二月二”认定为龙抬头之日？古人用28星宿概括星辰具体位置，从而预测未来的天象如何。而在二月二这天，星宿构成的东方青龙中，2个角从东方升起，看上去如同“龙抬头”一样，因此古人才将这天定义为龙抬头，为的是有好收成。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 碎碎念 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生活 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot单元测试</title>
      <link href="post/1832342668/"/>
      <url>post/1832342668/</url>
      
        <content type="html"><![CDATA[<h2 id="一、-单元测试的概念"><a href="#一、-单元测试的概念" class="headerlink" title="一、 单元测试的概念"></a>一、 单元测试的概念</h2><h3 id="概念："><a href="#概念：" class="headerlink" title="概念："></a><strong>概念：</strong></h3><ol><li>单元测试（unit testing），是指对软件中的最小可测试单元进行检查和验证。在Java中单元测试的最小单元是类。</li><li>单元测试是开发者编写的一小段代码，用于检验被测代码的一个很小的、很明确的功能是否正确。执行单元测试，就是为了证明这 段代码的行为和我们期望是否一致。</li></ol><h3 id="单元测试引用："><a href="#单元测试引用：" class="headerlink" title="单元测试引用："></a><strong>单元测试引用：</strong></h3><ol><li>众所周知，通过spring initialize创建的Spring Boot项目会在Maven中自动携带很多starter依赖：</li></ol><p><img src="https://cdn.jsdelivr.net/gh/cayzlh/git-img-repository@master/2021/03/14044716155290871615529087504.jpg" alt="图片"></p><p>其中包含了一个名为<code>spring-boot-starter-test</code>的依赖，本文是围绕这个依赖展开。</p><ol><li>Spring Boot中引入单元测试很简单，添加如下依赖（即<code>spring-boot-starter-test</code>依赖）：</li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;spring-boot-starter-test&lt;&#x2F;artifactId&gt;</span><br><span class="line">  &lt;scope&gt;test&lt;&#x2F;scope&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><ol><li>spring-boot-starter-test有如下几个库：</li></ol><p><code>spring-boot-starter-test</code>UML图：</p><p><img src="https://7.dusays.com/2021/03/12/208e02005c0b7.png" alt="image-20210312142854430"></p><p><img src="https://7.dusays.com/2021/03/12/23696982579aa.png" alt="image-20210312142907488"></p><h2 id="二、单元测试的作用"><a href="#二、单元测试的作用" class="headerlink" title="二、单元测试的作用"></a>二、单元测试的作用</h2><p>在没有接触单元测试之前我们是怎么做测试的？一般有两个方法：</p><p><img src="https://cdn.jsdelivr.net/gh/cayzlh/git-img-repository@master/2021/03/14044716155290871615529087678.jpg" alt="图片"></p><p>在时间允许的情况下，编写单元测试是程序员对代码的自测，这是对自己代码的负责。</p><h3 id="写单元测试的两个动机："><a href="#写单元测试的两个动机：" class="headerlink" title="写单元测试的两个动机："></a><strong>写单元测试的两个动机：</strong></h3><ol><li>保证或验证实现功能。</li><li>保护已经实现的功能不被破坏。</li></ol><h2 id="三、Spring-Boot引入的MockMvc的概念"><a href="#三、Spring-Boot引入的MockMvc的概念" class="headerlink" title="三、Spring Boot引入的MockMvc的概念"></a>三、Spring Boot引入的MockMvc的概念</h2><ol><li>什么是Mock?</li></ol><p>在面向对象的程序设计中，模拟对象（英语：mock object）是以可控的方式模拟真实对象行为的假对象。在编程过程中，通常通过模拟一些输入数据，来验证程序是否达到预期结果。</p><ol><li>为什么使用Mock对象？</li></ol><p>使用模拟对象，可以模拟复杂的、真实的对象行为。如果在单元测试中无法使用真实对象，可采用模拟对象进行替代。</p><ol><li>MockMvc的概念</li></ol><p>MockMvc是由spring-test包提供，实现了对Http请求的模拟，能够直接使用网络的形式，转换到Controller的调用，使得测试速度快、不依赖网络环境。同时提供了一套验证的工具，结果的验证十分方便。</p><p>接口MockMvcBuilder，提供一个唯一的build方法，用来构造MockMvc。主要有两个实现：StandaloneMockMvcBuilder和DefaultMockMvcBuilder。</p><p><img src="https://7.dusays.com/2021/03/12/8ca41b998aaab.png" alt="image-20210312142923082"></p><ol><li>MockMVC的基本步骤</li></ol><p>(1) mockMvc.perform执行一个请求。(2) MockMvcRequestBuilders.get(“XXX”)构造一个请求。(3) ResultActions.param添加请求传值 (4) ResultActions.accept()设置返回类型 (5) ResultActions.andExpect添加执行完成后的断言。(6) ResultActions.andDo添加一个结果处理器，表示要对结果做点什么事情，比如处使用print()输出整个响应结果信息。(7) ResultActions.andReturn表示执行完成后返回相应的结果。</p><h2 id="四、Service层的单元测试"><a href="#四、Service层的单元测试" class="headerlink" title="四、Service层的单元测试"></a>四、Service层的单元测试</h2><p><strong>第一步：</strong> Spring Boot中单元测试类写在src/test/java目录下，你可以手动创建具体测试类，也可以通过IDEA自动创建测试类，如下图：（注：点选并打开相应代码界面，再点击菜单栏的Navigate）</p><p><img src="https://7.dusays.com/2021/03/12/b9128a7d66811.png" alt="image-20210312140744322"></p><p><strong>第二步：</strong> 按照第一步的方法，点击测试后，出现<strong>图一</strong> 的对话框（如果想要测试的类已经存在测试类了会被列出来，也可以重新创建一个新的测试类），点击”Create New Test…”会弹出<strong>图二</strong> 的对话框，可以选择是否生成setUp以及要测试的成员方法等：</p><p>图一</p><p><img src="https://cdn.jsdelivr.net/gh/cayzlh/git-img-repository@master/2021/03/14044716155290871615529087979.jpg" alt="图片"></p><p>图二</p><p><img src="https://cdn.jsdelivr.net/gh/cayzlh/git-img-repository@master/2021/03/14044816155290881615529088115.jpg" alt="图片"></p><p><strong>第三步：</strong> 至此Service层的测试类就创建好了，测试类自动生成到了src/test/java目录下<strong>项目的同级目录中</strong> ，如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/cayzlh/git-img-repository@master/2021/03/14044816155290881615529088185.jpg" alt="图片"></p><p>Service层测试代码如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@SpringBootTest</span><br><span class="line">@RunWith(SpringRunner.class)</span><br><span class="line">public class XXXServiceTest &#123;</span><br><span class="line">@Resource</span><br><span class="line">private XXXService XXXService;</span><br><span class="line">@Test</span><br><span class="line">public void conflictTime() &#123;</span><br><span class="line">        DateTimeFormatter dtf &#x3D; DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd&quot;);</span><br><span class="line">        LocalDate start &#x3D; LocalDate.parse(&quot;2020-10-26&quot;, dtf);</span><br><span class="line">        LocalDate end &#x3D; LocalDate.parse(&quot;2020-10-31&quot;, dtf);</span><br><span class="line">        Integer integer &#x3D; XXXService.ConflictTime(&quot;10000001&quot;, start, end);</span><br><span class="line">        Assert.assertThat(integer, Matchers.notNullValue());&#x2F;&#x2F;assertThat断言后面介绍</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注解解释：</strong></p><p><code>@SpringBootTest</code>：获取启动类，加载配置，寻找主配置启动类（被 @SpringBootApplication 注解的） <code>@RunWith(SpringRunner.class)</code>：让JUnit运行Spring的测试环境,获得Spring环境的上下文的支持</p><h2 id="五、Controller层的单元测试"><a href="#五、Controller层的单元测试" class="headerlink" title="五、Controller层的单元测试"></a>五、Controller层的单元测试</h2><p>创建测试类步骤见第四部分，此处略。</p><p>第四部分只是针对Service层做了测试，但是咱么也需要对Controller层（API）做测试，这时候就用到MockMvc了，它使得你无需启动项目工程就能测试这些接口</p><p>MockMvc实现了对Http请求的模拟，能够直接使用网络的形式，转换到Controller的调用，这样可以使得测试速度快、不依赖网络环境，而且提供了一套验证的工具，这样可以使得请求的验证统一而且很方便。</p><p>Controller层部分的代码将分为三个代码块讲解，里面有看不懂的代码先不要着急哦😄，会在第五部分结尾处给大家汇总解答的，大家要坚持看到最后哟！😁</p><p><strong>代码块一：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@SpringBootTest</span><br><span class="line">@RunWith(SpringRunner.class)</span><br><span class="line">@AutoConfigureMockMvc</span><br><span class="line">public class DfTaskRecordControllerTest &#123;</span><br><span class="line">@Autowired</span><br><span class="line">private MockMvc mockMvc;</span><br><span class="line">@Before</span><br><span class="line">public void setUp() throws Exception &#123;</span><br><span class="line">       System.out.println(&quot;---------------start---------------&quot;);</span><br><span class="line">       save();</span><br><span class="line">get();</span><br><span class="line">       System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;end&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>注解解释：</strong></p><p><code>@SpringBootTest</code>&gt;：获取启动类，加载配置，寻找主配置启动类（被 @SpringBootApplication 注解的）</p><p><code>@RunWith(SpringRunner.class)</code>&gt;：让JUnit运行Spring的测试环境,获得Spring环境的上下文的支持 <code>@AutoConfigureMockMvc</code>：用于自动配置MockMvc,配置后MockMvc类可以直接注入,相当于new MockMvc <code>@Before</code>:初始化方法 ,对于每一个测试方法都要执行一次</p><p><strong>代码块二：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">@Transactional</span><br><span class="line">@Rollback()</span><br><span class="line">public void save() throws Exception &#123;</span><br><span class="line">        String json&quot;&#123;……&#125;&quot;;</span><br><span class="line">&#x2F;&#x2F;执行一个RequestBuilder请求，会自动执行SpringMVC的流程并映射到相应的控制器执行处理；</span><br><span class="line">        mockMvc.perform(MockMvcRequestBuilders</span><br><span class="line">                .post(&quot;&#x2F;XXX&#x2F;save&quot;)</span><br><span class="line">                .content(json.getBytes()) &#x2F;&#x2F;传json参数</span><br><span class="line">                .accept(MediaType.APPLICATION_JSON)</span><br><span class="line">                .contentType(MediaType.APPLICATION_JSON_VALUE)</span><br><span class="line">                .header(&quot;Authorization&quot;,&quot;Bearer ********-****-****-****-************&quot;)</span><br><span class="line">        )</span><br><span class="line">                .andExpect(MockMvcResultMatchers.status().isOk())</span><br><span class="line">                .andDo(print());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>注解解释：</strong></p><p><code>@Transactional</code>:开启事务功能</p><p><code>@Rollback()</code>: 事务回滚,默认是true</p><p><strong>代码块三：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void get() throws Exception&#123;</span><br><span class="line">        ResultActions resultActions &#x3D; mockMvc.perform(MockMvcRequestBuilders</span><br><span class="line">                .get(&quot;&#x2F;XXX&#x2F;get&quot;)</span><br><span class="line">                .param(&quot;id&quot;, &quot;**********&quot;)</span><br><span class="line">                .header(&quot;Authorization&quot;, &quot;Bearer ********-****-****-****-************&quot;)</span><br><span class="line">        );</span><br><span class="line">        resultActions.andReturn().getResponse().setCharacterEncoding(&quot;UTF-8&quot;);</span><br><span class="line">        resultActions.andExpect(MockMvcResultMatchers.status().isOk()).andDo(print());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>/get</code>运行结果如下：</p><p><img src="https://cdn.jsdelivr.net/gh/cayzlh/git-img-repository@master/2021/03/14044816155290881615529088275.jpg" alt="图片"></p><p><strong>现在将上面的一些琐碎的知识点汇总一下：</strong></p><p><code>1. mockMvc.perform</code>：执行一个请求</p><p><code>2. MockMvcRequestBuilders.get(“/XXX/get”)</code>：构造一个请求，Post请求使用.post方法</p><p><code>3. contentType(MediaType.APPLICATION_JSON_VALUE)</code>：代表发送端发送的数据格式是application/json;charset=UTF-8</p><p><code>4. accept(MediaType.APPLICATION_JSON)</code>：代表客户端希望接受的数据类型为application/json;charset=UTF-8</p><p><code>5. header(“Authorization”,“Bearer XXXX”)</code>：代表在报文头添加一些必须的信息，这里添加的是token</p><p><code>6. ResultActions.andExpect</code>：添加执行完成后的断言</p><p><code>7. ResultActions.andExpect(MockMvcResultMatchers.status().isOk())</code>：方法看请求的状态响应码是否为200如果不是则抛异常，测试不通过</p><p><code>8. ResultActions.andDo</code>：添加一个结果处理器，表示要对结果做点什么事情，比如此处使用print()：输出整个响应结果信息</p><h2 id="六、断言的概念"><a href="#六、断言的概念" class="headerlink" title="六、断言的概念"></a>六、断言的概念</h2><ol><li>断言（assert），是编程术语，表示为一些布尔表达式，程序员相信在程序中的某个特定点该表达式值为真。可以在任何时候启用和禁用断言验证，因此可以在测试时启用断言而在部署时禁用断言。</li><li>使用断言是判断一个函数或对象的一个方法所产生的结果是否符合你期望那个结果。</li></ol><h2 id="七、新断言assertThat使用"><a href="#七、新断言assertThat使用" class="headerlink" title="七、新断言assertThat使用"></a>七、新断言assertThat使用</h2><p>JUnit 4.4 结合 Hamcrest 提供了一个全新的断言语法——assertThat。程序员可以只使用 assertThat 一个断言语句，结合 Hamcrest 提供的匹配符，就可以表达全部的测试思想。</p><p><strong>assertThat 的优点：</strong></p><p><strong>优点 1：</strong> 以前 JUnit 提供了很多的 assertion 语句，如：assertEquals，assertNotSame，assertFalse，assertTrue，assertNotNull，assertNull 等，现在有了 JUnit 4.4，一条 assertThat 即可以替代所有的 assertion 语句，这样可以在所有的单元测试中只使用一个断言方法，使得编写测试用例变得简单，代码风格变得统一，测试代码也更容易维护。</p><p><strong>优点 2：</strong> assertThat 使用了 Hamcrest 的 Matcher 匹配符，用户可以使用匹配符规定的匹配准则精确的指定一些想设定满足的条件，具有很强的易读性，而且使用起来更加灵活。</p><p><strong>优点 3：</strong> assertThat 不再像 assertEquals 那样，使用比较难懂的“谓宾主”语法模式（如：assertEquals(3, x);），相反，assertThat 使用了类似于“主谓宾”的易读语法模式（如：assertThat(x,is(3));），使得代码更加直观、易读。</p><p><strong>assertThat 的基本语法如下：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">assertThat( [value], [matcher statement] );</span><br></pre></td></tr></table></figure><p><strong>value</strong> ：接下来想要测试的变量值；<strong>matcher statement</strong> ：使用 Hamcrest 匹配符来表达的对前面变量所期望的值的声明，如果 value 值与 matcher statement 所表达的期望值相符，则测试成功，否则测试失败。</p><h2 id="八、Postman与Spring-Boot-单元测试的区别"><a href="#八、Postman与Spring-Boot-单元测试的区别" class="headerlink" title="八、Postman与Spring Boot 单元测试的区别"></a>八、Postman与Spring Boot 单元测试的区别</h2><ol><li>Spring Boot的单元测试主要针对方法层面，可以测试Service层这类非对外暴露的接口的类中方法，并且可一次性批量测试多个方法、支持事务回滚。</li><li>Postman针对接口进行http测试，我平时这个比较多，创建的测试接口可保存、分类。</li></ol><h2 id="九、Postman基本用法"><a href="#九、Postman基本用法" class="headerlink" title="九、Postman基本用法"></a>九、Postman基本用法</h2><p>Postman是一款功能强大的网页调试与发送网页HTTP请求的工具。Postman能够发送任何类型的HTTP请求(GET, HEAD, POST,PUT..)，附带任何数量的参数和HTTP headers。支持不同的认证机制（basic, digest,OAuth），接收到的响应语法高亮（HTML，JSON或XML）。</p><p><strong>安装Postman</strong></p><p>官方网站：</p><p><a href="https://www.getpostman.com/apps">https://www.getpostman.com/apps</a></p><p><img src="https://7.dusays.com/2021/03/12/fb189913d88c3.png" alt="image-20210312140706367"></p><p>安装后，Postman是介样婶儿滴~~😊</p><p><img src="https://cdn.jsdelivr.net/gh/cayzlh/git-img-repository@master/2021/03/14044816155290881615529088535.jpg" alt="图片"></p>]]></content>
      
      
      <categories>
          
          <category> 编程技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 转载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>危险思想与言论自由</title>
      <link href="post/2567684096/"/>
      <url>post/2567684096/</url>
      
        <content type="html"><![CDATA[<p>思想本身没有丝毫危险的性质，只有愚暗与虚伪是顶危险的东西，只有禁止思想是顶危险的行为。</p><p>近来——自古已然——有许多人听见几个未曾听过、未能了解的名辞，便大惊小怪起来，说是危险思想。问他们这些思想有什么危险，为什么危险，他们认为危险思想的到底是些什么东西，他们都不能说出。象这种的人，我们和他共同生活，真是危险万分。</p><p>前些年科学的应用刚刚传入中国，一般愚暗的人都说是异端邪教。看待那些应用科学的发明的人，如同洪水猛兽一样。不晓得他们也是和我们同在一个世界上一样生存而且比我们进化的人类同胞，却说他们是“鬼子”，是“夷狄”。由此看来，到底是知识思想危险呢？还是愚暗无知危险呢？</p><p>听说日本有位议长，说俄国的布尔扎维克是实行托尔斯泰的学说，彼邦有识的人已经惊为奇谈。现在又出了一位明白公使，说我国人鼓吹爱国是无政府主义。他自己果然是这样愚暗无知，这更是可怜可笑的话。有人说他这话不过是利用我们政府的愚暗无知和恐怖的心理，故意来开玩笑。嗳呀！那更是我们莫大的耻辱！</p><p>原来恐怖和愚暗有密切的关系。青天白日，有眼的人在深池旁边走路，是一点也没有危险的。深池和走路的行为都不含着危险的性质。若是“盲人瞎马，夜半深池”那就危险万分，那就是最可恐怖的事情。可见危险和恐怖，都是愚昧造出来的，都是黑暗造出来的。</p><p>人生第一要求，就是光明与真实。只要得了光明与真实，什么东西、什么境界都不危险。知识是引导人生到光明与真实境界的灯烛，愚暗是达到光明与真实境界的障碍，也就是人生发展的障碍。</p><p>思想自由与言论自由，都是为保障人生达于光明与真实的境界而设的。无论什么思想言论，只要能够容他的真实没有矫揉造作的尽量发露出来，都是于人生有益，绝无一点害处。</p><p>说某种主义、学说是异端邪说的人，第一要知道他自己所排斥的主义、学说是什么东西，然后把这种主义、学说的真象，尽量传播，使人人都能认识他是异端邪说，大家自然不去信他，不至受他的害。若是自己未曾认清，只是强行禁止，就犯了泯没真实的罪恶。假使一种学说确与情理相合，我们硬要禁止他，不许公然传布，那是绝对无效。因为他的原素仍然在情理之中，情理不灭，这种学说也终不灭。假使一种学说确与情理相背，我以为不可禁止，不必禁止。因为大背情理的学说，正应该让大家知道，大家才不去信。若是把他隐蔽起来，很有容易被人误信的危险。</p><p>禁止人研究一种学说的，犯了使人愚暗的罪恶。禁止人信仰一种学说的，犯了教人虚伪的罪恶。世间本来没有“天经地义”与“异端邪说”这样东西。就说是有，也要听人去自由知识，自由信仰。就是错知识了、错信仰了所谓邪说异端，只要他的知识与信仰，是本于他思想的自由、知念的真实，一则得了自信，二则免了欺人，都是有益于人生的，都比那无知的排斥、自欺的顺从远好得多。</p><p>禁止思想是绝对不可能的，因为思想有超越一切的力量。监狱、刑罚、苦痛、穷困，乃至死杀，思想都能自由去思想他们，超越他们。这些东西，都不能钳制思想，束缚思想，禁止思想。这些东西，在思想中全没有一点价值，没有一点权威。</p><p>思想是绝对的自由，是不能禁止的自由，禁止思想自由的，断断没有一点的效果。你要禁止他，他的力量便跟着你的禁止越发强大。你怎样禁止他、制抑他、绝灭他、摧残他，他便怎样生存、发展、传播、滋荣，因为思想的性质力量，本来如此。我奉劝禁遏言论、思想自由的注意，要利用言论自由来破坏危险思想，不要借口危险思想来禁止言论自由。</p><p>1919年6月1日</p><hr><ul><li><strong>作者：</strong>李大钊</li></ul>]]></content>
      
      
      <categories>
          
          <category> 碎碎念 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 每日一文 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot自动部署脚本</title>
      <link href="post/3136136825/"/>
      <url>post/3136136825/</url>
      
        <content type="html"><![CDATA[<blockquote><p>SpringBoot自动部署脚本，可用于jenkins</p></blockquote><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> description:springboot 自动部署 1.0版本</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> version 1.0</span></span><br><span class="line">show_usage=&quot;args: [-t]\[--deploy-type=]&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash">版本部署路径</span>  </span><br><span class="line">mainpath=/data/service/youAppDir</span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash"> 应用名称</span></span><br><span class="line">appName=yourAppName</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">主函数</span></span><br><span class="line">function deploy()</span><br><span class="line">&#123;</span><br><span class="line">  cd $&#123;mainpath&#125;</span><br><span class="line">  echo &quot;[info]start deploy...[$(date +&#x27;%F %H:%M:%S&#x27;)]&quot;</span><br><span class="line">  stop</span><br><span class="line">  backup</span><br><span class="line">  upload</span><br><span class="line">  start</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">启动app</span></span><br><span class="line">function stop()&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">echo `ps -ef | grep $&#123;appName&#125; | grep -v &#x27;grep&#x27; | grep -v &#x27;deploy&#x27;|awk  &#x27;&#123;print $2&#125;&#x27; `; </span><br><span class="line"></span><br><span class="line">PIDCOUNT=`ps -ef | grep $&#123;appName&#125; | grep -v &#x27;grep&#x27; | grep -v &#x27;deploy&#x27; | awk  &#x27;&#123;print $2&#125;&#x27; | wc -l`;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">    echo &quot;stopping pid count:$PIDCOUNT&quot;</span><br><span class="line">    if [ $&#123;PIDCOUNT&#125; -gt 0 ];then</span><br><span class="line"> &#123;</span><br><span class="line">    # 获取进程ID</span><br><span class="line">appID=$(ps -ef | grep $&#123;appName&#125; | grep -v &#x27;grep&#x27; | grep -v &#x27;deploy&#x27; | awk  &#x27;&#123;print $2&#125;&#x27;)</span><br><span class="line">    echo &quot;[info]当前进程ID为:$appID&quot;</span><br><span class="line">kill -9 $appID</span><br><span class="line">&#125; || &#123; </span><br><span class="line">echo &quot;[info]进程ID为:$appID停止异常&quot;</span><br><span class="line">&#125;</span><br><span class="line">  fi</span><br><span class="line">  echo &quot;stoped pid:$appID&quot;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">启动app</span></span><br><span class="line">function start()&#123;</span><br><span class="line"></span><br><span class="line">echo &quot;starting $appName.jar&quot;</span><br><span class="line">    nohup java -jar -Dspring.profiles.active=test -Xms128m -Xmx512m $mainpath/$appName.jar &gt; /dev/null 2&gt;&amp;1 &amp;</span><br><span class="line"></span><br><span class="line">    echo &quot;success started $appName.jar&quot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash">上传文件</span></span><br><span class="line">function upload()&#123;</span><br><span class="line">echo &quot;uploading $mainpath/$&#123;appName&#125;.jar&quot;</span><br><span class="line">cp $mainpath/respo/$&#123;appName&#125;.jar $mainpath/$&#123;appName&#125;.jar</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">版本回滚</span>  </span><br><span class="line">deploy_Rollback()  </span><br><span class="line">&#123;  </span><br><span class="line"><span class="meta">#</span><span class="bash">进入备份文件夹</span>  </span><br><span class="line">    cd $&#123;mainpath&#125;/backup/  </span><br><span class="line">    #获取最新备份文件  </span><br><span class="line">    file_name_new=&#x27;&#x27;  </span><br><span class="line">    for i in `ls -tr`;  </span><br><span class="line">    do  </span><br><span class="line">        echo $i;  </span><br><span class="line">        file_name_new=$i;  </span><br><span class="line">    done;  </span><br><span class="line">    #将备份文件复制到webapps  </span><br><span class="line">    cp  $&#123;mainpath&#125;/backup/$&#123;file_name_new&#125; $&#123;mainpath&#125;/$&#123;appName&#125;.jar </span><br><span class="line">    if [ $? -eq 0 ]  </span><br><span class="line">    then  </span><br><span class="line">        echo 复制$&#123;file_name_new&#125;成功  </span><br><span class="line">    else  </span><br><span class="line">        echo 复制失败，退出！  </span><br><span class="line">    exit 1  </span><br><span class="line">    fi  </span><br><span class="line">    #进入webapps/目录  </span><br><span class="line">    cd  $&#123;mainpath&#125;</span><br><span class="line">    #重启App </span><br><span class="line">    stop</span><br><span class="line">    start  </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">备份原来的项目</span></span><br><span class="line">function backup()</span><br><span class="line">&#123;</span><br><span class="line">echo &quot;开始备份to$&#123;mainpath&#125;....&quot;</span><br><span class="line">fileDate=$(date &quot;+%Y%m%d%H%M%S&quot;)</span><br><span class="line">fileName=$&#123;appName&#125;$&#123;fileDate&#125;</span><br><span class="line">mv $mainpath/$&#123;appName&#125;.jar $mainpath/backup/$&#123;fileName&#125;.jar</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">echo --------欢迎使用shell自动部署脚本--------    </span><br><span class="line"><span class="meta">#</span><span class="bash">获取用户操作</span>  </span><br><span class="line">case $wm2 in  </span><br><span class="line">rollback)  </span><br><span class="line">    deploy_Rollback  </span><br><span class="line">    ;;  </span><br><span class="line">*)  </span><br><span class="line">    deploy  </span><br><span class="line">    ;;  </span><br><span class="line">esac</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记本 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Linux </tag>
            
            <tag> Spring </tag>
            
            <tag> SpringBoot </tag>
            
            <tag> shell </tag>
            
            <tag> Jenkins </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot启动脚本</title>
      <link href="post/2348855541/"/>
      <url>post/2348855541/</url>
      
        <content type="html"><![CDATA[<blockquote><p>SpringBoot启动脚本</p></blockquote><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/sh</span></span><br><span class="line"></span><br><span class="line">appName=yourAppName</span><br><span class="line">pidFile=&quot;$appName.pid&quot;</span><br><span class="line"></span><br><span class="line">start()&#123;</span><br><span class="line">    if [ -f &quot;$pidFile&quot; ]; then</span><br><span class="line">        pid=$(cat &quot;$pidFile&quot;)</span><br><span class="line">        echo &quot;STOP pid:$pid&quot;</span><br><span class="line">        kill -9 $pid</span><br><span class="line">        rm &quot;$pidFile&quot;</span><br><span class="line">    fi</span><br><span class="line">    nohup java -jar -Dspring.profiles.active=test -Xms128m -Xmx512m $appName.jar &gt; /dev/null 2&gt;&amp;1 &amp;</span><br><span class="line">    echo $! &gt; &quot;$pidFile&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">stop()&#123;</span><br><span class="line">   if [ -f &quot;$pidFile&quot; ]; then</span><br><span class="line">        pid=$(cat &quot;$pidFile&quot;)</span><br><span class="line">        echo &quot;STOP pid:$pid&quot;</span><br><span class="line">        kill -9 $pid</span><br><span class="line">        rm &quot;$pidFile&quot;</span><br><span class="line">    fi</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">case &quot;$1&quot; in</span><br><span class="line">  start)</span><br><span class="line">    start</span><br><span class="line">  ;;</span><br><span class="line">  stop)</span><br><span class="line">    stop</span><br><span class="line">  ;;</span><br><span class="line">  *)</span><br><span class="line">    printf &#x27;Usage: %s &#123;start|stop&#125;\n&#x27; &quot;$prog&quot;  </span><br><span class="line">    exit 1  </span><br><span class="line">  ;;</span><br><span class="line">esac</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记本 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Linux </tag>
            
            <tag> Spring </tag>
            
            <tag> SpringBoot </tag>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nginx简单配置示例</title>
      <link href="post/2487533199/"/>
      <url>post/2487533199/</url>
      
        <content type="html"><![CDATA[<blockquote><p>nginx简单配置示例</p></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># rewrite to Https</span></span><br><span class="line">server &#123;</span><br><span class="line">    listen  80;</span><br><span class="line">    server_name xxx.xxx.com;</span><br><span class="line"></span><br><span class="line">    rewrite ^(.*)$  https://$host<span class="variable">$1</span> permanent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen       443 ssl;</span><br><span class="line">    server_name  xxx.xxx.com;</span><br><span class="line"></span><br><span class="line">    ssl_certificate      /opt/nginx/ssl/xxxxx.pem;</span><br><span class="line">    ssl_certificate_key  /opt/nginx/ssl/xxxxx.key;</span><br><span class="line"></span><br><span class="line">    ssl_session_cache    shared:SSL:1m;</span><br><span class="line">    ssl_session_timeout  5m;</span><br><span class="line"></span><br><span class="line">    ssl_ciphers  HIGH:!aNULL:!MD5;</span><br><span class="line">    ssl_prefer_server_ciphers  on;</span><br><span class="line">    </span><br><span class="line">    underscores_in_headers on; </span><br><span class="line"></span><br><span class="line">   location ~ /demo &#123;</span><br><span class="line"></span><br><span class="line">        proxy_set_header   Host             xxx.xxx.com;</span><br><span class="line"></span><br><span class="line">        proxy_set_header   X-Real-IP        <span class="variable">$http_x_forwarded_for</span>;</span><br><span class="line"></span><br><span class="line">        proxy_set_header   X-Forwarded-For  <span class="variable">$http_x_forwarded_for</span>;</span><br><span class="line"></span><br><span class="line">        proxy_pass                          http://xxx.service;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记本 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git常用命令整理</title>
      <link href="post/3502630734/"/>
      <url>post/3502630734/</url>
      
        <content type="html"><![CDATA[<p><code>Git</code>的四个组成部分：</p><p><img src="https://github.com/cayzlh/git-img-repository/raw/master/blog/2018/11/10/1.jpg" alt="Git的四个组成部分"></p><h1 id="远程操作详解"><a href="#远程操作详解" class="headerlink" title="远程操作详解"></a>远程操作详解</h1><h2 id="git-clone"><a href="#git-clone" class="headerlink" title="git clone"></a>git clone</h2><p>远程操作的第一步，通常是从远程主机克隆一个版本库，这时就要用到<code>git clone</code>命令。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone &lt;版本库的网址&gt;</span><br></pre></td></tr></table></figure><p>比如：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/cayzlh/Scaffold.git</span><br></pre></td></tr></table></figure><p>该命令会在本地主机生成一个目录，与远程主机的版本库同名。如果要指定不同的目录名，可以将目录名作为<code>git clone</code>命令的第二个参数。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone &lt;版本库的网址&gt; &lt;本地目录名&gt;</span><br></pre></td></tr></table></figure><p><code>git clone</code>支持多种协议，除了HTTP(s)以外，还支持SSH、Git、本地文件协议等：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone http[s]://example.com/path/to/repo.git/</span><br><span class="line">git clone ssh://example.com/path/to/repo.git/</span><br><span class="line">git clone git://example.com/path/to/repo.git/</span><br><span class="line">git clone /opt/git/project.git </span><br><span class="line">git clone file:///opt/git/project.git</span><br><span class="line">git clone ftp[s]://example.com/path/to/repo.git/</span><br><span class="line">git clone rsync://example.com/path/to/repo.git/</span><br></pre></td></tr></table></figure><p>SSH协议还有另一种写法：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">clone</span> [user@]example.com:path/to/repo.git/</span></span><br></pre></td></tr></table></figure><h2 id="git-remote"><a href="#git-remote" class="headerlink" title="git remote"></a>git remote</h2><p>为了便于管理，<code>Git</code>要求每个远程主机都必须指定一个主机名。<code>git remote</code>命令就用于管理主机名。</p><p>不带选项的时候，<code>git remote</code>命令列出所有远程主机。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git remote</span><br><span class="line">origin</span><br></pre></td></tr></table></figure><p>使用<code>-v</code>选项，可以参看远程主机的网址。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git remote -v</span><br><span class="line">originhttps://github.com/cayzlh/Scaffold.git (fetch)</span><br><span class="line">originhttps://github.com/cayzlh/Scaffold.git (push)</span><br></pre></td></tr></table></figure><p>当前只有一台远程主机，叫做origin，以及它的网址。</p><p>克隆版本库的时候，所使用的远程主机自动被Git命名为<code>origin</code>。如果想用其他的主机名，需要用<code>git clone</code>命令的<code>-o</code>选项指定。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone -o Scaffold https://github.com/cayzlh/Scaffold.git</span><br><span class="line">git remote</span><br><span class="line">Scaffold</span><br></pre></td></tr></table></figure><p><code>git remote show</code>命令加上主机名，可以查看该主机的详细信息。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git remote show &lt;主机名&gt;</span><br></pre></td></tr></table></figure><p><code>git remote add</code>命令用于添加远程主机。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git remote add &lt;主机名&gt; &lt;网址&gt;</span><br></pre></td></tr></table></figure><p><code>git remote rm</code>命令用于删除远程主机。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git remote rm &lt;主机名&gt;</span><br></pre></td></tr></table></figure><p><code>git remote rename</code>命令用于远程主机的改名。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git remote rename &lt;原主机名&gt; &lt;新主机名&gt;</span><br></pre></td></tr></table></figure><h2 id="git-fetch"><a href="#git-fetch" class="headerlink" title="git fetch"></a>git fetch</h2><p>一旦远程主机的版本库有了更新（Git术语叫做commit），需要将这些更新取回本地，这时就要用到<code>git fetch</code>命令。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git fetch &lt;远程主机名&gt;</span><br></pre></td></tr></table></figure><p>这个命令表述将某个远程主机的更新，全部取回本地。</p><p>取回<code>origin</code>主机的<code>master</code>分支。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git fetch origin master</span><br></pre></td></tr></table></figure><p><code>git branch</code>命令的<code>-r</code>选项，可以用来查看远程分支，<code>-a</code>选项查看所有分支。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git branch -r</span><br><span class="line"></span><br><span class="line">origin/HEAD -&gt; origin/master</span><br><span class="line">origin/master</span><br></pre></td></tr></table></figure><p>上面命令表示，本地主机的当前分支是<code>master</code>，远程分支是<code>origin/master</code>。</p><p>取回远程主机的更新以后，可以在它的基础上，使用<code>git checkout</code>命令创建一个新的分支。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git checkout -b newBrach origin/master</span><br></pre></td></tr></table></figure><p>上面命令表示，在<code>origin/master</code>的基础上，创建一个新分支。</p><p>此外，也可以使用<code>git merge</code>命令或者<code>git rebase</code>命令，在本地分支上合并远程分支。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git merge origin/master</span><br><span class="line"><span class="meta">#</span><span class="bash"> 或者</span></span><br><span class="line">git rebase origin/master</span><br></pre></td></tr></table></figure><p>上面命令表示在当前分支上，合并<code>origin/master</code>。</p><h2 id="git-pull"><a href="#git-pull" class="headerlink" title="git pull"></a>git pull</h2><p><code>git pull</code>命令的作用是，取回远程主机某个分支的更新，再与本地的指定分支合并。它的完整格式稍稍有点复杂。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;</span><br></pre></td></tr></table></figure><p>比如，取回<code>origin</code>主机的<code>next</code>分支，与本地的<code>master</code>分支合并，需要写成下面这样。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git pull origin next:master</span><br></pre></td></tr></table></figure><p>如果远程分支是与当前分支合并，则冒号后面的部分可以省略。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git pull origin next</span><br></pre></td></tr></table></figure><p>上面命令表示，取回<code>origin/next</code>分支，再与当前分支合并。实质上，这等同于先做<code>git fetch</code>，再做<code>git merge</code>。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git fetch origin</span><br><span class="line">git merge origin/next</span><br></pre></td></tr></table></figure><p>在某些场合，Git会自动在本地分支与远程分支之间，建立一种追踪关系（tracking）。比如，在<code>git clone</code>的时候，所有本地分支默认与远程主机的同名分支，建立追踪关系，也就是说，本地的<code>master</code>分支自动”追踪”<code>origin/master</code>分支。</p><p>Git也允许手动建立追踪关系。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git branch --set-upstream master origin/next</span><br></pre></td></tr></table></figure><p>上面命令指定<code>master</code>分支追踪<code>origin/next</code>分支。</p><p>如果当前分支与远程分支存在追踪关系，<code>git pull</code>就可以省略远程分支名。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git pull origin</span><br></pre></td></tr></table></figure><p>上面命令表示，本地的当前分支自动与对应的<code>origin</code>主机”追踪分支”（remote-tracking branch）进行合并。</p><p>如果当前分支只有一个追踪分支，连远程主机名都可以省略。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git pull</span><br></pre></td></tr></table></figure><p>上面命令表示，当前分支自动与唯一一个追踪分支进行合并。</p><p>如果合并需要采用rebase模式，可以使用<code>--rebase</code>选项。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git pull --rebase &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;</span><br></pre></td></tr></table></figure><p>如果远程主机删除了某个分支，默认情况下，<code>git pull</code> 不会在拉取远程分支的时候，删除对应的本地分支。这是为了防止，由于其他人操作了远程主机，导致<code>git pull</code>不知不觉删除了本地分支。</p><p>但是，你可以改变这个行为，加上参数 <code>-p</code> 就会在本地删除远程已经删除的分支。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git pull -p</span><br><span class="line"><span class="meta">#</span><span class="bash"> 等同于下面的命令</span></span><br><span class="line">git fetch --prune origin </span><br><span class="line">git fetch -p</span><br></pre></td></tr></table></figure><h2 id="git-push"><a href="#git-push" class="headerlink" title="git push"></a>git push</h2><p><code>git push</code>命令用于将本地分支的更新，推送到远程主机。它的格式与<code>git pull</code>命令相仿。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;</span><br></pre></td></tr></table></figure><p>注意，分支推送顺序的写法是&lt;来源地&gt;:&lt;目的地&gt;，所以<code>git pull</code>是&lt;远程分支&gt;:&lt;本地分支&gt;，而<code>git push</code>是&lt;本地分支&gt;:&lt;远程分支&gt;。</p><p>如果省略远程分支名，则表示将本地分支推送与之存在”追踪关系”的远程分支（通常两者同名），如果该远程分支不存在，则会被新建。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git push origin master</span><br></pre></td></tr></table></figure><p>上面命令表示，将本地的<code>master</code>分支推送到<code>origin</code>主机的<code>master</code>分支。如果后者不存在，则会被新建。</p><p>如果省略本地分支名，则表示删除指定的远程分支，因为这等同于推送一个空的本地分支到远程分支。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git push origin :master</span><br><span class="line"><span class="meta">#</span><span class="bash"> 等同于</span></span><br><span class="line">git push origin --delete master</span><br></pre></td></tr></table></figure><p>上面命令表示删除<code>origin</code>主机的<code>master</code>分支。</p><p>如果当前分支与远程分支之间存在追踪关系，则本地分支和远程分支都可以省略。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git push origin</span><br></pre></td></tr></table></figure><p>上面命令表示，将当前分支推送到<code>origin</code>主机的对应分支。</p><p>如果当前分支只有一个追踪分支，那么主机名都可以省略。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git push</span><br></pre></td></tr></table></figure><p>如果当前分支与多个主机存在追踪关系，则可以使用<code>-u</code>选项指定一个默认主机，这样后面就可以不加任何参数使用<code>git push</code>。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure><p>上面命令将本地的<code>master</code>分支推送到<code>origin</code>主机，同时指定<code>origin</code>为默认主机，后面就可以不加任何参数使用<code>git push</code>了。</p><p>不带任何参数的<code>git push</code>，默认只推送当前分支，这叫做simple方式。此外，还有一种matching方式，会推送所有有对应的远程分支的本地分支。Git 2.0版本之前，默认采用matching方法，现在改为默认采用simple方式。如果要修改这个设置，可以采用<code>git config</code>命令。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git config --global push.default matching</span><br><span class="line"><span class="meta">#</span><span class="bash"> 或者</span></span><br><span class="line">git config --global push.default simple</span><br></pre></td></tr></table></figure><p>还有一种情况，就是不管是否存在对应的远程分支，将本地的所有分支都推送到远程主机，这时需要使用<code>--all</code>选项。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git push --all origin</span><br></pre></td></tr></table></figure><p>上面命令表示，将所有本地分支都推送到<code>origin</code>主机。</p><p>如果远程主机的版本比本地版本更新，推送时Git会报错，要求先在本地做<code>git pull</code>合并差异，然后再推送到远程主机。这时，如果你一定要推送，可以使用<code>--force</code>选项。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git push --force origin </span><br></pre></td></tr></table></figure><p>上面命令使用<code>--force</code>选项，结果导致远程主机上更新的版本被覆盖。除非你很确定要这样做，否则应该尽量避免使用<code>--force</code>选项。</p><p>最后，<code>git push</code>不会推送标签（tag），除非使用<code>--tags</code>选项。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git push origin --tags</span><br></pre></td></tr></table></figure><h1 id="速查手册"><a href="#速查手册" class="headerlink" title="速查手册"></a>速查手册</h1><h2 id="初始化仓库"><a href="#初始化仓库" class="headerlink" title="初始化仓库"></a>初始化仓库</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure><h2 id="将文件添加到仓库"><a href="#将文件添加到仓库" class="headerlink" title="将文件添加到仓库"></a>将文件添加到仓库</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git add 文件名 # 将工作区的某个文件添加到暂存区   </span><br><span class="line">git add -u # 添加所有被tracked文件中被修改或删除的文件信息到暂存区，不处理untracked的文件</span><br><span class="line">git add -A # 添加所有被tracked文件中被修改或删除的文件信息到暂存区，包括untracked的文件</span><br><span class="line">git add . # 将当前工作区的所有文件都加入暂存区</span><br><span class="line">git add -i # 进入交互界面模式，按需添加文件到缓存区</span><br></pre></td></tr></table></figure><h2 id="将暂存区文件提交到本地仓库"><a href="#将暂存区文件提交到本地仓库" class="headerlink" title="将暂存区文件提交到本地仓库"></a>将暂存区文件提交到本地仓库</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git commit -m &quot;提交说明&quot; # 将暂存区内容提交到本地仓库</span><br><span class="line">git commit -a -m &quot;提交说明&quot; # 跳过缓存区操作，直接把工作区内容提交到本地仓库</span><br></pre></td></tr></table></figure><h2 id="查看仓库当前状态"><a href="#查看仓库当前状态" class="headerlink" title="查看仓库当前状态"></a>查看仓库当前状态</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure><h2 id="比较文件异同"><a href="#比较文件异同" class="headerlink" title="比较文件异同"></a>比较文件异同</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git diff # 工作区与暂存区的差异</span><br><span class="line">git diff 分支名 #工作区与某分支的差异，远程分支这样写：remotes/origin/分支名</span><br><span class="line">git diff HEAD  # 工作区与HEAD指针指向的内容差异</span><br><span class="line">git diff 提交id 文件路径 # 工作区某文件当前版本与历史版本的差异</span><br><span class="line">git diff --stage # 工作区文件与上次提交的差异(1.6 版本前用 --cached)</span><br><span class="line">git diff 版本TAG # 查看从某个版本后都改动内容</span><br><span class="line">git diff 分支A 分支B # 比较从分支A和分支B的差异(也支持比较两个TAG)</span><br><span class="line">git diff 分支A...分支B # 比较两分支在分开后各自的改动</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 另外：如果只想统计哪些文件被改动，多少行被改动，可以添加 --<span class="built_in">stat</span> 参数</span></span><br></pre></td></tr></table></figure><h2 id="查看历史记录"><a href="#查看历史记录" class="headerlink" title="查看历史记录"></a>查看历史记录</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git log # 查看所有commit记录(SHA-A校验和，作者名称，邮箱，提交时间，提交说明)</span><br><span class="line">git log -p -次数 # 查看最近多少次的提交记录</span><br><span class="line">git log --stat # 简略显示每次提交的内容更改</span><br><span class="line">git log --name-only # 仅显示已修改的文件清单</span><br><span class="line">git log --name-status # 显示新增，修改，删除的文件清单</span><br><span class="line">git log --oneline # 让提交记录以精简的一行输出</span><br><span class="line">git log –graph –all --online # 图形展示分支的合并历史</span><br><span class="line">git log --author=作者  # 查询作者的提交记录(和grep同时使用要加一个--all--match参数)</span><br><span class="line">git log --grep=过滤信息 # 列出提交信息中包含过滤信息的提交记录</span><br><span class="line">git log -S查询内容 # 和--grep类似，S和查询内容间没有空格</span><br><span class="line">git log fileName # 查看某文件的修改记录，找背锅专用</span><br></pre></td></tr></table></figure><h2 id="代码回滚"><a href="#代码回滚" class="headerlink" title="代码回滚"></a>代码回滚</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git reset HEAD^ # 恢复成上次提交的版本</span><br><span class="line">git reset HEAD^^ # 恢复成上上次提交的版本，就是多个^，以此类推或用~次数</span><br><span class="line"></span><br><span class="line">git reflog</span><br><span class="line"></span><br><span class="line">git reset --hard 版本号</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> --soft：只是改变HEAD指针指向，缓存区和工作区不变；</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> --mixed：修改HEAD指针指向，暂存区内容丢失，工作区不变；</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> --hard：修改HEAD指针指向，暂存区内容丢失，工作区恢复以前状态；</span></span><br></pre></td></tr></table></figure><h2 id="同步远程仓库"><a href="#同步远程仓库" class="headerlink" title="同步远程仓库"></a>同步远程仓库</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure><h2 id="删除版本库文件"><a href="#删除版本库文件" class="headerlink" title="删除版本库文件"></a>删除版本库文件</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git rm 文件名</span><br></pre></td></tr></table></figure><h2 id="版本库里的版本替换工作区的版本"><a href="#版本库里的版本替换工作区的版本" class="headerlink" title="版本库里的版本替换工作区的版本"></a>版本库里的版本替换工作区的版本</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git checkout -- test.txt</span><br></pre></td></tr></table></figure><h2 id="本地仓库内容推送到远程仓库"><a href="#本地仓库内容推送到远程仓库" class="headerlink" title="本地仓库内容推送到远程仓库"></a>本地仓库内容推送到远程仓库</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git remote add origin git@github.com:帐号名/仓库名.git</span><br></pre></td></tr></table></figure><h2 id="从远程仓库克隆项目到本地"><a href="#从远程仓库克隆项目到本地" class="headerlink" title="从远程仓库克隆项目到本地"></a>从远程仓库克隆项目到本地</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone git@github.com:git帐号名/仓库名.git</span><br></pre></td></tr></table></figure><h2 id="创建分支"><a href="#创建分支" class="headerlink" title="创建分支"></a>创建分支</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git checkout -b dev</span><br><span class="line"><span class="meta">#</span><span class="bash"> -b表示创建并切换分支</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 上面一条命令相当于一面的二条：</span></span><br><span class="line">git branch dev # 创建分支</span><br><span class="line">git checkout dev # 切换分支</span><br></pre></td></tr></table></figure><h2 id="查看分支"><a href="#查看分支" class="headerlink" title="查看分支"></a>查看分支</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git branch</span><br></pre></td></tr></table></figure><h2 id="合并分支"><a href="#合并分支" class="headerlink" title="合并分支"></a>合并分支</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git merge dev</span><br><span class="line"><span class="meta">#</span><span class="bash"> 用于合并指定分支到当前分支</span></span><br><span class="line"></span><br><span class="line">git merge --no-ff -m &quot;merge with no-ff&quot; dev</span><br><span class="line"><span class="meta">#</span><span class="bash"> 加上--no-ff参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并</span></span><br></pre></td></tr></table></figure><h2 id="删除分支"><a href="#删除分支" class="headerlink" title="删除分支"></a>删除分支</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git branch -d dev</span><br></pre></td></tr></table></figure><h2 id="查看分支合并图"><a href="#查看分支合并图" class="headerlink" title="查看分支合并图"></a>查看分支合并图</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git log --graph --pretty=oneline --abbrev-commit</span><br></pre></td></tr></table></figure><h2 id="查看远程库信息"><a href="#查看远程库信息" class="headerlink" title="查看远程库信息"></a>查看远程库信息</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git remote</span><br><span class="line"><span class="meta">#</span><span class="bash"> -v 显示更详细的信息</span></span><br></pre></td></tr></table></figure><h2 id="git相关配置"><a href="#git相关配置" class="headerlink" title="git相关配置"></a>git相关配置</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 安装完Git后第一件要做的事，设置用户信息(global可换成<span class="built_in">local</span>在单独项目生效)：</span></span><br><span class="line">git config --global user.name &quot;用户名&quot; # 设置用户名</span><br><span class="line">git config --global user.email &quot;用户邮箱&quot;   #设置邮箱</span><br><span class="line">git config --global user.name   # 查看用户名是否配置成功</span><br><span class="line">git config --global user.email   # 查看邮箱是否配置</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 其他查看配置相关</span></span><br><span class="line">git config --global --list  # 查看全局设置相关参数列表</span><br><span class="line">git config --local --list # 查看本地设置相关参数列表</span><br><span class="line">git config --system --list # 查看系统配置参数列表</span><br><span class="line">git config --list  # 查看所有Git的配置(全局+本地+系统)</span><br><span class="line">git config --global color.ui true //显示git相关颜色</span><br></pre></td></tr></table></figure><h2 id="撤消某次提交"><a href="#撤消某次提交" class="headerlink" title="撤消某次提交"></a>撤消某次提交</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git revert HEAD # 撤销最近的一个提交</span><br><span class="line">git revert 版本号 # 撤销某次commit</span><br></pre></td></tr></table></figure><h2 id="拉取远程分支到本地仓库"><a href="#拉取远程分支到本地仓库" class="headerlink" title="拉取远程分支到本地仓库"></a>拉取远程分支到本地仓库</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git checkout -b 本地分支 远程分支 # 会在本地新建分支，并自动切换到该分支</span><br><span class="line">git fetch origin 远程分支:本地分支 # 会在本地新建分支，但不会自动切换，还需checkout</span><br><span class="line">git branch --set-upstream 本地分支 远程分支 # 建立本地分支与远程分支的链接</span><br></pre></td></tr></table></figure><h2 id="标签命令"><a href="#标签命令" class="headerlink" title="标签命令"></a>标签命令</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git tag &lt;标签&gt; # 打标签命令，默认为HEAD</span><br><span class="line">git tag # 显示所有标签</span><br><span class="line">git tag &lt;标签 ?版本号&gt; # 给某个commit版本添加标签</span><br><span class="line">git show &lt;标签&gt; # 显示某个标签的详细信息</span><br></pre></td></tr></table></figure><h2 id="同步远程仓库更新"><a href="#同步远程仓库更新" class="headerlink" title="同步远程仓库更新"></a>同步远程仓库更新</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git fetch  origin master</span><br><span class="line"><span class="meta">#</span><span class="bash"> 从远程获取最新的到本地，首先从远程的origin的master主分支下载最新的版本到origin/master分支上，然后比较本地的master分支和origin/master分支的差别，最后进行合并。</span></span><br><span class="line"></span><br><span class="line">git fetch比git pull更加安全</span><br></pre></td></tr></table></figure><h1 id="不常见但实用的命令"><a href="#不常见但实用的命令" class="headerlink" title="不常见但实用的命令"></a>不常见但实用的命令</h1><h2 id="拉取远程代码并且覆盖本地更改"><a href="#拉取远程代码并且覆盖本地更改" class="headerlink" title="拉取远程代码并且覆盖本地更改"></a>拉取远程代码并且覆盖本地更改</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git fetch origin &amp;&amp; git reset –hard origin/master</span><br></pre></td></tr></table></figure><h2 id="列出远程和本地所有分支"><a href="#列出远程和本地所有分支" class="headerlink" title="列出远程和本地所有分支"></a>列出远程和本地所有分支</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git branch -a</span><br><span class="line">git branch -r</span><br></pre></td></tr></table></figure><h2 id="强制更新远程分支"><a href="#强制更新远程分支" class="headerlink" title="强制更新远程分支"></a>强制更新远程分支</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git push origin master -f</span><br></pre></td></tr></table></figure><h2 id="回滚一个-merge"><a href="#回滚一个-merge" class="headerlink" title="回滚一个 merge"></a>回滚一个 merge</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git revert -m 1 xxxx</span><br></pre></td></tr></table></figure><h2 id="修改之前的提交记录或者很久前提交的记录"><a href="#修改之前的提交记录或者很久前提交的记录" class="headerlink" title="修改之前的提交记录或者很久前提交的记录"></a>修改之前的提交记录或者很久前提交的记录</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git rebase –interactive ID^</span><br></pre></td></tr></table></figure><p>将需要修改的记录的 <code>pick</code> 改成 <code>edit</code>，执行更改：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git commit –all –amend</span><br><span class="line">git rebase –continue</span><br></pre></td></tr></table></figure><h2 id="使用多个远程代码库，并且使用多个不同的-SSH-Key"><a href="#使用多个远程代码库，并且使用多个不同的-SSH-Key" class="headerlink" title="使用多个远程代码库，并且使用多个不同的 SSH Key"></a>使用多个远程代码库，并且使用多个不同的 SSH Key</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Host bitbucket.org</span><br><span class="line">HostName bitbucket.org</span><br><span class="line">PreferredAuthentications publickey</span><br><span class="line">IdentityFile ~/.ssh/id_rsa</span><br><span class="line">User git</span><br><span class="line"></span><br><span class="line">Host bitbucket.org-key2</span><br><span class="line">HostName bitbucket.org</span><br><span class="line">IdentityFile ~/.ssh/key2_id_rsa</span><br><span class="line">User git</span><br></pre></td></tr></table></figure><p>修改 <code>.git/config</code>：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[remote “origin”]</span><br><span class="line">url = git@bitbucket.org-key2:XXXX/yyyy.git</span><br><span class="line">fetch = +refs/heads/*:refs/remotes/origin/*</span><br></pre></td></tr></table></figure><h2 id="和外部团队协作需要的维护多个远程库，合并其他库的更新的过程"><a href="#和外部团队协作需要的维护多个远程库，合并其他库的更新的过程" class="headerlink" title="和外部团队协作需要的维护多个远程库，合并其他库的更新的过程"></a>和外部团队协作需要的维护多个远程库，合并其他库的更新的过程</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git remote rename origin upstream</span><br><span class="line">git remote add origin URL_TO_GITHUB_REPO</span><br><span class="line">git push origin master</span><br><span class="line">git pull upstream master &amp;&amp; git push origin master</span><br></pre></td></tr></table></figure><h2 id="撤销-Git-的最后一次提交"><a href="#撤销-Git-的最后一次提交" class="headerlink" title="撤销 Git 的最后一次提交"></a>撤销 Git 的最后一次提交</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git reset –soft HEAD~1</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="http://www.ruanyifeng.com/">阮一峰的网络日志</a></li><li><strong>芋道源码</strong> 微信公众号</li></ul>]]></content>
      
      
      <categories>
          
          <category> 笔记本 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用个人公众号或IOS快捷指令发「动态」到hexo博客</title>
      <link href="post/3385be1c/"/>
      <url>post/3385be1c/</url>
      
        <content type="html"><![CDATA[<h2 id="初衷"><a href="#初衷" class="headerlink" title="初衷"></a>初衷</h2><ul><li>不喜欢在朋友圈发动态（毕竟微商的地盘）</li><li>不喜欢在微博发动态（都是垃圾信息，账号都注销了）</li></ul><blockquote><p> 于是 –</p><p>寻找一处可以完全由自己定制的，方便保存自己的一些碎片化思考和动态的地方就成了这次折腾的目标</p></blockquote><h2 id="寻找解决方案"><a href="#寻找解决方案" class="headerlink" title="寻找解决方案"></a>寻找解决方案</h2><p>经过一番<strong>Google大法</strong>也是找到了几个可以实现这个需求的方案。</p><h3 id="Artitalk-js"><a href="#Artitalk-js" class="headerlink" title="Artitalk.js"></a><a href="https://artitalk.js.org/">Artitalk.js</a></h3><blockquote><p>基于 LeanCloud 实现的可实时发布说说/微语的 js。</p></blockquote><ul><li><p>🤞使用方便</p><p>简略的 html 片段即可实现，且理论上支持任何框架或单独页面。</p></li><li><p>🔐安全性高</p><p>直接通过 LeanCloud 的用户系统，保证只有站长可控发布权限。</p></li><li><p>🎁多功能输入</p><p>多功能输入框，满足你的一切需求</p></li></ul><p>使用了一段时间，交互体验方面做的还不错，样式也比较完善：</p><p><img src="https://gitee.com/cayzlh/img-repo/raw/master/2021/02/21253516143459351614345935610.png" alt="image-20210226212534781"></p><p><em>缺点是但是每次发表动态必须打开页面登录后进行。</em></p><h3 id="BBTalk"><a href="#BBTalk" class="headerlink" title="BBTalk"></a><a href="https://bb.js.org/">BBTalk</a></h3><blockquote><p>利用手机微信随时随地发布碎片化思想，基于 <strong>Leancloud</strong>。</p></blockquote><ul><li><p>📲随时发送</p><p>拿出手机即可发送碎片化思想，并同步博客显示。</p></li><li><p>🤞使用方便</p><p>简略的 html 片段即可实现，且理论上支持任何框架或单独页面。</p></li><li><p>🎁操作简单</p><p>微信端直接发送文字、表情以及图片，并支持外链图片。</p></li></ul><p>来自<code>Hexo</code>建站群群主大佬的巨作，可以满足随时随地免登录通过微信公众号来发表动态。</p><h3 id="「哔哔点啥」微信公众号-2-0"><a href="#「哔哔点啥」微信公众号-2-0" class="headerlink" title="「哔哔点啥」微信公众号 2.0"></a><a href="https://immmmm.com/bb-by-wechat-pro/">「哔哔点啥」微信公众号 2.0</a></h3><p>与<strong>BBTalk</strong>类似，也可以随意随地通过特定的公众号发送。</p><p>具体搭建步骤在这个帖子里都有。</p><blockquote><p><strong>「哔哔点啥」</strong>的优点在于它是基于<strong>「腾讯 CloudBase」</strong>来实现的。</p><blockquote><p>同时该博主也提供了「bber-weixin」的代码，这样就可以利用自己申请的公众号来实现这个发表动态的需求，一切都由自己掌控。</p></blockquote></blockquote><h2 id="折腾ing"><a href="#折腾ing" class="headerlink" title="折腾ing"></a>折腾ing</h2><p>因为自己对云函数也有一定的了解，于是就拿了「哔哔点啥」来实现自己的动态页。</p><p>搭建步骤参考<a href="https://immmmm.com/bb-by-wechat-pro/">「哔哔点啥」微信公众号 2.0</a>，重点记录一下踩坑与自定义部分。</p><h3 id="踩坑"><a href="#踩坑" class="headerlink" title="踩坑"></a>踩坑</h3><h4 id="广州地区云开发环境无法读取数据"><a href="#广州地区云开发环境无法读取数据" class="headerlink" title="广州地区云开发环境无法读取数据"></a>广州地区云开发环境无法读取数据</h4><p>由于我申请的云开发环境是广州地区的，照着该文章的步骤一顿操作之后，发现无法加载数据，报以下错：</p><p><img src="https://gitee.com/cayzlh/img-repo/raw/master/2021/02/22021616143481361614348136416.png" alt="image-20210226220215864"></p><p>😱 这就很难受了，于是联系作者，查阅资料，发现是部署前端的时候引入的云开发sdk版本太低了。</p><p><strong>解决：</strong></p><p>将以下代码：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.jsdelivr.net/gh/TencentCloudBase/tcb-js-sdk@master/tcbjs/1.10.10/tcb.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>替换成：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;https://imgcache.qq.com/qcloud/cloudbase-js-sdk/1.4.0/cloudbase.full.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>使用最新版的云开发SDK之后，问题解决。</p><p><em>如果还是不能加载数据，那么清除一下浏览器缓存一般就可以了（类似图中这些）：</em></p><p><img src="https://gitee.com/cayzlh/img-repo/raw/master/2021/02/22071616143484361614348436495.png" alt="image-20210226220715714"></p><h4 id="微信公众号服务器配置失败"><a href="#微信公众号服务器配置失败" class="headerlink" title="微信公众号服务器配置失败"></a>微信公众号服务器配置失败</h4><p>跟着步骤走，部署<code>bber-weixin</code>，在配置公众号服务器的时候，提示“参数错误，请重新填写”：</p><p><img src="https://gitee.com/cayzlh/img-repo/raw/master/2021/02/22100016143486001614348600180.png" alt="image-20210226220959747"></p><p>如果其他配置都没有问题，怎么检查都提示“参数错误，请重新填写”，那么有可能是因为云函数默认访问域名被微信屏蔽了，请求无法到达导致。</p><p><img src="https://gitee.com/cayzlh/img-repo/raw/master/2021/02/22113816143486981614348698954.png" alt="image-20210226221138586"></p><p>解决方法也是很简单，在云开发的<strong>HTTP访问服务</strong>给云函数分配一个自定义域名并使用即可。</p><p><img src="https://gitee.com/cayzlh/img-repo/raw/master/2021/02/22141116143488511614348851595.png" alt="image-20210226221411096"></p><h3 id="自定义"><a href="#自定义" class="headerlink" title="自定义"></a>自定义</h3><h4 id="定制bber-js"><a href="#定制bber-js" class="headerlink" title="定制bber.js"></a>定制bber.js</h4><p>其实也很简单，将<code>bber.js</code>下载下来研究它。</p><p>弄清楚它逻辑之后，做自己想做的事，实现自己的逻辑。</p><h4 id="使用IOS快捷指令发动态"><a href="#使用IOS快捷指令发动态" class="headerlink" title="使用IOS快捷指令发动态"></a>使用IOS快捷指令发动态</h4><p>在摸透了整个流程的逻辑之后，其实不难发现，想要发动态，只需要向下面的链接发送<code>POST</code>或<code>GET</code>请求就行，于是想到使用IOS提供的快捷指令来发送动态，这种交互模式比使用公众号更好。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">https://你后台显示的.ap-guangzhou.app.tcloudbase.com/bb?key=云函数里设置的&amp;from=自己发挥一个&amp;text=哔哔的内容</span><br></pre></td></tr></table></figure><p>接下来分享一下快捷指令的具体流程：</p><p><img src="https://gitee.com/cayzlh/img-repo/raw/master/2021/02/22280416143496841614349684711.jpg" alt="img"></p><p>使用效果：</p><p><img src="https://i.loli.net/2021/02/26/KI7N5EdxAciyL41.gif" alt="快捷指令效果图"></p><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p>当然Mac端还可以通过  Alfred Workflow 来使用，怎么方便怎么来。</p>]]></content>
      
      
      <categories>
          
          <category> 折腾 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot文件上传异常处理</title>
      <link href="post/2878379624/"/>
      <url>post/2878379624/</url>
      
        <content type="html"><![CDATA[<p>SpringBoot搭建的应用，一直工作得好好的，突然发现上传文件失败，提示<code>org.springframework.web.multipart.MultipartException: Failed to parse multipart servlet request; nested exception is java.io.IOException: The temporary upload location [/tmp/tomcat.6239989728636105816.19530/work/Tomcat/localhost/ROOT] is not valid</code>目录非法，实际查看目录，结果还真没有，下面就这个问题的表现，分析下SpringBoot针对文件上传的处理过程</p><h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><h3 id="堆栈分析"><a href="#堆栈分析" class="headerlink" title="堆栈分析"></a>堆栈分析</h3><p>问题定位，最佳的辅助手段就是堆栈分析，首先捞出核心的堆栈信息</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">org.springframework.web.multipart.MultipartException: Failed to parse multipart servlet request; nested exception is java.io.IOException: The temporary upload location [/tmp/tomcat.6239989728636105816.19530/work/Tomcat/localhost/ROOT] is not valid</span><br><span class="line">        at org.springframework.web.multipart.support.StandardMultipartHttpServletRequest.handleParseFailure(StandardMultipartHttpServletRequest.java:122)</span><br><span class="line">        at org.springframework.web.multipart.support.StandardMultipartHttpServletRequest.parseRequest(StandardMultipartHttpServletRequest.java:113)</span><br><span class="line">        at org.springframework.web.multipart.support.StandardMultipartHttpServletRequest.&lt;init&gt;(StandardMultipartHttpServletRequest.java:86)</span><br><span class="line">        at org.springframework.web.multipart.support.StandardServletMultipartResolver.resolveMultipart(StandardServletMultipartResolver.java:93)</span><br><span class="line">        at org.springframework.web.servlet.DispatcherServlet.checkMultipart(DispatcherServlet.java:1128)</span><br><span class="line">        at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:960)</span><br><span class="line">        at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:925)</span><br><span class="line">        at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:974)</span><br><span class="line">        at org.springframework.web.servlet.FrameworkServlet.doPost(FrameworkServlet.java:877)</span><br><span class="line">        at javax.servlet.http.HttpServlet.service(HttpServlet.java:661)</span><br><span class="line">        at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:851)</span><br><span class="line">        at javax.servlet.http.HttpServlet.service(HttpServlet.java:742)</span><br><span class="line">        at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:231)</span><br><span class="line">        at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)</span><br><span class="line">        at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:52)</span><br><span class="line">        at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)</span><br></pre></td></tr></table></figure><p>从堆栈内容来看，问题比较清晰，目录非法，根据<code>path</code>路径，进入目录，结果发现，没有这个目录，那么问题的关键就是没有目录为什么会导致异常了，这个目录到底有啥用</p><p>先简单描述下上面的原因，上传的文件会缓存到本地磁盘，而缓存的路径就是上面的<code>/tmp/tomcat.6239989728636105816.19530/work/Tomcat/localhost/ROOT</code>，接着引入的疑问就是：</p><ul><li>为什么上传的文件要缓存到本地</li><li>为什么临时目录会不存在</li><li>什么地方实现文件缓存</li></ul><h3 id="场景模拟"><a href="#场景模拟" class="headerlink" title="场景模拟"></a>场景模拟</h3><p>要确认上面的问题，最直观的方法就是撸源码，直接看代码就有点蛋疼了，接下来采用debug方式来层层剥离，看下根源再哪里。</p><p>首先是搭建一个简单的测试项目，进行场景复现, 首先创建一个接收文件上传的Controller，如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(path = &quot;/file&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileUploadRest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 保存上传的文件</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> file</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">saveFileToLocal</span><span class="params">(MultipartFile file)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String name = <span class="string">&quot;/tmp/out_&quot;</span> + System.currentTimeMillis() + file.getName();</span><br><span class="line">            FileOutputStream writer = <span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(name));</span><br><span class="line">            writer.write(file.getBytes());</span><br><span class="line">            writer.flush();</span><br><span class="line">            writer.close();</span><br><span class="line">            <span class="keyword">return</span> name;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> e.getMessage();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(path = &quot;upload&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">upload</span><span class="params">(<span class="meta">@RequestParam(&quot;file&quot;)</span> MultipartFile file)</span> </span>&#123;</span><br><span class="line">        String ans = saveFileToLocal(file);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其次就是使用curl来上传文件</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl http://127.0.0.1:8080/file/upload -F <span class="string">&quot;file=@/Users/user/Desktop/demo.jpg&quot;</span> -v</span><br></pre></td></tr></table></figure><p>然后在接收文件上传的方法中开启断点，注意下面红框中的 <code>location</code>, 就是文件上传的临时目录</p><p><img src="https://gitee.com/cayzlh/img-repo/raw/master/2021/02/10511616140486761614048676335.jpg" alt="IMAGE"></p><h3 id="源码定位"><a href="#源码定位" class="headerlink" title="源码定位"></a>源码定位</h3><p>上面的截图可以确认确实将上传的文件保存到了临时目录，验证方式就是进入那个目录进行查看，会看到一个<code>tmp</code>文件，接下来我们需要确定的是在什么地方，实现将数据缓存到本地的。</p><p>注意下图，左边红框是这次请求的完整链路，我们可以通过逆推链路，去定位可能实现文件缓存的地方</p><p><img src="https://gitee.com/cayzlh/img-repo/raw/master/2021/02/10511916140486791614048679920.jpg" alt="IMAGE"></p><p>如果对<code>spring</code>和<code>tomcat</code>的源码不熟的话，也没什么特别的好办法，从上面的链路中，多打一些断点，采用传说中的二分定位方法来缩小范围。</p><p>通过最开始的request对象和后面的request对象分析，发现一个可以作为参考标准的就是上图中右边红框的<code>request#parts</code>属性；开始是null，文件保存之后则会有数据，下面给一个最终定位的动图</p><p><img src="https://i.loli.net/2021/02/23/9dYwLfNEOZ6IvMB.gif" alt="2.gif"></p><p>所以关键就是<code>org.springframework.web.filter.HiddenHttpMethodFilter#doFilterInternal</code> 中的 <code>String paramValue = request.getParameter(this.methodParam);</code> 这一行代码</p><p><img src="https://gitee.com/cayzlh/img-repo/raw/master/2021/02/10513516140486951614048695101.jpg" alt="IMAGE"></p><p>到这里在单步进去，主要的焦点将集中在 <code>org.apache.catalina.connector.Request#parseParts</code></p><p><img src="https://gitee.com/cayzlh/img-repo/raw/master/2021/02/10513616140486961614048696886.jpg" alt="IMAGE"></p><p>进入上面方法的逻辑，很容易找到具体的实现位置 <code>org.apache.tomcat.util.http.fileupload.FileUploadBase#parseRequest</code>，这个方法的实现比较有意思，有必要贴出来看一下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;FileItem&gt; <span class="title">parseRequest</span><span class="params">(RequestContext ctx)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> FileUploadException </span>&#123;</span><br><span class="line">    List&lt;FileItem&gt; items = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">boolean</span> successful = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        FileItemIterator iter = getItemIterator(ctx);</span><br><span class="line">        <span class="comment">// 注意这里，文件工厂类，里面保存了临时目录的地址</span></span><br><span class="line">        <span class="comment">// 这个对象首次是在 org.apache.catalina.connector.Request#parseParts 方法的</span></span><br><span class="line">        FileItemFactory fac = getFileItemFactory();</span><br><span class="line">        <span class="keyword">if</span> (fac == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">&quot;No FileItemFactory has been set.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">            <span class="keyword">final</span> FileItemStream item = iter.next();</span><br><span class="line">            <span class="comment">// Don&#x27;t use getName() here to prevent an InvalidFileNameException.</span></span><br><span class="line">            <span class="keyword">final</span> String fileName = ((FileItemIteratorImpl.FileItemStreamImpl) item).name;</span><br><span class="line">            <span class="comment">// 创建一个临时文件对象</span></span><br><span class="line">            FileItem fileItem = fac.createItem(item.getFieldName(), item.getContentType(),</span><br><span class="line">                                               item.isFormField(), fileName);</span><br><span class="line">            items.add(fileItem);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 流的拷贝，这块代码也挺有意思，将输入流数据写入输出流</span></span><br><span class="line">                <span class="comment">// 后面会贴出源码，看下开源大佬们的玩法，和我们自己写的有啥区别</span></span><br><span class="line">                Streams.copy(item.openStream(), fileItem.getOutputStream(), <span class="keyword">true</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (FileUploadIOException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> (FileUploadException) e.getCause();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IOFileUploadException(String.format(<span class="string">&quot;Processing of %s request failed. %s&quot;</span>,</span><br><span class="line">                                                       MULTIPART_FORM_DATA, e.getMessage()), e);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">final</span> FileItemHeaders fih = item.getHeaders();</span><br><span class="line">            fileItem.setHeaders(fih);</span><br><span class="line">        &#125;</span><br><span class="line">        successful = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> items;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (FileUploadIOException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> (FileUploadException) e.getCause();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> FileUploadException(e.getMessage(), e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!successful) &#123;</span><br><span class="line">            <span class="keyword">for</span> (FileItem fileItem : items) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    fileItem.delete();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception ignored) &#123;</span><br><span class="line">                    <span class="comment">// ignored TODO perhaps add to tracker delete failure list somehow?</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>核心代码就两点，一个是文件工厂类，一个是流的拷贝；前者定义了我们的临时文件目录，也是我们解决前面问题的关键，换一个我自定义的目录永不删除，不就可以避免上面的问题了么；后面一个则是数据复用方面的</p><p>首先看下FileItemFactory的实例化位置，在<code>org.apache.catalina.connector.Request#parseParts</code>中，代码如下</p><p><img src="https://gitee.com/cayzlh/img-repo/raw/master/2021/02/10513716140486971614048697322.jpg" alt="IMAGE"></p><p>具体的<code>location</code>实例化代码为</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// TEMPDIR = &quot;javax.servlet.context.tempdir&quot;;</span></span><br><span class="line">location = ((File) context.getServletContext().getAttribute(ServletContext.TEMPDIR));</span><br></pre></td></tr></table></figure><p>##问题review</p><p>###解决问题</p><p>到上面，基本上就捞到了最终的问题，先看如何解决这个问题</p><h4 id="方法1"><a href="#方法1" class="headerlink" title="方法1"></a><strong>方法1</strong></h4><ul><li><strong>应用重启</strong></li></ul><h4 id="方法2"><a href="#方法2" class="headerlink" title="方法2"></a><strong>方法2</strong></h4><ul><li>增加服务配置，自定义<code>baseDir</code></li></ul><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">server.tomcat.basedir</span>=<span class="string">/tmp/tomcat</span></span><br></pre></td></tr></table></figure><h4 id="方法3"><a href="#方法3" class="headerlink" title="方法3"></a><strong>方法3</strong></h4><ul><li>注入bean，手动配置临时目录</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function">MultipartConfigElement <span class="title">multipartConfigElement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MultipartConfigFactory factory = <span class="keyword">new</span> MultipartConfigFactory();</span><br><span class="line">    factory.setLocation(<span class="string">&quot;/tmp/tomcat&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> factory.createMultipartConfig();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="方法4"><a href="#方法4" class="headerlink" title="方法4"></a><strong>方法4</strong></h4><ul><li>配置不删除<code>tmp</code>目录下的<code>tomcat</code></li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /usr/lib/tmpfiles.d/tmp.conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加一行</span></span><br><span class="line">x /tmp/tomcat.*</span><br></pre></td></tr></table></figure><h4 id="流拷贝"><a href="#流拷贝" class="headerlink" title="流拷贝"></a>流拷贝</h4><p><code>tomcat</code>中实现流的拷贝代码如下，<code>org.apache.tomcat.util.http.fileupload.util.Streams#copy(java.io.InputStream, java.io.OutputStream, boolean, byte[])</code> , 看下面的实现，直观影响就是写得真特么严谨</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">copy</span><span class="params">(InputStream inputStream,</span></span></span><br><span class="line"><span class="function"><span class="params">            OutputStream outputStream, <span class="keyword">boolean</span> closeOutputStream,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">byte</span>[] buffer)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    OutputStream out = outputStream;</span><br><span class="line">    InputStream in = inputStream;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">long</span> total = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> res = in.read(buffer);</span><br><span class="line">            <span class="keyword">if</span> (res == -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (res &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                total += res;</span><br><span class="line">                <span class="keyword">if</span> (out != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    out.write(buffer, <span class="number">0</span>, res);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (out != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (closeOutputStream) &#123;</span><br><span class="line">                out.close();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                out.flush();</span><br><span class="line">            &#125;</span><br><span class="line">            out = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        in.close();</span><br><span class="line">        in = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> total;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        IOUtils.closeQuietly(in);</span><br><span class="line">        <span class="keyword">if</span> (closeOutputStream) &#123;</span><br><span class="line">            IOUtils.closeQuietly(out);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>###自问自答</p><p>什么地方缓存文件</p><p>上面的定位过程给出答案，具体实现逻辑在 <code>org.apache.tomcat.util.http.fileupload.FileUploadBase#parseRequest</code></p><p>####为什么目录会不存在</p><p><code>springboot</code>启动时会创建一个<code>/tmp/tomcat.*/work/Tomcat/localhost/ROOT</code>的临时目录作为文件上传的临时目录，但是该目录会在<code>n</code>天之后被系统自动清理掉，这个清理是由<code>linux</code>操作系统完成的，具体的配置如下 <code>vim /usr/lib/tmpfiles.d/tmp.conf</code></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#  This file is part of systemd.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#  systemd is free software; you can redistribute it and/or modify it</span></span><br><span class="line"><span class="comment">#  under the terms of the GNU Lesser General Public License as published by</span></span><br><span class="line"><span class="comment">#  the Free Software Foundation; either version 2.1 of the License, or</span></span><br><span class="line"><span class="comment">#  (at your option) any later version.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># See tmpfiles.d(5) for details</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Clear tmp directories separately, to make them easier to override</span></span><br><span class="line">v /tmp 1777 root root 10d</span><br><span class="line">v /var/tmp 1777 root root 30d</span><br><span class="line"></span><br><span class="line"><span class="comment"># Exclude namespace mountpoints created with PrivateTmp=yes</span></span><br><span class="line">x /tmp/systemd-private-%b-*</span><br><span class="line">X /tmp/systemd-private-%b-*/tmp</span><br><span class="line">x /var/tmp/systemd-private-%b-*</span><br><span class="line">X /var/tmp/systemd-private-%b-*/tmp</span><br></pre></td></tr></table></figure><p>####为什么要缓存文件</p><p>因为流取一次消费之后，后面无法再从流中获取数据，所以缓存方便后续复用；</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://spring.hhui.top/spring-blog/2019/02/13/190213-SpringBoot%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E5%BC%82%E5%B8%B8%E4%B9%8B%E6%8F%90%E7%A4%BAThe-temporary-upload-location-xxx-is-not-valid/">一灰灰Blog - SpringBoot文件上传异常之提示The temporary upload location xxx is not valid</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 笔记本 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Spring </tag>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>你好，李焕英</title>
      <link href="post/5ad4076c/"/>
      <url>post/5ad4076c/</url>
      
        <content type="html"><![CDATA[<p><img src="https://gitee.com/cayzlh/img-repo/raw/master/2021/02/21391616139147561613914756550.png" alt="image-20210221213915135"></p><p><a href="https://movie.douban.com/subject/34841067/">《你好，李焕英》</a>，一部 国产+喜剧+催泪 的电影；</p><p>在以往的经验中，打上这几个标签的电影往往都是烂片了，但在豆瓣却有<code>8</code>分以上的成绩；</p><p>于是怀着好奇的心情，决定踏入许久没去过的电影院看看；</p><p><img src="https://gitee.com/cayzlh/img-repo/raw/master/2021/02/21431716139149971613914997594.png" alt="image-20210221214303484"></p><blockquote><p>我以为是我在为你圆梦，其实还是你陪着我做了一场好梦。</p></blockquote><p>整部电影的笑点泪点恰到好处，没有硬搞笑也没有刻意煽情；</p><p>作为贾玲的导演处女作，这部作品是值得肯定的，子欲养而亲不待，她在讲一个珍惜亲情的故事；</p><p>也许李焕英就是现实中所有母亲的真实写照，也曾经年轻过，也曾经是个花季少女，也曾经有过自己追逐的梦想；</p><p>在孩子出生之后，如同狗皮膏药一样，黏在身上，就是一辈子；</p><p>他们不舍得给自己买好的，一件衣服穿好几年，一双鞋子穿好几年；</p><p>对孩子确是恨不得把最好的拿给他；</p><p><em>甚至，在孩子好不容易成年之后，又有一个新的狗皮膏药（孙子）也黏了过来，生活中就只剩下孩子；</em></p><blockquote><p>说回电影，我认为结尾是整个剧情最升华的部分。</p></blockquote><p>如果剧情背景仅仅是穿越或者一场梦，那只能算一部普通的合家欢喜剧；</p><p>但是结尾说，李焕英是48岁的李焕英。 整个剧情就升华了；</p><p>我们最开始的视角，是贾晓玲视角，以为是穿越，又或者梦，我们跟随着贾晓玲，试着改变母亲的命运，让她更加开心；</p><p>剧情很好笑，又有些荒诞；</p><p>回头一想，如果主角视角是李焕英，那几乎是一部全新的电影；</p><p>前面剧情里一些不合理的地方，忽然又变得合理了起来；</p><p>… …</p><p>啊，总之，电影不错；</p>]]></content>
      
      
      <categories>
          
          <category> 碎碎念 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 电影 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2021春节随笔</title>
      <link href="post/57d8b90a/"/>
      <url>post/57d8b90a/</url>
      
        <content type="html"><![CDATA[<blockquote><p>恍惚间；又到了一年春节；</p><p>总感觉，2020没过几天；</p><p>弄丢了，时间；</p><p>过年的烟花声还在耳边；</p><p>迷糊间，又大了300多天；</p><p>已没人，给压岁钱；</p></blockquote><h2 id="魔幻的2020"><a href="#魔幻的2020" class="headerlink" title="魔幻的2020"></a>魔幻的2020</h2><p>2020真是魔幻的一年；</p><p>疫情下对未知的恐惧，过年在家甚至不敢出门；</p><p>在家远程办公到3月份；</p><p>回到广州上班也是人心惶惶，每天带着口罩，包里常备消毒液；</p><p>懵懵懂懂过完了上半年，不知道在忙（闲）啥；</p><p><strong>下半年，换了个新的环境；</strong></p><p>那一天，终于回想起了互联网公司的支配，国庆之后就没有闲下来过，忙成狗；</p><p><img src="https://gitee.com/cayzlh/img-repo/raw/master/2021/02/11101216137042121613704212946.png" alt="image-20210219111012445"></p><h2 id="成长"><a href="#成长" class="headerlink" title="成长"></a>成长</h2><p>还是由于疫情的影响，把六个月大的小粽子送回老家生活，只能从通过视频的方式来见证他的成长；</p><p>从只会咿呀学语到能准确的喊“爸爸” “妈妈”等叠词；</p><p>从只会爬行到蹒跚学步，再到蹦蹦跳跳；</p><p>… …</p><p>成长的过程，充满了惊喜与感动；</p><p><img src="https://gitee.com/cayzlh/img-repo/raw/master/2021/02/22271016136584301613658430840.png" alt="image-20210218222709998"></p><h2 id="2021"><a href="#2021" class="headerlink" title="2021"></a>2021</h2><p>假期假期悄悄过去，留下小肉肉；</p><p>在家里混吃混喝10多天，体重又上去了亿点点；</p><p>有人说怎么变油腻了；</p><p>看来要立个<code>FLAG</code>才行：**<u>2021年誓必将将小肚子减下去，体重减到120斤左右；</u>**</p><p><em>偶尔来个老年人的养生篮球也是不错滴；</em></p><p><img src="https://gitee.com/cayzlh/img-repo/raw/master/2021/02/22411416136592741613659274195.png" alt="image-20210218224113187"></p><h3 id="计划-amp-书单"><a href="#计划-amp-书单" class="headerlink" title="计划&amp;书单"></a>计划&amp;书单</h3><ul><li>《如何阅读一本书》— <strong>40%</strong></li><li>《阿里巴巴管理三板斧》— <strong>100%</strong></li><li>《Elasticsearch权威指南》— <strong>30%</strong></li><li>《代码整洁之道 clean code》— <strong>未开始</strong></li><li>《高性能MySQL》— <strong>未开始</strong></li><li>《重构改善既有代码设计》— <strong>未开始</strong></li><li>《大话设计模式》— 20%</li><li>《云攻略》— <strong>未开始</strong></li></ul><hr><p><em>想到啥，就写了啥，有点乱，没有逻辑</em>。</p>]]></content>
      
      
      <categories>
          
          <category> 碎碎念 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生活 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker部署elasticsearch</title>
      <link href="post/2481829941/"/>
      <url>post/2481829941/</url>
      
        <content type="html"><![CDATA[<h3 id="dockerhub找到elasticsearch镜像文档"><a href="#dockerhub找到elasticsearch镜像文档" class="headerlink" title="dockerhub找到elasticsearch镜像文档"></a>dockerhub找到elasticsearch镜像文档</h3><p>正常来说，按照<a href="https://hub.docker.com/_/elasticsearch">elasticsearch</a>上的文档提示，一步步操作即可。</p><p><strong>1、拉取镜像</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker pull elasticsearch</span><br></pre></td></tr></table></figure><p><strong>2、创建用户定义的网络（可用于连接到连接到同一网络的其他服务（例如Kibana））</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker network create somenetwork</span><br></pre></td></tr></table></figure><p><strong>3、运行elasticsearch容器</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d --name elasticsearch --net somenetwork -p 9200:9200 -p 9300:9300 -e <span class="string">&quot;discovery.type=single-node&quot;</span> elasticsearch:tag</span><br></pre></td></tr></table></figure><blockquote><p>本地机器环境为 <code>macOS</code> ，在运行之后发现容器直接挂了，通过查看日志发现：</p><p><img src="https://gitee.com/cayzlh/img-repo/raw/master/2021/01/11334316098176231609817623882.png" alt="image-20210105113343431"></p></blockquote><p><strong>由于<code>elasticsearch</code>默认分配<code>jvm</code>空间大小为<code>2g</code>，内存不足以分配导致。</strong></p><h3 id="解决报错问题"><a href="#解决报错问题" class="headerlink" title="解决报错问题"></a>解决报错问题</h3><p>在启动命令中指定<code>jvm</code>大小来启动容器，添加<code>-e ES_JAVA_OPTS=&quot;-Xms256m -Xmx256m&quot;</code>参数。完整命令如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d --name std-es --net esnetwork -p 9200:9200 -p 9300:9300 -e <span class="string">&quot;discovery.type=single-node&quot;</span> -e ES_JAVA_OPTS=<span class="string">&quot;-Xms256m -Xmx256m&quot;</span> elasticsearch</span><br></pre></td></tr></table></figure><p>…</p><p>后续关于<code>elasticsearch</code>使用的问题也会维护在这篇文章之中</p>]]></content>
      
      
      <categories>
          
          <category> 笔记本 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
            <tag> elasticsearch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记关于Consul的一点使用笔记</title>
      <link href="post/1320718638/"/>
      <url>post/1320718638/</url>
      
        <content type="html"><![CDATA[<blockquote><p>由于开发需要，需要在本地运行一个Consul环境，由于电脑上已经有Docker环境了，于是就直接在Docker里面搭一套Consul集群。</p></blockquote><h2 id="Docker搭建Consul集群"><a href="#Docker搭建Consul集群" class="headerlink" title="Docker搭建Consul集群"></a>Docker搭建Consul集群</h2><blockquote><p>集群要求要有<code>3</code>个<code>Server</code>，将容器<code>8500</code>端口映射到主机<code>8900</code>端口，同时开启管理界面</p></blockquote><h3 id="搭建集群"><a href="#搭建集群" class="headerlink" title="搭建集群"></a>搭建集群</h3><p><strong>1. 启动第1个Server节点</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d --name=consul1 -p 8500:8500 -e CONSUL_BIND_INTERFACE=eth0 consul:1.6.2 agent --server=<span class="literal">true</span> --bootstrap-expect=3 --client=0.0.0.0 -ui</span><br></pre></td></tr></table></figure><p><strong>2. 获取consul1的ip地址</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">JOIN_IP=<span class="string">&quot;<span class="subst">$(docker inspect -f &#x27;&#123;&#123;.NetworkSettings.IPAddress&#125;&#125;&#x27; do1_consul1)</span>&quot;</span>;</span><br></pre></td></tr></table></figure><p><strong>3. 启动第2个Server节点，并加入集群</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d --name=consul2 -e CONSUL_BIND_INTERFACE=eth0 consul:1.6.2 agent --server=<span class="literal">true</span> --client=0.0.0.0 --join <span class="variable">$JOIN_IP</span></span><br></pre></td></tr></table></figure><p><strong>4. 启动第3个Server节点，并加入集群</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d --name=consul3 -e CONSUL_BIND_INTERFACE=eth0 consul:1.6.2 agent --server=<span class="literal">true</span> --client=0.0.0.0 --join <span class="variable">$JOIN_IP</span></span><br></pre></td></tr></table></figure><p><strong>5. 启动第4个Client节点，并加入集群</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d --name=consul4 -e CONSUL_BIND_INTERFACE=eth0 consul:1.6.2 agent --server=<span class="literal">false</span> --client=0.0.0.0 --join <span class="variable">$JOIN_IP</span></span><br></pre></td></tr></table></figure><p>浏览器访问 <a href="http://localhost:8500/">http://localhost:8500</a>验证是否部署成功。</p><h3 id="导入kv"><a href="#导入kv" class="headerlink" title="导入kv"></a>导入kv</h3><p><strong>1. 将kv.json复制到容器内</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker cp ~/Desktop/consul_kv.json consul1:/tmp</span><br></pre></td></tr></table></figure><p><strong>2. 导入kv.json</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> consul1 consul kv import @/tmp/consul_kv.json</span><br></pre></td></tr></table></figure><h2 id="IDEA跑服务注册到Consul"><a href="#IDEA跑服务注册到Consul" class="headerlink" title="IDEA跑服务注册到Consul"></a>IDEA跑服务注册到Consul</h2><h3 id="遇到的坑"><a href="#遇到的坑" class="headerlink" title="遇到的坑"></a>遇到的坑</h3><p><code>consul</code>集群跑起来之后，于是在<code>IDEA</code>跑<code>SpringCloud</code>项目注册到部署好的<code>Consul</code>服务，当服务注册好之后，检查其健康状态，发现服务一直提示<code>All node checks passing</code>报了个小红叉❌。</p><h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><p>通过各种尝试都发解决之后，发现是因为在容器内部调用容器外（宿主机）的相应服务的时候网络不通，导致健康检查一直处于失败的状态，于是，修改<code>SpringCloud</code>工程的配置文件，新增配置：</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.cloud.consul.discovery.preferIpAddress</span>=<span class="string">true</span></span><br><span class="line"><span class="meta">spring.cloud.consul.discovery.ipAddress</span>=<span class="string">docker.for.mac.host.internal</span></span><br></pre></td></tr></table></figure><p>重新启动服务，各项检查都正常了。</p><ul><li>以上操作环境是<code>macOS</code>，未在别的环境重现和解决这个问题。</li><li>容器内可以通过<code>docker.for.mac.host.internal</code>访问宿主机网络和端口。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 笔记本 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 微服务 </tag>
            
            <tag> Consul </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>API签名验证方案</title>
      <link href="post/138fc827/"/>
      <url>post/138fc827/</url>
      
        <content type="html"><![CDATA[<h2 id="接口安全问题"><a href="#接口安全问题" class="headerlink" title="接口安全问题"></a>接口安全问题</h2><ul><li>请求身份是否合法？</li><li>请求参数是否被篡改？</li><li>请求是否唯一？</li></ul><h2 id="AccessKey-amp-SecretKey-（开放平台）"><a href="#AccessKey-amp-SecretKey-（开放平台）" class="headerlink" title="AccessKey&amp;SecretKey （开放平台）"></a>AccessKey&amp;SecretKey （开放平台）</h2><h3 id="请求身份"><a href="#请求身份" class="headerlink" title="请求身份"></a>请求身份</h3><p>为开发者分配**<code>AccessKey</code><strong>（开发者标识，确保唯一）和</strong><code>SecretKey</code>**（用于接口加密，确保不易被穷举，生成算法不易被猜测）。</p><h3 id="防止篡改"><a href="#防止篡改" class="headerlink" title="防止篡改"></a>防止篡改</h3><p><strong>参数签名</strong></p><ol><li>按照请求参数名的字母升序排列非空请求参数（包含<code>AccessKey</code>），使用<code>URL</code>键值对的格式（即<code>key1=value1&amp;key2=value2…</code>）拼接成字符串stringA；</li><li>在<code>stringA</code>最后拼接上<code>Secretkey</code>得到字符串<code>stringSignTemp</code>；</li><li>对<code>stringSignTemp</code>进行<code>MD5</code>运算，并将得到的字符串所有字符转换为大写，得到<code>sign</code>值。</li></ol><p>请求携带参数**<code>AccessKey</code><strong>和</strong><code>Sign</code><strong>，只有拥有合法的身份<code>AccessKey</code>和正确的签名<code>Sign</code>才能放行。这样就解决了身份验证和参数篡改问题，即使请求参数被劫持，由于获取不到<code>SecretKey</code>（</strong>仅作本地加密使用，不参与网络传输**），无法伪造合法的请求。</p><h3 id="重放攻击"><a href="#重放攻击" class="headerlink" title="重放攻击"></a>重放攻击</h3><p>虽然解决了请求参数被篡改的隐患，但是还存在着重复使用请求参数伪造二次请求的隐患。</p><p><strong>timestamp+nonce方案</strong></p><p><code>nonce</code>指<strong>唯一的随机字符串</strong>，用来标识每个被签名的请求。通过为每个请求提供一个唯一的标识符，服务器能够防止请求被多次使用（记录所有用过的<code>nonce</code>以阻止它们被二次使用）。</p><p>然而，对服务器来说永久存储所有接收到的<code>nonce</code>的代价是非常大的。可以使用**<code>timestamp</code>来优化<code>nonce</code>的存储**。</p><p>假设允许客户端和服务端最多能存在15分钟的时间差，同时追踪记录在服务端的<code>nonce</code>集合。当有新的请求进入时，首先检查携带的<code>timestamp</code>是否在15分钟内，如超出时间范围，则拒绝，然后查询携带的<code>nonce</code>，如存在已有集合，则拒绝。否则，记录该<code>nonce</code>，并删除集合内时间戳大于15分钟的<code>nonce</code>（可以使用<code>redis</code>的<code>expire</code>，新增<code>nonce</code>的同时设置它的超时失效时间为15分钟）。</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">请求接口：http://api.test.com/test?name=hello&amp;home=world&amp;work=java</span><br></pre></td></tr></table></figure><ul><li><p><u><strong>客户端</strong></u></p></li><li><ol><li><p>生成当前时间戳<code>timestamp=now</code>和唯一随机字符串<code>nonce=random</code></p></li><li><p>按照请求参数名的字母升序排列非空请求参数（包含<code>AccessKey</code>)：</p><p><code>stringA=&quot;AccessKey=access&amp;home=world&amp;name=hello&amp;work=java&amp;timestamp=now&amp;nonce=random&quot;;</code></p></li><li><p>拼接密钥<code>SecretKey</code>：</p><p><code>stringSignTemp=&quot;AccessKey=access&amp;home=world&amp;name=hello&amp;work=java&amp;timestamp=now&amp;nonce=random&amp;SecretKey=secret&quot;;</code></p></li><li><p><code>MD5</code>并转换为大写：</p><p><code>sign=MD5(stringSignTemp).toUpperCase();</code></p></li><li><p>最终请求：</p><p><code>http://api.test.com/test?name=hello&amp;home=world&amp;work=java&amp;timestamp=now&amp;nonce=nonce&amp;sign=sign;</code></p></li></ol></li><li><p><strong><u>服务端</u></strong></p><p><img src="https://gitee.com/cayzlh/img-repo/raw/master/2020/09/17024116013701611601370161045.png" alt="image-20200929170240504"></p></li></ul><h2 id="Token-amp-AppKey（APP）"><a href="#Token-amp-AppKey（APP）" class="headerlink" title="Token&amp;AppKey（APP）"></a>Token&amp;AppKey（APP）</h2><p>在<code>APP</code>开放<code>API</code>接口的设计中，由于大多数接口涉及到用户的个人信息以及产品的敏感数据，所以要对这些接口进行身份验证，为了安全起见让用户暴露的明文密码次数越少越好，然而客户端与服务器的交互在请求之间是无状态的，也就是说，当涉及到用户状态时，每次请求都要带上身份验证信息。</p><h3 id="Token身份验证"><a href="#Token身份验证" class="headerlink" title="Token身份验证"></a>Token身份验证</h3><ol><li>用户登录向服务器提供认证信息（如账号和密码），服务器验证成功后**返回<code>Token</code>**给客户端；</li><li>客户端将<code>Token</code>保存在本地，后续发起请求时，<strong>携带此Token</strong>；</li><li>服务器检查<code>Token</code>的有效性，有效则放行，无效（<code>Token</code>错误或过期）则拒绝。</li></ol><p><strong>安全隐患</strong>：<code>Token</code>被劫持，伪造请求和篡改参数。</p><h3 id="Token-AppKey签名验证"><a href="#Token-AppKey签名验证" class="headerlink" title="Token+AppKey签名验证"></a>Token+AppKey签名验证</h3><p>与上面开发平台的验证方式类似，为客户端分配**<code>AppKey</code><strong>（密钥，用于接口加密，不参与传输），将<code>AppKey</code>和所有请求参数组合成源串，根据</strong>签名算法<strong>生成签名值，发送请求时将签名值一起发送给服务器验证。这样，即使<code>Token</code>被劫持，对方不知道<code>AppKey</code>和签名算法，就无法伪造请求和篡改参数。再结合上述的</strong>重发攻击**解决方案，即使请求参数被劫持也无法伪造二次重复请求。</p><h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><p><strong><u>登录和退出请求</u></strong></p><p><img src="https://gitee.com/cayzlh/img-repo/raw/master/2020/09/17105416013706541601370654137.png" alt="image-20200929171053770"></p><p><strong><u>后续请求</u></strong></p><ul><li><p>客户端 和上述开放平台的客户端行为类似，把<code>AccessKey</code>改为<code>token</code>即可。</p></li><li><p>服务端</p><p><img src="https://gitee.com/cayzlh/img-repo/raw/master/2020/09/17140816013708481601370848386.png" alt="image-20200929171408101"></p></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>  <a href="https://mp.weixin.qq.com/s/QUaLa8oU4B1rCb-8FCs79g">芋道源码</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 笔记本 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 接口安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java中的引用类型</title>
      <link href="post/2928904442/"/>
      <url>post/2928904442/</url>
      
        <content type="html"><![CDATA[<p><code>Java</code>提供的4种引用类型，它们分别是**强引用(StrongReference)<strong>、</strong>软引用(SoftReference)<strong>、</strong>弱引用(WeakReference)<strong>和</strong>幽灵引用(PhantomReference)**。</p><h3 id="强引用-StrongReference"><a href="#强引用-StrongReference" class="headerlink" title="强引用(StrongReference)"></a>强引用(StrongReference)</h3><p>强引用是<code>Java</code>编程中最普遍的引用，例如<code>Objectobj=newObject()</code>中，新建的Object对象就是被强引用的。</p><p>如果一个对象被强引用，即使是<code>Java</code>虚拟机内存空间不足时，<code>GC</code>(垃圾收集器)也绝不会回收该对象。</p><p>当<code>Java</code>虚拟机内存不足时，就可能会导致内存溢出，我们常见的就是<code>OutOfMemoryError</code>异常。</p><h3 id="软引用-SoftReference"><a href="#软引用-SoftReference" class="headerlink" title="软引用(SoftReference)"></a>软引用(SoftReference)</h3><p>软引用是引用强度仅弱于强引用的一种引用，它使用类<code>SoftReference</code>来表示。</p><p>当<code>Java</code>虚拟机内存不足时，<code>GC</code>会回收那些只被软引用指向的对象，从而避免内存溢出。</p><p>在<code>GC</code>释放了那些只被软引用指向的对象之后，虚拟机内存依然不足，才会抛出<code>OutOfMemoryError</code>异常。</p><p>软引用适合引用那些可以通过其他方式恢复的对象，例如，数据库缓存中的对象就可以从数据库中恢复，所以软引用可以用来实现缓存。<br>另外，由于在程序使用软引用之前的某个时刻，其所指向的对象可能已经被G·C回收掉了，所以通过<code>Reference.get()</code>方法来获取软引用所指向的对象时，总是要通过检查该方法返回值是否为<code>null</code>,来判断被软引用的对象是否还存活。</p><h3 id="引用队列-ReferenceQueue"><a href="#引用队列-ReferenceQueue" class="headerlink" title="引用队列 (ReferenceQueue )"></a>引用队列 (ReferenceQueue )</h3><p>在很多场景下，我们的程序需要在一个对象的可达性(是否己经被<code>GC</code>回收)发生变化时得到通知，引用队列就是用于收集这些信息的队列。</p><p>在创建<code>SoftReference</code>对象时，可以为其关联一个引用队列，当<code>SoftReference</code>所引用的对象被GC回收时，<code>Java</code>虚拟机就会将该<code>SoftReference</code>对象添加到与之关联的引用队列中。</p><p>当需要检测这些通知信息时，就可以从引用队列中获取这些<code>SoftReference</code>对象。不仅是<code>SoftReference</code>，下面介绍的弱引用和幽灵引用都可以关联相应的队列。</p><h3 id="弱引用-WeakReference"><a href="#弱引用-WeakReference" class="headerlink" title="弱引用(WeakReference)"></a>弱引用(WeakReference)</h3><p><strong>弱引用的强度比软引用的强度还要弱。</strong>弱引用使用<code>WeakReference</code>来表示，它可以引用一个对象，但并不阻止被引用的对象被<code>GC</code>回收。在<code>JVM</code>虚拟机进行垃圾回收时，如果指向一个对象的所有引用都是弱引用，那么该对象会被回收。</p><p>由此可见，只被弱引用所指向的对象的生存周期是两次<code>GC</code>之间的这段时间，而只被软引用所指向的对象可以经历多次<code>GC</code>，直到出现内存紧张的情况才被回收。<br>弱引用典型的应用情景是就是<code>JDK</code>提供的<code>java.util.WeakHashMap</code>。<code>WeakHashMap.Entry</code>实现继承了<code>WeakReference</code>，<code>Entry</code>弱引用<code>key</code>，强引用<code>value</code>。</p><p><img src="https://gitee.com/cayzlh/img-repo/raw/master/2020/06/18/image-20200618214631511_eBFg3j.png" alt="image-20200618214631511"></p><p>当不再由强引用指向<code>key</code>时，则<code>key</code>可以被垃圾回收，当<code>key</code>被垃圾回收之后，对应的<code>Entry</code>对象会被<code>Java</code>虚拟机加入到其关联的队列中。</p><p>当应用程序下次操作<code>WeakHashMap</code>时，例如对<code>WeakHashMap</code>的扩容操作，就会遍历关联的引用队列，将其中的<code>Entry</code>对象从<code>WeakHashMap</code>中删除。</p><h3 id="幽灵引用-PhantomReference"><a href="#幽灵引用-PhantomReference" class="headerlink" title="幽灵引用(PhantomReference)"></a>幽灵引用(PhantomReference)</h3><p>在介绍幽灵引用之前，要先了解一下<code>Java</code>提供的对象终止化机制。</p><p>在<code>Object</code>类里面有个<code>finalize()</code>方法，设计该方法的初衷是在一个对象被真正回收之前，执行一些清理工作，但由于<code>GC</code>的运行时间是不固定的，所以这些清理工作的实际运行时间也是无法预知的，而且<code>JVM</code>虚拟机不能保证<code>finalize()</code>方法一定会被调用。</p><p>每个对象的<code>finalize()</code>方法至多由<code>GC</code>执行一次，对于再生对象<code>GC</code>不会再次调用其<code>finalize()</code>方法。另外，使用<code>finalize()</code>方法还会导致严重的内存消耗和性能损失。</p><p>由于<code>finalize()</code>方法存在的种种问题，该方法现在已经被废弃，而我们可以使用幽灵引用实现其替代方案。</p><p>幽灵引用，又叫“<strong>虚引用</strong>”，它是最弱的一种引用类型，由类<code>PhantomReference</code>表示。在引用的对象未被<code>GC</code>回收时，调用前面介绍的<code>SoftReference</code>以及<code>WeakReference</code>的<code>get()</code>方法，得到的是其引用的对象；当引用的对象已经被<code>GC</code>回收时，则得到<code>null</code>。但是<code>PhantomReference.get()</code>方法始终返回<code>null</code>。</p><p>在创建幽灵引用的时候必须要指定一个引用队列。当<code>GC</code>准备回收一个对象时，如果发现它还有幽灵引用，就会在回收对象的内存之前，把该虚引用加入到与之关联的引用队列中。</p><p>程序可以通过检查该引用队列里面的内容，跟踪对象是否己经被回收并进行一些清理工作。幽灵引用还可以用来实现比较精细的内存使用控制，例如应用程序可以在确定一个对象要被回收之后，再申请内存创建新对象，但这种需求并不多见。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记本 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 引用类型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>批量修改maven多模块版本号</title>
      <link href="post/2281897980/"/>
      <url>post/2281897980/</url>
      
        <content type="html"><![CDATA[<h2 id="前置"><a href="#前置" class="headerlink" title="前置"></a>前置</h2><p>最近在开发<code>starter</code>的时候发现，当进行版本升级的时候需要对每个子模块项目手动修改版本号，由于子模块较多，一个个修改的体验是极差的，而且还很容易出错。作为一个程序猿，当然要去寻找一个更好的姿势来完成这件事。</p><p><img src="https://gitee.com/cayzlh/img-repo/raw/master/2020/04/25/s6nLXV.jpeg" alt="耐心渐渐消失"></p><blockquote><p>代码经过长期修改后，版本号却从没有推进，导致个别release稳定版的模块更新代码之后，其他开发机器并不会自动更新本地依赖包。并使主干针对某分支的修改也同步到其他分支。<br>所以，此文档描述如何使用versions maven plugin插件，批量修改项目各模块的版本号，灵活推进或回退版本，避免主干每次更新代码，立即对所有分支产生影响。</p></blockquote><h2 id="versions-maven-plugin"><a href="#versions-maven-plugin" class="headerlink" title="versions-maven-plugin"></a>versions-maven-plugin</h2><p>在问过搜索引擎之后，一款<code>maven</code>插件进入了我的视线。。。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.codehaus.mojo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>versions-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这是一个能够批量修改版本号的插件，话不多说，在项目中引入。。</p><p>修改<code>pom.xml</code>，在plugins节点下添加如下代码：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.codehaus.mojo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>versions-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">generateBackupPoms</span>&gt;</span>false<span class="tag">&lt;/<span class="name">generateBackupPoms</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure><p>同步好插件之后，在<code>IDEA</code>右侧<code>maven</code>窗口可以看到该插件已经启用了。</p><p><img src="https://gitee.com/cayzlh/img-repo/raw/master/2020/04/25/WSOxFp.png" alt="image-20200425152743052"></p><p>展开插件，可以看到它有N个功能，我目前只用到了<code>version:set</code>这个功能：</p><p><img src="https://gitee.com/cayzlh/img-repo/raw/master/2020/04/25/4RcHEf.png" alt="image-20200425152923088"></p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>双击<code>version:set</code>运行插件，之后在控制台输入你想修改的版本号回车，等运行完毕之后就完成了所有模块的版本号修改。</p><p><img src="https://gitee.com/cayzlh/img-repo/raw/master/2020/04/25/whomAe.png" alt="image-20200425153124721"></p><p>查看<code>git</code>修改记录，所有模块的pom文件都被修改过来了。 。</p><p><img src="https://gitee.com/cayzlh/img-repo/raw/master/2020/04/25/mgHIsR.png" alt="image-20200425153302509"></p><p>比之前的手动修改升了不知道多少时间。。。</p><p>毕竟这年头，时间管理还是很重要的。 。 。 </p><p><img src="https://gitee.com/cayzlh/img-repo/raw/master/2020/04/25/PbF88R.jpg" alt="时间管理"></p>]]></content>
      
      
      <categories>
          
          <category> 笔记本 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Maven </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring面向切面编程（知识梳理）</title>
      <link href="post/741621cd/"/>
      <url>post/741621cd/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Aspect Oriented Programming with Spring</p><p>面向切面的编程（AOP）通过提供另一种思考程序结构的方式来补充面向对象的编程（OOP）。</p></blockquote><p> OOP中模块化的关键单元是类，而在AOP中模块化是方面。切面使关注点（例如事务管理）的模块化跨越了多个类型和对象。 （这种关注在AOP文献中通常被称为“跨领域”关注。）</p><p>Spring的关键组件之一是AOP框架。尽管Spring IoC容器不依赖于AOP，但<strong>AOP是对Spring IoC的补充，可以提供功能强大的中间件解决方案。</strong></p><blockquote><p>Spring AOP with AspectJ pointcuts</p><p>Spring provides simple and powerful ways of writing custom aspects by using either a <a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#aop-schema">schema-based approach</a> or the <a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#aop-ataspectj">@AspectJ annotation style</a>. Both of these styles offer fully typed advice and use of the AspectJ pointcut language while still using Spring AOP for weaving.</p><p>具有AspectJ切入点的Spring AOP<br>通过使用<strong>基于模式的方法</strong>或**@AspectJ注解样式**，Spring提供了编写自定义切面的简单而强大的方法。这两种样式都提供了完全类型化的建议，并使用了AspectJ切入点语言，同时仍然使用Spring AOP进行编程。</p></blockquote><h2 id="Spring-AOP概念"><a href="#Spring-AOP概念" class="headerlink" title="Spring AOP概念"></a>Spring AOP概念</h2><p>一些重要的AOP概念和术语。<em>这些术语不是特定于Spring的。</em></p><ul><li><p><strong>切面（Aspect）</strong></p><p>类是对物体特征的抽象，<em>切面就是对横切关注点的抽象</em>。</p><blockquote><p>在Spring AOP中，切面是通过使用常规类（基于架构的方法）或使用@Aspect注释（@AspectJ样式）注释的常规类来实现的。</p></blockquote><p><code>aspect</code> 由 <code>pointcount</code> 和 <code>advice</code> 组成, 它既包含了横切逻辑的定义, 也包括了连接点的定义. Spring AOP就是负责实施切面的框架, 它将切面所定义的横切逻辑织入到切面所指定的连接点中.<br>AOP的工作重心在于如何将增强织入目标对象的连接点上, 这里包含两个工作:</p><ol><li>如何通过 pointcut 和 advice 定位到特定的 joinpoint 上</li><li>如何在 advice 中编写切面代码.</li></ol></li><li><p><strong>连接点（Join point）</strong></p><blockquote><p>A point during the execution of a program, such as the execution of a method or the handling of an exception. In Spring AOP, a join point always represents a method execution.</p></blockquote><p>程序运行中的一些时间点，例如一个方法的执行，或者是一个异常的处理。<br><code>在 Spring AOP 中, join point 总是方法的执行点, 即只有方法连接点.</code></p></li><li><p><strong>增强（Advice）</strong></p><blockquote><p>Action taken by an aspect at a particular join point. Different types of advice include “around”, “before” and “after” advice. (Advice types are discussed later.) Many AOP frameworks, including Spring, model an advice as an interceptor and maintain a chain of interceptors around the join point.</p></blockquote><p>切面在特定的连接点处采取的操作。不同类型的建议包括<code>around</code>，<code>before</code>和<code>after</code>通知。 包括Spring在内的许多AOP框架都将通知建模为拦截器，并在连接点周围维护一系列拦截器。</p><p>由 <code>aspect</code> 添加到特定的 join point(即满足 <code>point cut</code> 规则的 join point) 的一段代码.<br>许多 <code>AOP</code>框架, 包括 <code>Spring AOP</code>, 会将 <code>advice</code> 模拟为一个拦截器(<code>interceptor</code>), 并且在 join point 上维护多个 <code>advice</code>, 进行层层拦截.<br><em>例如 <code>HTTP</code> 鉴权的实现, 我们可以为每个使用 <code>RequestMapping</code> 标注的方法织入 <code>advice</code>, 当 <code>HTTP</code> 请求到来时, 首先进入到 <code>advice</code> 代码中, 在这里我们可以分析这个 <code>HTTP</code> 请求是否有相应的权限, 如果有, 则执行 <code>Controller</code>, 如果没有, 则抛出异常. 这里的 <code>advice</code> 就扮演着鉴权拦截器的角色了.</em></p></li><li><p><strong>切入点（Pointcut）</strong></p><blockquote><p>A predicate that matches join points. Advice is associated with a pointcut expression and runs at any join point matched by the pointcut (for example, the execution of a method with a certain name). The concept of join points as matched by pointcut expressions is central to AOP, and Spring uses the AspectJ pointcut expression language by default.</p></blockquote><p>匹配连接点的谓词。通知与切入点表达式关联，并在与该切入点匹配的任何连接点处运行（例如，执行具有特定名称的方法）。使用切入点表达式来匹配连接点是AOP的核心，并且Spring默认使用AspectJ切入点表达语言。</p><p>在 <code>Spring</code> 中, 所有的方法都可以认为是 <code>joinpoint</code>, 但是我们并不希望在所有的方法上都添加 <code>Advice</code>, 而 pointcut 的作用就是提供一组规则(使用 <em>AspectJ pointcut expression language</em> 来描述) 来匹配<code>joinpoint</code>, 给满足规则的 <code>joinpoint</code> 添加 <code>Advice</code>.</p></li><li><p><strong>引入（Introduction）</strong></p><blockquote><p>Declaring additional methods or fields on behalf of a type. Spring AOP lets you introduce new interfaces (and a corresponding implementation) to any advised object. For example, you could use an introduction to make a bean implement an <code>IsModified</code> interface, to simplify caching. (An introduction is known as an inter-type declaration in the AspectJ community.)</p></blockquote><p>代表类型声明其他方法或字段。 Spring AOP允许您向任何建议的对象引入新的接口（和相应的实现）。例如，您可以使用<em>引入</em>使<code>Bean</code>实现<code>IsModified</code>接口，以简化缓存。 （在AspectJ社区中，<strong>引入</strong>被称为类型间声明。）</p></li></ul><blockquote><p>为一个类型添加额外的方法或字段. <code>Spring AOP</code> 允许我们为 <code>目标对象</code> 引入新的接口(和对应的实现). 例如我们可以使用 <code>introduction</code> 来为一个 <code>bean</code> 实现 <code>IsModified</code> 接口, 并以此来简化 <code>caching</code> 的实现.</p></blockquote><ul><li><p><strong>目标对象（Target object）</strong></p><blockquote><p>An object being advised by one or more aspects. Also referred to as the “advised object”. Since Spring AOP is implemented by using runtime proxies, this object is always a proxied object.</p></blockquote><p>一个或多个切面通知的对象。也称为“目标对象”。由于<code>Spring AOP</code>是使用运行时<strong>代理</strong>实现的，因此<strong>该对象始终是代理对象</strong>。</p><p>因为 Spring AOP 使用运行时代理的方式来实现 aspect, 因此 adviced object 总是一个代理对象(proxied object)。</p><p><em>注意, adviced object 指的不是原来的类, 而是织入 advice 后所产生的代理类</em></p></li><li><p><strong>代理（AOP proxy）</strong></p><blockquote><p> An object created by the AOP framework in order to implement the aspect contracts (advise method executions and so on). In the Spring Framework, an AOP proxy is a JDK dynamic proxy or a CGLIB proxy.</p></blockquote><p>一个类被 AOP 织入 <code>advice</code>， 就会产生一个结果类, 它是融合了原类和增强逻辑的代理类。在 Spring AOP 中, 一个 AOP 代理是一个 JDK 动态代理对象或 CGLIB 代理对象。</p></li><li><p><strong>织入（Weaving）</strong></p><blockquote><p> linking aspects with other application types or objects to create an advised object. This can be done at compile time (using the AspectJ compiler, for example), load time, or at runtime. Spring AOP, like other pure Java AOP frameworks, performs weaving at runtime.</p></blockquote><p>将切面与其他应用程序类型或对象链接以创建建议的对象（将 aspect 和其他对象连接起来, 并创建 adviced object 的过程）。这可以在编译时（例如，使用<code>AspectJ</code>编译器），加载时或在运行时完成。像其他纯Java AOP框架一样，<code>Spring AOP</code>在运行时执行编织。根据不同的实现技术, AOP织入有三种方式:</p><ul><li>编译器织入, 这要求有特殊的Java编译器.</li><li>类装载期织入, 这需要有特殊的类装载器.</li><li>动态代理织入, 在运行期为目标类添加增强(Advice)生成子类的方式.<br>Spring 采用动态代理织入, 而AspectJ采用编译器织入和类装载期织入.</li></ul></li></ul><h3 id="advice的几种类型"><a href="#advice的几种类型" class="headerlink" title="advice的几种类型"></a>advice的几种类型</h3><ul><li><p><strong>前置通知（Before advice）</strong></p><p>在连接点之前运行但无法阻止执行流前进到连接点的通知（除非它引发异常）。</p></li><li><p><strong>后置通知（After returning advice）</strong></p><p>连接点正常完成后要运行的通知（例如，如果方法返回而没有引发异常）。</p></li><li><p><strong>抛出异常后通知（After throwing advice）</strong></p><p>如果存在方法则通过抛出异常来执行的通知。</p></li><li><p><strong>在finally执行后通知（After (finally) advice）</strong></p><p>无论连接点退出的方式如何（正常或异常返回），都将执行通知。</p></li><li><p><strong>环绕通知（Around advice</strong>）</p><p>围绕联接点的通知，例如方法调用。这是最有力的通知。<strong>环绕通知可以在方法调用之前和之后执行自定义行为</strong>。它还负责选择是返回连接点还是通过返回其自身的返回值或引发异常来进行通知的方法执行。</p></li></ul><h2 id="AOP代理"><a href="#AOP代理" class="headerlink" title="AOP代理"></a>AOP代理</h2><p><code>Spring AOP</code>默认将标准<code>JDK</code>动态代理用于<code>AOP</code>代理。这使得可以代理任何接口（或一组接口）。</p><p><code>Spring AOP</code>也可以使用<code>CGLIB</code>代理。这对于代理类而不是接口是必需的。<strong>默认情况下，如果业务对象未实现接口，则使用CGLIB。</strong>由于对接口而不是对类进行编程是一种好习惯，因此业务类通常实现一个或多个业务接口。在那些需要建议在接口上未声明的方法或需要将代理对象作为具体类型传递给方法的情况下（在极少数情况下），可以强制使用<code>CGLIB</code>。</p><h3 id="Spring-Bean的生命周期"><a href="#Spring-Bean的生命周期" class="headerlink" title="Spring Bean的生命周期"></a>Spring Bean的生命周期</h3><blockquote><p>插播一下Spring Bean的生命周期</p></blockquote><p>两个概念：<code>Spring Bean</code> 和 <code>对象</code>：</p><ol><li><strong>spring bean</strong>——受spring容器管理的对象，可能经过了完整的spring bean生命周期（为什么是可能？难道还有bean是没有经过bean生命周期的？答案是有的，具体我们后面文章分析），最终存在spring容器当中；一个bean一定是个对象</li><li><strong>对象</strong>——任何符合java语法规则实例化出来的对象，但是一个对象并不一定是spring bean；</li></ol><p>所谓的bean的生命周期就是磁盘上的类通过Spring扫描，然后实例化，跟着初始化，继而放到容器当中的过程。下图展示Spring Bean的生命周期大概有哪些步骤：</p><p><img src="https://cdn.jsdelivr.net/gh/cayzlh/git-img-repository@master/uPic/20191118210559319.png" alt="Spring Bean的生命周期"></p><p><strong>其中AOP的代理也是在这个过程中完成的。</strong></p><h2 id="AOP的使用"><a href="#AOP的使用" class="headerlink" title="AOP的使用"></a>AOP的使用</h2><h3 id="AspectJ与-AspectJ"><a href="#AspectJ与-AspectJ" class="headerlink" title="AspectJ与@AspectJ"></a>AspectJ与@AspectJ</h3><p><code>@AspectJ</code>是一种将切面声明为带有注解的常规<code>Java</code>类的样式。 <code>@AspectJ</code>样式是<code>AspectJ</code>项目在<code>AspectJ 5</code>版本中引入的。 <code>Spring</code>使用<code>AspectJ</code>提供的用于切入点解析和匹配的库来解释与<code>AspectJ 5</code>相同的注解。但是，<code>AOP</code>运行时仍然是纯<code>Spring AOP</code>，并且不依赖于<code>AspectJ</code>编译器或编织器。</p><blockquote><p>为了方便使用，<code>Spring</code>借鉴了<code>AspectJ</code>的语法。</p><p>使用<code>AspectJ</code>编译器和<code>weaver</code>可以使用完整的<code>AspectJ</code>语法。</p></blockquote><blockquote><p>AspectJ 是最早、功能比较强大的 AOP 实现之一，对整套 AOP 机制都有较好的实现，很多其他语言的 AOP 实现，也借鉴或采纳了 AspectJ 中很多设计。</p></blockquote><h3 id="启用-AspectJ支持"><a href="#启用-AspectJ支持" class="headerlink" title="启用@AspectJ支持"></a>启用@AspectJ支持</h3><ol><li><p>通过<code>Java</code>配置启用<code>@AspectJ</code>支持</p><p>在配置类加上<code>@EnableAspectJAutoProxy</code>注解以启用<code>@AspectJ</code>支持</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>通过<code>XML</code>配置启用<code>@Aspect</code>J支持</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span>/&gt;</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="声明一个切面"><a href="#声明一个切面" class="headerlink" title="声明一个切面"></a>声明一个切面</h3><p>启用<code>@AspectJ</code>支持后，<code>Spring</code>会自动检测在应用程序上下文中使用<code>@AspectJ</code>切面（具有<code>@Aspect</code>批注）的类定义的bean，并用于配置<code>Spring AOP</code>。</p><ol><li><p>使用xml配置声明切面</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;myAspect&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.xyz.NotVeryUsefulAspect&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- configure properties of the aspect here --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>使用注解声明切面</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.xyz;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotVeryUsefulAspect</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="声明切入点"><a href="#声明切入点" class="headerlink" title="声明切入点"></a>声明切入点</h3><p>切入点确定了关注的的连接点，从而使我们能够控制执行通知的时机。 <code>Spring AOP</code>仅支持<code>Spring Bean</code>的方法执行连接点，可以将切入点视为与<code>Spring Bean</code>上的方法执行匹配。</p><p>切入点声明由两部分组成：一个包含名称和任何参数的签名，以及一个切入点表达式，该切入点表达式精确地确定我们关注的方法执行。在<code>AOP</code>的<code>@AspectJ</code>批注样式中，常规方法定义提供了切入点签名。 并通过使用<code>@Pointcut</code>注解声明切入点表达式（<strong>用作切入点签名的方法必须具有void返回类型</strong>）。</p><p>一个例子：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Pointcut(&quot;execution(* transfer(..))&quot;)</span> <span class="comment">// 切入点表达式</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">anyOldTransfer</span><span class="params">()</span> </span>&#123;&#125; <span class="comment">// 切入点方法签名</span></span><br></pre></td></tr></table></figure><h4 id="支持的切入点指示符"><a href="#支持的切入点指示符" class="headerlink" title="支持的切入点指示符"></a>支持的切入点指示符</h4><p><code>Spring AOP</code>支持以下在切入点表达式中使用的<code>AspectJ</code>切入点指示符（PCD）：</p><ul><li><p><code>execution</code>：匹配方法执行的连接点，这是你将会用到的Spring的最主要的切入点指定者。</p><blockquote><p>描述的最小粒度精确到方法（甚至方法的参数）</p></blockquote></li><li><p><code>within</code>：限定匹配特定类型的连接点（在使用SpringAOP的时候，在匹配的类型中定义的方法的执行）。</p><blockquote><p>描述的最小粒度仅仅到一个类</p></blockquote></li><li><p><code>this</code>：限定匹配特定的连接点（使用Spring AOP的时候方法的执行），其中bean reference（Spring AOP 代理）是<strong>指定类型的实例。</strong>（代理的对象本身）</p></li><li><p><code>target</code>：限定匹配特定的连接点（使用SpringAOP的时候方法的执行），其中目标对象（被代理的appolication object）是<strong>指定类型的实例。</strong>（被代理的对象）</p></li><li><p><code>args</code>：限定匹配特定的连接点（使用Spring AOP的时候方法的执行），其中参数是指定类型的实例。</p></li><li><p><code>@target</code>：限定匹配特定的连接点（使用SpringAOP的时候方法的执行），其中执行的对象的类已经有指定类型的注解。</p></li><li><p>@args：限定匹配特定的连接点（使用SpringAOP的时候方法的执行），其中实际传入参数的运行时类型有指定类型的注解。</p></li><li><p><code>@within</code>：限定匹配特定的连接点，其中连接点所在类型已指定注解（在使用Spring AOP的时候，所执行的方法所在类型已指定注解）。</p></li><li><p> <code>@annotation</code>：限定匹配特定的连接点（使用SpringAOP的时候方法的执行），其中连接点的主题有某种给定的注解合并切入点表达式</p></li></ul><h4 id="组合切入点"><a href="#组合切入点" class="headerlink" title="组合切入点"></a>组合切入点</h4><p>您可以使用<code>&amp;&amp;</code>，<code>||</code>组合切入点表达式和<code>！</code>您也可以按名称引用切入点表达式。以下示例显示了三个切入点表达式：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Pointcut(&quot;execution(public * *(..))&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">anyPublicOperation</span><span class="params">()</span> </span>&#123;&#125;  <span class="comment">// 1⃣️ 匹配所有公共方法</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Pointcut(&quot;within(com.xyz.someapp.trading..*)&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inTrading</span><span class="params">()</span> </span>&#123;&#125;  <span class="comment">// 2⃣️ 匹配指定包里面的所有方法</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Pointcut(&quot;anyPublicOperation() &amp;&amp; inTrading()&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">tradingOperation</span><span class="params">()</span> </span>&#123;&#125;  <span class="comment">// 3⃣️ 匹配指定包里面的所有公共方法</span></span><br></pre></td></tr></table></figure><h4 id="共享通用切入点定义"><a href="#共享通用切入点定义" class="headerlink" title="共享通用切入点定义"></a>共享通用切入点定义</h4><p>在开发应用程序时，开发人员通常希望从多个方面引用应用程序的模块和特定的操作集。我们建议为此定义一个 <code>SystemArchitecture</code>切面，以捕获常见的切入点表达式。这样的方面通常类似于以下示例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xyz.someapp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Pointcut;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SystemArchitecture</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * A join point is in the web layer if the method is defined</span></span><br><span class="line"><span class="comment">     * in a type in the com.xyz.someapp.web package or any sub-package</span></span><br><span class="line"><span class="comment">     * under that.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Pointcut(&quot;within(com.xyz.someapp.web..*)&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inWebLayer</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * A join point is in the service layer if the method is defined</span></span><br><span class="line"><span class="comment">     * in a type in the com.xyz.someapp.service package or any sub-package</span></span><br><span class="line"><span class="comment">     * under that.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Pointcut(&quot;within(com.xyz.someapp.service..*)&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inServiceLayer</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * A join point is in the data access layer if the method is defined</span></span><br><span class="line"><span class="comment">     * in a type in the com.xyz.someapp.dao package or any sub-package</span></span><br><span class="line"><span class="comment">     * under that.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Pointcut(&quot;within(com.xyz.someapp.dao..*)&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inDataAccessLayer</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * A business service is the execution of any method defined on a service</span></span><br><span class="line"><span class="comment">     * interface. This definition assumes that interfaces are placed in the</span></span><br><span class="line"><span class="comment">     * &quot;service&quot; package, and that implementation types are in sub-packages.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * If you group service interfaces by functional area (for example,</span></span><br><span class="line"><span class="comment">     * in packages com.xyz.someapp.abc.service and com.xyz.someapp.def.service) then</span></span><br><span class="line"><span class="comment">     * the pointcut expression &quot;execution(* com.xyz.someapp..service.*.*(..))&quot;</span></span><br><span class="line"><span class="comment">     * could be used instead.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Alternatively, you can write the expression using the &#x27;bean&#x27;</span></span><br><span class="line"><span class="comment">     * PCD, like so &quot;bean(*Service)&quot;. (This assumes that you have</span></span><br><span class="line"><span class="comment">     * named your Spring service beans in a consistent fashion.)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(* com.xyz.someapp..service.*.*(..))&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">businessService</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * A data access operation is the execution of any method defined on a</span></span><br><span class="line"><span class="comment">     * dao interface. This definition assumes that interfaces are placed in the</span></span><br><span class="line"><span class="comment">     * &quot;dao&quot; package, and that implementation types are in sub-packages.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(* com.xyz.someapp.dao.*.*(..))&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dataAccessOperation</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以在需要切入点表达式的任何地方引用切面中定义的切入点。例如，要使服务层具有事务性：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    &lt;aop:advisor</span><br><span class="line">        pointcut=&quot;com.xyz.someapp.SystemArchitecture.businessService()&quot;</span><br><span class="line">        advice-ref=&quot;tx-advice&quot;/&gt;</span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">&quot;tx-advice&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;*&quot;</span> <span class="attr">propagation</span>=<span class="string">&quot;REQUIRED&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h4><blockquote><p>语法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">execution(modifiers-pattern? ret-type-pattern declaring-type-pattern?name-pattern(param-pattern) <span class="keyword">throws</span>-pattern?)</span><br></pre></td></tr></table></figure><ul><li>问号表示当前项有也可以没有</li><li>其中各项语义如下：<ul><li><strong>modifiers- pattern</strong>：方法的可见性，如 public, protected</li><li><strong>ret-type- pattern</strong>：方法的返回值类型，如 int, void 等</li><li><strong>declaring-type- pattern</strong>：方法所在类的全路径名，如 com, spring, Aspect</li><li><strong>name- pattern</strong>：方法名，如 bui sinessservice () </li><li><strong>param- pattern</strong>：方法的参数类型，如 java. Lang String</li><li><strong>throws- pattern</strong>: 方法抛出的异常类型，如 java.Lang. Exception</li></ul></li></ul></blockquote><p>一些常见的表达式：</p><ul><li><p>匹配任意<code>public</code>方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">execution(<span class="keyword">public</span> * *(..))</span><br></pre></td></tr></table></figure></li><li><p>匹配所有以<code>set</code>开头的方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">execution(* set*(..))</span><br></pre></td></tr></table></figure></li><li><p>匹配<code>AccountService</code>接口定义的任何方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">execution(* com.xyz.service.AccountService.*(..))</span><br></pre></td></tr></table></figure></li><li><p>匹配指定包下的方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">execution(* com.xyz.service.*.*(..))</span><br></pre></td></tr></table></figure></li><li><p>匹配指定包下面的一个或多个子包下的类方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">execution(* com.xyz.service..*.*(..))</span><br></pre></td></tr></table></figure></li><li><p>匹配<code>service</code>包中的所有连接点</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">within(com.xyz.service.*)</span><br></pre></td></tr></table></figure></li><li><p>匹配<code>service</code>一个或多个子包中的所有连接点</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">within(com.xyz.service..*)</span><br></pre></td></tr></table></figure></li><li><p>代理实现<code>AccountService</code>接口的任何连接点</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>(com.xyz.service.AccountService)</span><br></pre></td></tr></table></figure></li><li><p>目标对象实现AccountService接口的任何连接点</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">target(com.xyz.service.AccountService)</span><br></pre></td></tr></table></figure></li><li><p>任何采用单个参数并且在运行时传递的参数为Serializable的连接点</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">args(java.io.Serializable)</span><br></pre></td></tr></table></figure></li><li><p>目标对象具有<code>@Transactional</code>注解的任何连接点</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@target(org.springframework.transaction.annotation.Transactional)</span></span><br></pre></td></tr></table></figure></li><li><p>目标对象的声明类型具有<code>@Transactional</code>注解的任何连接点</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@within(org.springframework.transaction.annotation.Transactional)</span></span><br></pre></td></tr></table></figure></li><li><p>任何执行方法带有@Transactional批注的连接点</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@annotation(org.springframework.transaction.annotation.Transactional)</span></span><br></pre></td></tr></table></figure></li><li><p>任何采用单个参数的联接点，并且传递的参数的运行时类型具有<code>Classified</code>注解</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@args(com.xyz.security.Classified)</span></span><br></pre></td></tr></table></figure></li><li><p>名为<code>tradeService</code>的<code>Spring bean</code>上的任何连接点</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">bean(tradeService)</span><br></pre></td></tr></table></figure></li><li><p><code>Spring Bean</code>上具有与通配符表达式<code>* Service</code>匹配的名称的任何连接点</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">bean(*Service)</span><br></pre></td></tr></table></figure></li></ul><h3 id="声明通知"><a href="#声明通知" class="headerlink" title="声明通知"></a>声明通知</h3><p>通知用来声明方法在切入点表达式匹配的方法执行之前，之后或周围运行。切入点表达式可以是对命名切入点的简单引用，也可以是就地声明的切入点表达式。</p><h4 id="Before-Advice"><a href="#Before-Advice" class="headerlink" title="Before Advice"></a>Before Advice</h4><p>使用<code>@Before</code>注解在切面中声明通知。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Before;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeforeExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before(&quot;com.xyz.myapp.SystemArchitecture.dataAccessOperation()&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAccessCheck</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>声明通知的同时声明切入点：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Before;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeforeExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before(&quot;execution(* com.xyz.myapp.dao.*.*(..))&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAccessCheck</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="After-Returning-Advice"><a href="#After-Returning-Advice" class="headerlink" title="After Returning Advice"></a>After Returning Advice</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.AfterReturning;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AfterReturningExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterReturning(&quot;com.xyz.myapp.SystemArchitecture.dataAccessOperation()&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAccessCheck</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有时，您需要在通知正文中访问返回的实际值。您可以使用<code>@AfterReturning</code>的形式绑定返回值以获取该访问权限，如以下示例所示：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.AfterReturning;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AfterReturningExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterReturning(</span></span><br><span class="line"><span class="meta">        pointcut=&quot;com.xyz.myapp.SystemArchitecture.dataAccessOperation()&quot;,</span></span><br><span class="line"><span class="meta">        returning=&quot;retVal&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAccessCheck</span><span class="params">(Object retVal)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="After-Throwing-Advice"><a href="#After-Throwing-Advice" class="headerlink" title="After Throwing Advice"></a>After Throwing Advice</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.AfterThrowing;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AfterThrowingExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterThrowing(&quot;com.xyz.myapp.SystemArchitecture.dataAccessOperation()&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doRecoveryActions</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>指定异常类型：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.AfterThrowing;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AfterThrowingExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterThrowing(</span></span><br><span class="line"><span class="meta">        pointcut=&quot;com.xyz.myapp.SystemArchitecture.dataAccessOperation()&quot;,</span></span><br><span class="line"><span class="meta">        throwing=&quot;ex&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doRecoveryActions</span><span class="params">(DataAccessException ex)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="After-Finally-Advice"><a href="#After-Finally-Advice" class="headerlink" title="After (Finally) Advice"></a>After (Finally) Advice</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.After;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AfterFinallyExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@After(&quot;com.xyz.myapp.SystemArchitecture.dataAccessOperation()&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doReleaseLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Around-Advice"><a href="#Around-Advice" class="headerlink" title="Around Advice"></a>Around Advice</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Around;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.ProceedingJoinPoint;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AroundExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around(&quot;com.xyz.myapp.SystemArchitecture.businessService()&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">doBasicProfiling</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">// start stopwatch</span></span><br><span class="line">        Object retVal = pjp.proceed();</span><br><span class="line">        <span class="comment">// stop stopwatch</span></span><br><span class="line">        <span class="keyword">return</span> retVal;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h3><p>引入（<strong>Introductions</strong>）（在AspectJ中称为类型间声明）使切面可以声明通知对象实现给定的接口，并代表那些对象提供该接口的实现。</p><p>您可以使用<code>@DeclareParents</code>批注进行介绍。此批注用于声明匹配类型具有新的父代（因此而得名）。例如，给定一个名为<code>UsageTracked</code>的接口和该接口名为<code>DefaultUsageTracked</code>的实现，以下方面声明服务接口的所有实现者也都实现了<code>UsageTracked</code>接口（例如，通过JMX公开统计信息）：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UsageTracking</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@DeclareParents(value=&quot;com.xzy.myapp.service.*+&quot;, defaultImpl=DefaultUsageTracked.class)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> UsageTracked mixin;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before(&quot;com.xyz.myapp.SystemArchitecture.businessService() &amp;&amp; this(usageTracked)&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recordUsage</span><span class="params">(UsageTracked usageTracked)</span> </span>&#123;</span><br><span class="line">        usageTracked.incrementUseCount();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Spring-AOP实例"><a href="#Spring-AOP实例" class="headerlink" title="Spring AOP实例"></a>Spring AOP实例</h2><p><strong>代码地址：</strong><a href="https://github.com/cayzlh/cayzlh-demos">https://github.com/cayzlh/cayzlh-demos</a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><code>Spring</code>借鉴了<code>AspectJ</code>的语法</li><li><code>Spring</code>通过动态代理来实现<code>aop</code></li><li>对接口创建代理优于对类创建代理，因为会产生更加松耦合的系统，所以spring默认是使用JDK代理。对类代理是让遗留系统或无法实现接口的第三方类库同样可以得到通知，这种方式应该是备用方案</li><li>标记为<code>final</code>的方法不能够被通知。spring是为目标类产生子类。任何需要被通知的方法都被复写，将通知织入。<code>final</code>方法是不允许重写的</li><li>spring只支持方法连接点：不提供属性接入点，spring的观点是属性拦截破坏了封装。面向对象的概念是对象自己处理工作，其他对象只能通过方法调用的得到的结果</li></ul><blockquote><p>spring在运行期，生成动态代理对象，不需要特殊的编译器</p><p>Spring AOP 优先对接口进行代理 （使用Jdk动态代理）如果目标对象没有实现任何接口，才会对类进行代理 （使用cglib动态代理）</p></blockquote><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#aop">Spring官网(aop)</a></li><li><a href="https://zhuanlan.zhihu.com/p/97223347">Spring AOP简介与底层实现机制——动态代理</a></li><li><a href="https://blog.csdn.net/java_lyvee/article/details/101793774">spring源码系列（一）——spring循环引用</a></li><li><a href="https://segmentfault.com/a/1190000007469968">彻底征服 Spring AOP 之 理论篇</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot异步请求和异步调用</title>
      <link href="post/1086706207/"/>
      <url>post/1086706207/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文转载自：<a href="https://cnblogs.com/baixianlong/p/10661591.html">https://cnblogs.com/baixianlong/p/10661591.html</a></p></blockquote><h2 id="异步请求与同步请求"><a href="#异步请求与同步请求" class="headerlink" title="异步请求与同步请求"></a>异步请求与同步请求</h2><h3 id="同步请求"><a href="#同步请求" class="headerlink" title="同步请求"></a>同步请求</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">%% 时序图例子,-&gt; 直线，--&gt;虚线，-&gt;&gt;实线箭头</span><br><span class="line"></span><br><span class="line">sequenceDiagram</span><br><span class="line"></span><br><span class="line">participant 浏览器&#x2F;APP</span><br><span class="line"></span><br><span class="line">participant 请求处理线程</span><br><span class="line"></span><br><span class="line">participant 处理线程</span><br><span class="line"></span><br><span class="line">浏览器&#x2F;APP-&gt;&gt;请求处理线程: request</span><br><span class="line"></span><br><span class="line">loop 等待</span><br><span class="line">浏览器&#x2F;APP--&gt;浏览器&#x2F;APP: 等待Response</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">请求处理线程-&gt;&gt;处理线程: call</span><br><span class="line"></span><br><span class="line">loop 阻塞</span><br><span class="line">请求处理线程-&gt;请求处理线程: 请求处理线程阻塞</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">loop 处理中</span><br><span class="line">处理线程-&gt;处理线程: 处理线程处理中</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">处理线程-&gt;&gt;请求处理线程: return</span><br><span class="line"></span><br><span class="line">请求处理线程 -&gt;&gt; 浏览器&#x2F;APP: Response</span><br></pre></td></tr></table></figure><h3 id="异步请求"><a href="#异步请求" class="headerlink" title="异步请求"></a>异步请求</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line"></span><br><span class="line">participant 浏览器&#x2F;APP</span><br><span class="line"></span><br><span class="line">participant 请求处理线程</span><br><span class="line"></span><br><span class="line">participant 回调处理线程</span><br><span class="line"></span><br><span class="line">participant 处理线程</span><br><span class="line"></span><br><span class="line">浏览器&#x2F;APP-&gt;&gt;请求处理线程: request</span><br><span class="line"></span><br><span class="line">loop 等待</span><br><span class="line">浏览器&#x2F;APP-&gt;浏览器&#x2F;APP: 等待Response</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">请求处理线程-&gt;&gt;处理线程: invoke</span><br><span class="line"></span><br><span class="line">loop 结束</span><br><span class="line">请求处理线程--&gt;&gt;请求处理线程: 处理别的请求去了</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">loop 处理中</span><br><span class="line">处理线程-&gt;处理线程: 处理线程处理中</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">处理线程-&gt;&gt;回调处理线程: callback</span><br><span class="line"></span><br><span class="line">回调处理线程 -&gt;&gt; 浏览器&#x2F;APP: Response</span><br></pre></td></tr></table></figure><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p>可以先释放容器分配给请求的线程与相关资源，减轻系统负担，释放了容器所分配线程的请求，其响应将被延后，可以在耗时处理完成（例如长时间的运算）时再对客户端进行响应。</p><p><strong>一句话：增加了服务器对客户端请求的吞吐量</strong>（实际生产上我们用的比较少，如果并发请求量很大的情况下，我们会通过nginx把请求负载到集群服务的各个节点上来分摊请求压力，当然还可以通过消息队列来做请求的缓冲）<strong>。</strong></p><h2 id="异步请求的实现"><a href="#异步请求的实现" class="headerlink" title="异步请求的实现"></a>异步请求的实现</h2><h3 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h3><p>Servlet方式实现异步请求 ：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value = &quot;/email/servletReq&quot;, method = GET)</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">servletReq</span> <span class="params">(HttpServletRequest request, HttpServletResponse response)</span> </span>&#123;</span><br><span class="line">      AsyncContext asyncContext = request.startAsync();</span><br><span class="line">      <span class="comment">//设置监听器:可设置其开始、完成、异常、超时等事件的回调处理</span></span><br><span class="line">      asyncContext.addListener(<span class="keyword">new</span> AsyncListener() &#123;</span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onTimeout</span><span class="params">(AsyncEvent event)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">              System.out.println(<span class="string">&quot;超时了...&quot;</span>);</span><br><span class="line">              <span class="comment">//做一些超时后的相关操作...</span></span><br><span class="line">          &#125;</span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStartAsync</span><span class="params">(AsyncEvent event)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">              System.out.println(<span class="string">&quot;线程开始&quot;</span>);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(AsyncEvent event)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">              System.out.println(<span class="string">&quot;发生错误：&quot;</span>+event.getThrowable());</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">(AsyncEvent event)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">              System.out.println(<span class="string">&quot;执行完成&quot;</span>);</span><br><span class="line">              <span class="comment">//这里可以做一些清理资源的操作...</span></span><br><span class="line">          &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">      <span class="comment">//设置超时时间</span></span><br><span class="line">      asyncContext.setTimeout(<span class="number">20000</span>);</span><br><span class="line">      asyncContext.start(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">              <span class="keyword">try</span> &#123;</span><br><span class="line">                  Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">                  System.out.println(<span class="string">&quot;内部线程：&quot;</span> + Thread.currentThread().getName());</span><br><span class="line">                  asyncContext.getResponse().setCharacterEncoding(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">                  asyncContext.getResponse().setContentType(<span class="string">&quot;text/html;charset=UTF-8&quot;</span>);</span><br><span class="line">                  asyncContext.getResponse().getWriter().println(<span class="string">&quot;这是异步的请求返回&quot;</span>);</span><br><span class="line">              &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                  System.out.println(<span class="string">&quot;异常：&quot;</span>+e);</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="comment">//异步请求完成通知</span></span><br><span class="line">              <span class="comment">//此时整个请求才完成</span></span><br><span class="line">              asyncContext.complete();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">      <span class="comment">//此时之类 request的线程连接已经释放了</span></span><br><span class="line">      System.out.println(<span class="string">&quot;主线程：&quot;</span> + Thread.currentThread().getName());</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h3><p>使用很简单，直接返回的参数包裹一层callable即可，可以继承WebMvcConfigurerAdapter类来设置默认线程池和超时处理。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value = &quot;/email/callableReq&quot;, method = GET)</span></span><br><span class="line">  <span class="meta">@ResponseBody</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Callable&lt;String&gt; <span class="title">callableReq</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;外部线程：&quot;</span> + Thread.currentThread().getName());</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Callable&lt;String&gt;() &#123;</span><br><span class="line"></span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">              Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">              System.out.println(<span class="string">&quot;内部线程：&quot;</span> + Thread.currentThread().getName());</span><br><span class="line">              <span class="keyword">return</span> <span class="string">&quot;callable!&quot;</span>;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Configuration</span></span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestAsyncPoolConfig</span> <span class="keyword">extends</span> <span class="title">WebMvcConfigurerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Resource</span></span><br><span class="line">  <span class="keyword">private</span> ThreadPoolTaskExecutor myThreadPoolTaskExecutor;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configureAsyncSupport</span><span class="params">(<span class="keyword">final</span> AsyncSupportConfigurer configurer)</span> </span>&#123;</span><br><span class="line">      <span class="comment">//处理 callable超时</span></span><br><span class="line">      configurer.setDefaultTimeout(<span class="number">60</span>*<span class="number">1000</span>);</span><br><span class="line">      configurer.setTaskExecutor(myThreadPoolTaskExecutor);</span><br><span class="line">      configurer.registerCallableInterceptors(timeoutCallableProcessingInterceptor());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> TimeoutCallableProcessingInterceptor <span class="title">timeoutCallableProcessingInterceptor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> TimeoutCallableProcessingInterceptor();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方式三"><a href="#方式三" class="headerlink" title="方式三"></a>方式三</h3><p>和方式二差不多，在Callable外包一层，给WebAsyncTask设置一个超时回调，即可实现超时处理。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value = &quot;/email/webAsyncReq&quot;, method = GET)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> WebAsyncTask&lt;String&gt; <span class="title">webAsyncReq</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;外部线程：&quot;</span> + Thread.currentThread().getName());</span><br><span class="line">        Callable&lt;String&gt; result = () -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;内部线程开始：&quot;</span> + Thread.currentThread().getName());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">4</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">            &#125;</span><br><span class="line">            logger.info(<span class="string">&quot;副线程返回&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;内部线程返回：&quot;</span> + Thread.currentThread().getName());</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        WebAsyncTask&lt;String&gt; wat = <span class="keyword">new</span> WebAsyncTask&lt;String&gt;(<span class="number">3000L</span>, result);</span><br><span class="line">        wat.onTimeout(<span class="keyword">new</span> Callable&lt;String&gt;() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;超时&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> wat;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="方式四"><a href="#方式四" class="headerlink" title="方式四"></a>方式四</h3><p>DeferredResult可以处理一些相对复杂一些的业务逻辑，最主要还是可以在另一个线程里面进行业务处理及返回，即可在两个完全不相干的线程间的通信。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value = &quot;/email/deferredResultReq&quot;, method = GET)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DeferredResult&lt;String&gt; <span class="title">deferredResultReq</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;外部线程：&quot;</span> + Thread.currentThread().getName());</span><br><span class="line">        <span class="comment">//设置超时时间</span></span><br><span class="line">        DeferredResult&lt;String&gt; result = <span class="keyword">new</span> DeferredResult&lt;String&gt;(<span class="number">60</span>*<span class="number">1000L</span>);</span><br><span class="line">        <span class="comment">//处理超时事件 采用委托机制</span></span><br><span class="line">        result.onTimeout(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;DeferredResult超时&quot;</span>);</span><br><span class="line">                result.setResult(<span class="string">&quot;超时了!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        result.onCompletion(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="comment">//完成后</span></span><br><span class="line">                System.out.println(<span class="string">&quot;调用完成&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        myThreadPoolTaskExecutor.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="comment">//处理业务逻辑</span></span><br><span class="line">                System.out.println(<span class="string">&quot;内部线程：&quot;</span> + Thread.currentThread().getName());</span><br><span class="line">                <span class="comment">//返回结果</span></span><br><span class="line">                result.setResult(<span class="string">&quot;DeferredResult!!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">       <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="SpringBoot中异步调用的使用"><a href="#SpringBoot中异步调用的使用" class="headerlink" title="SpringBoot中异步调用的使用"></a>SpringBoot中异步调用的使用</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>异步请求的处理。除了异步请求，一般上我们用的比较多的应该是异步调用。通常在开发过程中，会遇到一个方法是和实际业务无关的，没有紧密性的。比如记录日志信息等业务。这个时候正常就是启一个新线程去做一些业务处理，让主线程异步的执行其他业务。</p><h3 id="使用方式（基于spring下）"><a href="#使用方式（基于spring下）" class="headerlink" title="使用方式（基于spring下）"></a>使用方式（基于spring下）</h3><p>需要在启动类加入<code>@EnableAsync</code>使异步调用<code>@Async</code>注解生效</p><p>在需要异步执行的方法上加入此注解即可<code>@Async(&quot;threadPool&quot;)</code>,threadPool为自定义线程池。</p><p>代码略。</p><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>在默认情况下，未设置TaskExecutor时，默认是使用SimpleAsyncTaskExecutor这个线程池，但此线程不是真正意义上的线程池，因为线程不重用，每次调用都会创建一个新的线程。可通过控制台日志输出可以看出，每次输出线程名都是递增的。所以最好我们来自定义一个线程池。</p><p>调用的异步方法，不能为同一个类的方法（包括同一个类的内部类），简单来说，因为Spring在启动扫描时会为其创建一个代理类，而同类调用时，还是调用本身的代理类的，所以和平常调用是一样的。</p><p>其他的注解如@Cache等也是一样的道理，说白了，就是Spring的代理机制造成的。所以在开发中，最好把异步服务单独抽出一个类来管理。下面会重点讲述。。</p><h3 id="什么情况下会导致-Async异步方法会失效？"><a href="#什么情况下会导致-Async异步方法会失效？" class="headerlink" title="什么情况下会导致@Async异步方法会失效？"></a>什么情况下会导致@Async异步方法会失效？</h3><ul><li><p><strong>调用同一个类下注有@Async异步方法：</strong></p><p>在spring中像@Async和@Transactional、cache等注解本质使用的是动态代理，其实Spring容器在初始化的时候Spring容器会将含有AOP注解的类对象“替换”为代理对象（简单这么理解），那么注解失效的原因就很明显了，就是因为调用方法的是对象本身而不是代理对象，因为没有经过Spring容器，那么解决方法也会沿着这个思路来解决。</p></li><li><p><strong>调用的是静态(static )方法</strong></p></li><li><p><strong>调用(private)私有化方法</strong></p></li></ul><h3 id="解决4中问题1的方式"><a href="#解决4中问题1的方式" class="headerlink" title="解决4中问题1的方式"></a>解决4中问题1的方式</h3><p><strong>将要异步执行的方法单独抽取成一个类，</strong>原理就是当你把执行异步的方法单独抽取成一个类的时候，这个类肯定是被Spring管理的，其他Spring组件需要调用的时候肯定会注入进去，这时候实际上注入进去的就是代理类了。</p><p>其实我们的注入对象都是从Spring容器中给当前Spring组件进行成员变量的赋值，由于某些类使用了AOP注解，那么实际上在Spring容器中实际存在的是它的代理对象。那么我们就可以<strong>通过上下文获取自己的代理对象调用异步方法。</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/app&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmailController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取ApplicationContext对象方式有多种,这种最简单,其它的大家自行了解一下</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ApplicationContext applicationContext;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/email/asyncCall&quot;, method = GET)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title">asyncCall</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        Map&lt;String, Object&gt; resMap = <span class="keyword">new</span> HashMap&lt;String, Object&gt;();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//这样调用同类下的异步方法是不起作用的</span></span><br><span class="line">            <span class="comment">//this.testAsyncTask();</span></span><br><span class="line">            <span class="comment">//通过上下文获取自己的代理对象调用异步方法</span></span><br><span class="line">            EmailController emailController = (EmailController)applicationContext.getBean(EmailController.class);</span><br><span class="line">            emailController.testAsyncTask();</span><br><span class="line">            resMap.put(<span class="string">&quot;code&quot;</span>,<span class="number">200</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            resMap.put(<span class="string">&quot;code&quot;</span>,<span class="number">400</span>);</span><br><span class="line">            logger.error(<span class="string">&quot;error!&quot;</span>,e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> resMap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//注意一定是public,且是非static方法</span></span><br><span class="line">    <span class="meta">@Async</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testAsyncTask</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;异步任务执行完成！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>开启cglib代理，手动获取Spring代理类,从而调用同类下的异步方法。首先，在启动类上加上<code>@EnableAspectJAutoProxy(exposeProxy = true)</code>注解。代码实现，如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Transactional(value = &quot;transactionManager&quot;, readOnly = false, propagation = Propagation.REQUIRED, rollbackFor = Throwable.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmailService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ApplicationContext applicationContext;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Async</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSyncTask</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;异步任务执行完成！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">asyncCallTwo</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">//this.testSyncTask();</span></span><br><span class="line"><span class="comment">// EmailService emailService = (EmailService)applicationContext.getBean(EmailService.class);</span></span><br><span class="line"><span class="comment">// emailService.testSyncTask();</span></span><br><span class="line">        <span class="keyword">boolean</span> isAop = AopUtils.isAopProxy(EmailController.class);<span class="comment">//是否是代理对象；</span></span><br><span class="line">        <span class="keyword">boolean</span> isCglib = </span><br><span class="line">          AopUtils.isCglibProxy(EmailController.class); <span class="comment">//是否是CGLIB方式的代理对象；</span></span><br><span class="line">        <span class="keyword">boolean</span> isJdk = </span><br><span class="line">          AopUtils.isJdkDynamicProxy(EmailController.class); <span class="comment">//是否是JDK动态代理方式的代理对象；</span></span><br><span class="line">        <span class="comment">//以下才是重点!!!</span></span><br><span class="line">        EmailService emailService = (EmailService)applicationContext.getBean(EmailService.class);</span><br><span class="line">        EmailService proxy = (EmailService) AopContext.currentProxy();</span><br><span class="line">        System.out.println(emailService == proxy ? <span class="keyword">true</span> : <span class="keyword">false</span>);</span><br><span class="line">        proxy.testSyncTask();</span><br><span class="line">        System.out.println(<span class="string">&quot;end!!!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="异步请求与异步调用的区别"><a href="#异步请求与异步调用的区别" class="headerlink" title="异步请求与异步调用的区别"></a><strong>异步请求与异步调用的区别</strong></h2><p>两者的使用场景不同，异步请求用来解决并发请求对服务器造成的压力，从而提高对请求的吞吐量；而异步调用是用来做一些非主线流程且不需要实时计算和响应的任务，比如同步日志到kafka中做日志分析等。</p><p>异步请求是会一直等待response相应的，需要返回结果给客户端的；而异步调用我们往往会马上返回给客户端响应，完成这次整个的请求，至于异步调用的任务后台自己慢慢跑就行，客户端不会关心。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://cnblogs.com/baixianlong/p/10661591.html">会炼钢的小白龙-SpringBoot中异步请求和异步调用（看这一篇就够了）</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Spring </tag>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis中用到的几种设计模式</title>
      <link href="post/26b455b4/"/>
      <url>post/26b455b4/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文转载自：<a href="http://www.crazyant.net/2022.html">http://www.crazyant.net/2022.html</a></p></blockquote><p>Mybatis至少遇到了以下的设计模式的使用：</p><ol><li><strong>Builder模式</strong>，例如<code>SqlSessionFactoryBuilder</code>、<code>XMLConfigBuilder</code>、<code>XMLMapperBuilder</code>、<code>XMLStatementBuilder</code>、<code>CacheBuilder</code>；</li><li><strong>工厂模式</strong>，例如<code>SqlSessionFactory</code>、<code>ObjectFactory</code>、<code>MapperProxyFactory</code>；</li><li><strong>单例模式</strong>，例如ErrorContext和<code>LogFactory</code>；</li><li><strong>代理模式</strong>，Mybatis实现的核心，比如<code>MapperProxy</code>、<code>ConnectionLogger</code>，用的jdk的动态代理；还有executor.loader包使用了cglib或者javassist达到延迟加载的效果；</li><li>组合模式，例如<code>SqlNode</code>和各个子类<code>ChooseSqlNode</code>等；</li><li><strong>模板方法模式</strong>，例如<code>BaseExecutor</code>和<code>SimpleExecutor</code>，还有<code>BaseTypeHandler</code>和所有的子类例如<code>IntegerTypeHandler</code>；</li><li><strong>适配器模式</strong>，例如Log的Mybatis接口和它对jdbc、log4j等各种日志框架的适配实现；</li><li><strong>装饰者模式</strong>，例如Cache包中的cache.decorators子包中等各个装饰者的实现；</li><li><strong>迭代器模式</strong>，例如迭代器模式<code>PropertyTokenizer</code>；</li></ol><p>接下来挨个模式进行解读，先介绍模式自身的知识，然后解读在Mybatis中怎样应用了该模式。</p><h2 id="Builder模式"><a href="#Builder模式" class="headerlink" title="Builder模式"></a>Builder模式</h2><p>Builder模式的定义是“将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示”，它属于创建类模式，一般来说，如果一个对象的构建比较复杂，超出了构造函数所能包含的范围，就可以使用工厂模式和Builder模式，相对于工厂模式会产出一个完整的产品，Builder应用于更加复杂的对象的构建，甚至只会构建产品的一个部分。</p><p><img src="https://cdn.jsdelivr.net/gh/cayzlh/git-img-repository@master/uPic/c32qrf.jpg" alt="Builder模式"></p><p>在Mybatis环境的初始化过程中，<code>SqlSessionFactoryBuilder</code>会调用<code>XMLConfigBuilder</code>读取所有的<code>MybatisMapConfig.xml</code>和所有的*Mapper.xml文件，构建Mybatis运行的核心对象Configuration对象，然后将该Configuration对象作为参数构建一个SqlSessionFactory对象。</p><p>其中<code>XMLConfigBuilder</code>在构建<code>Configuration</code>对象时，也会调用<code>XMLMapperBuilder</code>用于读取*Mapper文件，而<code>XMLMapperBuilder</code>会使用<code>XMLStatementBuilder</code>来读取和build所有的SQL语句。</p><p>在这个过程中，有一个相似的特点，就是这些Builder会读取文件或者配置，然后做大量的XpathParser解析、配置或语法的解析、反射生成对象、存入结果缓存等步骤，这么多的工作都不是一个构造函数所能包括的，因此大量采用了Builder模式来解决。</p><p>对于builder的具体类，方法都大都用build*开头，比如<code>SqlSessionFactoryBuilder</code>为例，它包含以下方法：</p><p><img src="https://cdn.jsdelivr.net/gh/cayzlh/git-img-repository@master/uPic/KAGdgM.jpg" alt="SqlSessionFactoryBuilder"></p><p>即根据不同的输入参数来构建<code>SqlSessionFactory</code>这个工厂对象。</p><h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><p>在Mybatis中比如<code>SqlSessionFactory</code>使用的是工厂模式，该工厂没有那么复杂的逻辑，是一个简单工厂模式。</p><p>简单工厂模式(Simple Factory Pattern)：又称为静态工厂方法(Static Factory Method)模式，它属于类创建型模式。在简单工厂模式中，可以根据参数的不同返回不同类的实例。简单工厂模式专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。</p><p><img src="https://cdn.jsdelivr.net/gh/cayzlh/git-img-repository@master/uPic/Z3PDMk.jpg" alt="简单工厂模式"></p><p>SqlSession可以认为是一个Mybatis工作的核心的接口，通过这个接口可以执行执行SQL语句、获取Mappers、管理事务。类似于连接MySQL的Connection对象。</p><p><img src="https://cdn.jsdelivr.net/gh/cayzlh/git-img-repository@master/uPic/70L93B.jpg" alt="70L93B"></p><p>可以看到，该Factory的openSession方法重载了很多个，分别支持autoCommit、Executor、Transaction等参数的输入，来构建核心的SqlSession对象。</p><p>在DefaultSqlSessionFactory的默认工厂实现里，有一个方法可以看出工厂怎么产出一个产品：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> SqlSession <span class="title">openSessionFromDataSource</span><span class="params">(ExecutorType execType,</span></span></span><br><span class="line"><span class="function"><span class="params">                                             TransactionIsolationLevel level,</span></span></span><br><span class="line"><span class="function"><span class="params">                                             <span class="keyword">boolean</span> autoCommit)</span> </span>&#123;</span><br><span class="line">Transaction tx = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">final</span> Environment environment = configuration.getEnvironment();</span><br><span class="line"><span class="keyword">final</span> TransactionFactory transactionFactory = </span><br><span class="line">        getTransactionFactoryFromEnvironment(environment);</span><br><span class="line">tx = </span><br><span class="line">        transactionFactory.newTransaction(environment.getDataSource(), </span><br><span class="line">                                          level, autoCommit);</span><br><span class="line"><span class="keyword">final</span> Executor executor = configuration.newExecutor(tx, execType);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> DefaultSqlSession(configuration, executor, autoCommit);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">closeTransaction(tx); <span class="comment">// may have fetched a connection so lets call</span></span><br><span class="line"><span class="comment">// close()</span></span><br><span class="line"><span class="keyword">throw</span> ExceptionFactory.wrapException(<span class="string">&quot;Error opening session.  Cause: &quot;</span> + e, e);</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">ErrorContext.instance().reset();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一个openSession调用的底层方法，该方法先从configuration读取对应的环境配置，然后初始化<code>TransactionFactory</code>获得一个<code>Transaction</code>对象，然后通过<code>Transaction</code>获取一个<code>Executor</code>对象，最后通过configuration、Executor、是否autoCommit三个参数构建了<code>SqlSession</code>。</p><p>在这里其实也可以看到端倪，<code>SqlSession</code>的执行，其实是委托给对应的<code>Executor</code>来进行的。</p><p>而对于<code>LogFactory</code>，它的实现代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">LogFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Constructor&lt;? extends Log&gt; logConstructor;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LogFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// disable construction</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Log <span class="title">getLog</span><span class="params">(Class&lt;?&gt; aClass)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getLog(aClass.getName());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这里有个特别的地方，是Log变量的的类型是<code>Constructor</code>，也就是说该工厂生产的不只是一个产品，而是具有Log公共接口的一系列产品，比如<code>Log4jImpl</code>、<code>Slf4jImpl</code>等很多具体的Log。</p><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>单例模式(Singleton Pattern)：单例模式确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例，这个类称为单例类，它提供全局访问的方法。</p><p>单例模式的要点有三个：一是某个类只能有一个实例；二是它必须自行创建这个实例；三是它必须自行向整个系统提供这个实例。单例模式是一种对象创建型模式。单例模式又名单件模式或单态模式。</p><p><img src="https://cdn.jsdelivr.net/gh/cayzlh/git-img-repository@master/uPic/tHOgLF.jpg" alt="tHOgLF"></p><p>在Mybatis中有两个地方用到单例模式，<code>ErrorContext</code>和<code>LogFactory</code>，其中<code>ErrorContext</code>是用在每个线程范围内的单例，用于记录该线程的执行环境错误信息，而<code>LogFactory</code>则是提供给整个Mybatis使用的日志工厂，用于获得针对项目配置好的日志对象。</p><p><code>ErrorContext</code>的单例实现代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ErrorContext</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;ErrorContext&gt; LOCAL = <span class="keyword">new</span> ThreadLocal&lt;ErrorContext&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ErrorContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ErrorContext <span class="title">instance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ErrorContext context = LOCAL.get();</span><br><span class="line">        <span class="keyword">if</span> (context == <span class="keyword">null</span>) &#123;</span><br><span class="line">            context = <span class="keyword">new</span> ErrorContext();</span><br><span class="line">            LOCAL.set(context);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> context;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>构造函数是private修饰，具有一个static的局部instance变量和一个获取instance变量的方法，在获取实例的方法中，先判断是否为空如果是的话就先创建，然后返回构造好的对象。</p><p>只是这里有个有趣的地方是，LOCAL的静态实例变量使用了<code>ThreadLocal</code>修饰，也就是说它属于每个线程各自的数据，而在<code>instance()</code>方法中，先获取本线程的该实例，如果没有就创建该线程独有的<code>ErrorContext</code>。</p><h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><p>代理模式可以认为是Mybatis的核心使用的模式，正是由于这个模式，我们只需要编写<code>Mapper.java</code>接口，不需要实现，由Mybatis后台帮我们完成具体SQL的执行。</p><p>代理模式(Proxy Pattern) ：给某一个对象提供一个代 理，并由代理对象控制对原对象的引用。代理模式的英 文叫做Proxy或Surrogate，它是一种对象结构型模式。</p><p>代理模式包含如下角色：</p><ul><li>Subject: 抽象主题角色</li><li>Proxy: 代理主题角色</li><li>RealSubject: 真实主题角色</li></ul><p><img src="https://cdn.jsdelivr.net/gh/cayzlh/git-img-repository@master/uPic/57qXzr.jpg" alt="57qXzr"></p><p>这里有两个步骤，第一个是提前创建一个Proxy，第二个是使用的时候会自动请求Proxy，然后由Proxy来执行具体事务；</p><p>当我们使用<code>Configuration</code>的<code>getMapper</code>方法时，会调用<code>mapperRegistry.getMapper</code>方法，而该方法又会调用<code>mapperProxyFactory.newInstance(sqlSession)</code>来生成一个具体的代理：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> mapperInterface;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;Method, MapperMethod&gt; <span class="title">getMethodCache</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> methodCache;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> T <span class="title">newInstance</span><span class="params">(MapperProxy&lt;T&gt; mapperProxy)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (T) Proxy.newProxyInstance(mapperInterface.getClassLoader(), </span><br><span class="line">                                          <span class="keyword">new</span> Class[] &#123; mapperInterface &#125;,</span><br><span class="line">                mapperProxy);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">newInstance</span><span class="params">(SqlSession sqlSession)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> MapperProxy&lt;T&gt; mapperProxy = <span class="keyword">new</span> MapperProxy&lt;T&gt;(sqlSession, </span><br><span class="line">                                                              mapperInterface, methodCache);</span><br><span class="line">        <span class="keyword">return</span> newInstance(mapperProxy);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里，先通过<code>T newInstance(SqlSession sqlSession)</code>方法会得到一个<code>MapperProxy</code>对象，然后调用<code>T newInstance(MapperProxy mapperProxy)</code>生成代理对象然后返回。</p><p>而查看<code>MapperProxy</code>的代码，可以看到如下内容：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapperProxy</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">InvocationHandler</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (Object.class.equals(method.getDeclaringClass())) &#123;</span><br><span class="line">                <span class="keyword">return</span> method.invoke(<span class="keyword">this</span>, args);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isDefaultMethod(method)) &#123;</span><br><span class="line">                <span class="keyword">return</span> invokeDefaultMethod(proxy, method, args);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            <span class="keyword">throw</span> ExceptionUtil.unwrapThrowable(t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> MapperMethod mapperMethod = cachedMapperMethod(method);</span><br><span class="line">        <span class="keyword">return</span> mapperMethod.execute(sqlSession, args);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>非常典型的，该<code>MapperProxy</code>类实现了<code>InvocationHandler</code>接口，并且实现了该接口的<code>invoke</code>方法。</p><p>通过这种方式，我们只需要编写<code>Mapper.java</code>接口类，当真正执行一个<code>Mapper</code>接口的时候，就会转发给<code>MapperProxy.invoke</code>方法，而该方法则会调用后续的<code>sqlSession.cud&gt;executor.execute&gt;prepareStatement</code>等一系列方法，完成SQL的执行和返回。</p><h2 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h2><p>组合模式组合多个对象形成树形结构以表示“整体-部分”的结构层次。</p><p>组合模式对单个对象(叶子对象)和组合对象(组合对象)具有一致性，它将对象组织到树结构中，可以用来描述整体与部分的关系。同时它也模糊了简单元素(叶子对象)和复杂元素(容器对象)的概念，使得客户能够像处理简单元素一样来处理复杂元素，从而使客户程序能够与复杂元素的内部结构解耦。</p><p>在使用组合模式中需要注意一点也是组合模式最关键的地方：叶子对象和组合对象实现相同的接口。这就是组合模式能够将叶子节点和对象节点进行一致处理的原因。</p><p><img src="https://cdn.jsdelivr.net/gh/cayzlh/git-img-repository@master/uPic/kEL5d7.jpg" alt="kEL5d7"></p><p>Mybatis支持动态SQL的强大功能，比如下面的这个SQL：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;update&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;org.format.dynamicproxy.mybatis.bean.User&quot;</span>&gt;</span></span><br><span class="line">    UPDATE users</span><br><span class="line">    <span class="tag">&lt;<span class="name">trim</span> <span class="attr">prefix</span>=<span class="string">&quot;SET&quot;</span> <span class="attr">prefixOverrides</span>=<span class="string">&quot;,&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;name != null and name != &#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">            name = #&#123;name&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;age != null and age != &#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">            , age = #&#123;age&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;birthday != null and birthday != &#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">            , birthday = #&#123;birthday&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">trim</span>&gt;</span></span><br><span class="line">    where id = $&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在这里面使用到了trim、if等动态元素，可以根据条件来生成不同情况下的SQL；</p><p>在<code>DynamicSqlSource.getBoundSql</code>方法里，调用了<code>rootSqlNode.apply(context)</code>方法，<code>apply</code>方法是所有的动态节点都实现的接口：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SqlNode</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">apply</span><span class="params">(DynamicContext context)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于实现该<code>SqlSource</code>接口的所有节点，就是整个组合模式树的各个节点：</p><p><img src="https://cdn.jsdelivr.net/gh/cayzlh/git-img-repository@master/uPic/4eSz9o.jpg" alt="4eSz9o"></p><p>组合模式的简单之处在于，所有的子节点都是同一类节点，可以递归的向下执行，比如对于TextSqlNode，因为它是最底层的叶子节点，所以直接将对应的内容append到SQL语句中：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">apply</span><span class="params">(DynamicContext context)</span> </span>&#123;</span><br><span class="line">  GenericTokenParser parser = createParser(<span class="keyword">new</span> BindingTokenParser(context,</span><br><span class="line">                                                                  injectionFilter));</span><br><span class="line">  context.appendSql(parser.parse(text));</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是对于IfSqlNode，就需要先做判断，如果判断通过，仍然会调用子元素的SqlNode，即<code>contents.apply</code>方法，实现递归的解析。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">apply</span><span class="params">(DynamicContext context)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (evaluator.evaluateBoolean(test, context.getBindings())) &#123;</span><br><span class="line">        contents.apply(context);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h2><p>模板方法模式是所有模式中最为常见的几个模式之一，是基于继承的代码复用的基本技术。</p><p>模板方法模式需要开发抽象类和具体子类的设计师之间的协作。一个设计师负责给出一个算法的轮廓和骨架，另一些设计师则负责给出这个算法的各个逻辑步骤。代表这些具体逻辑步骤的方法称做基本方法(primitive method)；而将这些基本方法汇总起来的方法叫做模板方法(template method)，这个设计模式的名字就是从此而来。</p><p>模板类定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。</p><p><img src="https://cdn.jsdelivr.net/gh/cayzlh/git-img-repository@master/uPic/mPNlOa.jpg" alt="mPNlOa"></p><p>在Mybatis中，sqlSession的SQL执行，都是委托给Executor实现的，Executor包含以下结构：</p><p><img src="https://cdn.jsdelivr.net/gh/cayzlh/git-img-repository@master/uPic/dq9xXH.jpg" alt="dq9xXH"></p><p>其中的BaseExecutor就采用了模板方法模式，它实现了大部分的SQL执行逻辑，然后把以下几个方法交给子类定制化完成：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">apply</span><span class="params">(DynamicContext context)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (evaluator.evaluateBoolean(test, context.getBindings())) &#123;</span><br><span class="line">     contents.apply(context);</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>该模板方法类有几个子类的具体实现，使用了不同的策略：</p><ul><li>简单<code>SimpleExecutor</code>：每执行一次<code>update</code>或<code>select</code>，就开启一个<code>Statement</code>对象，用完立刻关闭<code>Statement</code>对象。（可以是<code>Statement</code>或<code>PrepareStatement</code>对象）</li><li>重用<code>ReuseExecutor</code>：执行<code>update</code>或<code>select</code>，以sql作为key查找<code>Statement</code>对象，存在就使用，不存在就创建，用完后，不关闭<code>Statement</code>对象，而是放置于<code>Map</code>内，供下一次使用。（可以是<code>Statement</code>或<code>PrepareStatement</code>对象）</li><li>批量<code>BatchExecutor</code>：执行update（没有select，JDBC批处理不支持select），将所有sql都添加到批处理中（<code>addBatch()</code>），等待统一执行（<code>executeBatch()</code>），它缓存了多个Statement对象，每个Statement对象都是<code>addBatch()</code>完毕后，等待逐一执行<code>executeBatch()</code>批处理的；<code>BatchExecutor</code>相当于维护了多个桶，每个桶里都装了很多属于自己的SQL，就像苹果蓝里装了很多苹果，番茄蓝里装了很多番茄，最后，再统一倒进仓库。（可以是Statement或PrepareStatement对象）</li></ul><p>比如在SimpleExecutor中这样实现update方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">doUpdate</span><span class="params">(MappedStatement ms, Object parameter)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    Statement stmt = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Configuration configuration = ms.getConfiguration();</span><br><span class="line">        StatementHandler handler = configuration.newStatementHandler(<span class="keyword">this</span>, ms, parameter, RowBounds.DEFAULT, <span class="keyword">null</span>,</span><br><span class="line">                <span class="keyword">null</span>);</span><br><span class="line">        stmt = prepareStatement(handler, ms.getStatementLog());</span><br><span class="line">        <span class="keyword">return</span> handler.update(stmt);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        closeStatement(stmt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><p>适配器模式(Adapter Pattern) ：将一个接口转换成客户希望的另一个接口，适配器模式使接口不兼容的那些类可以一起工作，其别名为包装器(Wrapper)。适配器模式既可以作为类结构型模式，也可以作为对象结构型模式。</p><p><img src="https://cdn.jsdelivr.net/gh/cayzlh/git-img-repository@master/uPic/rkEM6Y.jpg" alt="rkEM6Y"></p><p>在Mybatsi的logging包中，有一个Log接口：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Log</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isDebugEnabled</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isTraceEnabled</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">error</span><span class="params">(String s, Throwable e)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">error</span><span class="params">(String s)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">debug</span><span class="params">(String s)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">trace</span><span class="params">(String s)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">warn</span><span class="params">(String s)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该接口定义了Mybatis直接使用的日志方法，而Log接口具体由谁来实现呢？Mybatis提供了多种日志框架的实现，这些实现都匹配这个Log接口所定义的接口方法，最终实现了所有外部日志框架到Mybatis日志包的适配：</p><p><img src="https://cdn.jsdelivr.net/gh/cayzlh/git-img-repository@master/uPic/uVGQZ0.jpg" alt="uVGQZ0"></p><p>比如对于<code>Log4jImpl</code>的实现来说，该实现持有了<code>org.apache.log4j.Logger</code>的实例，然后所有的日志方法，均委托该实例来实现。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Log4jImpl</span> <span class="keyword">implements</span> <span class="title">Log</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String FQCN = Log4jImpl.class.getName();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Logger log;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Log4jImpl</span><span class="params">(String clazz)</span> </span>&#123;</span><br><span class="line">        log = Logger.getLogger(clazz);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isDebugEnabled</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> log.isDebugEnabled();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isTraceEnabled</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> log.isTraceEnabled();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">error</span><span class="params">(String s, Throwable e)</span> </span>&#123;</span><br><span class="line">        log.log(FQCN, Level.ERROR, s, e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">error</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        log.log(FQCN, Level.ERROR, s, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">debug</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        log.log(FQCN, Level.DEBUG, s, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">trace</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        log.log(FQCN, Level.TRACE, s, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">warn</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        log.log(FQCN, Level.WARN, s, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h2><p>装饰模式(Decorator Pattern) ：动态地给一个对象增加一些额外的职责(Responsibility)，就增加对象功能来说，装饰模式比生成子类实现更为灵活。其别名也可以称为包装器(Wrapper)，与适配器模式的别名相同，但它们适用于不同的场合。根据翻译的不同，装饰模式也有人称之为“油漆工模式”，它是一种对象结构型模式。</p><p><img src="https://cdn.jsdelivr.net/gh/cayzlh/git-img-repository@master/uPic/BdaHcM.jpg" alt="BdaHcM"></p><p>在mybatis中，缓存的功能由根接口<code>Cache（org.apache.ibatis.cache.Cache）</code>定义。整个体系采用装饰器设计模式，数据存储和缓存的基本功能由<code>PerpetualCache（org.apache.ibatis.cache.impl.PerpetualCache）</code>永久缓存实现，然后通过一系列的装饰器来对<code>PerpetualCache</code>永久缓存进行缓存策略等方便的控制。如下图：</p><p>用于装饰PerpetualCache的标准装饰器共有8个（全部在org.apache.ibatis.cache.decorators包中）：</p><ol><li><code>FifoCache</code>：先进先出算法，缓存回收策略</li><li><code>LoggingCache</code>：输出缓存命中的日志信息</li><li><code>LruCache</code>：最近最少使用算法，缓存回收策略</li><li><code>ScheduledCache</code>：调度缓存，负责定时清空缓存</li><li><code>SerializedCache</code>：缓存序列化和反序列化存储</li><li><code>SoftCache</code>：基于软引用实现的缓存管理策略</li><li><code>SynchronizedCache</code>：同步的缓存装饰器，用于防止多线程并发访问</li><li><code>WeakCache</code>：基于弱引用实现的缓存管理策略</li></ol><p>另外，还有一个特殊的装饰器<code>TransactionalCache</code>：事务性的缓存正如大多数持久层框架一样，mybatis缓存同样分为一级缓存和二级缓存</p><ul><li>一级缓存，又叫本地缓存，是<code>PerpetualCache</code>类型的永久缓存，保存在执行器中（<code>BaseExecutor</code>），而执行器又在<code>SqlSession</code>（<code>DefaultSqlSession</code>）中，所以一级缓存的生命周期与<code>SqlSession</code>是相同的。</li><li>二级缓存，又叫自定义缓存，实现了<code>Cache</code>接口的类都可以作为二级缓存，所以可配置如encache等的第三方缓存。二级缓存以namespace名称空间为其唯一标识，被保存在<code>Configuration</code>核心配置对象中。</li></ul><p>二级缓存对象的默认类型为PerpetualCache，如果配置的缓存是默认类型，则mybatis会根据配置自动追加一系列装饰器。</p><p>Cache对象之间的引用顺序为：</p><p><code>SynchronizedCache</code>–&gt;<code>LoggingCache</code>–&gt;<code>SerializedCache</code>–&gt;<code>ScheduledCache</code>–&gt;<code>LruCache</code>–&gt;<code>PerpetualCache</code></p><h2 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h2><p>迭代器（Iterator）模式，又叫做游标（Cursor）模式。GOF给出的定义为：提供一种方法访问一个容器（container）对象中各个元素，而又不需暴露该对象的内部细节。</p><p><img src="https://cdn.jsdelivr.net/gh/cayzlh/git-img-repository@master/uPic/49UcwT.jpg" alt="49UcwT"></p><p>Java的<code>Iterator</code>就是迭代器模式的接口，只要实现了该接口，就相当于应用了迭代器模式：</p><p><img src="https://cdn.jsdelivr.net/gh/cayzlh/git-img-repository@master/uPic/dsNpxb.jpg" alt="dsNpxb"></p><p>比如Mybatis的<code>PropertyTokenizer</code>是property包中的重量级类，该类会被reflection包中其他的类频繁的引用到。这个类实现了<code>Iterator</code>接口，在使用时经常被用到的是<code>Iterator</code>接口中的<code>hasNext</code>这个函数。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PropertyTokenizer</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">PropertyTokenizer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String indexedName;</span><br><span class="line">    <span class="keyword">private</span> String index;</span><br><span class="line">    <span class="keyword">private</span> String children;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PropertyTokenizer</span><span class="params">(String fullname)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> delim = fullname.indexOf(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span> (delim &gt; -<span class="number">1</span>) &#123;</span><br><span class="line">            name = fullname.substring(<span class="number">0</span>, delim);</span><br><span class="line">            children = fullname.substring(delim + <span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            name = fullname;</span><br><span class="line">            children = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        indexedName = name;</span><br><span class="line">        delim = name.indexOf(<span class="string">&#x27;[&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span> (delim &gt; -<span class="number">1</span>) &#123;</span><br><span class="line">            index = name.substring(delim + <span class="number">1</span>, name.length() - <span class="number">1</span>);</span><br><span class="line">            name = name.substring(<span class="number">0</span>, delim);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getIndexedName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> indexedName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getChildren</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> children;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> children != <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PropertyTokenizer <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PropertyTokenizer(children);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(</span><br><span class="line">                <span class="string">&quot;Remove is not supported, as it has no meaning in the context of properties.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，这个类传入一个字符串到构造函数，然后提供了iterator方法对解析后的子串进行遍历，是一个很常用的方法类。</p><p><strong>参考资料</strong></p><ul><li><a href="http://design-patterns.readthedocs.io/zh_CN/latest/index.html">图说设计模式</a></li><li><a href="http://www.cnblogs.com/dongying/p/4142476.html">深入浅出Mybatis系列（十）—SQL执行流程分析（源码篇）</a></li><li><a href="http://www.cnblogs.com/chenssy/p/3299719.html">设计模式读书笔记—–组合模式</a></li><li><a href="http://blog.csdn.net/wagcy/article/details/32963235">Mybatis3.3.x技术内幕（四）：五鼠闹东京之执行器Executor设计原本</a></li><li><a href="https://my.oschina.net/lixin91/blog/620068">mybatis缓存机制详解（一）——Cache</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 转载 </tag>
            
            <tag> MyBatis </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java8 的日期处理实践</title>
      <link href="post/3629577035/"/>
      <url>post/3629577035/</url>
      
        <content type="html"><![CDATA[<blockquote><p>出处：<a href="https://juejin.im/post/5a795bad6fb9a0634f407ae5">JavaSE基础:扩展Java 8 日期操作</a></p></blockquote><h2 id="示例1：-获取当天日期"><a href="#示例1：-获取当天日期" class="headerlink" title="示例1： 获取当天日期"></a>示例1： 获取当天日期</h2><p>Java 8中获取今天的日期 Java 8中的 LocalDate 用于表示当天日期。和java.util.Date不同，它只有日期，不包含时间。当你仅需要表示日期时就用这个类。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    LocalDate today = LocalDate.now();</span><br><span class="line">    System.out.println(<span class="string">&quot;今天的日期:&quot;</span> + today);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;<span class="comment">/*运行结果:今天的日期:2018-02-05*/</span></span><br></pre></td></tr></table></figure><h2 id="示例2：获取年、月、日"><a href="#示例2：获取年、月、日" class="headerlink" title="示例2：获取年、月、日"></a>示例2：获取年、月、日</h2><p>Java 8中获取年、月、日信息</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo02</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    LocalDate today = LocalDate.now();</span><br><span class="line">    <span class="keyword">int</span> year = today.getYear();</span><br><span class="line">    <span class="keyword">int</span> month = today.getMonthValue();</span><br><span class="line">    <span class="keyword">int</span> day = today.getDayOfMonth();</span><br><span class="line">    System.out.println(<span class="string">&quot;year:&quot;</span> + year);</span><br><span class="line">    System.out.println(<span class="string">&quot;month:&quot;</span> + month);</span><br><span class="line">    System.out.println(<span class="string">&quot;day:&quot;</span> + day);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="示例3：创建任意日期"><a href="#示例3：创建任意日期" class="headerlink" title="示例3：创建任意日期"></a>示例3：创建任意日期</h2><p>Java 8中处理特定日期 我们通过静态工厂方法now()非常容易地创建了当天日期，你还可以调用另一个有用的工厂方法LocalDate.of()创建任意日期， 该方法需要传入年、月、日做参数，返回对应的LocalDate实例。这个方法的好处是没再犯老API的设计错误，比如年度起始于1900，月份是从0开 始等等。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo03</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    LocalDate date = LocalDate.of(<span class="number">2018</span>, <span class="number">2</span>, <span class="number">6</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;自定义日期:&quot;</span> + date);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="示例4：判断日期是否相等"><a href="#示例4：判断日期是否相等" class="headerlink" title="示例4：判断日期是否相等"></a>示例4：判断日期是否相等</h2><p>Java 8中判断两个日期是否相等</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo04</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    LocalDate date1 = LocalDate.now();</span><br><span class="line">    LocalDate date2 = LocalDate.of(<span class="number">2018</span>, <span class="number">2</span>, <span class="number">5</span>);</span><br><span class="line">    <span class="keyword">if</span> (date1.equals(date2)) &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;时间相等&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;时间不等&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="示例5：周期性事件（生日）"><a href="#示例5：周期性事件（生日）" class="headerlink" title="示例5：周期性事件（生日）"></a>示例5：周期性事件（生日）</h2><p>Java 8中检查像生日这种周期性事件</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo05</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    LocalDate date1 = LocalDate.now();</span><br><span class="line">    LocalDate date2 = LocalDate.of(<span class="number">2018</span>, <span class="number">2</span>, <span class="number">6</span>);</span><br><span class="line">    MonthDay birthday = MonthDay.of(date2.getMonth(), date2.getDayOfMonth());</span><br><span class="line">    MonthDay currentMonthDay = MonthDay.from(date1);</span><br><span class="line">    <span class="keyword">if</span> (currentMonthDay.equals(birthday)) &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;是你的生日&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;你的生日还没有到&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只要当天的日期和生日匹配，无论是哪一年都会打印出祝贺信息。你可以把程序整合进系统时钟，看看生日时是否会受到提醒，或者写一个单元测试来检测代码是否运行正确。</p><h2 id="示例6：获取当前时间"><a href="#示例6：获取当前时间" class="headerlink" title="示例6：获取当前时间"></a>示例6：获取当前时间</h2><p>Java 8中获取当前时间</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo06</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    LocalTime time = LocalTime.now();</span><br><span class="line">    System.out.println(<span class="string">&quot;获取当前的时间,不含有日期:&quot;</span> + time);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到当前时间就只包含时间信息，没有日期</p><h2 id="示例7：计算3小时以后的时间"><a href="#示例7：计算3小时以后的时间" class="headerlink" title="示例7：计算3小时以后的时间"></a>示例7：计算3小时以后的时间</h2><p>Java 8中获取当前时间 通过增加小时、分、秒来计算将来的时间很常见。Java 8除了不变类型和线程安全的好处之外，还提供了更好的plusHours()方法替换add()，并且是兼容的。注意，这些方法返回一个全新的LocalTime实例，由于其不可变性，返回后一定要用变量赋值。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo07</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    LocalTime time = LocalTime.now();</span><br><span class="line">    LocalTime newTime = time.plusHours(<span class="number">3</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;三个小时后的时间为:&quot;</span> + newTime);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="示例8：计算一周后的日期"><a href="#示例8：计算一周后的日期" class="headerlink" title="示例8：计算一周后的日期"></a>示例8：计算一周后的日期</h2><p>Java 8如何计算一周后的日期 和上个例子计算3小时以后的时间类似，这个例子会计算一周后的日期。LocalDate日期不包含时间信息，它的plus()方法用来增加天、周、月，ChronoUnit类声明了这些时间单位。由于LocalDate也是不变类型，返回后一定要用变量赋值。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo08</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    LocalDate today = LocalDate.now();</span><br><span class="line">    System.out.println(<span class="string">&quot;今天的日期为:&quot;</span> + today);</span><br><span class="line">    LocalDate nextWeek = today.plus(<span class="number">1</span>, ChronoUnit.WEEKS);</span><br><span class="line">    System.out.println(<span class="string">&quot;一周后的日期为:&quot;</span> + nextWeek);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到新日期离当天日期是7天，也就是一周。你可以用同样的方法增加1个月、1年、1小时、1分钟甚至一个世纪，更多选项可以查看Java 8 API中的ChronoUnit类</p><h2 id="示例9：计算一年前的日期"><a href="#示例9：计算一年前的日期" class="headerlink" title="示例9：计算一年前的日期"></a>示例9：计算一年前的日期</h2><p>Java 8计算一年前或一年后的日期 利用minus()方法计算一年前的日期</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo09</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    LocalDate today = LocalDate.now();</span><br><span class="line">    LocalDate previousYear = today.minus(<span class="number">1</span>, ChronoUnit.YEARS);</span><br><span class="line">    System.out.println(<span class="string">&quot;一年前的日期 : &quot;</span> + previousYear);</span><br><span class="line">    LocalDate nextYear = today.plus(<span class="number">1</span>, ChronoUnit.YEARS);</span><br><span class="line">    System.out.println(<span class="string">&quot;一年后的日期:&quot;</span> + nextYear);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="示例10：时间戳"><a href="#示例10：时间戳" class="headerlink" title="示例10：时间戳"></a>示例10：时间戳</h2><p>Java 8的Clock时钟类 Java 8增加了一个Clock时钟类用于获取当时的时间戳，或当前时区下的日期时间信息。以前用到System.currentTimeInMillis()和TimeZone.getDefault()的地方都可用Clock替换。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo10</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    String[] args)</span> </span>&#123;        </span><br><span class="line">    <span class="comment">// Returns the current time based on your system clock and set to UTC.        </span></span><br><span class="line">    Clock clock = Clock.systemUTC();        </span><br><span class="line">    System.out.println(<span class="string">&quot;Clock : &quot;</span> + clock.millis());</span><br><span class="line">    <span class="comment">// Returns time based on system clock zone        </span></span><br><span class="line">    Clock defaultClock = Clock.systemDefaultZone();        </span><br><span class="line">    System.out.println(<span class="string">&quot;Clock : &quot;</span> + defaultClock.millis());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="示例11：判断日期的前后"><a href="#示例11：判断日期的前后" class="headerlink" title="示例11：判断日期的前后"></a>示例11：判断日期的前后</h2><p>如何用Java判断日期是早于还是晚于另一个日期 另一个工作中常见的操作就是如何判断给定的一个日期是大于某天还是小于某天？在Java 8中，LocalDate类有两类方法isBefore()和isAfter()用于比较日期。调用isBefore()方法时，如果给定日期小于当前日期则返回true。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo11</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    LocalDate today = LocalDate.now();</span><br><span class="line">    LocalDate tomorrow = LocalDate.of(<span class="number">2018</span>, <span class="number">2</span>, <span class="number">6</span>);</span><br><span class="line">    <span class="keyword">if</span> (tomorrow.isAfter(today)) &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;之后的日期:&quot;</span> + tomorrow);</span><br><span class="line">    &#125;</span><br><span class="line">    LocalDate yesterday = today.minus(<span class="number">1</span>, ChronoUnit.DAYS);</span><br><span class="line">    <span class="keyword">if</span> (yesterday.isBefore(today)) &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;之前的日期:&quot;</span> + yesterday);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="示例12：时区分离"><a href="#示例12：时区分离" class="headerlink" title="示例12：时区分离"></a>示例12：时区分离</h2><p>Java 8中处理时区 Java 8不仅分离了日期和时间，也把时区分离出来了。现在有一系列单独的类如ZoneId来处理特定时区，ZoneDateTime类来表示某时区下的时间。这在Java 8以前都是 GregorianCalendar类来做的。下面这个例子展示了如何把本时区的时间转换成另一个时区的时间。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo12</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;        </span><br><span class="line">    <span class="comment">// Date and time with timezone in Java 8        </span></span><br><span class="line">    ZoneId america = ZoneId.of(<span class="string">&quot;America/New_York&quot;</span>);        </span><br><span class="line">    LocalDateTime localtDateAndTime = LocalDateTime.now();        </span><br><span class="line">    ZonedDateTime dateAndTimeInNewYork  = </span><br><span class="line">      ZonedDateTime.of(localtDateAndTime, america );        </span><br><span class="line">    System.out.println(<span class="string">&quot;Current date and time in a particular timezone : &quot;</span> </span><br><span class="line">                       + dateAndTimeInNewYork);    </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="示例13：固定日期"><a href="#示例13：固定日期" class="headerlink" title="示例13：固定日期"></a>示例13：固定日期</h2><p>如何表示信用卡到期这类固定日期，答案就在YearMonth 与 MonthDay检查重复事件的例子相似，YearMonth是另一个组合类，用于表示信用卡到期日、FD到期日、期货期权到期日等。还可以用这个类得到 当月共有多少天，YearMonth实例的lengthOfMonth()方法可以返回当月的天数，在判断2月有28天还是29天时非常有用。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo13</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    YearMonth currentYearMonth = YearMonth.now();</span><br><span class="line">    System.out.printf(<span class="string">&quot;Days in month year %s: %d%n&quot;</span>, currentYearMonth,</span><br><span class="line">                      currentYearMonth.lengthOfMonth());</span><br><span class="line">    YearMonth creditCardExpiry = YearMonth.of(<span class="number">2019</span>, Month.FEBRUARY);</span><br><span class="line">    System.out.printf(<span class="string">&quot;Your credit card expires on %s %n&quot;</span>, creditCardExpiry);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="示例14：检查闰年"><a href="#示例14：检查闰年" class="headerlink" title="示例14：检查闰年"></a>示例14：检查闰年</h2><p>如何在Java 8中检查闰年</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo14</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    LocalDate today = LocalDate.now();</span><br><span class="line">    <span class="keyword">if</span> (today.isLeapYear()) &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;This year is Leap year&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;2018 is not a Leap year&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="示例15：计算日期之间的天数"><a href="#示例15：计算日期之间的天数" class="headerlink" title="示例15：计算日期之间的天数"></a>示例15：计算日期之间的天数</h2><p>计算两个日期之间的天数和月数 有一个常见日期操作是计算两个日期之间的天数、周数或月数。在Java 8中可以用java.time.Period类来做计算。下面这个例子中，我们计算了当天和将来某一天之间的月数。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo15</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    LocalDate today = LocalDate.now();</span><br><span class="line">    LocalDate java8Release = LocalDate.of(<span class="number">2018</span>, <span class="number">12</span>, <span class="number">14</span>);</span><br><span class="line">    Period periodToNextJavaRelease = Period.between(today, java8Release);</span><br><span class="line">    System.out.println(</span><br><span class="line">      <span class="string">&quot;Months left between today and Java 8 release : &quot;</span> + </span><br><span class="line">      periodToNextJavaRelease.getMonths());</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="示例16：获取时间戳"><a href="#示例16：获取时间戳" class="headerlink" title="示例16：获取时间戳"></a>示例16：获取时间戳</h2><p>在Java 8中获取当前的时间戳 Instant类有一个静态工厂方法now()会返回当前的时间戳，如下所示：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo16</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Instant timestamp = Instant.now();</span><br><span class="line">    System.out.println(<span class="string">&quot;What is value of this instant &quot;</span> + timestamp.toEpochMilli());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间戳信息里同时包含了日期和时间，这和java.util.Date很像。实际上Instant类确实等同于 Java 8之前的Date类，你可以使用Date类和Instant类各自的转换方法互相转换，例如：Date.from(Instant) 将Instant转换成java.util.Date，Date.toInstant()则是将Date类转换成Instant类。</p><h2 id="示例17：格式化工具"><a href="#示例17：格式化工具" class="headerlink" title="示例17：格式化工具"></a>示例17：格式化工具</h2><p>:Java 8中如何使用预定义的格式化工具去解析或格式化日期</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo17</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    String dayAfterTommorrow = <span class="string">&quot;20180205&quot;</span>;</span><br><span class="line">    LocalDate formatted = LocalDate</span><br><span class="line">      .parse(dayAfterTommorrow, DateTimeFormatter.BASIC_ISO_DATE);</span><br><span class="line">    System.out.println(dayAfterTommorrow + <span class="string">&quot;  格式化后的日期为:  &quot;</span> + formatted);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="示例18：字符串互转"><a href="#示例18：字符串互转" class="headerlink" title="示例18：字符串互转"></a>示例18：字符串互转</h2><p>字符串互转日期类型</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo18</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    LocalDateTime date = LocalDateTime.now();</span><br><span class="line">    DateTimeFormatter format1 = DateTimeFormatter.ofPattern(</span><br><span class="line">      <span class="string">&quot;yyyy/MM/dd HH:mm:ss&quot;</span>);        <span class="comment">//日期转字符串        </span></span><br><span class="line">    String str = date.format(format1);</span><br><span class="line">    System.out.println(<span class="string">&quot;日期转换为字符串:&quot;</span> + str);</span><br><span class="line">    DateTimeFormatter format2 = DateTimeFormatter.ofPattern(</span><br><span class="line">      <span class="string">&quot;yyyy/MM/dd HH:mm:ss&quot;</span>);        <span class="comment">//字符串转日期        </span></span><br><span class="line">    LocalDate date2 = LocalDate.parse(str,format2);        </span><br><span class="line">    System.out.println(<span class="string">&quot;日期类型:&quot;</span>+date2);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 日期处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于Redis中的过期时间</title>
      <link href="post/3697040241/"/>
      <url>post/3697040241/</url>
      
        <content type="html"><![CDATA[<p>当使用Redis的时候，可以对Redis中的每个key设置一个过期时间，当到达过期时间的时候，这个key就会被自动删除。关于过期时间，还有一些可以关注的点。</p><h2 id="DEL-SET-GETSET等命令会清除过期时间"><a href="#DEL-SET-GETSET等命令会清除过期时间" class="headerlink" title="DEL/SET/GETSET等命令会清除过期时间"></a>DEL/SET/GETSET等命令会清除过期时间</h2><p>在使用DEL、SET、GETSET等会覆盖key对应value的命令操作一个设置了过期时间的key的时候，会导致对应的key的过期时间被清除。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//设置mykey的过期时间为300s</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> mykey hello ex 300</span><br><span class="line">OK</span><br><span class="line">//查看过期时间</span><br><span class="line">127.0.0.1:6379&gt; ttl mykey</span><br><span class="line">(<span class="built_in">integer</span>) 294</span><br><span class="line">//使用<span class="built_in">set</span>命令覆盖mykey的内容</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> mykey olleh</span><br><span class="line">OK</span><br><span class="line">//过期时间被清除</span><br><span class="line">127.0.0.1:6379&gt; ttl mykey</span><br><span class="line">(<span class="built_in">integer</span>) -1</span><br></pre></td></tr></table></figure><h2 id="INCR-LPUSH-HSET等命令不会清除过期时间"><a href="#INCR-LPUSH-HSET等命令不会清除过期时间" class="headerlink" title="INCR/LPUSH/HSET等命令不会清除过期时间"></a>INCR/LPUSH/HSET等命令不会清除过期时间</h2><p>而在使用INCR/LPUSH/HSET这种只是修改一个key的value，而不是覆盖整个value的命令，则不会清除key的过期时间。INCR：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//设置incr_key的过期时间为300s</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> incr_key 1 ex 300</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; ttl incr_key</span><br><span class="line">(<span class="built_in">integer</span>) 291</span><br><span class="line">//进行自增操作</span><br><span class="line">127.0.0.1:6379&gt; incr incr_key</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt; get incr_key</span><br><span class="line"><span class="string">&quot;2&quot;</span></span><br><span class="line">//查询过期时间，发现过期时间没有被清除</span><br><span class="line">127.0.0.1:6379&gt; ttl incr_key</span><br><span class="line">(<span class="built_in">integer</span>) 277</span><br></pre></td></tr></table></figure><p>LPUSH：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//新增一个list类型的key，并添加一个为1的值</span><br><span class="line">127.0.0.1:6379&gt; LPUSH list 1</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">//为list设置300s的过期时间</span><br><span class="line">127.0.0.1:6379&gt; expire list 300</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">//查看过期时间</span><br><span class="line">127.0.0.1:6379&gt; ttl list</span><br><span class="line">(<span class="built_in">integer</span>) 292</span><br><span class="line">//往list里面添加值2</span><br><span class="line">127.0.0.1:6379&gt; lpush list 2</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">//查看list的所有值</span><br><span class="line">127.0.0.1:6379&gt; lrange list 0 1</span><br><span class="line">1) <span class="string">&quot;2&quot;</span></span><br><span class="line">2) <span class="string">&quot;1&quot;</span></span><br><span class="line">//能看到往list里面添加值并没有使过期时间清除</span><br><span class="line">127.0.0.1:6379&gt; ttl list</span><br><span class="line">(<span class="built_in">integer</span>) 252</span><br></pre></td></tr></table></figure><h2 id="PERSIST命令会清除过期时间"><a href="#PERSIST命令会清除过期时间" class="headerlink" title="PERSIST命令会清除过期时间"></a>PERSIST命令会清除过期时间</h2><p>当使用PERSIST命令将一个设置了过期时间的key转变成一个持久化的key的时候，也会清除过期时间。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> persist_key haha ex 300</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; ttl persist_key</span><br><span class="line">(<span class="built_in">integer</span>) 296</span><br><span class="line">//将key变为持久化的</span><br><span class="line">127.0.0.1:6379&gt; persist persist_key</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">//过期时间被清除</span><br><span class="line">127.0.0.1:6379&gt; ttl persist_key</span><br><span class="line">(<span class="built_in">integer</span>) -1</span><br></pre></td></tr></table></figure><h2 id="使用RENAME命令，老key的过期时间将会转到新key上"><a href="#使用RENAME命令，老key的过期时间将会转到新key上" class="headerlink" title="使用RENAME命令，老key的过期时间将会转到新key上"></a>使用RENAME命令，老key的过期时间将会转到新key上</h2><p>在使用例如：RENAME KEY_A KEY_B命令将KEY_A重命名为KEY_B，不管KEY_B有没有设置过期时间，新的key KEY_B将会继承KEY_A的所有特性。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//设置key_a的过期时间为300s</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> key_a value_a ex 300</span><br><span class="line">OK</span><br><span class="line">//设置key_b的过期时间为600s</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> key_b value_b ex 600</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; ttl key_a</span><br><span class="line">(<span class="built_in">integer</span>) 279</span><br><span class="line">127.0.0.1:6379&gt; ttl key_b</span><br><span class="line">(<span class="built_in">integer</span>) 591</span><br><span class="line">//将key_a重命名为key_b</span><br><span class="line">127.0.0.1:6379&gt; rename key_a key_b</span><br><span class="line">OK</span><br><span class="line">//新的key_b继承了key_a的过期时间</span><br><span class="line">127.0.0.1:6379&gt; ttl key_b</span><br><span class="line">(<span class="built_in">integer</span>) 248</span><br></pre></td></tr></table></figure><h2 id="使用EXPIRE-PEXPIRE设置的过期时间为负数或者使用EXPIREAT-PEXPIREAT设置过期时间戳为过去的时间会导致key被删除"><a href="#使用EXPIRE-PEXPIRE设置的过期时间为负数或者使用EXPIREAT-PEXPIREAT设置过期时间戳为过去的时间会导致key被删除" class="headerlink" title="使用EXPIRE/PEXPIRE设置的过期时间为负数或者使用EXPIREAT/PEXPIREAT设置过期时间戳为过去的时间会导致key被删除"></a>使用EXPIRE/PEXPIRE设置的过期时间为负数或者使用EXPIREAT/PEXPIREAT设置过期时间戳为过去的时间会导致key被删除</h2><p>EXPIRE：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> key_1 value_1</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get key_1</span><br><span class="line"><span class="string">&quot;value_1&quot;</span></span><br><span class="line">//设置过期时间为-1</span><br><span class="line">127.0.0.1:6379&gt; expire key_1 -1</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">//发现key被删除</span><br><span class="line">127.0.0.1:6379&gt; get key_1</span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure><p>EXPIREAT：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> key_2 value_2</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get key_2</span><br><span class="line"><span class="string">&quot;value_2&quot;</span></span><br><span class="line">//设置的时间戳为过去的时间</span><br><span class="line">127.0.0.1:6379&gt; expireat key_2 10000</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">//key被删除</span><br><span class="line">127.0.0.1:6379&gt; get key_2</span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure><h2 id="EXPIRE命令可以更新过期时间"><a href="#EXPIRE命令可以更新过期时间" class="headerlink" title="EXPIRE命令可以更新过期时间"></a>EXPIRE命令可以更新过期时间</h2><p>对一个已经设置了过期时间的key使用expire命令，可以更新其过期时间。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//设置key_1的过期时间为100s</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> key_1 value_1 ex 100</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; ttl key_1</span><br><span class="line">(<span class="built_in">integer</span>) 95</span><br><span class="line">//更新key_1的过期时间为300s</span><br><span class="line">127.0.0.1:6379&gt; expire key_1 300</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; ttl key_1</span><br><span class="line">(<span class="built_in">integer</span>) 295</span><br></pre></td></tr></table></figure><h2 id="Redis的过期策略"><a href="#Redis的过期策略" class="headerlink" title="Redis的过期策略"></a>Redis的过期策略</h2><p>那你有没有想过一个问题，Redis里面如果有大量的key，怎样才能高效的找出过期的key并将其删除呢，难道是遍历每一个key吗？假如同一时期过期的key非常多，Redis会不会因为一直处理过期事件，而导致读写指令的卡顿。</p><blockquote><p>这里说明一下，Redis是单线程的，所以一些耗时的操作会导致Redis卡顿，比如当Redis数据量特别大的时候，使用keys * 命令列出所有的key。</p></blockquote><p>实际上Redis使用懒惰删除+定期删除相结合的方式处理过期的key。</p><h3 id="懒惰删除"><a href="#懒惰删除" class="headerlink" title="懒惰删除"></a>懒惰删除</h3><p>所谓懒惰删除就是在客户端访问该key的时候，redis会对key的过期时间进行检查，如果过期了就立即删除。<br>这种方式看似很完美，在访问的时候检查key的过期时间，不会占用太多的额外CPU资源。但是如果一个key已经过期了，如果长时间没有被访问，那么这个key就会一直存留在内存之中，严重消耗了内存资源。</p><h3 id="定期删除"><a href="#定期删除" class="headerlink" title="定期删除"></a>定期删除</h3><p>定期删除的原理是，Redis会将所有设置了过期时间的key放入一个字典中，然后每隔一段时间从字典中随机一些key检查过期时间并删除已过期的key。</p><p>Redis默认每秒进行10次过期扫描：</p><ol><li>从过期字典中随机20个key</li><li>删除这20个key中已过期的</li><li>如果超过25%的key过期，则重复第一步</li></ol><p>同时，为了保证不出现循环过度的情况，Redis还设置了扫描的时间上限，默认不会超过25ms。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记本 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>正确访问redis中的海量数据，避免事故产生</title>
      <link href="post/506775304/"/>
      <url>post/506775304/</url>
      
        <content type="html"><![CDATA[<h2 id="事故产生"><a href="#事故产生" class="headerlink" title="事故产生"></a>事故产生</h2><p>当我们使用<code>usertoken:userid</code>这样的格式的key来保存用户token值，这个时候想统计一下在线用户数量。</p><p>直接使用<code>keys usertoken*</code>方式进行查询，当用户数量巨大的时候，事故就产生了。导致redis不可用， 假死。</p><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>我们线上的登录用户有几百万，数据量比较多；keys算法是遍历算法，复杂度是O(n)，也就是数据越多，时间复杂度越高。</p><p>数据量达到几百万，keys这个指令就会导致 Redis 服务卡顿，因为 Redis 是单线程程序，顺序执行所有指令，其它指令必须等到当前的 keys 指令执行完了才可以继续。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>们可以采用redis的另一个命令scan。我们看一下scan的特点</p><ul><li>复杂度虽然也是 O(n)，但是它是通过游标分步进行的，不会阻塞线程</li><li>提供 count 参数，不是结果数量，是redis单次遍历字典槽位数量(约等于)</li><li>同 keys 一样，它也提供模式匹配功能;</li><li>服务器不需要为游标保存状态，游标的唯一状态就是 scan 返回给客户端的游标整数;</li><li>返回的结果可能会有重复，需要客户端去重复，这点非常重要;</li><li>单次返回的结果是空的并不意味着遍历结束，而要看返回的游标值是否为零</li></ul><h3 id="scan命令的格式"><a href="#scan命令的格式" class="headerlink" title="scan命令的格式"></a>scan命令的格式</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">SCAN cursor [MATCH pattern] [COUNT count]</span><br></pre></td></tr></table></figure><h3 id="命令解释"><a href="#命令解释" class="headerlink" title="命令解释"></a>命令解释</h3><p><strong>scan 游标 MATCH &lt;返回和给定模式相匹配的元素&gt; count 每次迭代所返回的元素数量</strong></p><ol><li><code>SCAN命令是增量的循环，每次调用只会返回一小部分的元素。所以不会让redis假死</code></li><li><code>SCAN命令返回的是一个游标，从0开始遍历，到0结束遍历</code></li></ol><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">redis &gt; scan 0 match usertoken* count 5</span><br><span class="line">1) <span class="string">&quot;6&quot;</span></span><br><span class="line">2) 1) <span class="string">&quot;usertoken:100&quot;</span></span><br><span class="line">2) <span class="string">&quot;usertoken:101&quot;</span></span><br><span class="line">3) <span class="string">&quot;usertoken:102&quot;</span></span><br><span class="line">4) <span class="string">&quot;usertoken:103&quot;</span></span><br><span class="line">5) <span class="string">&quot;usertoken:104&quot;</span></span><br></pre></td></tr></table></figure><p>从0开始遍历，返回了游标6，又返回了数据，继续scan遍历，就要从6开始</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">redis &gt; scan 6 match usertoken* count 5</span><br><span class="line">1) <span class="string">&quot;10&quot;</span></span><br><span class="line">2) 1) <span class="string">&quot;usertoken:200&quot;</span></span><br><span class="line">2) <span class="string">&quot;usertoken:201&quot;</span></span><br><span class="line">3) <span class="string">&quot;usertoken:202&quot;</span></span><br><span class="line">4) <span class="string">&quot;usertoken:203&quot;</span></span><br><span class="line">5) <span class="string">&quot;usertoken:204&quot;</span></span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>^_^.</p>]]></content>
      
      
      <categories>
          
          <category> 笔记本 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker Swarm</title>
      <link href="post/656e6847/"/>
      <url>post/656e6847/</url>
      
        <content type="html"><![CDATA[<p> 实践中会发现，生产环境中使用单个 Docker 节点是远远不够的，搭建 Docker 集群势在必行。然而，面对 Kubernetes, Mesos 以及 Swarm 等众多容器集群系统，我们该如何选择呢？它们之中，Swarm 是 Docker 原生的，同时也是最简单，最易学，最节省资源的，比较适合中小型公司使用。</p><h2 id="Docker-Swarm-介绍"><a href="#Docker-Swarm-介绍" class="headerlink" title="Docker Swarm 介绍"></a>Docker Swarm 介绍</h2><p>Swarm 在 Docker 1.12 版本之前属于一个独立的项目，在 Docker 1.12 版本发布之后，该项目合并到了 Docker 中，成为 Docker 的一个子命令。目前，Swarm 是 Docker 社区提供的唯一一个原生支持 Docker 集群管理的工具。它可以把多个 Docker 主机组成的系统转换为单一的虚拟 Docker 主机，使得容器可以组成跨主机的子网网络。</p><p>Docker Swarm 是一个为 IT 运维团队提供集群和调度能力的编排工具。用户可以把集群中所有 Docker Engine 整合进一个「虚拟 Engine」的资源池，通过执行命令与单一的主 Swarm 进行沟通，而不必分别和每个 Docker Engine 沟通。在灵活的调度策略下，IT 团队可以更好地管理可用的主机资源，保证应用容器的高效运行。</p><p><img src="https://github.com/cayzlh/git-img-repository/raw/master/blog/2019/09/22.png" alt="Docker Swarm"></p><h2 id="Docker-Swarm-优点"><a href="#Docker-Swarm-优点" class="headerlink" title="Docker Swarm 优点"></a>Docker Swarm 优点</h2><h3 id="任何规模都有高性能表现"><a href="#任何规模都有高性能表现" class="headerlink" title="任何规模都有高性能表现"></a>任何规模都有高性能表现</h3><p>对于企业级的 Docker Engine 集群和容器调度而言，可拓展性是关键。任何规模的公司——不论是拥有五个还是上千个服务器——都能在其环境下有效使用 Swarm。 经过测试，Swarm 可拓展性的极限是在 1000 个节点上运行 50000 个部署容器，每个容器的启动时间为亚秒级，同时性能无减损。</p><h3 id="灵活的容器调度"><a href="#灵活的容器调度" class="headerlink" title="灵活的容器调度"></a>灵活的容器调度</h3><p>Swarm 帮助 IT 运维团队在有限条件下将性能表现和资源利用最优化。Swarm 的内置调度器（scheduler）支持多种过滤器，包括：节点标签，亲和性和多种容器部策略如 binpack、spread、random 等等。</p><h3 id="服务的持续可用性"><a href="#服务的持续可用性" class="headerlink" title="服务的持续可用性"></a>服务的持续可用性</h3><p>Docker Swarm 由 Swarm Manager 提供高可用性，通过创建多个 Swarm master 节点和制定主 master 节点宕机时的备选策略。如果一个 master 节点宕机，那么一个 slave 节点就会被升格为 master 节点，直到原来的 master 节点恢复正常。 此外，如果某个节点无法加入集群，Swarm 会继续尝试加入，并提供错误警报和日志。在节点出错时，Swarm 现在可以尝试把容器重新调度到正常的节点上去。</p><p><strong>和 Docker API 及整合支持的兼容性</strong> Swarm 对 Docker API 完全支持，这意味着它能为使用不同 Docker 工具（如 Docker CLI，Compose，Trusted Registry，Hub 和 UCP）的用户提供无缝衔接的使用体验。</p><p><strong>Docker Swarm 为 Docker 化应用的核心功能（诸如多主机网络和存储卷管理）提供原生支持。</strong>开发的 Compose 文件能（通过 docker-compose up ）轻易地部署到测试服务器或 Swarm 集群上。Docker Swarm 还可以从 Docker Trusted Registry 或 Hub 里 pull 并 run 镜像。</p><p><strong>综上所述，Docker Swarm 提供了一套高可用 Docker 集群管理的解决方案，完全支持标准的 Docker API，方便管理调度集群 Docker 容器，合理充分利用集群主机资源</strong>。</p><blockquote><p><strong>并非所有服务都应该部署在Swarm集群内。数据库以及其它有状态服务就不适合部署在Swarm集群内。</strong></p></blockquote><h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><h3 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h3><p>运行 Docker 的主机可以主动初始化一个 Swarm 集群或者加入一个已存在的 Swarm 集群，这样这个运行 Docker 的主机就成为一个 Swarm 集群的节点 (node) 。节点分为管理 (manager) 节点和工作 (worker) 节点。</p><p>管理节点用于 Swarm 集群的管理，docker swarm 命令基本只能在管理节点执行（节点退出集群命令 docker swarm leave 可以在工作节点执行）。一个 Swarm 集群可以有多个管理节点，但只有一个管理节点可以成为 leader，leader 通过 raft 协议实现。</p><p>工作节点是任务执行节点，管理节点将服务 (service) 下发至工作节点执行。管理节点默认也作为工作节点。你也可以通过配置让服务只运行在管理节点。下图展示了集群中管理节点与工作节点的关系。</p><p><img src="https://github.com/cayzlh/git-img-repository/raw/master/blog/2019/09/23.png" alt="节点"></p><h3 id="服务和任务"><a href="#服务和任务" class="headerlink" title="服务和任务"></a>服务和任务</h3><p>任务 （Task）是 Swarm 中的最小的调度单位，目前来说就是一个单一的容器。 服务 （Services） 是指一组任务的集合，服务定义了任务的属性。服务有两种模式：</p><ul><li>replicated services 按照一定规则在各个工作节点上运行指定个数的任务。</li><li>global services 每个工作节点上运行一个任务</li></ul><p>两种模式通过 docker service create 的 –mode 参数指定。下图展示了容器、任务、服务的关系。</p><p><img src="https://github.com/cayzlh/git-img-repository/raw/master/blog/2019/09/24.png" alt="服务和任务"></p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><ul><li><p>转自：<a href="http://www.ityouknow.com/docker/2018/04/19/docker-swarm.html">Docker(六)：Docker 三剑客之 Docker Swarm</a></p></li><li><p>对这个Docker Swarm这部分不是很熟悉，主要是想了解其概念。转发这篇文章内容以免以后找不到。</p></li><li><p>实践之后再做补充</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
            <tag> 转载 </tag>
            
            <tag> 微服务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用Docker Compose</title>
      <link href="post/2311352951/"/>
      <url>post/2311352951/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Docker-Compose 是 Docker 的一种编排服务，是一个用于在 Docker 上定义并运行复杂应用的工具，可以让用户在集群中部署分布式应用。</p><p>使用一个 Dockerfile 模板文件可以定义一个单独的应用容器，如果需要定义多个容器就需要服务编排。Docker Compose是其中的一种服务编排技术方案，是Docker的官方产品。</p><p>Dockerfile 可以让用户管理一个单独的应用容器；而 Compose 则允许用户在一个模板（YAML 格式）中定义一组相关联的应用容器（被称为一个 project，即项目），例如一个 Web 服务容器再加上后端的数据库服务容器等。</p><p>参考：<a href="http://www.ityouknow.com/docker/2018/03/22/docker-compose.html">Docker 三剑客之 Docker Compose</a></p></blockquote><h2 id="Docker-Compose-介绍"><a href="#Docker-Compose-介绍" class="headerlink" title="Docker Compose 介绍"></a>Docker Compose 介绍</h2><p>通过 Docker-Compose 用户可以很容易地用一个配置文件定义一个多容器的应用，然后使用一条指令安装这个应用的所有依赖，完成构建。Docker-Compose 解决了容器与容器之间如何管理编排的问题。</p><p><img src="https://github.com/cayzlh/git-img-repository/raw/master/blog/2019/09/19.png" alt="Docker Compose 工作原理图"></p><p>Compose 中有两个重要的概念：</p><ul><li>服务 (service) ：一个应用的容器，实际上可以包括若干运行相同镜像的容器实例。</li><li>项目 (project) ：由一组关联的应用容器组成的一个完整业务单元，在 docker-compose.yml 文件中定义。</li></ul><p>一个项目可以由多个服务（容器）关联而成，Compose 面向项目进行管理，通过子命令对项目中的一组容器进行便捷地生命周期管理。</p><p>Compose 项目由 Python 编写，实现上调用了 Docker 服务提供的 API 来对容器进行管理。因此，只要所操作的平台支持 Docker API，就可以在其上利用 Compose 来进行编排管理。</p><h2 id="Docker-Compose-安装"><a href="#Docker-Compose-安装" class="headerlink" title="Docker Compose 安装"></a>Docker Compose 安装</h2><p>Docker Compose 是 Docker 的独立产品，因此需要安装 Docker 之后在单独安装 Docker Compose .</p><h3 id="macOS"><a href="#macOS" class="headerlink" title="macOS"></a>macOS</h3><p>macOS下使用<code>homebrew</code>安装之后默认安装好了<code>Docker Compose</code>。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">brew cask install docker</span><br></pre></td></tr></table></figure><h3 id="Centos"><a href="#Centos" class="headerlink" title="Centos"></a>Centos</h3><p><strong>方法一：</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#下载</span></span><br><span class="line">sudo curl -L https://github.com/docker/compose/releases/download/1.20.0/docker-compose-`uname -s`-`uname -m` -o /usr/<span class="built_in">local</span>/bin/docker-compose</span><br><span class="line"><span class="comment">#安装</span></span><br><span class="line">chmod +x /usr/<span class="built_in">local</span>/bin/docker-compose</span><br><span class="line"><span class="comment">#查看版本</span></span><br><span class="line">docker-compose version</span><br></pre></td></tr></table></figure><p><strong>方法二：</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#安装pip</span></span><br><span class="line">yum -y install epel-release</span><br><span class="line">yum -y install python-pip</span><br><span class="line"><span class="comment">#确认版本</span></span><br><span class="line">pip --version</span><br><span class="line"><span class="comment">#更新pip</span></span><br><span class="line">pip install --upgrade pip</span><br><span class="line"><span class="comment">#安装docker-compose</span></span><br><span class="line">pip install docker-compose </span><br><span class="line"><span class="comment">#查看版本</span></span><br><span class="line">docker-compose version</span><br></pre></td></tr></table></figure><p>安装完成后执行<code>docker-compose version</code>，输出以下信息，说明安装完成。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker-compose version 1.24.1, build 4667896b</span><br><span class="line">docker-py version: 3.7.3</span><br><span class="line">CPython version: 3.6.8</span><br><span class="line">OpenSSL version: OpenSSL 1.1.0j  20 Nov 2018</span><br></pre></td></tr></table></figure><h2 id="一个小例子"><a href="#一个小例子" class="headerlink" title="一个小例子"></a>一个小例子</h2><blockquote><p>源码地址：<a href="https://github.com/cayzlh/springboot-docker-demo">https://github.com/cayzlh/springboot-docker-demo</a></p></blockquote><h3 id="创建一个SpringBoot应用"><a href="#创建一个SpringBoot应用" class="headerlink" title="创建一个SpringBoot应用"></a>创建一个SpringBoot应用</h3><p>创建于SpringBoot应用，配合Redis记录访问次数。</p><h4 id="pom"><a href="#pom" class="headerlink" title="pom"></a>pom</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="DockerController"><a href="#DockerController" class="headerlink" title="DockerController"></a>DockerController</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DockerController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Lazy</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">index</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        redisTemplate.opsForValue().increment(<span class="string">&quot;request_key&quot;</span>, <span class="number">1</span>);</span><br><span class="line">        String times = redisTemplate.opsForValue().get(<span class="string">&quot;request_key&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello Docker! you had request &quot;</span>+times+<span class="string">&quot; times!!!!!!!!!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h4><p>在<code>src/main/docker</code>路径中创建<code>Dockerfile</code>文件.</p><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> openjdk:<span class="number">8</span>-jdk-alpine</span><br><span class="line"></span><br><span class="line"><span class="keyword">MAINTAINER</span> chenanyu antchenanyu@<span class="number">163</span>.com</span><br><span class="line"></span><br><span class="line"><span class="keyword">VOLUME</span><span class="bash"> /tmp</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> target/springboot-docker-demo-0.0.3.jar app.jar</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> [<span class="string">&quot;java&quot;</span>,<span class="string">&quot;-Djava.security.egd=file:/dev/./urandom&quot;</span>,<span class="string">&quot;-jar&quot;</span>,<span class="string">&quot;/app.jar&quot;</span>]</span></span><br></pre></td></tr></table></figure><h4 id="docker-compose"><a href="#docker-compose" class="headerlink" title="docker-compose"></a>docker-compose</h4><p>在根目录创建<code>docker-compose.yml</code>文件。</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3&#x27;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">app:</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">v-app</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">build:</span> <span class="string">.</span></span><br><span class="line">    <span class="attr">working_dir:</span> <span class="string">/app</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./:/app</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">~/.m2:/root/.m2</span></span><br><span class="line">    <span class="attr">expose:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;8080&quot;</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">nginx</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">redisserver</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">mvn</span> <span class="string">clean</span> <span class="string">spring-boot:run</span> <span class="string">-Dspring-boot.run.profiles=docker</span></span><br><span class="line">  <span class="attr">redisserver:</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">v-redis</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">&quot;redis:alpine&quot;</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">6379</span><span class="string">:6379</span></span><br><span class="line">  <span class="attr">nginx:</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">v-nginx</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx:1.13</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">8081</span><span class="string">:80</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">443</span><span class="string">:443</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./nginx:/etc/nginx/conf.d</span></span><br></pre></td></tr></table></figure><h3 id="使用docker-compose命令运行"><a href="#使用docker-compose命令运行" class="headerlink" title="使用docker-compose命令运行"></a>使用docker-compose命令运行</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker-compose up</span><br></pre></td></tr></table></figure><p><img src="https://github.com/cayzlh/git-img-repository/raw/master/blog/2019/09/20.png" alt="docker-compose up"></p><p>这个时候浏览器访问<code>http://youipaddress:8081</code>，就能看到效果了，访问次数会不断的叠加。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">Hello Docker! you had request 5 times!!!!!!!!!</span><br></pre></td></tr></table></figure><p><img src="https://github.com/cayzlh/git-img-repository/raw/master/blog/2019/09/21.gif" alt="nginx"></p><p><em>在macOS中，非root用户是无法使用小于1024的常用端口的。如果开发中需要用到80端口, 就要设置端口转发。<br>这里就不想麻烦了，使用8081来做测试。</em></p><h2 id="Docker-Compose常用命令"><a href="#Docker-Compose常用命令" class="headerlink" title="Docker Compose常用命令"></a>Docker Compose常用命令</h2><ul><li><p>使用<code>docker-compose up -d</code>在后台启动服务</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost composetest]<span class="comment"># docker-compose up -d</span></span><br><span class="line">Starting composetest_web_1 ... </span><br><span class="line">Starting composetest_web_1 ... <span class="keyword">done</span></span><br></pre></td></tr></table></figure></li><li><p>使用<code>docker-compose ps</code>命令查看启动的服务</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost composetest]<span class="comment"># docker-compose ps</span></span><br><span class="line">       Name                      Command               State           Ports         </span><br><span class="line">-------------------------------------------------------------------------------------</span><br><span class="line">composetest_redis_1   docker-entrypoint.sh redis ...   Up      6379/tcp              </span><br><span class="line">composetest_web_1     python app.py                    Up      0.0.0.0:5000-&gt;5000/tcp</span><br></pre></td></tr></table></figure></li><li><p>使用<code>docker-compose stop</code>停止服务。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost composetest]<span class="comment"># docker-compose stop</span></span><br><span class="line">Stopping composetest_web_1   ... <span class="keyword">done</span></span><br><span class="line">Stopping composetest_redis_1 ... <span class="keyword">done</span></span><br></pre></td></tr></table></figure></li><li><p>其他</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#查看帮助</span></span><br><span class="line">docker-compose -h</span><br><span class="line"></span><br><span class="line"><span class="comment"># -f  指定使用的 Compose 模板文件，默认为 docker-compose.yml，可以多次指定。</span></span><br><span class="line">docker-compose -f docker-compose.yml up -d </span><br><span class="line"></span><br><span class="line"><span class="comment">#启动所有容器，-d 将会在后台启动并运行所有的容器</span></span><br><span class="line">docker-compose up -d</span><br><span class="line"></span><br><span class="line"><span class="comment">#停用移除所有容器以及网络相关</span></span><br><span class="line">docker-compose down</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看服务容器的输出</span></span><br><span class="line">docker-compose logs</span><br><span class="line"></span><br><span class="line"><span class="comment">#列出项目中目前的所有容器</span></span><br><span class="line">docker-compose ps</span><br><span class="line"></span><br><span class="line"><span class="comment">#构建（重新构建）项目中的服务容器。服务容器一旦构建后，将会带上一个标记名，例如对于 web 项目中的一个 db 容器，可能是 web_db。可以随时在项目目录下运行 docker-compose build 来重新构建服务</span></span><br><span class="line">docker-compose build</span><br><span class="line"></span><br><span class="line"><span class="comment">#拉取服务依赖的镜像</span></span><br><span class="line">docker-compose pull</span><br><span class="line"></span><br><span class="line"><span class="comment">#重启项目中的服务</span></span><br><span class="line">docker-compose restart</span><br><span class="line"></span><br><span class="line"><span class="comment">#删除所有（停止状态的）服务容器。推荐先执行 docker-compose stop 命令来停止容器。</span></span><br><span class="line">docker-compose rm </span><br><span class="line"></span><br><span class="line"><span class="comment">#在指定服务上执行一个命令。</span></span><br><span class="line">docker-compose run ubuntu ping docker.com</span><br><span class="line"></span><br><span class="line"><span class="comment">#设置指定服务运行的容器个数。通过 service=num 的参数来设置数量</span></span><br><span class="line">docker-compose scale web=3 db=2</span><br><span class="line"></span><br><span class="line"><span class="comment">#启动已经存在的服务容器。</span></span><br><span class="line">docker-compose start</span><br><span class="line"></span><br><span class="line"><span class="comment">#停止已经处于运行状态的容器，但不删除它。通过 docker-compose start 可以再次启动这些容器。</span></span><br><span class="line">docker-compose stop</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="http://www.ityouknow.com/docker/2018/03/22/docker-compose.html">Docker 三剑客之 Docker Compose</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 笔记本 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Docker </tag>
            
            <tag> Compose </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用Docker部署SpringBoot项目</title>
      <link href="post/709624188/"/>
      <url>post/709624188/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Docker 技术发展为微服务落地提供了更加便利的环境，使用 Docker 部署 Spring Boot 其实非常简单。</p></blockquote><h2 id="创建SpringBoot项目"><a href="#创建SpringBoot项目" class="headerlink" title="创建SpringBoot项目"></a>创建SpringBoot项目</h2><p>使用<code>SpringBoot2.0</code>创建一个SpringBoot项目。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br></pre></td></tr></table></figure><p>添加 web 和测试依赖</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>创建一个 DockerController，在其中有一个<code>index()</code>方法，访问时返回：<code>Hello Docker!</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DockerController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">index</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello Docker!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DockerApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">SpringApplication.run(DockerApplication.class, args);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>添加完毕后启动项目，启动成功后浏览器放问：<code>http://localhost:8080/</code>，页面返回：<code>Hello Docker!</code>，说明 Spring Boot 项目配置正常。</p><h2 id="为SpringBoot项目添加Docker支持"><a href="#为SpringBoot项目添加Docker支持" class="headerlink" title="为SpringBoot项目添加Docker支持"></a>为SpringBoot项目添加Docker支持</h2><p>在 <code>pom.xml</code>的<code>properties </code>节点中添加 Docker 镜像名称</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">docker.image.prefix</span>&gt;</span>springboot<span class="tag">&lt;/<span class="name">docker.image.prefix</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>plugins</code> 中添加 <code>Docker</code> 构建插件：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Docker maven plugin --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.spotify<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>docker-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">imageName</span>&gt;</span>$&#123;docker.image.prefix&#125;/$&#123;project.artifactId&#125;<span class="tag">&lt;/<span class="name">imageName</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dockerDirectory</span>&gt;</span>src/main/docker<span class="tag">&lt;/<span class="name">dockerDirectory</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">targetPath</span>&gt;</span>/<span class="tag">&lt;/<span class="name">targetPath</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">directory</span>&gt;</span>$&#123;project.build.directory&#125;<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">include</span>&gt;</span>$&#123;project.build.finalName&#125;.jar<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Docker maven plugin --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在目录<code>src/main/docker</code>下创建 Dockerfile 文件，Dockerfile 文件用来说明如何来构建镜像。</p><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> openjdk:<span class="number">8</span>-jdk-alpine</span><br><span class="line"><span class="keyword">VOLUME</span><span class="bash"> /tmp</span></span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> spring-boot-docker-1.0.jar app.jar</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> [<span class="string">&quot;java&quot;</span>,<span class="string">&quot;-Djava.security.egd=file:/dev/./urandom&quot;</span>,<span class="string">&quot;-jar&quot;</span>,<span class="string">&quot;/app.jar&quot;</span>]</span></span><br></pre></td></tr></table></figure><p>这个 Dockerfile 文件很简单，构建 Jdk 基础环境，添加 Spring Boot Jar 到镜像中，简单解释一下:</p><ul><li>FROM ，表示使用 Jdk8 环境 为基础镜像，如果镜像不是本地的会从 DockerHub 进行下载</li><li>VOLUME ，VOLUME 指向了一个<code>/tmp</code>的目录，由于 Spring Boot 使用内置的Tomcat容器，Tomcat 默认使用<code>/tmp</code>作为工作目录。这个命令的效果是：在宿主机的<code>/var/lib/docker</code>目录下创建一个临时文件并把它链接到容器中的<code>/tmp</code>目录</li><li>ADD ，拷贝文件并且重命名</li><li>ENTRYPOINT ，为了缩短 Tomcat 的启动时间，添加<code>java.security.egd</code>的系统属性指向<code>/dev/urandom</code>作为 ENTRYPOINT</li></ul><blockquote><p>SpringBoot项目的Docker依赖就配置完成了</p></blockquote><h2 id="使用dockerfile打包镜像"><a href="#使用dockerfile打包镜像" class="headerlink" title="使用dockerfile打包镜像"></a>使用dockerfile打包镜像</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mvn package docker:build</span><br></pre></td></tr></table></figure><p>当看到<code>BUILD SUCCESS</code>的时候，说明构建成功了。</p><p>使用<code>docker images</code>命令查看构建好的镜像：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker images</span><br><span class="line">REPOSITORY                      TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">springboot/spring-boot-docker   latest              99ce9468da74        6 seconds ago       117.5 MB</span><br></pre></td></tr></table></figure><p><code>springboot/spring-boot-docker</code> 就是我们构建好的镜像，下一步就是运行该镜像</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -p 8080:8080 -t springboot/spring-boot-docker</span><br></pre></td></tr></table></figure><p>可以看到我们构建的容器正在在运行，访问浏览器：<code>http://192.168.0.x:8080/</code>,返回</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">Hello Docker!</span><br></pre></td></tr></table></figure><p>^_^。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记本 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Docker </tag>
            
            <tag> Spring </tag>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RocketMQ相关流程图/原理图</title>
      <link href="post/3135129110/"/>
      <url>post/3135129110/</url>
      
        <content type="html"><![CDATA[<blockquote><p>转自：<a href="https://juejin.im/post/5d7b06596fb9a06ae61ae5e3">后端程序员必备：RocketMQ相关流程图/原理图</a>，怕以后找不到。</p></blockquote><h2 id="RocketMQ是什么"><a href="#RocketMQ是什么" class="headerlink" title="RocketMQ是什么"></a>RocketMQ是什么</h2><p><img src="https://github.com/cayzlh/git-img-repository/raw/master/blog/2019/09/4.png" alt="RocketMQ是什么"></p><ul><li>是一个队列模型的消息中间件，具有高性能、高可靠、高实时、分布式特点。</li><li>Producer、Consumer、队列都可以分布式。</li><li>Producer 向一些队列轮流发送消息，队列集合称为 Topic，Consumer 如果做广播消费，则一个 consumer 实例消费这个 Topic 对应的所有队列，如果做集群消费，则多个 Consumer 实例平均消费这个 topic 对应的队列集合。</li><li>能够保证严格的消息顺序</li><li>提供丰富的消息拉取模式</li><li>高效的订阅者水平扩展能力</li><li>实时的消息订阅机制</li><li>亿级消息堆积能力</li><li>较少的依赖</li></ul><h2 id="RocketMQ-核心组件图"><a href="#RocketMQ-核心组件图" class="headerlink" title="RocketMQ 核心组件图"></a>RocketMQ 核心组件图</h2><p>RocketMQ是开源的消息中间件，它主要由<code>NameServer</code>，<code>Producer</code>，<code>Broker</code>，<code>Consumer</code>四部分构成。</p><p><img src="https://github.com/cayzlh/git-img-repository/raw/master/blog/2019/09/5.png" alt="RocketMQ 核心组件图"></p><h3 id="NameServer"><a href="#NameServer" class="headerlink" title="NameServer"></a>NameServer</h3><p>NameServer主要负责Topic和路由信息的管理，功能类似Dubbo的zookeeper。</p><h3 id="Producer"><a href="#Producer" class="headerlink" title="Producer"></a>Producer</h3><p>消息生产者，负责产生消息，一般由业务系统负责产生消息。</p><h3 id="Broker"><a href="#Broker" class="headerlink" title="Broker"></a>Broker</h3><p>消息中转角色，负责存储消息，转发消息。</p><h3 id="Consumer"><a href="#Consumer" class="headerlink" title="Consumer"></a>Consumer</h3><p>消息消费者，负责消息消费，一般是后台系统负责异步消费。</p><h2 id="RokcetMQ-物理部署图"><a href="#RokcetMQ-物理部署图" class="headerlink" title="RokcetMQ 物理部署图"></a>RokcetMQ 物理部署图</h2><p><img src="https://github.com/cayzlh/git-img-repository/raw/master/blog/2019/09/6.png" alt="RokcetMQ 物理部署图"></p><h3 id="NameServer-1"><a href="#NameServer-1" class="headerlink" title="NameServer"></a>NameServer</h3><p>NameServer是一个几乎无状态节点，可集群部署，节点之间无任何信息同步。</p><h3 id="Broker-1"><a href="#Broker-1" class="headerlink" title="Broker"></a>Broker</h3><p>Broker分为Master与Slave，一个Master可以对应多个Slave，但是一个Slave只能对应一个Master，Master与Slave的对应关系通过指定相同的BrokerName，不同的BrokerId来定义，BrokerId为0表示Master，非0表示Slave。Master也可以部署多个。每个Broker与Name Server集群中的所有节点建立长连接，定时注册Topic信息到所有Name Server。</p><h3 id="Producer-1"><a href="#Producer-1" class="headerlink" title="Producer"></a>Producer</h3><p>Producer与Name Server集群中的其中一个节点（随机选择）建立长连接，定期从Name Server取Topic路由信息，并向提供Topic服务的Master建立长连接，且定时向Master发送心跳。Producer完全无状态，可集群部署。</p><h3 id="Consumer-1"><a href="#Consumer-1" class="headerlink" title="Consumer"></a>Consumer</h3><p>Consumer与Name Server集群中的其中一个节点（随机选择）建立长连接，定期从Name Server取Topic路由信息，并向提供Topic服务的Master、Slave建立长连接，且定时向Master、Slave发送心跳。Consumer既可以从Master订阅消息，也可以从Slave订阅消息，订阅规则由Broker配置决定。</p><h2 id="RocketMQ-逻辑部署结构"><a href="#RocketMQ-逻辑部署结构" class="headerlink" title="RocketMQ 逻辑部署结构"></a>RocketMQ 逻辑部署结构</h2><p><img src="https://github.com/cayzlh/git-img-repository/raw/master/blog/2019/09/7.png" alt="RocketMQ 逻辑部署结构"></p><h3 id="Producer-Group"><a href="#Producer-Group" class="headerlink" title="Producer Group"></a>Producer Group</h3><p>用来表示一个发送消息应用，一个 Producer Group 下包含多个 Producer 实例，可以是多台机器，也可以 是一台机器的多个进程，或者一个进程的多个 Producer 对象。一个 Producer Group 可以发送多个 Topic 消息，Producer Group 作用如下：</p><ul><li>标识一类 Producer</li><li>可以通过运维工具查询这个发送消息应用下有多个 Producer 实例</li><li>发送分布式事务消息时，如果 Producer 中途意外宕机，Broker 会主动回调 Producer Group 内的任意 一台机器来确认事务状态。</li></ul><h3 id="Consumer-Group"><a href="#Consumer-Group" class="headerlink" title="Consumer Group"></a>Consumer Group</h3><p>用来表示一个消费消息应用，一个 Consumer Group 下包含多个 Consumer 实例，可以是多台机器，也可 以是多个进程，或者是一个进程的多个 Consumer 对象。一个 Consumer Group 下的多个 Consumer 以均摊 方式消费消息，如果设置为广播方式，那么这个 Consumer Group 下的每个实例都消费全量数据。</p><h2 id="NameServer-路由注册、删除机制"><a href="#NameServer-路由注册、删除机制" class="headerlink" title="NameServer 路由注册、删除机制"></a>NameServer 路由注册、删除机制</h2><p><img src="https://github.com/cayzlh/git-img-repository/raw/master/blog/2019/09/8.png" alt="NameServer 路由注册、删除机制"></p><ul><li>Broker每30秒向NameServer发送心跳包，心跳包中包含topic的路由信息</li><li>NarneServer 收到 Broker 心跳包后 更新 brokerLiveTable 中的信息， 特别记录心跳时间 lastUpdateTime</li><li>NarneServer 每隔 10s 扫描 brokerLiveTable， 检 测表中上次收到心跳包的时间，比较当前时间 与上一次时间，如果超过120s，则认为 broker 不可用，移除路由表中与该 broker相关的所有 信息</li><li>消息生产者拉取主题的路由信息，即消息生产者并不会立即感知 Broker 服务器的新增与删除。</li></ul><h2 id="RocketMQ的消息领域模型图"><a href="#RocketMQ的消息领域模型图" class="headerlink" title="RocketMQ的消息领域模型图"></a>RocketMQ的消息领域模型图</h2><p><img src="https://github.com/cayzlh/git-img-repository/raw/master/blog/2019/09/9.png" alt="RocketMQ的消息领域模型图"></p><h3 id="Topic"><a href="#Topic" class="headerlink" title="Topic"></a>Topic</h3><ul><li>Topic表示消息的第一级类型，比如一个电商系统的消息可以分为：交易消息、物流消息等。一条消息必须有一个Topic。</li><li>最细粒度的订阅单位，一个Group可以订阅多个Topic的消息。</li></ul><h3 id="Tag"><a href="#Tag" class="headerlink" title="Tag"></a>Tag</h3><p>Tag表示消息的第二级类型，比如交易消息又可以分为：交易创建消息，交易完成消息等。RocketMQ提供2级消息分类，方便灵活控制。</p><h3 id="Group"><a href="#Group" class="headerlink" title="Group"></a>Group</h3><p>组，一个组可以订阅多个Topic。</p><h3 id="Message-Queue"><a href="#Message-Queue" class="headerlink" title="Message Queue"></a>Message Queue</h3><p>消息的物理管理单位。一个Topic下可以有多个Queue，Queue的引入使得消息的存储可以分布式集群化，具有了水平扩展能力。</p><p>在 RocketMQ 中，所有消息队列都是持久化，长度无限的数据结构，所谓长度无限是指队列中的每个存储单元都是定长，访问其中的存储单元使用 Offset 来访问，offset 为 java long 类型，64 位，理论上在 100年内不会溢出，所以认为是长度无限。</p><p>也可以认为 Message Queue 是一个长度无限的数组，Offset 就是下标。</p><h2 id="顺序消息原理图"><a href="#顺序消息原理图" class="headerlink" title="顺序消息原理图"></a>顺序消息原理图</h2><p><img src="https://github.com/cayzlh/git-img-repository/raw/master/blog/2019/09/10.png" alt="顺序消息原理图"></p><p>消费消息的顺序要同发送消息的顺序一致，在 RocketMQ 中，主要的是局部顺序，即一类消息为满足顺 序性，必须 Producer 单线程顺序发送，且发送到同一个队列，这样 Consumer 就可以按照 Producer 收送 的顺序去消费消息。</p><h2 id="RocketMQ-消息存储设计原理图"><a href="#RocketMQ-消息存储设计原理图" class="headerlink" title="RocketMQ 消息存储设计原理图"></a>RocketMQ 消息存储设计原理图</h2><p><img src="https://github.com/cayzlh/git-img-repository/raw/master/blog/2019/09/11.png" alt="RocketMQ 消息存储设计原理图"></p><h3 id="CommitLog"><a href="#CommitLog" class="headerlink" title="CommitLog"></a>CommitLog</h3><p>消息存储文件，所有消息主题的消息都存储在 CommitLog 文件中。 Commitlog 文件存储的逻辑视图如图所示</p><p><img src="https://github.com/cayzlh/git-img-repository/raw/master/blog/2019/09/12.png" alt="CommitLog"></p><h3 id="ConsumeQueue"><a href="#ConsumeQueue" class="headerlink" title="ConsumeQueue"></a>ConsumeQueue</h3><p>消息消费队列，消息到达 CommitLog 文件后，将异步转发到消息 消费队列，供消息消费者消费。ConsumeQueue存储格式如下：</p><p><img src="https://github.com/cayzlh/git-img-repository/raw/master/blog/2019/09/13.png" alt="ConsumeQueue"></p><ul><li>单个 ConsumeQueue 文件中默认包含 30 万个条目，单个文件的长度为 30w × 20 字节， 单个 ConsumeQueue 文件可以看出是一个 ConsumeQueue 条目的数组，其下标为 ConsumeQueue 的逻辑偏移量，消息消费进度存储的偏移量 即逻辑偏移量。</li><li>ConsumeQueue 即为 Commitlog 文件的索引文件， 其构建机制是当消息到达 Commitlog 文件后， 由专门的线程 产生消息转发任务，从而构建消息消费队列文件与下文提到的索引文件。</li></ul><h3 id="IndexFile"><a href="#IndexFile" class="headerlink" title="IndexFile"></a>IndexFile</h3><p>消息索引文件，主要存储消息 Key 与 Offset 的对应关系。</p><p>消息消费队列是RocketMQ专门为消息订阅构建的索引文件，提高根据主题与消息队 列检索消息的速度 ，另外 RocketMQ 引入了 Hash 索引机制为消息建立索引， HashMap 的设 计包含两个基本点 ： Hash 槽与 Hash 冲突的链表结构。 RocketMQ 索引文件布局如图所示</p><p><img src="https://github.com/cayzlh/git-img-repository/raw/master/blog/2019/09/14.png" alt="IndexFile"></p><p>lndexFile 总共包含 lndexHeader、 Hash 槽、 Hash 条目</p><h3 id="事务状态服务"><a href="#事务状态服务" class="headerlink" title="事务状态服务"></a>事务状态服务</h3><p>存储每条消息的事务状态。</p><h3 id="定时消息服务"><a href="#定时消息服务" class="headerlink" title="定时消息服务"></a>定时消息服务</h3><p>每一个延迟级别对应一个消息消费队列，存储延迟队列的消息拉取进度。</p><h2 id="RMQ文件存储模型层"><a href="#RMQ文件存储模型层" class="headerlink" title="RMQ文件存储模型层"></a>RMQ文件存储模型层</h2><p><img src="https://github.com/cayzlh/git-img-repository/raw/master/blog/2019/09/15.png" alt="RMQ文件存储模型层"></p><h3 id="RocketMQ业务处理器层"><a href="#RocketMQ业务处理器层" class="headerlink" title="RocketMQ业务处理器层"></a>RocketMQ业务处理器层</h3><p>Broker端对消息进行读取和写入的业务逻辑入口，这一层主要包含了业务逻辑相关处理操作（根据解析RemotingCommand中的RequestCode来区分具体的业务操作类型，进而执行不同的业务处理流程），比如前置的检查和校验步骤、构造MessageExtBrokerInner对象、decode反序列化、构造Response返回对象等。</p><h3 id="RocketMQ数据存储组件层"><a href="#RocketMQ数据存储组件层" class="headerlink" title="RocketMQ数据存储组件层"></a>RocketMQ数据存储组件层</h3><ul><li>该层主要是RocketMQ的存储核心类—DefaultMessageStore，其为RocketMQ消息数据文件的访问入口，通过该类的“putMessage()”和“getMessage()”方法完成对CommitLog消息存储的日志数据文件进行读写操作（具体的读写访问操作还是依赖下一层中CommitLog对象模型提供的方法）；</li><li>另外，在该组件初始化时候，还会启动很多存储相关的后台服务线程，包括AllocateMappedFileService（MappedFile预分配服务线程）、ReputMessageService（回放存储消息服务线程）、HAService（Broker主从同步高可用服务线程）、StoreStatsService（消息存储统计服务线程）、IndexService（索引文件服务线程）等。</li></ul><h3 id="RocketMQ存储逻辑对象层"><a href="#RocketMQ存储逻辑对象层" class="headerlink" title="RocketMQ存储逻辑对象层"></a>RocketMQ存储逻辑对象层</h3><ul><li>该层主要包含了RocketMQ数据文件存储直接相关的三个模型类IndexFile、ConsumerQueue和CommitLog。</li><li>IndexFile为索引数据文件提供访问服务，ConsumerQueue为逻辑消息队列提供访问服务，CommitLog则为消息存储的日志数据文件提供访问服务。</li><li>这三个模型类也是构成了RocketMQ存储层的整体结构。</li></ul><h3 id="封装的文件内存映射层"><a href="#封装的文件内存映射层" class="headerlink" title="封装的文件内存映射层"></a>封装的文件内存映射层</h3><ul><li>RocketMQ主要采用JDK NIO中的MappedByteBuffer和FileChannel两种方式完成数据文件的读写。</li><li>其中，采用MappedByteBuffer这种内存映射磁盘文件的方式完成对大文件的读写，在RocketMQ中将该类封装成MappedFile类。</li><li>这里，每一种类的单个文件均由MappedFile类提供读写操作服务（其中，MappedFile类提供了顺序写/随机读、内存数据刷盘、内存清理等和文件相关的服务）。</li></ul><h3 id="磁盘存储层"><a href="#磁盘存储层" class="headerlink" title="磁盘存储层"></a>磁盘存储层</h3><p>主要指的是部署RocketMQ服务器所用的磁盘。这里，需要考虑不同磁盘类型（如SSD或者普通的HDD）特性以及磁盘的性能参数（如IOPS、吞吐量和访问时延等指标）对顺序写/随机读操作带来的影响。</p><h2 id="RocketMQ中消息刷盘"><a href="#RocketMQ中消息刷盘" class="headerlink" title="RocketMQ中消息刷盘"></a>RocketMQ中消息刷盘</h2><p>在RocketMQ中消息刷盘主要可以分为同步刷盘和异步刷盘两种。</p><h3 id="同步刷盘"><a href="#同步刷盘" class="headerlink" title="同步刷盘"></a>同步刷盘</h3><p><img src="https://github.com/cayzlh/git-img-repository/raw/master/blog/2019/09/16.png" alt="同步刷盘"></p><ul><li>在返回写成功状态时，消息已经被写入磁盘。</li><li>具体流程是，消息写入内存的PAGECACHE后，立刻通知刷盘线程刷盘，然后等待刷盘完成，刷盘线程执行完成后唤醒等待的线程，返回消息写成功的状态。</li><li>一般只用于金融场景。</li></ul><h3 id="异步刷盘"><a href="#异步刷盘" class="headerlink" title="异步刷盘"></a>异步刷盘</h3><p><img src="https://github.com/cayzlh/git-img-repository/raw/master/blog/2019/09/17.png" alt="异步刷盘"></p><p>在返回写成功状态时，消息可能只是被写入了内存的PAGECACHE，写操作的返回快，吞吐量大；当内存里的消息量积累到一定程度时，统一触发写磁盘操作，快速写入。</p><h2 id="消息在系统中流转图"><a href="#消息在系统中流转图" class="headerlink" title="消息在系统中流转图"></a>消息在系统中流转图</h2><p><img src="https://github.com/cayzlh/git-img-repository/raw/master/blog/2019/09/18.png" alt="消息在系统中流转图"></p><p>1、Producer 发送消息，消息从 socket 进入 java 堆。</p><p>2、Producer 发送消息，消息从 java 堆转入 PAGACACHE，物理内存。</p><p>3、Producer 发送消息，由异步线程刷盘，消息从 PAGECACHE 刷入磁盘。</p><p>4、Consumer 拉消息（正常消费），消息直接从 PAGECACHE（数据在物理内存）转入 socket，到达 consumer， 不经过 java 堆。这种消费场景最多，线上 96G 物理内存，按照 1K 消息算，可以在物理内存缓存 1 亿条消 息。</p><p>5、Consumer 拉消息（异常消费），消息直接从 PAGECACHE（数据在虚拟内存）转入 socket。</p><p>6、Consumer 拉消息（异常消费），由于 Socket 访问了虚拟内存，产生缺页中断，此时会产生磁盘 IO，从磁 盘 Load 消息到 PAGECACHE，然后直接从 socket 发出去。</p><p>7、同 5 一致。</p><p>8、同 6 一致。</p><hr><p>^_^.</p>]]></content>
      
      
      <categories>
          
          <category> 笔记本 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 消息队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Gson简易指南</title>
      <link href="post/2680260790/"/>
      <url>post/2680260790/</url>
      
        <content type="html"><![CDATA[<h2 id="Gson简介"><a href="#Gson简介" class="headerlink" title="Gson简介"></a>Gson简介</h2><p>在正式介绍 Gson 之前，我们可以先从<a href="https://link.juejin.im/?target=https://github.com/google/gson/blob/master/UserGuide.md%23TOC-Overview">官方的wiki</a>看下 Gson 的描述，了解它是什么？</p><blockquote><p>Gson is a Java library that can be used to convert Java Objects into their JSON representation. It can also be used to convert a JSON string to an equivalent Java object。</p></blockquote><p>从描述可以看出，Gson 是用于将 Java 对象与 JSON格式字符串数据相互转换的 Java 库。它起初在Google 内部广泛使用在 Android 平台 和 Java 服务端上。2008 年开源之后，成为了谷歌又一个被广泛使用的开源框架，截止目前*(2019.09.08)* 在GitHub 上已有1W6 多星，相同作用的类库还有 Spring Framework 中集成的 Jackson，以及阿里开源的 fastjson等。</p><p>在特性方面，Gson 提供简易的API <code>fromJson/toJson</code> 来实现 Java 与 JSON 之间的转换，并且能生成紧凑，可读的 JSON 字符串输出，还支持复杂对象转换和丰富的自定义表示，足以满足在日常开发中我们绝大部分的 JSON 数据处理需求。</p><blockquote><p>通常将对象与JSON字符串间的转换称之为序列化和反序列化(Serialization/Deserialization)。将 对象转化成 JSON字符串的过程称为序列化，将JSON 字符串转化成对象的过程称为反序列化。</p></blockquote><h2 id="Gson基本使用"><a href="#Gson基本使用" class="headerlink" title="Gson基本使用"></a>Gson基本使用</h2><p>使用 Gson 框架进行序列化与反序列操作，都离不开 <code>com.google.gson.Gson</code> 对象，它也是 Gson 框架的关键对象，提供的公共 API 具备了多种序列化和反序列方式。</p><p>Gson 对象的创建主要有两种方式：</p><ul><li>使用 <strong>new</strong> 关键字直接创建：<code>Gson gson = new Gson()</code></li><li>由 <code>GsonBuilder</code> 对象构建：<code>Gson gson = new GsonBuilder().create()</code></li></ul><p>通常情况下，上面两种方式创建的 Gson 对象在进行序列化与反序列操作时行为都是一样的，但是第二种方式构建 Gson 对象时，允许进行额外的行为定制，比如格式化 JSON 字符串的输出内容，是否序列化 <strong>null</strong> 值等等。</p><h3 id="Java序列化"><a href="#Java序列化" class="headerlink" title="Java序列化"></a>Java序列化</h3><h4 id="简单对象的序列化"><a href="#简单对象的序列化" class="headerlink" title="简单对象的序列化"></a>简单对象的序列化</h4><p>通过下面的例子来看下通过上述两种方式序列化 Java 对象的不同效果：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResultTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test_serialization</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Gson gson = <span class="keyword">new</span> Gson();</span><br><span class="line">        Result result = <span class="keyword">new</span> Result(<span class="number">200</span>, <span class="string">&quot;成功&quot;</span>, <span class="keyword">null</span>);</span><br><span class="line">        String json = gson.toJson(result);</span><br><span class="line">        System.out.println(<span class="string">&quot;json is &quot;</span> + json);</span><br><span class="line">      </span><br><span class="line">        Gson buildedGson = <span class="keyword">new</span> GsonBuilder().setPrettyPrinting().serializeNulls().create();</span><br><span class="line">        String buildedJson = buildedGson.toJson(result);</span><br><span class="line">        System.out.println(<span class="string">&quot;buildedJson is &quot;</span> + buildedJson);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Result</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> code;</span><br><span class="line">        <span class="keyword">private</span> String message;</span><br><span class="line">        <span class="keyword">private</span> Object data;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Result</span><span class="params">(<span class="keyword">int</span> code, String message, Object data)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.code = code;</span><br><span class="line">            <span class="keyword">this</span>.message = message;</span><br><span class="line">            <span class="keyword">this</span>.data = data;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从结果可以看出，默认的 Gson 对象行为序列化对象时会将 <code>null</code> 值的字段忽略，而 <code>com.google.gson.GsonBuilder#serializeNulls</code> 方法将允许 Gson 对象序列化 <code>null</code> 字段；并且正常序列化后的 JSON 字符串是紧凑格式，节省字符串内存，使用 <code>com.google.gson.GsonBuilder#setPrettyPrinting</code> 方法之后最终输出的 JSON 字符串是更易读的格式。当然除了这两个方法，GsonBuilder 还提供了许多定制序列化和反序列化行为的API。</p><h4 id="JosnObject-生成-JSON"><a href="#JosnObject-生成-JSON" class="headerlink" title="JosnObject 生成 JSON"></a>JosnObject 生成 JSON</h4><p>除了上述将自定义类的对象转换成 JSON 的方式之外，还可以使用 Gson 框架提供的 JsonObject 构建普通对象，然后使用 <code>toJson</code> 方法生成 JSON 字符串，在原测试类中补充下方测试类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_jsonObject_serialization</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Gson gson = <span class="keyword">new</span> Gson();</span><br><span class="line">  JsonObject jsonObject = <span class="keyword">new</span> JsonObject();</span><br><span class="line">  jsonObject.addProperty(<span class="string">&quot;code&quot;</span>, <span class="number">400</span>);</span><br><span class="line">  jsonObject.addProperty(<span class="string">&quot;message&quot;</span>, <span class="string">&quot;参数错误&quot;</span>);</span><br><span class="line">  String toJson = gson.toJson(jsonObject);</span><br><span class="line">  String exceptedJson = <span class="string">&quot;&#123;\&quot;code\&quot;:400,\&quot;message\&quot;:\&quot;参数错误\&quot;&#125;&quot;</span>;</span><br><span class="line">  Assertions.assertEquals(exceptedJson, toJson); <span class="comment">//true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JsonObject 使用 <code>addProperty(property,value)</code> 方法只能用来添加 String，Number，Boolean，Character这四类数据， 因为内部是调用 <code>com.google.gson.JsonObject#add</code>, 将 value 封装成了 JsonPrimitive 对象，然后保存到了内部自定义的 <code>LinkedTreeMap</code> 集合变量 members 中；如果需要在 JsonObject 对象上添加其他对象时，就需要直接使用 <code>add(String property, JsonElement value)</code> 方法添加一个 JsonElement 对象。这里的 JsonElement 是一个抽象类，JsonObject 和 JsonPrimitive 都继承了JsonElement，所以我们最终通过另外的 JsonObject 对象来作为原 JsonObject 上的属性对象：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Gson gson = <span class="keyword">new</span> Gson();</span><br><span class="line">JsonObject jsonObject = <span class="keyword">new</span> JsonObject();</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">JsonObject nestJsonObject = <span class="keyword">new</span> JsonObject();</span><br><span class="line">nestJsonObject.addProperty(<span class="string">&quot;username&quot;</span>, <span class="string">&quot;one&quot;</span>);</span><br><span class="line">nestJsonObject.addProperty(<span class="string">&quot;score&quot;</span>, <span class="number">99</span>);</span><br><span class="line">jsonObject.add(<span class="string">&quot;data&quot;</span>, nestJsonObject);</span><br><span class="line">String toJson2 = gson.toJson(jsonObject);</span><br><span class="line">System.out.println(toJson2);</span><br><span class="line"><span class="comment">// &#123;&quot;code&quot;:400,&quot;message&quot;:&quot;参数错误&quot;,&quot;data&quot;:&#123;&quot;username&quot;:&quot;one&quot;,&quot;score&quot;:99&#125;&#125;</span></span><br></pre></td></tr></table></figure><h3 id="JSON-反序列化"><a href="#JSON-反序列化" class="headerlink" title="JSON 反序列化"></a>JSON 反序列化</h3><h4 id="简单对象的反序列化"><a href="#简单对象的反序列化" class="headerlink" title="简单对象的反序列化"></a>简单对象的反序列化</h4><p>现在我们再来看下 JSON 反序列化成 Java 对象用法，这里主要使用方法是 <code>com.google.gson.Gson#fromJson</code>，它最基础的用法就是 <code>fromJson(String json, Class&lt;T&gt; classOfT)</code>，尝试将 JSON 字符串转为指定 Class 的对象，如果转换失败，就会抛出 <code>JsonSyntaxException</code> 异常。我们可以在原来代码上新增一个测试用例，运行看下效果：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_deserialization</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String json = <span class="string">&quot;&#123;\&quot;code\&quot;:400,\&quot;message\&quot;:\&quot;参数错误\&quot;&#125;&quot;</span>;</span><br><span class="line">    Result result = <span class="keyword">new</span> Gson().fromJson(json, Result.class);</span><br><span class="line">    Assertions.assertEquals(<span class="number">400</span>, result.code); <span class="comment">// true</span></span><br><span class="line">    Assertions.assertEquals(<span class="string">&quot;参数错误&quot;</span>, result.message); <span class="comment">// true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="反序列化-Map"><a href="#反序列化-Map" class="headerlink" title="反序列化 Map"></a>反序列化 Map</h4><p>除了将JSON 字符串序列化为自定义的Java 对象之外，我们还可以转为 Map 集合，Gson 提供了对 Map 集合的转换，使用起来也十分简单：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_map</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String jsonString = <span class="string">&quot;&#123;&#x27;employee.name&#x27;:&#x27;one&#x27;,&#x27;employee.salary&#x27;:10&#125;&quot;</span>;</span><br><span class="line">    Gson gson = <span class="keyword">new</span> Gson();</span><br><span class="line">    Map map = gson.fromJson(jsonString, Map.class);</span><br><span class="line">    assertEquals(<span class="number">2</span>, map.size());</span><br><span class="line">assertEquals(<span class="string">&quot;one&quot;</span>, map.get(<span class="string">&quot;employee.name&quot;</span>));</span><br><span class="line">    assertEquals(Double.class, map.get(<span class="string">&quot;employee.name&quot;</span>).getClass());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是转换后的 Map 对象真实类型并不是我们经常用的 HashMap，而是 Gson 自定义集合<code>LinkedTreeMap</code> ，它实现Map 接口来存储键值对，在新增和删除上实现上进行了优化，并且将存储键值对的顺序作为遍历顺序，也就是先存入的先被遍历到。除此之外，JSON 字符串里的数值型数据都会转转换为 Double 类型，而 <code>true/false</code> 数据被会被转换成 Boolean 类型，具体判断依据可以参考 <code>com.google.gson.internal.bind.ObjectTypeAdapter#read</code> 方法的实现。</p><h3 id="JSON-与-Array，List-转换"><a href="#JSON-与-Array，List-转换" class="headerlink" title="JSON 与 Array，List 转换"></a>JSON 与 Array，List 转换</h3><h4 id="JSON-转换-Array"><a href="#JSON-转换-Array" class="headerlink" title="JSON 转换 Array"></a>JSON 转换 Array</h4><p>当我们正对 JSON 数据进行数组转换时，类似普通对象转换的方式即可， <code>toJson</code> 方法直接使用转为 JSON 数据，<code>fromJson</code> 指定数组类型转换为对应类型的数组。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_array</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Gson gson = <span class="keyword">new</span> Gson();</span><br><span class="line">  <span class="keyword">int</span>[] ints = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">  String[] strings = &#123;<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;def&quot;</span>, <span class="string">&quot;ghi&quot;</span>&#125;;</span><br><span class="line">  String s = gson.toJson(ints);<span class="comment">// [1,2,3,4,5]</span></span><br><span class="line">  assertEquals(<span class="string">&quot;[1,2,3,4,5]&quot;</span>, s); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">  String s1 = gson.toJson(strings);<span class="comment">// [&quot;abc&quot;, &quot;def&quot;, &quot;ghi&quot;]</span></span><br><span class="line">  assertEquals(<span class="string">&quot;[\&quot;abc\&quot;,\&quot;def\&quot;,\&quot;ghi\&quot;]&quot;</span>, s1);</span><br><span class="line">  String[] strings1 = gson.fromJson(s1, String[].class);</span><br><span class="line">  assertEquals(strings.length, strings1.length); <span class="comment">// true</span></span><br><span class="line">  assertEquals(strings[<span class="number">0</span>], strings1[<span class="number">0</span>]); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span>[] ints2 = gson.fromJson(<span class="string">&quot;[1,2,3,4,5]&quot;</span>, <span class="keyword">int</span>[].class);</span><br><span class="line">  assertEquals(<span class="number">1</span>, ints2[<span class="number">0</span>]); <span class="comment">// true</span></span><br><span class="line">  assertEquals(<span class="number">5</span>, ints2[<span class="number">4</span>]); <span class="comment">// true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="JSON-转换-List"><a href="#JSON-转换-List" class="headerlink" title="JSON 转换 List"></a>JSON 转换 List</h4><p>要将 List 数据转换为 JSON数据，使用 Gson 的方式与处理 Array 数据一样；这里主要讲的是将JSON 数据转为 List 对象的操作略有不同，要将一个 JSON 数组数据转换为一个自定义类的List 时，我们按照原来的写法如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">givenJsonString_whenIncorrectDeserializing</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Gson gson = <span class="keyword">new</span> Gson();</span><br><span class="line">    String inputString = <span class="string">&quot;[&#123;\&quot;id\&quot;:1,\&quot;name\&quot;:\&quot;one\&quot;&#125;,&#123;\&quot;id\&quot;:2,\&quot;name\&quot;:\&quot;two\&quot;&#125;]&quot;</span>;</span><br><span class="line">    List&lt;Person&gt; outputList = gson.fromJson(inputString, List.class);</span><br><span class="line">outputList.get(<span class="number">0</span>).getId();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是不幸的是，运行这段代码后会抛出 <code>ClassCastException</code> 异常，具体描述如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java.lang.ClassCastException: com.google.gson.internal.LinkedTreeMap cannot be cast to com.one.learn.Person</span><br></pre></td></tr></table></figure><p>从上述描述中我们可以知道执行 <code>fromJson</code> 之后，反序列化后得到的 List 元素类型为 LinkedTreeMap，而不是 Person，所以以 Person 对象方式访问 id 属性时就会抛出 <code>ClassCastException</code> 异常。那又该如何处理呢,   我们需要调用 Gson 的 另外一个 <code>fromJson</code> 方法：<code>fromJson(String json, Type typeOfT)</code> ，先看下使用方式</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">givenJsonString_whenCorrectDeserializing_</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Gson gson = <span class="keyword">new</span> Gson();</span><br><span class="line">  String inputString = <span class="string">&quot;[&#123;\&quot;id\&quot;:1,\&quot;name\&quot;:\&quot;one\&quot;&#125;,&#123;\&quot;id\&quot;:2,\&quot;name\&quot;:\&quot;two\&quot;&#125;]&quot;</span>;</span><br><span class="line">  Type type = <span class="keyword">new</span> TypeToken&lt;List&lt;Person&gt;&gt;()&#123;&#125;.getType();</span><br><span class="line">  List&lt;Person&gt; outputList = gson.fromJson(inputString, type);</span><br><span class="line">  <span class="keyword">int</span> id = outputList.get(<span class="number">0</span>).getId();</span><br><span class="line">  assertEquals(<span class="number">1</span>, id); <span class="comment">// true</span></span><br><span class="line">  assertEquals(<span class="string">&quot;one&quot;</span>, outputList.get(<span class="number">0</span>).getName()); <span class="comment">// true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法中的 Type 对象通过 TypeToken 对象的 <code>getType</code> 方法获取到，就是 TypeToken 对象所关联的泛型类型。而这里 TypeToken 是 Gson 为了支持泛型而引入的类，来解决 Java 无法提供泛型类型表示的问题，由于 TypeToken 的构造方法是<code>protected</code>修饰的，无法直接构造，使用就需要写成<code>new TypeToken&lt;List&lt;String&gt;&gt;() &#123;&#125;.getType()</code>  形式。</p><h2 id="Gson进阶用法"><a href="#Gson进阶用法" class="headerlink" title="Gson进阶用法"></a>Gson进阶用法</h2><p>接触了 Gson 基本的使用之后，我们接着进一步学习 Gson 的其他用法。</p><h3 id="泛型对象反序列化"><a href="#泛型对象反序列化" class="headerlink" title="泛型对象反序列化"></a>泛型对象反序列化</h3><p>简单接触了 Gson 对泛型的支持，接下来用代码来展示下它的强大之处，首先我们将上文的 Result 类调整下接受泛型参数：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Result</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> code;</span><br><span class="line">  <span class="keyword">private</span> String message;</span><br><span class="line">  <span class="keyword">private</span> T data;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Result</span><span class="params">(<span class="keyword">int</span> code, String message, T data)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.code = code;</span><br><span class="line">    <span class="keyword">this</span>.message = message;</span><br><span class="line">    <span class="keyword">this</span>.data = data;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后对一个有内嵌对象的 JSON字符串进行解析成 Result<User> 对象，示例代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_genric_object</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  String json = <span class="string">&quot;&#123;\&quot;code\&quot;:200,\&quot;message\&quot;:\&quot;操作成功\&quot;,\&quot;data\&quot;:&#123;\&quot;username\&quot;: \&quot;one\&quot;,\&quot;avater\&quot;: \&quot;image.jpg\&quot;&quot;</span> +</span><br><span class="line">    <span class="string">&quot;&#125;&#125;&quot;</span>;</span><br><span class="line">  Type type = <span class="keyword">new</span> TypeToken&lt;Result&lt;User&gt;&gt;()&#123;&#125;.getType();</span><br><span class="line">  Result&lt;User&gt; result = <span class="keyword">new</span> Gson().fromJson(json, type);</span><br><span class="line">  Assertions.assertEquals(<span class="number">200</span>, result.code);</span><br><span class="line">  Assertions.assertEquals(<span class="string">&quot;one&quot;</span>, result.data.getUsername());</span><br><span class="line">  Assertions.assertEquals(<span class="string">&quot;image.jpg&quot;</span>, result.data.getAvater());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String username;</span><br><span class="line">  <span class="keyword">private</span> String avater;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getUsername</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> username;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getAvater</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> avater;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用 TypeToken 对象获取具体泛型类型 Result<User> , 然后在 <code>fromJson</code> 方法中传入就会根据对应类型的执行反序列化操作。</p><h3 id="自定义序列化"><a href="#自定义序列化" class="headerlink" title="自定义序列化"></a>自定义序列化</h3><p>要对Java 对象的某些字段进行特殊处理，比如隐藏某些字段的序列化，对字段的数据格式化处理等，我们可以通过实现 JsonSerializer 接口，对序列化逻辑进行自定义。例如，我们需要对 Date 类型属性进行特定格式的处理，可以声明 DateSerializer 类实现如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DateSerializer</span> <span class="keyword">implements</span> <span class="title">JsonSerializer</span>&lt;<span class="title">Date</span>&gt; </span>&#123;</span><br><span class="line">    SimpleDateFormat dateTime = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> JsonElement <span class="title">serialize</span><span class="params">(Date src, Type typeOfSrc, </span></span></span><br><span class="line"><span class="function"><span class="params">                                 JsonSerializationContext context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JsonPrimitive(dateTime.format(src));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在构建 Gson 对象前，利用 GsonBuilder 将 DateSerializer 实例进行注册，使用方式如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Gson gson = <span class="keyword">new</span> GsonBuilder()</span><br><span class="line">    .registerTypeAdapter(Date.class, <span class="keyword">new</span> DateSerializer())</span><br><span class="line">    .create();</span><br></pre></td></tr></table></figure><p>这样一来，一旦遇到要序列化 Date 类型的字段时，都会通过自定义的 <code>serialize</code> 方法将日期以 <code>yyyy-MM-dd</code> 格式进行输出，如下方的示例代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_dateSerializer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  MyObject myObject = <span class="keyword">new</span> MyObject(<span class="keyword">new</span> Date(), <span class="string">&quot;one&quot;</span>);</span><br><span class="line">  Gson gson = <span class="keyword">new</span> GsonBuilder().registerTypeAdapter(Date.class, <span class="keyword">new</span> DateSerializer()).create();</span><br><span class="line">  String json = gson.toJson(myObject);</span><br><span class="line">  String exceptedJson = <span class="string">&quot;&#123;\&quot;date\&quot;:\&quot;2019-09-08\&quot;,\&quot;name\&quot;:\&quot;one\&quot;&#125;&quot;</span>;</span><br><span class="line">  Assertions.assertEquals(exceptedJson, json); <span class="comment">// true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyObject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Date date;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyObject</span><span class="params">(Date date, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.date = date;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyObject</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="自定义反序列化"><a href="#自定义反序列化" class="headerlink" title="自定义反序列化"></a>自定义反序列化</h3><p>与自定义序列化实现方式类似，想要自定义反序列化逻辑，就需要同样要实现一个叫 JsonDeserializer 的接口，进行自定义反序列化逻辑的实现。比如现在有个 JSON 字符串内容为 <code>&#123;&quot;CODE&quot;: 400, &quot;MESSAGE&quot;: &quot;参数错误&quot;&#125;</code>，需要被反序列化为前文提到的 Result 对象，由于字段名不一样，为了实现对应的转换，就需要自定义 ResultDeserializer 类，具体实现如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ResultDeserializer</span> <span class="keyword">implements</span> <span class="title">JsonDeserializer</span>&lt;<span class="title">Result</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Result <span class="title">deserialize</span><span class="params">(JsonElement json, </span></span></span><br><span class="line"><span class="function"><span class="params">                              Type typeOfT, </span></span></span><br><span class="line"><span class="function"><span class="params">                              JsonDeserializationContext context)</span> <span class="keyword">throws</span> JsonParseException </span>&#123;</span><br><span class="line">        JsonObject object = json.getAsJsonObject();</span><br><span class="line">        Result&lt;Object&gt; result = <span class="keyword">new</span> Result&lt;&gt;(object.getAsJsonPrimitive(<span class="string">&quot;CODE&quot;</span>)</span><br><span class="line">                                             .getAsInt(),</span><br><span class="line">                                             object.getAsJsonPrimitive(<span class="string">&quot;MESSAGE&quot;</span>)</span><br><span class="line">                                             .getAsString(), <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来就是利用 GsonBuilder 注册 ResultDeserializer 实例，生成对应的 Gson 对象，并进行反序列化操作：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_resultDeserializer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//language=JSON</span></span><br><span class="line">String json = <span class="string">&quot;&#123;\&quot;CODE\&quot;: 400,\&quot;MESSAGE\&quot;: \&quot;参数错误\&quot;&#125;&quot;</span>;</span><br><span class="line">    Gson gson = <span class="keyword">new</span> GsonBuilder().registerTypeAdapter(Result.class, <span class="keyword">new</span> ResultDeserializer())</span><br><span class="line">            .create();</span><br><span class="line">    Result result = gson.fromJson(json, Result.class);</span><br><span class="line">    Assertions.assertEquals(<span class="number">400</span>, result.code); <span class="comment">// true</span></span><br><span class="line">    Assertions.assertEquals(<span class="string">&quot;参数错误&quot;</span>, result.message); <span class="comment">// true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Gson常用注解"><a href="#Gson常用注解" class="headerlink" title="Gson常用注解"></a>Gson常用注解</h2><p>Gson 除了提供一些 API 供开发者使用之外，还有一些具有特性的注解可以使用，接下来就介绍在 Gson 中最常用的注解。</p><h3 id="Expose"><a href="#Expose" class="headerlink" title="@Expose"></a>@Expose</h3><p>这个注解只能用在字段上，作用就是注明对应的字段是否将在序列化或者反序列化时暴露出来，有两个属性 <code>serialize</code> 和 <code>deserialize</code> ，默认都为 true。当给一个字段加上 注解<code>@Expose(serialize = true, deserialize = false)</code>，则表示了该字段尽在序列化时可见，在反序列化时会忽略赋值。需要额外注意的一点是，@Expose 注解只有在用 GsonBuilder 方式构建 Gson 时有限，并且构建前必须调用 <code>excludeFieldsWithoutExposeAnnotation</code> 方法，下面是具体的使用示例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_expose</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MySubClass subclass = <span class="keyword">new</span> MySubClass(<span class="number">42L</span>, <span class="string">&quot;the answer&quot;</span>, <span class="string">&quot;Verbose field not to serialize&quot;</span>);</span><br><span class="line">    MyClass source = <span class="keyword">new</span> MyClass(<span class="number">1L</span>, <span class="string">&quot;foo&quot;</span>, <span class="string">&quot;bar&quot;</span>, subclass);</span><br><span class="line">    Gson gson = <span class="keyword">new</span> GsonBuilder().excludeFieldsWithoutExposeAnnotation().create();</span><br><span class="line">    String s = gson.toJson(source);</span><br><span class="line">    System.out.println(s);</span><br><span class="line"><span class="comment">// &#123;&quot;id&quot;:1,&quot;name&quot;:&quot;foo&quot;,&quot;subclass&quot;:&#123;&quot;id&quot;:42,&quot;description&quot;:&quot;the answer&quot;,&quot;otherVerboseInfo&quot;:&quot;Verbose field not to serialize&quot;&#125;&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> id;</span><br><span class="line">    <span class="meta">@Expose(serialize = false, deserialize = true)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> String other;</span><br><span class="line">    <span class="meta">@Expose</span></span><br><span class="line">    <span class="keyword">private</span> MySubClass subclass;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MySubClass</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Expose</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> id;</span><br><span class="line">    <span class="meta">@Expose</span></span><br><span class="line">    <span class="keyword">private</span> String description;</span><br><span class="line">    <span class="meta">@Expose</span></span><br><span class="line">    <span class="keyword">private</span> String otherVerboseInfo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在 Gson 中 <code>transient</code> 关键字修饰的字段默认不会被序列化和反序列化，这个行为是与 Java 原生的序列化和反序列化操作一致的。</p></blockquote><h3 id="Since"><a href="#Since" class="headerlink" title="@Since"></a>@Since</h3><p>该注解用于标记对应字段或者类型的版本，让 Gson 可以指定版本号进行序列化和反序列化操作。当Web服务上的 JSON 数据对应的类存在多个版本的字段时，这个注解就十分有用。</p><p>同样地，该注解只针对使用 <code>GsonBuilder</code> 方式构建的 Gson 对象，并且使用 <code>setVersion</code> 方法指明版本号时有效，只解析对象中对应版本的字段，下面为具体示例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VersioningSupportTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        VersionedClass versionedObject = <span class="keyword">new</span> VersionedClass();</span><br><span class="line">        Gson gson = <span class="keyword">new</span> GsonBuilder().setVersion(<span class="number">1.0</span>).create();</span><br><span class="line">        String jsonOutput = gson.toJson(versionedObject);</span><br><span class="line">        System.out.println(jsonOutput); <span class="comment">// &#123;&quot;newField&quot;:&quot;new&quot;,&quot;field&quot;:&quot;old&quot;&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VersionedClass</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Since(1.1)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String newerField;</span><br><span class="line">    <span class="meta">@Since(1.0)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String newField;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String field;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">VersionedClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.newerField = <span class="string">&quot;newer&quot;</span>;</span><br><span class="line">        <span class="keyword">this</span>.newField = <span class="string">&quot;new&quot;</span>;</span><br><span class="line">        <span class="keyword">this</span>.field = <span class="string">&quot;old&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="SerializedName"><a href="#SerializedName" class="headerlink" title="@SerializedName"></a>@SerializedName</h3><p>这个注解使用起来比较简单，也很有用。@SerializedName 指定了成员字段被序列化和反序列化时所采用的名称下面是具体使用方式：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JSONFieldNamingSupportTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">SomeObject</span> </span>&#123;</span><br><span class="line">        <span class="meta">@SerializedName(&quot;custom_naming&quot;)</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> String someField;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> String someOtherField;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">SomeObject</span><span class="params">(String a, String b)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.someField = a;</span><br><span class="line">            <span class="keyword">this</span>.someOtherField = b;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        SomeObject someObject = <span class="keyword">new</span> SomeObject(<span class="string">&quot;first&quot;</span>, <span class="string">&quot;second&quot;</span>);</span><br><span class="line">        String jsonRepresentation = gson.toJson(someObject);</span><br><span class="line">        System.out.println(jsonRepresentation);</span><br><span class="line">      <span class="comment">// &#123;&quot;custom_naming&quot;:&quot;first&quot;,&quot;someOtherField&quot;:&quot;second&quot;&#125;</span></span><br><span class="line">        SomeObject someObject1 = gson.fromJson(jsonRepresentation, SomeObject.class);</span><br><span class="line">        System.out.println(someObject1);</span><br><span class="line">      <span class="comment">// SomeObject&#123;someField=&#x27;first&#x27;, someOtherField=&#x27;second&#x27;&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="JsonAdapter"><a href="#JsonAdapter" class="headerlink" title="@JsonAdapter"></a>@JsonAdapter</h3><p><code>@JsonAdapter</code> 主要作用就是代替  <code>GsonBuilder.registerTypeAdapter</code> 方法的执行，直接通过 <code>@JsonAdapter(aClass.class)</code> 方式指定 JsonDeserializer 对象或者 JsonSerializer 对象，可以起到相同的作用，并且优先级比<code>GsonBuilder.registerTypeAdapter</code>的优先级更高，由于只是将 <code>registerTypeAdapter</code>方法执行简化成了注解方法，这里就不再演示，直接在前文<strong>自定义反序列化</strong>一节的 Result 类上使用就可以看到效果。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>^_^.</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="https://juejin.im/post/5d764dcc6fb9a06b130f4b2a#heading-0">除了FastJson,你还有选择: Gson简易指南</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 笔记本 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Gson </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SonarQube的安装与使用</title>
      <link href="post/4084397208/"/>
      <url>post/4084397208/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>随着代码量的越来越多，同时对代码质量的要求也越来越高，对于代码<code>review</code>的需求越来越多。因此，引入<code>SonarQube</code>这个工具对Java代码进行质量管控。</p><blockquote><p><strong>SonarQube</strong>（曾用名<strong>Sonar</strong>（声纳））是一个<a href="https://zh.wikipedia.org/wiki/%E5%BC%80%E6%BA%90">开源</a>的<a href="https://zh.wikipedia.org/wiki/%E8%BD%AF%E4%BB%B6%E8%B4%A8%E9%87%8F">代码质量</a>管理系统。</p></blockquote><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="前置条件"><a href="#前置条件" class="headerlink" title="前置条件"></a>前置条件</h3><ul><li>系统环境：Centos 7</li><li>Java环境：1.8</li><li>SonarQube版本：6.7.7</li></ul><blockquote><p>由于最新版的SonarQube7.9要求Java环境必须是Java11以上，我们目前开发使用的是1.8，所以选用较低版本的6.7.7</p></blockquote><h3 id="创建sonar用户"><a href="#创建sonar用户" class="headerlink" title="创建sonar用户"></a>创建sonar用户</h3><p>由于sonar用到了<code>es</code>，不允许直接使用root用户运行，因此，需要在linux下，创建sonar用户，专门用来运行sonar程序。</p><p><em>假设当前使用的是root用户登录：</em></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">useradd sonar</span><br><span class="line">passwd sonar</span><br><span class="line">su sonar</span><br></pre></td></tr></table></figure><h3 id="安装mysql数据库，创建sonar库"><a href="#安装mysql数据库，创建sonar库" class="headerlink" title="安装mysql数据库，创建sonar库"></a>安装mysql数据库，创建sonar库</h3><p>1、mysql的安装步骤：<a href="/2018/05/27/2018052701/">记录Linux安装Mysql全过程</a></p><p>2、创建sonar库</p><p>​    创建sonar数据库，用于保存soanrqube的扫描数据</p><h3 id="安装sonarqube"><a href="#安装sonarqube" class="headerlink" title="安装sonarqube"></a>安装sonarqube</h3><p>1、将sonar6.7.7安装包拉到<code>/opt/SonarQube</code>目录</p><p>2、解压</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">unzip sonarqube-6.7.7.zip</span><br></pre></td></tr></table></figure><p>3、修改配置</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vi ./sonarqube-6.7.7/conf/sonar.properties</span><br></pre></td></tr></table></figure><p>添加mysql配置：</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">#--------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># DATABASE</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># User credentials.</span></span><br><span class="line"><span class="comment"># Permissions to create tables, indices and triggers must be granted to JDBC user.</span></span><br><span class="line"><span class="comment"># The schema must be created first.</span></span><br><span class="line"><span class="meta">sonar.jdbc.username</span>=<span class="string">sonar</span></span><br><span class="line"><span class="meta">sonar.jdbc.password</span>=<span class="string">*******</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#----- MySQL 5.6 or greater</span></span><br><span class="line"><span class="comment"># Only InnoDB storage engine is supported (not myISAM).</span></span><br><span class="line"><span class="comment"># Only the bundled driver is supported. It can not be changed.</span></span><br><span class="line"><span class="meta">sonar.jdbc.url</span>=<span class="string">jdbc:mysql://localhost:3306/sonar?useUnicode=true&amp;characterEncoding=utf8&amp;rewriteBatchedStatements=true&amp;useConfigs=maxPerformance&amp;useSSL=false</span></span><br></pre></td></tr></table></figure><blockquote><p>省略了不需要展示的部分</p></blockquote><h3 id="创建软连接"><a href="#创建软连接" class="headerlink" title="创建软连接"></a>创建软连接</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ln -s /opt/SonarQube/sonarqube-6.7.7/bin/linux-x86-64/sonar.sh /usr/bin/sonar</span><br></pre></td></tr></table></figure><h3 id="运行sonar"><a href="#运行sonar" class="headerlink" title="运行sonar"></a>运行sonar</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sonar start</span><br></pre></td></tr></table></figure><p>重启 <code>sonar restart</code></p><p>停止 <code>sonar stop</code></p><p>查看状态 <code>sonar status</code></p><h3 id="可能遇到的问题"><a href="#可能遇到的问题" class="headerlink" title="可能遇到的问题"></a>可能遇到的问题</h3><ul><li><p>没有目录权限：</p><p><em>将目录授权给sonar用户:</em></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">su root</span><br><span class="line">chown -R sonar /opt/SonarQube</span><br></pre></td></tr></table></figure></li><li><p>没有操作权限</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">chmod a+x /opt/SonarQube/sonarqube-6.7.7/bin/linux-x86-64/sonar.sh</span><br><span class="line">chmod a+x /opt/SonarQube/sonarqube-6.7.7/bin/linux-x86-64/wrapper</span><br><span class="line">chmod a+x /opt/SonarQube/sonarqube-6.7.7/elasticsearch/bin/elasticsearch</span><br></pre></td></tr></table></figure></li><li><p>数据库问题</p><p><em>录数据库后执行：</em></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SET GLOBAL max_allowed_packet &#x3D; 4*1024*1024*16</span><br></pre></td></tr></table></figure></li></ul><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h3><p>扫描Java的maven项目，首先要在<code>pom.xml</code>中添加配置：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.sonarsource.scanner.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>sonar-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.3.0.603<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="使用logintoken扫描"><a href="#使用logintoken扫描" class="headerlink" title="使用logintoken扫描"></a>使用logintoken扫描</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mvn sonar:sonar \</span><br><span class="line">  -Dsonar.host.url=http://10.0.2.91:9000 \</span><br><span class="line">  -Dsonar.login=youtoken</span><br></pre></td></tr></table></figure><p>其中<code>youtoken</code>可以在登录sonar后台后找到：<code>我的账号 - 安全</code></p><p><img src="https://gitee.com/cayzlh/img-repo/raw/master/2020/05/29/1_bxS48X.png" alt="token"></p><h4 id="设置settings-xml扫描"><a href="#设置settings-xml扫描" class="headerlink" title="设置settings.xml扫描"></a>设置settings.xml扫描</h4><p> 修改本地maven的<code>settings.xml</code>文件，添加配置：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">pluginGroups</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">pluginGroup</span>&gt;</span>org.sonarsource.scanner.maven<span class="tag">&lt;/<span class="name">pluginGroup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">pluginGroups</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">profiles</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>sonar<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">activation</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">activeByDefault</span>&gt;</span>true<span class="tag">&lt;/<span class="name">activeByDefault</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">activation</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 配置 Sonar Host地址，默认：http://localhost:9000 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">sonar.host.url</span>&gt;</span></span><br><span class="line">                http://10.0.2.91:9000</span><br><span class="line">            <span class="tag">&lt;/<span class="name">sonar.host.url</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">profiles</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后执行：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mvn clean verify sonar:sonar</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mvn clean install sonar:sonar</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mvn clean -Dmaven.test.skip=<span class="literal">true</span> verify sonar:sonar</span><br></pre></td></tr></table></figure><p>或在IDEA中执行maven插件：</p><p><img src="https://gitee.com/cayzlh/img-repo/raw/master/2020/05/29/2_HhJkOr.png" alt="idea sonar plugin"></p><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>扫描完成后，登录sonar后台，将可以看到本次扫描的项目，和相应的分析：</p><p><img src="https://gitee.com/cayzlh/img-repo/raw/master/2020/05/29/3_TTSvPo.png" alt="sonar"></p><h4 id="over"><a href="#over" class="headerlink" title="over"></a>over</h4><p> ^_^.</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://blog.csdn.net/aixiaoyang168/article/details/77565756">SonarQube 的安装、配置及 Maven 项目的使用</a></li><li><a href="https://www.sonarqube.org/">SonarQube官网</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 笔记本 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> SonarQube </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用Spring读取文件的几种方式</title>
      <link href="post/1399731042/"/>
      <url>post/1399731042/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>在业务开发中经常有可能读取一些自定义配置或者文件。比如说公私钥文件、一些固定的词典文件之类的，这一类统称为资源（Resource）。Spring自带有资源加载功能，甚至还有非常便利的方法将读取的内容注入Spring bean。</p><blockquote><p>整理网络上相关方法与自身实践的实践</p></blockquote><h2 id="通过Resource接口读取文件"><a href="#通过Resource接口读取文件" class="headerlink" title="通过Resource接口读取文件"></a>通过Resource接口读取文件</h2><p>我们可以使用<strong>org.springframework.core.io.Resource</strong>接口简化资源文件的定位。Spring帮助我们使用资源加载器查找和读取资源，资源加载器根据提供的路径决定选择哪个Resource实现。</p><h3 id="使用Resource的实现类"><a href="#使用Resource的实现类" class="headerlink" title="使用Resource的实现类"></a>使用Resource的实现类</h3><p> <strong>org.springframework.core.io.Resource</strong>接口常用的有两个实现类：</p><ul><li><p>org.springframework.core.io.ClassPathResource</p><p>用来加载<code>classpath</code>下的资源，直接读取<code>springboot</code> 配置文件 <code>application.properties</code>,其中已经写入了一个配置 <code>server.port=8080</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">classPathResourceTest</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    Resource resource = <span class="keyword">new</span> ClassPathResource(<span class="string">&quot;application.properties&quot;</span>);</span><br><span class="line">    InputStream inputStream = resource.getInputStream();</span><br><span class="line">    Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">    properties.load(inputStream);</span><br><span class="line">    properties.forEach((o, o2) -&gt; &#123;</span><br><span class="line">        Assertions.assertThat(o).isEqualTo(<span class="string">&quot;server.address&quot;</span>);</span><br><span class="line">        Assertions.assertThat(o2).isEqualTo(<span class="string">&quot;8080&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>org.springframework.core.io.FileSystemResource</p><p>用来加载系统文件，通常通过文件的绝对值或者相对路径来读取。<em>需要文件的路径。</em></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fileResourceTest</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    String path = <span class="string">&quot;/workspaces/springboot-demo/src/main/resources/application.properties&quot;</span>;</span><br><span class="line">    FileSystemResource resource = <span class="keyword">new</span> FileSystemResource(path);</span><br><span class="line">    InputStream inputStream = resource.getInputStream();</span><br><span class="line">    Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">    properties.load(inputStream);</span><br><span class="line">  properties.forEach((o,o2) -&gt; &#123;</span><br><span class="line">        Assertions.assertThat(o).isEqualTo(<span class="string">&quot;server.adderss&quot;</span>);</span><br><span class="line">        Assertions.assertThat(o2).isEqualTo(<span class="string">&quot;8080&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="使用ResourceLoader"><a href="#使用ResourceLoader" class="headerlink" title="使用ResourceLoader"></a>使用ResourceLoader</h3><p>使用<code>ResourceLoader</code>可以实现延迟加载：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">resourceLoaderTest</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    ResourceLoader resourceLoader = <span class="keyword">new</span> DefaultResourceLoader();</span><br><span class="line">    String location = <span class="string">&quot;application.properties&quot;</span>;</span><br><span class="line">    Resource resource = resourceLoader.getResource(location);</span><br><span class="line">    InputStream is = resource.getInputStream();</span><br><span class="line">    Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">    properties.load(is);</span><br><span class="line">    properties.forEach((o,o2) -&gt; &#123;</span><br><span class="line">        Assertions.assertThat(o).isEqualTo(<span class="string">&quot;server.adderss&quot;</span>);</span><br><span class="line">        Assertions.assertThat(o2).isEqualTo(<span class="string">&quot;8080&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以使用<code>@Autowired</code>将<code>ResourceLoader</code>注入为<code>bean</code>.</p><h3 id="使用-Value注解"><a href="#使用-Value注解" class="headerlink" title="使用@Value注解"></a>使用@Value注解</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Value(&quot;classpath:application.properties&quot;)</span></span><br><span class="line"><span class="keyword">private</span> Resource resource;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">resourceLoader</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    InputStream inputStream = resource.getInputStream;</span><br><span class="line">    Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">    properties.load(inputStream);</span><br><span class="line">    </span><br><span class="line">    properties.forEach((o,o2) -&gt; &#123;</span><br><span class="line">        Assertions.assertThat(o).isEqualTo(<span class="string">&quot;server.adderss&quot;</span>);</span><br><span class="line">        Assertions.assertThat(o2).isEqualTo(<span class="string">&quot;8080&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>^_^.</p>]]></content>
      
      
      <categories>
          
          <category> 笔记本 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Maven中Scope的分类</title>
      <link href="post/928941173/"/>
      <url>post/928941173/</url>
      
        <content type="html"><![CDATA[<h1 id="Scope的分类"><a href="#Scope的分类" class="headerlink" title="Scope的分类"></a>Scope的分类</h1><h2 id="compile"><a href="#compile" class="headerlink" title="compile"></a>compile</h2><p><strong>默认就是compile</strong>，什么都不配置也就是意味着compile。compile表示被依赖项目需要参与当前项目的编译，当然后续的测试，运行周期也参与其中，是一个比较强的依赖。打包的时候通常需要包含进去。</p><h2 id="test"><a href="#test" class="headerlink" title="test"></a>test</h2><p>scope为test表示依赖项目仅仅参与测试相关的工作，包括测试代码的编译，执行。比较典型的如junit。</p><h2 id="runntime"><a href="#runntime" class="headerlink" title="runntime"></a>runntime</h2><p>runntime表示被依赖项目无需参与项目的编译，不过后期的测试和运行周期需要其参与。与compile相比，<strong>跳过编译</strong>而已，说实话在终端的项目（非开源，企业内部系统）中，和compile区别不是很大。比较常见的如JSR×××的实现，对应的API jar是compile的，具体实现是runtime的，compile只需要知道接口就足够了。oracle jdbc驱动架包就是一个很好的例子，一般scope为runntime。另外runntime的依赖通常和optional搭配使用，optional为true。我可以用A实现，也可以用B实现。</p><h2 id="provided"><a href="#provided" class="headerlink" title="provided"></a>provided</h2><p>provided意味着打包的时候可以不用包进去，别的设施(Web Container)会提供。事实上该依赖理论上可以参与编译，测试，运行等周期。相当于compile，但是在打包阶段做了exclude的动作。</p><h2 id="system"><a href="#system" class="headerlink" title="system"></a>system</h2><p>从参与度来说，也provided相同，不过被依赖项不会从maven仓库抓，而是从本地文件系统拿，一定需<strong>要配合systemPath属性使用</strong>。</p><h2 id="scope的依赖传递"><a href="#scope的依赖传递" class="headerlink" title="scope的依赖传递"></a>scope的依赖传递</h2><p>A–&gt;B–&gt;C。当前项目为A，A依赖于B，B依赖于C。知道B在A项目中的scope，那么怎么知道C在A中的scope呢？答案是：<br> 当C是test或者provided时，C直接被丢弃，A不依赖C；<br> 否则A依赖C，C的scope继承于B的scope。</p><h2 id="import"><a href="#import" class="headerlink" title="import"></a>import</h2><p>在做SpringBoot应用的时候，都会有如下代码：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.3.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br></pre></td></tr></table></figure><p>继承一个父模块，然后再引入相应的依赖。</p><p>但是一般来说，自己的项目不会用springboot作为父maven；Maven的继承和Java的继承一样，是无法实现多重继承的，如果10个、20个甚至更多模块继承自同一个模块，那么按照我们之前的做法，这个父模块的dependencyManagement会包含大量的依赖。如果你想把这些依赖分类以更清晰的管理，那就不可能了，import scope依赖能解决这个问题。你可以把dependencyManagement放到单独的专门用来管理依赖的pom中，然后在需要使用依赖的模块中通过import scope依赖，就可以引入dependencyManagement。例如可以写这样一个用于依赖管理的pom：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.test.sample<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>base-parent1<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactid</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>4.8.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactid</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.16<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后我就可以通过非继承的方式来引入这段依赖管理配置</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.test.sample<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactid</span>&gt;</span>base-parent1<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactid</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactid</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>注意：import scope只能用在dependencyManagement里面</p></blockquote><p>父模块的pom就会非常干净，由专门的packaging为pom来管理依赖，也契合的面向对象设计中的单一职责原则。此外，还能够创建多个这样的依赖管理pom，以更细化的方式管理依赖。这种做法与面向对象设计中使用组合而非继承也有点相似的味道。</p><p>用这个方法来解决SpringBoot的那个继承问题：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.3.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这样配置的话，自己的项目里面就不需要继承SpringBoot的module了，而可以继承自己项目的module了。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记本 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Maven </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Springboot集成Shiro（前后端分离）</title>
      <link href="post/416884162/"/>
      <url>post/416884162/</url>
      
        <content type="html"><![CDATA[<h2 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h2><p><img src="https://github.com/cayzlh/git-img-repository/raw/master/blog/2019/04/1.png" alt="Shiro"></p><h2 id="什么是Shiro"><a href="#什么是Shiro" class="headerlink" title="什么是Shiro"></a>什么是Shiro</h2><p>shiro是apache的一个开源框架，是一个权限管理的框架，实现 用户认证、用户授权。</p><p>spring中有spring security (原名Acegi)，是一个权限框架，它和spring依赖过于紧密，没有shiro使用简单。</p><p>shiro不依赖于spring，shiro不仅可以实现 web应用的权限管理，还可以实现c/s系统，分布式系统权限管理，shiro属于轻量框架，越来越多企业项目开始使用shiro。 </p><p>使用shiro实现系统的权限管理，有效提高开发效率，从而降低开发成本。</p><blockquote><p>用户通过subject登陆，形成一个UsernamePasswordToken，令牌，在域realm里完成认证、授权，成功后加入缓存。（realm可以写、也可以用默认的，也可以写很多个域）</p></blockquote><p><img src="https://github.com/cayzlh/git-img-repository/raw/master/blog/2019/04/3.png" alt="Shiro"></p><h2 id="Shiro架构"><a href="#Shiro架构" class="headerlink" title="Shiro架构"></a>Shiro架构</h2><p><img src="https://github.com/cayzlh/git-img-repository/raw/master/blog/2019/04/2.png" alt="Shiro架构"></p><ul><li><p><strong>subject：</strong>主体，可以是用户也可以是程序，主体要访问系统，系统需要对主体进行认证、授权。</p></li><li><p><strong>securityManager：</strong>安全管理器，主体进行认证和授权都是通过securityManager进行。</p></li><li><p><strong>authenticator：</strong>认证器，主体进行认证最终通过authenticator进行的。</p></li><li><p><strong>authorizer：</strong>授权器，主体进行授权最终通过authorizer进行的。</p></li><li><p><strong>sessionManager：</strong>web应用中一般是用web容器对session进行管理，shiro也提供一套session管理的方式。</p></li><li><p><strong>SessionDao：</strong>  通过SessionDao管理session数据，针对个性化的session数据存储需要使用sessionDao。</p></li><li><p><strong>cache Manager：</strong>缓存管理器，主要对session和授权数据进行缓存，比如将授权数据通过cacheManager进行缓存管理，和ehcache整合对缓存数据进行管理。</p></li><li><p><strong>realm：</strong>域，领域，相当于数据源，通过realm存取认证、授权相关数据。</p><p><strong>在realm中存储授权和认证的逻辑。</strong></p></li></ul><h2 id="认证过程"><a href="#认证过程" class="headerlink" title="认证过程"></a>认证过程</h2><p><img src="https://github.com/cayzlh/git-img-repository/raw/master/blog/2019/04/4.png" alt="认证过程"></p><h3 id="认证执行流程"><a href="#认证执行流程" class="headerlink" title="认证执行流程"></a>认证执行流程</h3><p>1、通过ini配置文件创建securityManager</p><p>2、调用subject.login方法主体提交认证，提交的token</p><p>3、securityManager进行认证，securityManager最终由ModularRealmAuthenticator进行认证。</p><p>4、ModularRealmAuthenticator调用IniRealm(给realm传入token) 去ini配置文件中查询用户信息</p><p>5、IniRealm根据输入的token（UsernamePasswordToken）从 shiro.ini查询用户信息，根据账号查询用户信息（账号和密码）</p><pre><code>如果查询到用户信息，就给ModularRealmAuthenticator返回用户信息（账号和密码）如果查询不到，就给ModularRealmAuthenticator返回null</code></pre><p>6、ModularRealmAuthenticator接收IniRealm返回Authentication认证信息</p><p><strong>如果返回的认证信息是null，ModularRealmAuthenticator抛出异常（org.apache.shiro.authc.UnknownAccountException）</strong></p><p><strong>如果返回的认证信息不是null（说明inirealm找到了用户），对IniRealm返回用户密码 （在ini文件中存在）<br>和 token中的密码 进行对比，如果不一致抛出异常（org.apache.shiro.authc.IncorrectCredentialsException）</strong></p><h2 id="授权流程"><a href="#授权流程" class="headerlink" title="授权流程"></a>授权流程</h2><p><img src="https://github.com/cayzlh/git-img-repository/raw/master/blog/2019/04/5.png" alt="授权过程"></p><p>1、对subject进行授权，调用方法isPermitted（”permission串”）</p><p>2、SecurityManager执行授权，通过ModularRealmAuthorizer执行授权</p><p>3、ModularRealmAuthorizer执行realm（自定义的Realm）从数据库查询权限数据</p><p><strong>调用realm的授权方法：doGetAuthorizationInfo</strong></p><p>4、realm从数据库查询权限数据，返回ModularRealmAuthorizer</p><p>5、ModularRealmAuthorizer调用PermissionResolver进行权限串比对</p><p>6、如果比对后，isPermitted中”permission串”在realm查询到权限数据中，说明用户访问permission串有权限，否则 没有权限，抛出异常。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><blockquote><p>代码地址：<a href="https://github.com/cayzlh/spring-boot-shiro-demo">https://github.com/cayzlh/spring-boot-shiro-demo</a></p></blockquote><h3 id="自定义Realm"><a href="#自定义Realm" class="headerlink" title="自定义Realm"></a>自定义Realm</h3><p><strong>CustRealm：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomRealm</span> <span class="keyword">extends</span> <span class="title">AuthorizingRealm</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Lazy</span></span><br><span class="line">    <span class="keyword">private</span> AuthorizingService authorizingService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Shiro 的权限授权是通过继承AuthorizingRealm抽象类，重载doGetAuthorizationInfo();</span></span><br><span class="line"><span class="comment">     * 当访问到页面的时候，链接配置了相应的权限或者 Shiro 标签才会执行此方法否则不会执行，</span></span><br><span class="line"><span class="comment">     * 所以如果只是简单的身份认证没有权限的控制的话，那么这个方法可以不进行实现，直接返回 null 即可。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> principalCollection</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> AuthorizationInfo <span class="title">doGetAuthorizationInfo</span><span class="params">(PrincipalCollection principalCollection)</span> </span>&#123;</span><br><span class="line">        String username = (String) <span class="keyword">super</span>.getAvailablePrincipal(principalCollection);</span><br><span class="line">        SimpleAuthorizationInfo authorizationInfo = <span class="keyword">new</span> SimpleAuthorizationInfo();</span><br><span class="line">        Set&lt;String&gt; roles = authorizingService.findRoleListByUsername(username);</span><br><span class="line">        authorizationInfo.setRoles(roles);</span><br><span class="line">        roles.forEach(role -&gt; &#123;</span><br><span class="line">            Set&lt;String&gt; permissions = authorizingService.findPermissionsByRole(roles);</span><br><span class="line">            authorizationInfo.addStringPermissions(permissions);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> authorizationInfo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在认证、授权内部实现机制中都有提到，最终处理都将交给Real进行处理。</span></span><br><span class="line"><span class="comment">     * 因为在 Shiro 中，最终是通过 Realm 来获取应用程序中的用户、角色及权限信息的。</span></span><br><span class="line"><span class="comment">     * 通常情况下，在 Realm 中会直接从我们的数据源中获取 Shiro 需要的验证信息。</span></span><br><span class="line"><span class="comment">     * 可以说，Realm 是专用于安全框架的 DAO. Shiro 的认证过程最终会交由 Realm 执行，</span></span><br><span class="line"><span class="comment">     * 这时会调用 Realm 的getAuthenticationInfo(token)方法。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 该方法主要执行以下操作:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 1、检查提交的进行认证的令牌信息</span></span><br><span class="line"><span class="comment">     * 2、根据令牌信息从数据源(通常为数据库)中获取用户信息</span></span><br><span class="line"><span class="comment">     * 3、对用户信息进行匹配验证。</span></span><br><span class="line"><span class="comment">     * 4、验证通过将返回一个封装了用户信息的AuthenticationInfo实例。</span></span><br><span class="line"><span class="comment">     * 5、验证失败则抛出AuthenticationException异常信息。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> authenticationToken</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> AuthenticationException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> AuthenticationInfo <span class="title">doGetAuthenticationInfo</span><span class="params">(AuthenticationToken authenticationToken)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> AuthenticationException </span>&#123;</span><br><span class="line">        UsernamePasswordToken token = (UsernamePasswordToken) authenticationToken;</span><br><span class="line">        String username = token.getUsername();</span><br><span class="line">        UserInfo user = authorizingService.selectByUserName(username);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == user) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UnknownAccountException(<span class="string">&quot;doGetAuthenticationInfo() has an UnknownAccountException: &quot;</span>+username);</span><br><span class="line">        &#125;</span><br><span class="line">        String passwordInToken = <span class="keyword">new</span> String(token.getPassword());</span><br><span class="line">        String passwordInDb = user.getPassword();</span><br><span class="line">        <span class="keyword">if</span> (!StringUtils.equals(passwordInDb, passwordInToken)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IncorrectCredentialsException(<span class="string">&quot;doGetAuthenticationInfo() has an IncorrectCredentialsException: &quot;</span>+username);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SimpleAuthenticationInfo(username, passwordInToken, ByteSource.Util.bytes(user.getSalt()), getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="自定义SessionManager"><a href="#自定义SessionManager" class="headerlink" title="自定义SessionManager"></a>自定义SessionManager</h3><p>在我们项目中， 由于使用前后端分离的架构，所以要自定义Shiro的session管理：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomSessionManager</span> <span class="keyword">extends</span> <span class="title">DefaultWebSessionManager</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String HEADER_TOKEN = <span class="string">&quot;token&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String REFERENCED_SESSION_ID_SOURCE = <span class="string">&quot;Stateless request&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CustomSessionManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Serializable <span class="title">getSessionId</span><span class="params">(ServletRequest request, ServletResponse response)</span> </span>&#123;</span><br><span class="line">        String id = WebUtils.toHttp(request).getHeader(HEADER_TOKEN);</span><br><span class="line">        <span class="keyword">if</span> (!StringUtils.isEmpty(id)) &#123;</span><br><span class="line">            request.setAttribute(ShiroHttpServletRequest.REFERENCED_SESSION_ID_SOURCE, REFERENCED_SESSION_ID_SOURCE);</span><br><span class="line">            request.setAttribute(ShiroHttpServletRequest.REFERENCED_SESSION_ID, id);</span><br><span class="line">            request.setAttribute(ShiroHttpServletRequest.REFERENCED_SESSION_ID_IS_VALID, Boolean.TRUE);</span><br><span class="line">            <span class="keyword">return</span> id;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">super</span>.getSessionId(request, response);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过监听请求Header里的token字段，如果有值，则作为shiro的sessionid。</p><h3 id="配置Shiro"><a href="#配置Shiro" class="headerlink" title="配置Shiro"></a>配置Shiro</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShiroConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(name = &quot;customRealm&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CustomRealm <span class="title">customRealm</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CustomRealm();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(name = &quot;sessionManager&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SessionManager <span class="title">sessionManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CustomSessionManager();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(name = &quot;securityManager&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DefaultWebSecurityManager <span class="title">defaultWebSecurityManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        DefaultWebSecurityManager securityManager = <span class="keyword">new</span> DefaultWebSecurityManager();</span><br><span class="line"></span><br><span class="line">        securityManager.setRealm(customRealm());</span><br><span class="line">        securityManager.setSessionManager(sessionManager());</span><br><span class="line">        <span class="keyword">return</span> securityManager;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(name = &quot;lifecycleBeanPostProcessor&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> LifecycleBeanPostProcessor <span class="title">lifecycleBeanPostProcessor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> LifecycleBeanPostProcessor();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(name = &quot;shiroFilter&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ShiroFilterFactoryBean <span class="title">shiroFilterFactoryBean</span><span class="params">(DefaultWebSecurityManager securityManager)</span> </span>&#123;</span><br><span class="line">        ShiroFilterFactoryBean shiroFilterFactoryBean = <span class="keyword">new</span> ShiroFilterFactoryBean();</span><br><span class="line">        shiroFilterFactoryBean.setSecurityManager(securityManager);</span><br><span class="line">        <span class="keyword">return</span> shiroFilterFactoryBean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DefaultAdvisorAutoProxyCreator <span class="title">advisorAutoProxyCreator</span><span class="params">()</span></span>&#123;</span><br><span class="line">        DefaultAdvisorAutoProxyCreator advisorAutoProxyCreator = <span class="keyword">new</span> DefaultAdvisorAutoProxyCreator();</span><br><span class="line">        advisorAutoProxyCreator.setProxyTargetClass(<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">return</span> advisorAutoProxyCreator;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AuthorizationAttributeSourceAdvisor <span class="title">authorizationAttributeSourceAdvisor</span><span class="params">(DefaultWebSecurityManager securityManager)</span> </span>&#123;</span><br><span class="line">        AuthorizationAttributeSourceAdvisor authorizationAttributeSourceAdvisor = <span class="keyword">new</span> AuthorizationAttributeSourceAdvisor();</span><br><span class="line">        authorizationAttributeSourceAdvisor.setSecurityManager(securityManager);</span><br><span class="line">        <span class="keyword">return</span> authorizationAttributeSourceAdvisor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DefaultAdvisorAutoProxyCreator <span class="title">advisorAutoProxyCreator</span><span class="params">()</span></span>&#123;</span><br><span class="line">    DefaultAdvisorAutoProxyCreator advisorAutoProxyCreator = <span class="keyword">new</span> DefaultAdvisorAutoProxyCreator();</span><br><span class="line">    advisorAutoProxyCreator.setProxyTargetClass(<span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">return</span> advisorAutoProxyCreator;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> AuthorizationAttributeSourceAdvisor <span class="title">authorizationAttributeSourceAdvisor</span><span class="params">(DefaultWebSecurityManager securityManager)</span> </span>&#123;</span><br><span class="line">    AuthorizationAttributeSourceAdvisor authorizationAttributeSourceAdvisor = <span class="keyword">new</span> AuthorizationAttributeSourceAdvisor();</span><br><span class="line">    authorizationAttributeSourceAdvisor.setSecurityManager(securityManager);</span><br><span class="line">    <span class="keyword">return</span> authorizationAttributeSourceAdvisor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>在spring boot中， shiro使用@RequiresRoles,@RequiresPermissions注解无效时，需要添加这两个配置。</strong></p><h3 id="其他代码"><a href="#其他代码" class="headerlink" title="其他代码"></a>其他代码</h3><p><strong>AuthorizingService：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AuthorizingService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RoleDao roleDao;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> PermissionDao permissionDao;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> UserInfo <span class="title">selectByUserName</span><span class="params">(String username)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userDao.selectByUsername(username);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Set&lt;String&gt; <span class="title">findRoleListByUsername</span><span class="params">(String username)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> roleDao.selectByUsername(username);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Set&lt;String&gt; <span class="title">findPermissionsByRole</span><span class="params">(Set&lt;String&gt; roles)</span> </span>&#123;</span><br><span class="line">        HashSet&lt;String&gt; permissions = Sets.newHashSet();</span><br><span class="line">        roles.forEach(role -&gt; permissions.addAll(permissionDao.selectByRole(role)));</span><br><span class="line">        <span class="keyword">return</span> permissions;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">login</span><span class="params">(String username, String password)</span> </span>&#123;</span><br><span class="line">        UsernamePasswordToken token = <span class="keyword">new</span> UsernamePasswordToken(username,</span><br><span class="line">                password);</span><br><span class="line">        Subject currentUser = SecurityUtils.getSubject();</span><br><span class="line">        currentUser.login(token);</span><br><span class="line">        currentUser.getSession().setTimeout(<span class="number">60</span> * <span class="number">60</span> * <span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">return</span> currentUser.getSession().getId().toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">logout</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Subject currentUser = SecurityUtils.getSubject();</span><br><span class="line">        currentUser.logout();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>PermissionDao：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PermissionDao</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Set&lt;String&gt; <span class="title">selectByRole</span><span class="params">(String role)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (role) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;admin&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> Sets.newHashSet(<span class="string">&quot;Idea&quot;</span>, <span class="string">&quot;navicat&quot;</span>, <span class="string">&quot;notepad&quot;</span>, <span class="string">&quot;webstorm&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;chrome&quot;</span>);</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;java&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> Sets.newHashSet(<span class="string">&quot;Idea&quot;</span>);</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;mysql&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> Sets.newHashSet(<span class="string">&quot;navicat&quot;</span>);</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;html&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> Sets.newHashSet(<span class="string">&quot;notepad&quot;</span>);</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;javascript&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> Sets.newHashSet(<span class="string">&quot;webstorm&quot;</span>);</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;guest&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> Sets.newHashSet(<span class="string">&quot;chrome&quot;</span>);</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">return</span> Sets.newHashSet();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>RoleDao：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RoleDao</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Set&lt;String&gt; <span class="title">selectByUsername</span><span class="params">(String username)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (username) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;zhangsan&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> Sets.newHashSet(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;lisi&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> Sets.newHashSet(<span class="string">&quot;java&quot;</span>, <span class="string">&quot;mysql&quot;</span>);</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;wangwu&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> Sets.newHashSet(<span class="string">&quot;html&quot;</span>, <span class="string">&quot;javascript&quot;</span>);</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">return</span> Sets.newHashSet(<span class="string">&quot;guest&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>UserDao：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> UserInfo <span class="title">selectByUsername</span><span class="params">(String username)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (username) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;zhangsan&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> UserInfo.builder()</span><br><span class="line">                        .userName(<span class="string">&quot;zhangsan&quot;</span>).password(<span class="string">&quot;123456&quot;</span>).salt(<span class="string">&quot;123456&quot;</span>)</span><br><span class="line">                        .build();</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;lisi&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> UserInfo.builder()</span><br><span class="line">                        .userName(<span class="string">&quot;lisi&quot;</span>).password(<span class="string">&quot;123456&quot;</span>).salt(<span class="string">&quot;123456&quot;</span>)</span><br><span class="line">                        .build();</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;wangwu&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> UserInfo.builder()</span><br><span class="line">                        .userName(<span class="string">&quot;wangwu&quot;</span>).password(<span class="string">&quot;123456&quot;</span>).salt(<span class="string">&quot;123456&quot;</span>)</span><br><span class="line">                        .build();</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里没有使用数据库， 直接模拟数据库操作。</p><h3 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h3><blockquote><p>在实际项目运行中，为了达到高可用的目的，通常要把应用部署在多台服务器上，这个时候就要对session进行集群的管理</p></blockquote><h4 id="添加redis支持"><a href="#添加redis支持" class="headerlink" title="添加redis支持"></a>添加redis支持</h4><h5 id="pom-xml"><a href="#pom-xml" class="headerlink" title="pom.xml"></a>pom.xml</h5><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h5><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">shiro-demo</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="string">redistest.xxxx.com</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line">    <span class="attr">database:</span> <span class="number">10</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">test@2018</span></span><br><span class="line">    <span class="attr">timeout:</span> <span class="number">180000</span></span><br><span class="line">    <span class="attr">jedis:</span></span><br><span class="line">      <span class="attr">pool:</span></span><br><span class="line">        <span class="attr">max-active:</span> <span class="number">100</span></span><br><span class="line">        <span class="attr">max-wait:</span> <span class="number">360000</span></span><br><span class="line">        <span class="attr">min-idle:</span> <span class="number">0</span></span><br><span class="line">        <span class="attr">max-idle:</span> <span class="number">100</span></span><br><span class="line"><span class="attr">my:</span></span><br><span class="line">  <span class="attr">shiro:</span></span><br><span class="line">    <span class="attr">session:</span></span><br><span class="line">      <span class="attr">expireTime:</span> <span class="number">1800</span></span><br><span class="line">      <span class="attr">prefix:</span> <span class="string">you-shiro-session</span></span><br></pre></td></tr></table></figure><h5 id="新增Java类：ShiroCacheManager"><a href="#新增Java类：ShiroCacheManager" class="headerlink" title="新增Java类：ShiroCacheManager"></a>新增Java类：<code>ShiroCacheManager</code></h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShiroCacheManager</span> <span class="keyword">implements</span> <span class="title">CacheManager</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> expireTime;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;K, V&gt; <span class="function">Cache&lt;K, V&gt; <span class="title">getCache</span><span class="params">(String name)</span> <span class="keyword">throws</span> CacheException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ShiroRedisCache&lt;&gt;(name, redisTemplate, expireTime);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ShiroCacheManager</span><span class="params">(RedisTemplate redisTemplate, <span class="keyword">int</span> expireTime)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.redisTemplate = redisTemplate;</span><br><span class="line">        <span class="keyword">this</span>.expireTime = expireTime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShiroRedisCache</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Cache</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> String cacheKey;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> expireTime;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="title">ShiroRedisCache</span><span class="params">(String cacheKey, RedisTemplate redisTemplate, <span class="keyword">int</span> expireTime)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.cacheKey = cacheKey;</span><br><span class="line">            <span class="keyword">this</span>.redisTemplate = redisTemplate;</span><br><span class="line">            <span class="keyword">this</span>.expireTime = expireTime;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> Object <span class="title">hashKey</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (key <span class="keyword">instanceof</span> PrincipalCollection) &#123;</span><br><span class="line">                PrincipalCollection principalCollection = (PrincipalCollection) key;</span><br><span class="line">                <span class="keyword">return</span> principalCollection.getPrimaryPrincipal().toString();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> key;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(K key)</span> <span class="keyword">throws</span> CacheException </span>&#123;</span><br><span class="line">            BoundHashOperations&lt;String, K, V&gt; boundHashOperations = redisTemplate.boundHashOps(cacheKey);</span><br><span class="line">            Object realKey = hashKey(key);</span><br><span class="line">            <span class="keyword">return</span> boundHashOperations.get(realKey);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> <span class="keyword">throws</span> CacheException </span>&#123;</span><br><span class="line">            BoundHashOperations&lt;String, K, V&gt; boundHashOperations = redisTemplate.boundHashOps(cacheKey);</span><br><span class="line">            Object realKey = hashKey(key);</span><br><span class="line">            boundHashOperations.put((K) realKey, value);</span><br><span class="line">            boundHashOperations.expire(expireTime, TimeUnit.SECONDS);</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(K key)</span> <span class="keyword">throws</span> CacheException </span>&#123;</span><br><span class="line">            BoundHashOperations&lt;String, K, V&gt; boundHashOperations = redisTemplate.boundHashOps(cacheKey);</span><br><span class="line">            Object realKey = hashKey(key);</span><br><span class="line">            V value = boundHashOperations.get(realKey);</span><br><span class="line">            boundHashOperations.delete(realKey);</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> <span class="keyword">throws</span> CacheException </span>&#123;</span><br><span class="line">            redisTemplate.delete(cacheKey);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            BoundHashOperations&lt;String, K, V&gt; boundHashOperations = redisTemplate.boundHashOps(cacheKey);</span><br><span class="line">            <span class="keyword">return</span> boundHashOperations.size().intValue();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Set&lt;K&gt; <span class="title">keys</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            BoundHashOperations&lt;String, K, V&gt; boundHashOperations = redisTemplate.boundHashOps(cacheKey);</span><br><span class="line">            <span class="keyword">return</span> boundHashOperations.keys();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Collection&lt;V&gt; <span class="title">values</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            BoundHashOperations&lt;String, K, V&gt; boundHashOperations = redisTemplate.boundHashOps(cacheKey);</span><br><span class="line">            <span class="keyword">return</span> boundHashOperations.values();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="新增java类：RedisSessionDAO，继承EnterpriseCacheSessionDAO"><a href="#新增java类：RedisSessionDAO，继承EnterpriseCacheSessionDAO" class="headerlink" title="新增java类：RedisSessionDAO，继承EnterpriseCacheSessionDAO"></a>新增java类：RedisSessionDAO，继承EnterpriseCacheSessionDAO</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisSessionDAO</span> <span class="keyword">extends</span> <span class="title">EnterpriseCacheSessionDAO</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> expireTime;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String prefix;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RedisSessionDAO</span><span class="params">(RedisTemplate redisTemplate, <span class="keyword">int</span> expireTime, String prefix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.redisTemplate = redisTemplate;</span><br><span class="line">        <span class="keyword">this</span>.expireTime = expireTime;</span><br><span class="line">        <span class="keyword">this</span>.prefix = prefix;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Serializable <span class="title">doCreate</span><span class="params">(Session session)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;doCreate(&#123;&#125;)&quot;</span>, session.getId());</span><br><span class="line">        Serializable sessionId = <span class="keyword">super</span>.doCreate(session);</span><br><span class="line">        redisTemplate.opsForValue().set(prefix + <span class="string">&quot;:&quot;</span> + sessionId.toString(), session);</span><br><span class="line">        <span class="keyword">return</span> sessionId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Session <span class="title">doReadSession</span><span class="params">(Serializable sessionId)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;doReadSession(&#123;&#125;)&quot;</span>, sessionId);</span><br><span class="line">        Session session = <span class="keyword">super</span>.doReadSession(sessionId);</span><br><span class="line">        <span class="keyword">if</span> (session == <span class="keyword">null</span>) &#123;</span><br><span class="line">            session = (Session) redisTemplate.opsForValue().get(prefix + <span class="string">&quot;:&quot;</span> + sessionId.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> session;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doUpdate</span><span class="params">(Session session)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.doUpdate(session);</span><br><span class="line">        String key = prefix + <span class="string">&quot;:&quot;</span> + session.getId().toString();</span><br><span class="line">        <span class="keyword">if</span> (!redisTemplate.hasKey(key)) &#123;</span><br><span class="line">            redisTemplate.opsForValue().set(key, session);</span><br><span class="line">        &#125;</span><br><span class="line">        redisTemplate.expire(key, expireTime, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doDelete</span><span class="params">(Session session)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;doDelete(&#123;&#125;)&quot;</span>, session.getId());</span><br><span class="line">        <span class="keyword">super</span>.doDelete(session);</span><br><span class="line">        redisTemplate.delete(prefix + <span class="string">&quot;:&quot;</span> + session.getId().toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="新增Java类：RedisObjectSerializer-implements-RedisSerializer"><a href="#新增Java类：RedisObjectSerializer-implements-RedisSerializer" class="headerlink" title="新增Java类：RedisObjectSerializer implements RedisSerializer"></a>新增Java类：RedisObjectSerializer implements RedisSerializer<Object></h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisObjectSerializer</span> <span class="keyword">implements</span> <span class="title">RedisSerializer</span>&lt;<span class="title">Object</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Converter&lt;Object, <span class="keyword">byte</span>[]&gt; serializer = <span class="keyword">new</span> SerializingConverter();</span><br><span class="line">    <span class="keyword">private</span> Converter&lt;<span class="keyword">byte</span>[], Object&gt; deserializer = <span class="keyword">new</span> DeserializingConverter();</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span>[] EMPTY_ARRAY = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">deserialize</span><span class="params">(<span class="keyword">byte</span>[] bytes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty(bytes)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> deserializer.convert(bytes);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SerializationException(<span class="string">&quot;Cannot deserialize&quot;</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">byte</span>[] serialize(Object object) &#123;</span><br><span class="line">        <span class="keyword">if</span> (object == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> EMPTY_ARRAY;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> serializer.convert(object);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            <span class="keyword">return</span> EMPTY_ARRAY;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">(<span class="keyword">byte</span>[] data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (data == <span class="keyword">null</span> || data.length == <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="修改ShiroConfig"><a href="#修改ShiroConfig" class="headerlink" title="修改ShiroConfig"></a>修改ShiroConfig</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShiroConfig</span> <span class="keyword">implements</span> <span class="title">InitializingBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;my.shiro.session.expireTime:1800&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> expireTime;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;my.shiro.session.prefix:you-shiro-session&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String prefix;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ParserConfig.getGlobalInstance().setAutoTypeSupport(<span class="keyword">true</span>);</span><br><span class="line">        redisTemplate.setKeySerializer(<span class="keyword">new</span> StringRedisSerializer());</span><br><span class="line">        redisTemplate.setValueSerializer(<span class="keyword">new</span> RedisObjectSerializer());</span><br><span class="line">        redisTemplate.afterPropertiesSet();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RedisTemplate <span class="title">redisTemplate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RedisTemplate();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(name = &quot;shiroCacheManager&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ShiroCacheManager <span class="title">shiroCacheManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ShiroCacheManager(redisTemplate, expireTime);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(name = &quot;redisSessionDAO&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RedisSessionDAO <span class="title">redisSessionDAO</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RedisSessionDAO(redisTemplate, expireTime, prefix);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(name = &quot;customRealm&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CustomRealm <span class="title">customRealm</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CustomRealm();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(name = &quot;sessionManager&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SessionManager <span class="title">sessionManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        CustomSessionManager sessionManager = <span class="keyword">new</span> CustomSessionManager();</span><br><span class="line">        sessionManager.setSessionDAO(redisSessionDAO());</span><br><span class="line">        <span class="keyword">return</span> sessionManager;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(name = &quot;securityManager&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DefaultWebSecurityManager <span class="title">defaultWebSecurityManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        DefaultWebSecurityManager securityManager = <span class="keyword">new</span> DefaultWebSecurityManager();</span><br><span class="line"></span><br><span class="line">        securityManager.setRealm(customRealm());</span><br><span class="line"></span><br><span class="line">        securityManager.setCacheManager(shiroCacheManager());</span><br><span class="line"></span><br><span class="line">        securityManager.setSessionManager(sessionManager());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> securityManager;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(name = &quot;lifecycleBeanPostProcessor&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> LifecycleBeanPostProcessor <span class="title">lifecycleBeanPostProcessor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> LifecycleBeanPostProcessor();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(name = &quot;shiroFilter&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ShiroFilterFactoryBean <span class="title">shiroFilterFactoryBean</span><span class="params">(DefaultWebSecurityManager securityManager)</span> </span>&#123;</span><br><span class="line">        ShiroFilterFactoryBean shiroFilterFactoryBean = <span class="keyword">new</span> ShiroFilterFactoryBean();</span><br><span class="line">        shiroFilterFactoryBean.setSecurityManager(securityManager);</span><br><span class="line">        <span class="keyword">return</span> shiroFilterFactoryBean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DefaultAdvisorAutoProxyCreator <span class="title">advisorAutoProxyCreator</span><span class="params">()</span></span>&#123;</span><br><span class="line">        DefaultAdvisorAutoProxyCreator advisorAutoProxyCreator = <span class="keyword">new</span> DefaultAdvisorAutoProxyCreator();</span><br><span class="line">        advisorAutoProxyCreator.setProxyTargetClass(<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">return</span> advisorAutoProxyCreator;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AuthorizationAttributeSourceAdvisor <span class="title">authorizationAttributeSourceAdvisor</span><span class="params">(DefaultWebSecurityManager securityManager)</span> </span>&#123;</span><br><span class="line">        AuthorizationAttributeSourceAdvisor authorizationAttributeSourceAdvisor = <span class="keyword">new</span> AuthorizationAttributeSourceAdvisor();</span><br><span class="line">        authorizationAttributeSourceAdvisor.setSecurityManager(securityManager);</span><br><span class="line">        <span class="keyword">return</span> authorizationAttributeSourceAdvisor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="集群完成"><a href="#集群完成" class="headerlink" title="集群完成"></a>集群完成</h5><p>^_^.</p><p>经过以上改造，shiro就可以在分布式应用中集群使用。</p><p><a href="https://github.com/cayzlh/spring-boot-shiro-demo">项目代码</a>，在 with-redis 分支中。</p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>运行Demo，测试登录和请求其他接口：</p><p><img src="https://github.com/cayzlh/git-img-repository/raw/master/blog/2019/04/6.png" alt="登录"></p><p>–</p><p><img src="https://github.com/cayzlh/git-img-repository/raw/master/blog/2019/04/7.png" alt="请求"></p>]]></content>
      
      
      <categories>
          
          <category> 编程技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Spring </tag>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker私有仓库的搭建与使用</title>
      <link href="post/2865582791/"/>
      <url>post/2865582791/</url>
      
        <content type="html"><![CDATA[<blockquote><p>转载自：<a href="https://github.com/eacdy/spring-cloud-book">spring-cloud-book</a></p></blockquote><p>和Maven一样，Docker不仅提供了一个中央仓库，同时也允许我们搭建私有仓库。如果读者对Maven有所了解，将会很容易理解私有仓库的优势：</p><ul><li>节省带宽，镜像无需从中央仓库下载，只需从私有仓库中下载即可</li><li>对于私有仓库中已有的镜像，提升了下载速度</li><li>便于内部镜像的统一管理</li></ul><p>下面我们来讲解一下如何搭建、使用私有仓库</p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>准备两台安装有Docker的CentOS7的机器，主机规划如下（仅供参考）：</p><table><thead><tr><th>主机</th><th>IP</th><th>角色</th></tr></thead><tbody><tr><td>node0</td><td>192.168.11.143</td><td>Docker开发机</td></tr><tr><td>node1</td><td>192.168.11.144</td><td>Docker私有仓库</td></tr></tbody></table><h2 id="安装、使用私有仓库"><a href="#安装、使用私有仓库" class="headerlink" title="安装、使用私有仓库"></a>安装、使用私有仓库</h2><p>网上有很多<code>docker-registry</code> 的教程，但是<code>docker-registry</code> 已经过时，并且已经2年不维护了。详见<a href="https://github.com/docker/docker-registry">https://github.com/docker/docker-registry</a> ，故而本文不做探讨，对<code>docker-registry</code> 有兴趣的童鞋可以查阅本节的参考文档。</p><p>本节讲解registry V2，registry V2需要Docker版本高于1.6.0。registry V2要求使用https访问，那么我们先做一些准备，为了方便，这边模拟以域名<code>reg.itmuch.com</code> 进行讲解。</p><h3 id="使用域名搭建https的私有仓库"><a href="#使用域名搭建https的私有仓库" class="headerlink" title="使用域名搭建https的私有仓库"></a>使用域名搭建https的私有仓库</h3><ul><li>首先修改两台机器的hosts，配置<code>192.168.11.144</code>  到<code> reg.itmuch.com</code> 的映射</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo &#x27;192.168.11.144 reg.itmuch.com&#x27;&gt;&gt; /etc/hosts</span><br></pre></td></tr></table></figure><ul><li>既然使用https，那么我们需要生成证书，本文讲解的是使用openssl自签名证书，当然也可以使用诸如<code>Let’s Encrypt</code> 等工具生成证书，首先在node1机器上生成key：</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir -p ~/certs</span><br><span class="line">cd ~/certs</span><br><span class="line">openssl genrsa -out reg.itmuch.com.key 2048</span><br></pre></td></tr></table></figure><p>再生成密钥文件：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">openssl req -newkey rsa:4096 -nodes -sha256 -keyout reg.itmuch.com.key -x509 -days 365 -out reg.itmuch.com.crt</span><br></pre></td></tr></table></figure><p>会有一些信息需要填写：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Country Name (2 letter code) [XX]:CN# 你的国家名称</span><br><span class="line">State or Province Name (full name) []:JS# 省份</span><br><span class="line">Locality Name (eg, city) [Default City]:NJ# 所在城市</span><br><span class="line">Organization Name (eg, company) [Default Company Ltd]:ITMUCH# 组织名称</span><br><span class="line">Organizational Unit Name (eg, section) []:ITMUCH# 组织单元名称</span><br><span class="line">Common Name (eg, your name or your server&#x27;s hostname) []:reg.itmuch.com # 域名</span><br><span class="line">Email Address []:eacdy0000@126.com# 邮箱</span><br></pre></td></tr></table></figure><p>这样自签名证书就制作完成了。</p><ul><li>由于是自签名证书，默认是不受Docker信任的，故而需要将证书添加到Docker的根证书中，Docker在CentOS 7中，证书存放路径是<code>/etc/docker/certs.d/域名</code>：</li></ul><p><code>node1</code> 端：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir -p /etc/docker/certs.d/reg.itmuch.com</span><br><span class="line">cp ~/certs/reg.itmuch.com.crt /etc/docker/certs.d/reg.itmuch.com/</span><br></pre></td></tr></table></figure><p><code>node0</code> 端：将生成的证书下载到根证书路径</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir -p /etc/docker/certs.d/reg.itmuch.com</span><br><span class="line">scp root@192.168.11.144:/root/certs/reg.itmuch.com.crt /etc/docker/certs.d/reg.itmuch.com/</span><br></pre></td></tr></table></figure><ul><li>重新启动<code>node0</code> 和 <code>node1</code> 的Docker</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">service docker restart</span><br></pre></td></tr></table></figure><ul><li>在<code>node1</code> 上启动私有仓库</li></ul><p>首先切换到家目录中，这一步不能少，原因是下面的-v 挂载了证书，如果不切换，将会引用不到证书文件。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd ~</span><br></pre></td></tr></table></figure><p>启动Docker私有仓库（注意：如果直接粘贴运行，请删除掉注释）：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d -p 443:5000 --restart=always --name registry \</span><br><span class="line">  -v `pwd`/certs:/certs \# 将“当前目录/certs”挂载到容器的“/certs”</span><br><span class="line">  -v /opt/docker-image:/opt/docker-image \</span><br><span class="line">  -e STORAGE_PATH=/opt/docker-image \# 指定容器内存储镜像的路径</span><br><span class="line">  -e REGISTRY_HTTP_TLS_CERTIFICATE=/certs/reg.itmuch.com.crt \# 指定证书文件</span><br><span class="line">  -e REGISTRY_HTTP_TLS_KEY=/certs/reg.itmuch.com.key \# 指定key文件</span><br><span class="line">  registry:2</span><br></pre></td></tr></table></figure><p>其中，之所以挂载/opt/docker-image目录，是为了防止私有仓库容器被删除，私有仓库中的镜像也会丢失。</p><ul><li>在<code>node0</code> 上测试，将镜像push到私服</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull kitematic/hello-world-nginx</span><br><span class="line">docker tag kitematic/hello-world-nginx reg.itmuch.com/kitematic/hello-world-nginx # 为本地镜像打标签</span><br><span class="line">docker push reg.itmuch.com/kitematic/hello-world-nginx# 将镜像push到私服</span><br></pre></td></tr></table></figure><p>会发现如下内容：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">The push refers to a repository [reg.itmuch.com/kitematic/hello-world-nginx]</span><br><span class="line">5f70bf18a086: Pushed </span><br><span class="line">b51acdd3ef48: Pushed </span><br><span class="line">3f47ff454588: Pushed </span><br><span class="line">....</span><br><span class="line">latest: digest: sha256:d3e1883b703c39556f2f09da14cc3b820f69a43436655c882c0c0ded0dda6a4b size: 3226</span><br></pre></td></tr></table></figure><p>说明已经push成功。</p><ul><li>从私服中下载镜像：</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull reg.itmuch.com/kitematic/hello-world-nginx</span><br></pre></td></tr></table></figure><h3 id="配置登录认证"><a href="#配置登录认证" class="headerlink" title="配置登录认证"></a>配置登录认证</h3><p>在很多场景下，我们需要用户登录后才能访问私有仓库，那么我们可以如下操作：</p><p>建立在上文生成证书，同时重启过Docker服务的前提下，我们讲解一下如何配置：</p><ul><li>为防止端口冲突，我们首先删除或停止之前启动好的私有仓库：</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker kill registry</span><br></pre></td></tr></table></figure><ul><li>在node1机器上安装<code>httpd-tools</code> ：</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install httpd-tools</span><br></pre></td></tr></table></figure><ul><li>在node机器上创建密码文件，并添加一个用户<code>testuser</code> ，密码是<code>testpassword</code> ：</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd ~</span><br><span class="line">mkdir auth</span><br><span class="line">htpasswd -Bbn testuser testpassword &gt; auth/htpasswd</span><br></pre></td></tr></table></figure><ul><li>在node1机器上切换到<code>~</code> 目录，并启动私有仓库（注意：如果直接粘贴运行，请删除掉注释）：</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d -p 443:5000 --restart=always --name registry2 \</span><br><span class="line">  -v /opt/docker-image:/var/lib/registry \# 挂载容器内存储镜像路径到宿主机</span><br><span class="line">  -v `pwd`/certs:/certs \</span><br><span class="line">  -e REGISTRY_HTTP_TLS_CERTIFICATE=/certs/reg.itmuch.com.crt \</span><br><span class="line">  -e REGISTRY_HTTP_TLS_KEY=/certs/reg.itmuch.com.key \</span><br><span class="line">  -v `pwd`/auth:/auth \</span><br><span class="line">  -e &quot;REGISTRY_AUTH=htpasswd&quot; \</span><br><span class="line">  -e &quot;REGISTRY_AUTH_HTPASSWD_REALM=Registry Realm&quot; \</span><br><span class="line">  -e REGISTRY_AUTH_HTPASSWD_PATH=/auth/htpasswd \</span><br><span class="line">  registry:2</span><br></pre></td></tr></table></figure><ul><li>测试：</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker push reg.itmuch.com/kitematic/hello-world-nginx</span><br></pre></td></tr></table></figure><p>提示：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">461f75075df2: Image push failed </span><br><span class="line">no basic auth credentials</span><br></pre></td></tr></table></figure><p>说明需要认证。</p><p>我们登陆一下，执行：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker login reg.imuch.com</span><br></pre></td></tr></table></figure><p>再次执行</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker push reg.itmuch.com/kitematic/hello-world-nginx</span><br></pre></td></tr></table></figure><p>就可以正常push镜像到私有仓库了。</p><p><strong>注意：</strong>如果想要从私有仓库上下载镜像，同样需要登录。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记本 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Dockerfile常用指令</title>
      <link href="post/2644493537/"/>
      <url>post/2644493537/</url>
      
        <content type="html"><![CDATA[<blockquote><p>转载自：<a href="http://www.ityouknow.com/docker/2018/03/15/docker-dockerfile-command-introduction.html">Docker(三)：Dockerfile 命令详解</a>，怕以后找不到</p></blockquote><h2 id="Dockerfile-指令详解"><a href="#Dockerfile-指令详解" class="headerlink" title="Dockerfile 指令详解"></a>Dockerfile 指令详解</h2><h3 id="1-FROM-指定基础镜像"><a href="#1-FROM-指定基础镜像" class="headerlink" title="1 FROM 指定基础镜像"></a>1 FROM 指定基础镜像</h3><p>FROM 指令用于指定其后构建新镜像所使用的基础镜像。FROM 指令必是 Dockerfile 文件中的首条命令，启动构建流程后，Docker 将会基于该镜像构建新镜像，FROM 后的命令也会基于这个基础镜像。</p><p>FROM语法格式为：</p><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> &lt;image&gt;</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> &lt;image&gt;:&lt;tag&gt;</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> &lt;image&gt;:&lt;digest&gt;</span><br></pre></td></tr></table></figure><p>通过 FROM 指定的镜像，可以是任何有效的基础镜像。FROM 有以下限制：</p><ul><li>FROM 必须 是 Dockerfile 中第一条非注释命令</li><li>在一个 Dockerfile 文件中创建多个镜像时，FROM 可以多次出现。只需在每个新命令 FROM 之前，记录提交上次的镜像 ID。</li><li>tag 或 digest 是可选的，如果不使用这两个值时，会使用 latest 版本的基础镜像</li></ul><h3 id="2-RUN-执行命令"><a href="#2-RUN-执行命令" class="headerlink" title="2 RUN 执行命令"></a>2 RUN 执行命令</h3><p>在镜像的构建过程中执行特定的命令，并生成一个中间镜像。格式:</p><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="comment">#shell格式</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> &lt;<span class="built_in">command</span>&gt;</span></span><br><span class="line"><span class="comment">#exec格式</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> [<span class="string">&quot;executable&quot;</span>, <span class="string">&quot;param1&quot;</span>, <span class="string">&quot;param2&quot;</span>]</span></span><br></pre></td></tr></table></figure><ul><li>RUN 命令将在当前 image 中执行任意合法命令并提交执行结果。命令执行提交后，就会自动执行 Dockerfile 中的下一个指令。</li><li>层级 RUN 指令和生成提交是符合 Docker 核心理念的做法。它允许像版本控制那样，在任意一个点，对 image 镜像进行定制化构建。</li><li>RUN 指令创建的中间镜像会被缓存，并会在下次构建中使用。如果不想使用这些缓存镜像，可以在构建时指定 <code>--no-cache</code> 参数，如：<code>docker build --no-cache</code>。</li></ul><h3 id="3-COPY-复制文件"><a href="#3-COPY-复制文件" class="headerlink" title="3 COPY 复制文件"></a>3 COPY 复制文件</h3><p>格式：</p><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">COPY</span><span class="bash"> &lt;源路径&gt;... &lt;目标路径&gt;</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> [<span class="string">&quot;&lt;源路径1&gt;&quot;</span>,... <span class="string">&quot;&lt;目标路径&gt;&quot;</span>]</span></span><br></pre></td></tr></table></figure><p>和 RUN 指令一样，也有两种格式，一种类似于命令行，一种类似于函数调用。COPY 指令将从构建上下文目录中 &lt;源路径&gt; 的文件/目录复制到新的一层的镜像内的<code>&lt;目标路径&gt;</code>位置。比如：</p><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">COPY</span><span class="bash"> package.json /usr/src/app/</span></span><br></pre></td></tr></table></figure><p><code>&lt;源路径&gt;</code>可以是多个，甚至可以是通配符，其通配符规则要满足 Go 的 filepath.Match 规则，如：</p><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">COPY</span><span class="bash"> hom* /mydir/</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> hom?.txt /mydir/</span></span><br></pre></td></tr></table></figure><p><code>&lt;目标路径&gt;</code>可以是容器内的绝对路径，也可以是相对于工作目录的相对路径（工作目录可以用 WORKDIR 指令来指定）。目标路径不需要事先创建，如果目录不存在会在复制文件前先行创建缺失目录。</p><p>此外，还需要注意一点，使用 COPY 指令，源文件的各种元数据都会保留。比如读、写、执行权限、文件变更时间等。这个特性对于镜像定制很有用。特别是构建相关文件都在使用 Git 进行管理的时候。</p><h3 id="4-ADD-更高级的复制文件"><a href="#4-ADD-更高级的复制文件" class="headerlink" title="4 ADD 更高级的复制文件"></a>4 ADD 更高级的复制文件</h3><p>ADD 指令和 COPY 的格式和性质基本一致。但是在 COPY 基础上增加了一些功能。比如<code>&lt;源路径&gt;</code>可以是一个 URL，这种情况下，Docker 引擎会试图去下载这个链接的文件放到<code>&lt;目标路径&gt;</code>去。</p><p>在构建镜像时，复制上下文中的文件到镜像内，格式：</p><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ADD</span><span class="bash"> &lt;源路径&gt;... &lt;目标路径&gt;</span></span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> [<span class="string">&quot;&lt;源路径&gt;&quot;</span>,... <span class="string">&quot;&lt;目标路径&gt;&quot;</span>]</span></span><br></pre></td></tr></table></figure><p><strong>注意</strong><br>如果 docker 发现文件内容被改变，则接下来的指令都不会再使用缓存。关于复制文件时需要处理的/，基本跟正常的 copy 一致</p><h3 id="5-ENV-设置环境变量"><a href="#5-ENV-设置环境变量" class="headerlink" title="5 ENV 设置环境变量"></a>5 ENV 设置环境变量</h3><p>格式有两种：</p><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ENV</span> &lt;key&gt; &lt;value&gt;</span><br><span class="line"><span class="keyword">ENV</span> &lt;key1&gt;=&lt;value1&gt; &lt;key2&gt;=&lt;value2&gt;...</span><br></pre></td></tr></table></figure><p>这个指令很简单，就是设置环境变量而已，无论是后面的其它指令，如 RUN，还是运行时的应用，都可以直接使用这里定义的环境变量。</p><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ENV</span> VERSION=<span class="number">1.0</span> DEBUG=on \</span><br><span class="line">    NAME=<span class="string">&quot;Happy Feet&quot;</span></span><br></pre></td></tr></table></figure><p>这个例子中演示了如何换行，以及对含有空格的值用双引号括起来的办法，这和 Shell 下的行为是一致的。</p><h3 id="6-EXPOSE"><a href="#6-EXPOSE" class="headerlink" title="6 EXPOSE"></a>6 EXPOSE</h3><p>为构建的镜像设置监听端口，使容器在运行时监听。格式：</p><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">EXPOSE</span> &lt;port&gt; [&lt;port&gt;...]</span><br></pre></td></tr></table></figure><p>EXPOSE 指令并不会让容器监听 host 的端口，如果需要，需要在 docker run 时使用 <code>-p</code>、<code>-P</code> 参数来发布容器端口到 host 的某个端口上。</p><h3 id="7-VOLUME-定义匿名卷"><a href="#7-VOLUME-定义匿名卷" class="headerlink" title="7 VOLUME 定义匿名卷"></a>7 VOLUME 定义匿名卷</h3><p>VOLUME用于创建挂载点，即向基于所构建镜像创始的容器添加卷：</p><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">VOLUME</span><span class="bash"> [<span class="string">&quot;/data&quot;</span>]</span></span><br></pre></td></tr></table></figure><p>一个卷可以存在于一个或多个容器的指定目录，该目录可以绕过联合文件系统，并具有以下功能：</p><ul><li>卷可以容器间共享和重用</li><li>容器并不一定要和其它容器共享卷</li><li>修改卷后会立即生效</li><li>对卷的修改不会对镜像产生影响</li><li>卷会一直存在，直到没有任何容器在使用它</li></ul><p>VOLUME 让我们可以将源代码、数据或其它内容添加到镜像中，而又不并提交到镜像中，并使我们可以多个容器间共享这些内容。</p><h3 id="8-WORKDIR-指定工作目录"><a href="#8-WORKDIR-指定工作目录" class="headerlink" title="8 WORKDIR 指定工作目录"></a>8 WORKDIR 指定工作目录</h3><p>WORKDIR用于在容器内设置一个工作目录：</p><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /path/to/workdir</span></span><br></pre></td></tr></table></figure><p>通过WORKDIR设置工作目录后，Dockerfile 中其后的命令 RUN、CMD、ENTRYPOINT、ADD、COPY 等命令都会在该目录下执行。 如，使用WORKDIR设置工作目录：</p><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /a</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> b</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> c</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> <span class="built_in">pwd</span></span></span><br></pre></td></tr></table></figure><p>在以上示例中，pwd 最终将会在 <code>/a/b/c</code> 目录中执行。在使用 docker run 运行容器时，可以通过<code>-w</code>参数覆盖构建时所设置的工作目录。</p><h3 id="9-USER-指定当前用户"><a href="#9-USER-指定当前用户" class="headerlink" title="9 USER 指定当前用户"></a>9 USER 指定当前用户</h3><p>USER 用于指定运行镜像所使用的用户：</p><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">USER</span> daemon</span><br></pre></td></tr></table></figure><p>使用USER指定用户时，可以使用用户名、UID 或 GID，或是两者的组合。以下都是合法的指定试：</p><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">USER</span> <span class="keyword">user</span></span><br><span class="line"><span class="keyword">USER</span> <span class="keyword">user</span>:group</span><br><span class="line"><span class="keyword">USER</span> uid</span><br><span class="line"><span class="keyword">USER</span> uid:gid</span><br><span class="line"><span class="keyword">USER</span> <span class="keyword">user</span>:gid</span><br><span class="line"><span class="keyword">USER</span> uid:group</span><br></pre></td></tr></table></figure><p>使用USER指定用户后，Dockerfile 中其后的命令 RUN、CMD、ENTRYPOINT 都将使用该用户。镜像构建完成后，通过 docker run 运行容器时，可以通过 <code>-u</code> 参数来覆盖所指定的用户。</p><h3 id="10-CMD"><a href="#10-CMD" class="headerlink" title="10 CMD"></a>10 CMD</h3><p>CMD用于指定在容器启动时所要执行的命令。CMD 有以下三种格式：</p><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">&quot;executable&quot;</span>,<span class="string">&quot;param1&quot;</span>,<span class="string">&quot;param2&quot;</span>]</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">&quot;param1&quot;</span>,<span class="string">&quot;param2&quot;</span>]</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> <span class="built_in">command</span> param1 param2</span></span><br></pre></td></tr></table></figure><p>省略可执行文件的 exec 格式，这种写法使 CMD 中的参数当做 ENTRYPOINT 的默认参数，此时 ENTRYPOINT 也应该是 exec 格式，具体与 ENTRYPOINT 的组合使用，参考 ENTRYPOINT。</p><p><strong>注意</strong><br>与 RUN 指令的区别：RUN 在构建的时候执行，并生成一个新的镜像，CMD 在容器运行的时候执行，在构建时不进行任何操作。</p><h3 id="11-ENTRYPOINT"><a href="#11-ENTRYPOINT" class="headerlink" title="11 ENTRYPOINT"></a>11 ENTRYPOINT</h3><p>ENTRYPOINT 用于给容器配置一个可执行程序。也就是说，每次使用镜像创建容器时，通过 ENTRYPOINT 指定的程序都会被设置为默认程序。ENTRYPOINT 有以下两种形式：</p><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> [<span class="string">&quot;executable&quot;</span>, <span class="string">&quot;param1&quot;</span>, <span class="string">&quot;param2&quot;</span>]</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> <span class="built_in">command</span> param1 param2</span></span><br></pre></td></tr></table></figure><p>ENTRYPOINT 与 CMD 非常类似，不同的是通过<code>docker run</code>执行的命令不会覆盖 ENTRYPOINT，而<code>docker run</code>命令中指定的任何参数，都会被当做参数再次传递给 ENTRYPOINT。Dockerfile 中只允许有一个 ENTRYPOINT 命令，多指定时会覆盖前面的设置，而只执行最后的 ENTRYPOINT 指令。</p><p><code>docker run</code>运行容器时指定的参数都会被传递给 ENTRYPOINT ，且会覆盖 CMD 命令指定的参数。如，执行<code>docker run &lt;image&gt; -d</code>时，-d 参数将被传递给入口点。</p><p>也可以通过<code>docker run --entrypoint</code>重写 ENTRYPOINT 入口点。如：可以像下面这样指定一个容器执行程序：</p><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> [<span class="string">&quot;/usr/bin/nginx&quot;</span>]</span></span><br></pre></td></tr></table></figure><p>完整构建代码：</p><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Version: 0.0.3</span></span><br><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">16.04</span></span><br><span class="line"><span class="keyword">MAINTAINER</span> 何民三 <span class="string">&quot;cn.liuht@gmail.com&quot;</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> apt-get update</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> apt-get install -y nginx</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> <span class="built_in">echo</span> <span class="string">&#x27;Hello World, 我是个容器&#x27;</span> \ </span></span><br><span class="line">   &gt; /var/www/html/index.html</span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> [<span class="string">&quot;/usr/sbin/nginx&quot;</span>]</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">80</span></span><br></pre></td></tr></table></figure><p>使用docker build构建镜像，并将镜像指定为 itbilu/test：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker build -t=<span class="string">&quot;itbilu/test&quot;</span> .</span><br></pre></td></tr></table></figure><p>构建完成后，使用itbilu/test启动一个容器：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -i -t  itbilu/<span class="built_in">test</span> -g <span class="string">&quot;daemon off;&quot;</span></span><br></pre></td></tr></table></figure><p>在运行容器时，我们使用了 <code>-g &quot;daemon off;&quot;</code>，这个参数将会被传递给 ENTRYPOINT，最终在容器中执行的命令为 <code>/usr/sbin/nginx -g &quot;daemon off;&quot;</code>。</p><h3 id="12-LABEL"><a href="#12-LABEL" class="headerlink" title="12 LABEL"></a>12 LABEL</h3><p>LABEL用于为镜像添加元数据，元数以键值对的形式指定：</p><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">LABEL</span><span class="bash"> &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; ...</span></span><br></pre></td></tr></table></figure><p>使用LABEL指定元数据时，一条LABEL指定可以指定一或多条元数据，指定多条元数据时不同元数据之间通过空格分隔。推荐将所有的元数据通过一条LABEL指令指定，以免生成过多的中间镜像。 如，通过LABEL指定一些元数据：</p><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">LABEL</span><span class="bash"> version=<span class="string">&quot;1.0&quot;</span> description=<span class="string">&quot;这是一个Web服务器&quot;</span> by=<span class="string">&quot;IT笔录&quot;</span></span></span><br></pre></td></tr></table></figure><p>指定后可以通过docker inspect查看：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker inspect itbilu/<span class="built_in">test</span></span><br><span class="line"><span class="string">&quot;Labels&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;version&quot;</span>: <span class="string">&quot;1.0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;description&quot;</span>: <span class="string">&quot;这是一个Web服务器&quot;</span>,</span><br><span class="line">    <span class="string">&quot;by&quot;</span>: <span class="string">&quot;IT笔录&quot;</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h3 id="13-ARG"><a href="#13-ARG" class="headerlink" title="13 ARG"></a>13 ARG</h3><p>ARG用于指定传递给构建运行时的变量：</p><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ARG</span> &lt;name&gt;[=&lt;default value&gt;]</span><br></pre></td></tr></table></figure><p>如，通过ARG指定两个变量：</p><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ARG</span> site</span><br><span class="line"><span class="keyword">ARG</span> build_user=IT笔录</span><br></pre></td></tr></table></figure><p>以上我们指定了 site 和 build_user 两个变量，其中 build_user 指定了默认值。在使用 docker build 构建镜像时，可以通过 <code>--build-arg &lt;varname&gt;=&lt;value&gt;</code> 参数来指定或重设置这些变量的值。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker build --build-arg site=itiblu.com -t itbilu/<span class="built_in">test</span> .</span><br></pre></td></tr></table></figure><p>这样我们构建了 itbilu/test 镜像，其中site会被设置为 itbilu.com，由于没有指定 build_user，其值将是默认值 IT 笔录。</p><h3 id="14-ONBUILD"><a href="#14-ONBUILD" class="headerlink" title="14 ONBUILD"></a>14 ONBUILD</h3><p>ONBUILD用于设置镜像触发器：</p><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ONBUILD</span> [INSTRUCTION]</span><br></pre></td></tr></table></figure><p>当所构建的镜像被用做其它镜像的基础镜像，该镜像中的触发器将会被钥触发。 如，当镜像被使用时，可能需要做一些处理：</p><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">[...]</span><br><span class="line"><span class="keyword">ONBUILD</span> <span class="keyword">ADD</span><span class="bash"> . /app/src</span></span><br><span class="line"><span class="keyword">ONBUILD</span> <span class="keyword">RUN</span><span class="bash"> /usr/<span class="built_in">local</span>/bin/python-build --dir /app/src</span></span><br><span class="line">[...]</span><br></pre></td></tr></table></figure><h3 id="15-STOPSIGNAL"><a href="#15-STOPSIGNAL" class="headerlink" title="15 STOPSIGNAL"></a>15 STOPSIGNAL</h3><p>STOPSIGNAL用于设置停止容器所要发送的系统调用信号：</p><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">STOPSIGNAL</span> signal</span><br></pre></td></tr></table></figure><p>所使用的信号必须是内核系统调用表中的合法的值，如：SIGKILL。</p><h3 id="16-SHELL"><a href="#16-SHELL" class="headerlink" title="16 SHELL"></a>16 SHELL</h3><p>SHELL用于设置执行命令（shell式）所使用的的默认 shell 类型：</p><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHELL</span><span class="bash"> [<span class="string">&quot;executable&quot;</span>, <span class="string">&quot;parameters&quot;</span>]</span></span><br></pre></td></tr></table></figure><p>SHELL在Windows环境下比较有用，Windows 下通常会有 cmd 和 powershell 两种 shell，可能还会有 sh。这时就可以通过 SHELL 来指定所使用的 shell 类型：</p><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> microsoft/windowsservercore</span><br><span class="line"></span><br><span class="line"><span class="comment"># Executed as cmd /S /C echo default</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> <span class="built_in">echo</span> default</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Executed as cmd /S /C powershell -command Write-Host default</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> powershell -<span class="built_in">command</span> Write-Host default</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Executed as powershell -command Write-Host hello</span></span><br><span class="line"><span class="keyword">SHELL</span><span class="bash"> [<span class="string">&quot;powershell&quot;</span>, <span class="string">&quot;-command&quot;</span>]</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> Write-Host hello</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Executed as cmd /S /C echo hello</span></span><br><span class="line"><span class="keyword">SHELL</span><span class="bash"> [<span class="string">&quot;cmd&quot;</span>, <span class="string">&quot;/S&quot;</span><span class="string">&quot;, &quot;</span>/C<span class="string">&quot;]</span></span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> <span class="built_in">echo</span> hello</span></span><br></pre></td></tr></table></figure><h2 id="Dockerfile-使用经验"><a href="#Dockerfile-使用经验" class="headerlink" title="Dockerfile 使用经验"></a>Dockerfile 使用经验</h2><h3 id="Dockerfile-示例"><a href="#Dockerfile-示例" class="headerlink" title="Dockerfile 示例"></a>Dockerfile 示例</h3><p><strong>构建Nginx运行环境</strong></p><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 指定基础镜像</span></span><br><span class="line"><span class="keyword">FROM</span> sameersbn/ubuntu:<span class="number">14.04</span>.<span class="number">20161014</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 维护者信息</span></span><br><span class="line"><span class="keyword">MAINTAINER</span> sameer@damagehead.com</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置环境</span></span><br><span class="line"><span class="keyword">ENV</span> RTMP_VERSION=<span class="number">1.1</span>.<span class="number">10</span> \</span><br><span class="line">    NPS_VERSION=<span class="number">1.11</span>.<span class="number">33.4</span> \</span><br><span class="line">    LIBAV_VERSION=<span class="number">11.8</span> \</span><br><span class="line">    NGINX_VERSION=<span class="number">1.10</span>.<span class="number">1</span> \</span><br><span class="line">    NGINX_USER=www-data \</span><br><span class="line">    NGINX_SITECONF_DIR=/etc/nginx/sites-enabled \</span><br><span class="line">    NGINX_LOG_DIR=/var/log/nginx \</span><br><span class="line">    NGINX_TEMP_DIR=/var/lib/nginx \</span><br><span class="line">    NGINX_SETUP_DIR=/var/cache/nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置构建时变量，镜像建立完成后就失效</span></span><br><span class="line"><span class="keyword">ARG</span> BUILD_LIBAV=false</span><br><span class="line"><span class="keyword">ARG</span> WITH_DEBUG=false</span><br><span class="line"><span class="keyword">ARG</span> WITH_PAGESPEED=true</span><br><span class="line"><span class="keyword">ARG</span> WITH_RTMP=true</span><br><span class="line"></span><br><span class="line"><span class="comment"># 复制本地文件到容器目录中</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> setup/ <span class="variable">$&#123;NGINX_SETUP_DIR&#125;</span>/</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> bash <span class="variable">$&#123;NGINX_SETUP_DIR&#125;</span>/install.sh</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 复制本地配置文件到容器目录中</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> nginx.conf /etc/nginx/nginx.conf</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> entrypoint.sh /sbin/entrypoint.sh</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行指令</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> chmod 755 /sbin/entrypoint.sh</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 允许指定的端口</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">80</span>/tcp <span class="number">443</span>/tcp <span class="number">1935</span>/tcp</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定网站目录挂载点</span></span><br><span class="line"><span class="keyword">VOLUME</span><span class="bash"> [<span class="string">&quot;<span class="variable">$&#123;NGINX_SITECONF_DIR&#125;</span>&quot;</span>]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> [<span class="string">&quot;/sbin/entrypoint.sh&quot;</span>]</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">&quot;/usr/sbin/nginx&quot;</span>]</span></span><br></pre></td></tr></table></figure><p><strong>构建tomcat 环境</strong></p><p>Dockerfile文件</p><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 指定基于的基础镜像</span></span><br><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">13.10</span>  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 维护者信息</span></span><br><span class="line"><span class="keyword">MAINTAINER</span> zhangjiayang <span class="string">&quot;zhangjiayang@sczq.com.cn&quot;</span>  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 镜像的指令操作</span></span><br><span class="line"><span class="comment"># 获取APT更新的资源列表</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> <span class="built_in">echo</span> <span class="string">&quot;deb http://archive.ubuntu.com/ubuntu precise main universe&quot;</span>&gt; /etc/apt/sources.list</span></span><br><span class="line"><span class="comment"># 更新软件</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> apt-get update  </span></span><br><span class="line">  </span><br><span class="line"><span class="comment"># Install curl  </span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> apt-get -y install curl  </span></span><br><span class="line">  </span><br><span class="line"><span class="comment"># Install JDK 7  </span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> <span class="built_in">cd</span> /tmp &amp;&amp;  curl -L <span class="string">&#x27;http://download.oracle.com/otn-pub/java/jdk/7u65-b17/jdk-7u65-linux-x64.tar.gz&#x27;</span> -H <span class="string">&#x27;Cookie: oraclelicense=accept-securebackup-cookie; gpw_e24=Dockerfile&#x27;</span> | tar -xz  </span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> mkdir -p /usr/lib/jvm  </span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> mv /tmp/jdk1.7.0_65/ /usr/lib/jvm/java-7-oracle/  </span></span><br><span class="line">  </span><br><span class="line"><span class="comment"># Set Oracle JDK 7 as default Java  </span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> update-alternatives --install /usr/bin/java java /usr/lib/jvm/java-7-oracle/bin/java 300     </span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> update-alternatives --install /usr/bin/javac javac /usr/lib/jvm/java-7-oracle/bin/javac 300     </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置系统环境</span></span><br><span class="line"><span class="keyword">ENV</span> JAVA_HOME /usr/lib/jvm/java-<span class="number">7</span>-oracle/  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># Install tomcat7  </span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> <span class="built_in">cd</span> /tmp &amp;&amp; curl -L <span class="string">&#x27;http://archive.apache.org/dist/tomcat/tomcat-7/v7.0.8/bin/apache-tomcat-7.0.8.tar.gz&#x27;</span> | tar -xz  </span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> mv /tmp/apache-tomcat-7.0.8/ /opt/tomcat7/  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">ENV</span> CATALINA_HOME /opt/tomcat7  </span><br><span class="line"><span class="keyword">ENV</span> PATH $PATH:$CATALINA_HOME/bin  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 复件tomcat7.sh到容器中的目录 </span></span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> tomcat7.sh /etc/init.d/tomcat7  </span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> chmod 755 /etc/init.d/tomcat7  </span></span><br><span class="line">  </span><br><span class="line"><span class="comment"># Expose ports.  指定暴露的端口</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">8080</span>  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># Define default command.  </span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> service tomcat7 start &amp;&amp; tail -f /opt/tomcat7/logs/catalina.out</span></span><br></pre></td></tr></table></figure><p><code>tomcat7.sh</code>命令文件</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export JAVA_HOME=/usr/lib/jvm/java-7-oracle/  </span><br><span class="line">export TOMCAT_HOME=/opt/tomcat7  </span><br><span class="line">  </span><br><span class="line">case $1 in  </span><br><span class="line">start)  </span><br><span class="line">  sh $TOMCAT_HOME/bin/startup.sh  </span><br><span class="line">;;  </span><br><span class="line">stop)  </span><br><span class="line">  sh $TOMCAT_HOME/bin/shutdown.sh  </span><br><span class="line">;;  </span><br><span class="line">restart)  </span><br><span class="line">  sh $TOMCAT_HOME/bin/shutdown.sh  </span><br><span class="line">  sh $TOMCAT_HOME/bin/startup.sh  </span><br><span class="line">;;  </span><br><span class="line">esac  </span><br><span class="line">exit 0</span><br></pre></td></tr></table></figure><h3 id="原则与建议"><a href="#原则与建议" class="headerlink" title="原则与建议"></a>原则与建议</h3><ul><li>容器轻量化。从镜像中产生的容器应该尽量轻量化，能在足够短的时间内停止、销毁、重新生成并替换原来的容器。</li><li>使用 <code>.gitignore</code>。在大部分情况下，Dockerfile 会和构建所需的文件放在同一个目录中，为了提高构建的性能，应该使用 <code>.gitignore</code> 来过滤掉不需要的文件和目录。</li><li>为了减少镜像的大小，减少依赖，仅安装需要的软件包。</li><li>一个容器只做一件事。解耦复杂的应用，分成多个容器，而不是所有东西都放在一个容器内运行。如一个 Python Web 应用，可能需要 Server、DB、Cache、MQ、Log 等几个容器。一个更加极端的说法：One process per container。</li><li>减少镜像的图层。不要多个 Label、ENV 等标签。</li><li>对续行的参数按照字母表排序，特别是使用<code>apt-get install -y</code>安装包的时候。</li><li>使用构建缓存。如果不想使用缓存，可以在构建的时候使用参数<code>--no-cache=true</code>来强制重新生成中间镜像。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 笔记本 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
            <tag> Dockerfile </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Dockerfile使用介绍</title>
      <link href="post/c15a63a5/"/>
      <url>post/c15a63a5/</url>
      
        <content type="html"><![CDATA[<blockquote><p>转自：<a href="http://www.ityouknow.com/docker/2018/03/12/docker-use-dockerfile.html">Docker(二)：Dockerfile 使用介绍</a>， 怕以后找不到</p></blockquote><h2 id="Dockerfile-概念"><a href="#Dockerfile-概念" class="headerlink" title="Dockerfile 概念"></a>Dockerfile 概念</h2><p>Docker 镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。镜像不包含任何动态数据，其内容在构建之后也不会被改变。</p><p>镜像的定制实际上就是定制每一层所添加的配置、文件。如果我们可以把每一层修改、安装、构建、操作的命令都写入一个脚本，用这个脚本来构建、定制镜像，那么之前提及的无法重复的问题、镜像构建透明性的问题、体积的问题就都会解决。这个脚本就是 Dockerfile。</p><p>Dockerfile 是一个文本文件，其内包含了一条条的指令(Instruction)，每一条指令构建一层，因此每一条指令的内容，就是描述该层应当如何构建。有了 Dockerfile，当我们需要定制自己额外的需求时，只需在 Dockerfile 上添加或者修改指令，重新生成 image 即可，省去了敲命令的麻烦。</p><h2 id="Dockerfile-文件格式"><a href="#Dockerfile-文件格式" class="headerlink" title="Dockerfile 文件格式"></a>Dockerfile 文件格式</h2><p>Dockerfile文件格式如下：</p><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="comment">##  Dockerfile文件格式</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># This dockerfile uses the ubuntu image</span></span><br><span class="line"><span class="comment"># VERSION 2 - EDITION 1</span></span><br><span class="line"><span class="comment"># Author: docker_user</span></span><br><span class="line"><span class="comment"># Command format: Instruction [arguments / command] ..</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 1、第一行必须指定 基础镜像信息</span></span><br><span class="line"><span class="keyword">FROM</span> ubuntu</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 2、维护者信息</span></span><br><span class="line"><span class="keyword">MAINTAINER</span> docker_user docker_user@email.com</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 3、镜像操作指令</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> <span class="built_in">echo</span> <span class="string">&quot;deb http://archive.ubuntu.com/ubuntu/ raring main universe&quot;</span> &gt;&gt; /etc/apt/sources.list</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> apt-get update &amp;&amp; apt-get install -y nginx</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> <span class="built_in">echo</span> <span class="string">&quot;\ndaemon off;&quot;</span> &gt;&gt; /etc/nginx/nginx.conf</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 4、容器启动执行指令</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> /usr/sbin/nginx</span></span><br></pre></td></tr></table></figure><p>Dockerfile 分为四部分：<strong>基础镜像信息、维护者信息、镜像操作指令、容器启动执行指令</strong>。一开始必须要指明所基于的镜像名称，接下来一般会说明维护者信息；后面则是镜像操作指令，例如 RUN 指令。每执行一条RUN 指令，镜像添加新的一层，并提交；最后是 CMD 指令，来指明运行容器时的操作命令。</p><h2 id="构建镜像"><a href="#构建镜像" class="headerlink" title="构建镜像"></a>构建镜像</h2><p>docker build 命令会根据 Dockerfile 文件及上下文构建新 Docker 镜像。构建上下文是指 Dockerfile 所在的本地路径或一个URL（Git仓库地址）。构建上下文环境会被递归处理，所以构建所指定的路径还包括了子目录，而URL还包括了其中指定的子模块。</p><p>将当前目录做为构建上下文时，可以像下面这样使用docker build命令构建镜像：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker build .</span><br><span class="line">Sending build context to Docker daemon  6.51 MB</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>说明：构建会在 Docker 后台守护进程（daemon）中执行，而不是<code>CLI</code>中。构建前，构建进程会将全部内容（递归）发送到守护进程。大多情况下，应该将一个空目录作为构建上下文环境，并将 Dockerfile 文件放在该目录下。</p><p>在构建上下文中使用的 Dockerfile 文件，是一个构建指令文件。为了提高构建性能，可以通过<code>.dockerignore</code>文件排除上下文目录下不需要的文件和目录。</p><p>在 Docker 构建镜像的第一步，docker CLI 会先在上下文目录中寻找<code>.dockerignore</code>文件，根据<code>.dockerignore</code> 文件排除上下文目录中的部分文件和目录，然后把剩下的文件和目录传递给 Docker 服务。</p><p>Dockerfile 一般位于构建上下文的根目录下，也可以通过<code>-f</code>指定该文件的位置：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker build -f /path/to/a/Dockerfile .</span><br></pre></td></tr></table></figure><p>构建时，还可以通过<code>-t</code>参数指定构建成镜像的仓库、标签。</p><h2 id="镜像标签"><a href="#镜像标签" class="headerlink" title="镜像标签"></a>镜像标签</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker build -t nginx/v3 .</span><br></pre></td></tr></table></figure><p>如果存在多个仓库下，或使用多个镜像标签，就可以使用多个<code>-t</code>参数：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker build -t nginx/v3:1.0.2 -t nginx/v3:latest .</span><br></pre></td></tr></table></figure><p>在 Docker 守护进程执行 Dockerfile 中的指令前，首先会对 Dockerfile 进行语法检查，有语法错误时会返回：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker build -t nginx/v3 .</span><br><span class="line">Sending build context to Docker daemon 2.048 kB</span><br><span class="line">Error response from daemon: Unknown instruction: RUNCMD</span><br></pre></td></tr></table></figure><h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><p>Docker 守护进程会一条一条的执行 Dockerfile 中的指令，而且会在每一步提交并生成一个新镜像，最后会输出最终镜像的ID。生成完成后，Docker 守护进程会自动清理你发送的上下文。 Dockerfile文件中的每条指令会被独立执行，并会创建一个新镜像，RUN cd /tmp等命令不会对下条指令产生影响。 Docker 会重用已生成的中间镜像，以加速docker build的构建速度。以下是一个使用了缓存镜像的执行过程：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker build -t svendowideit/ambassador .</span><br><span class="line">Sending build context to Docker daemon 15.36 kB</span><br><span class="line">Step 1/4 : FROM alpine:3.2</span><br><span class="line"> ---&gt; 31f630c65071</span><br><span class="line">Step 2/4 : MAINTAINER SvenDowideit@home.org.au</span><br><span class="line"> ---&gt; Using cache</span><br><span class="line"> ---&gt; 2a1c91448f5f</span><br><span class="line">Step 3/4 : RUN apk update &amp;&amp;      apk add socat &amp;&amp;        rm -r /var/cache/</span><br><span class="line"> ---&gt; Using cache</span><br><span class="line"> ---&gt; 21ed6e7fbb73</span><br><span class="line">Step 4/4 : CMD env | grep _TCP= | (sed <span class="string">&#x27;s/.*_PORT_\([0-9]*\)_TCP=tcp:\/\/\(.*\):\(.*\)/socat -t 100000000 TCP4-LISTEN:\1,fork,reuseaddr TCP4:\2:\3 \&amp;/&#x27;</span> &amp;&amp; <span class="built_in">echo</span> <span class="built_in">wait</span>) | sh</span><br><span class="line"> ---&gt; Using cache</span><br><span class="line"> ---&gt; 7ea8aef582cc</span><br><span class="line">Successfully built 7ea8aef582cc</span><br></pre></td></tr></table></figure><p>构建缓存仅会使用本地父生成链上的镜像，如果不想使用本地缓存的镜像，也可以通过<code>--cache-from</code>指定缓存。指定后将不再使用本地生成的镜像链，而是从镜像仓库中下载。</p><h2 id="寻找缓存的逻辑"><a href="#寻找缓存的逻辑" class="headerlink" title="寻找缓存的逻辑"></a>寻找缓存的逻辑</h2><p>Docker 寻找缓存的逻辑其实就是树型结构根据 Dockerfile 指令遍历子节点的过程。下图可以说明这个逻辑。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">     FROM base_image:version           Dockerfile:</span><br><span class="line">           +----------+                FROM base_image:version</span><br><span class="line">           |base image|                RUN cmd1  --&gt; use cache because we found base image</span><br><span class="line">           +-----X----+                RUN cmd11 --&gt; use cache because we found cmd1</span><br><span class="line">                / \</span><br><span class="line">               /   \</span><br><span class="line">       RUN cmd1     RUN cmd2           Dockerfile:</span><br><span class="line">       +------+     +------+           FROM base_image:version</span><br><span class="line">       |image1|     |image2|           RUN cmd2  --&gt; use cache because we found base image</span><br><span class="line">       +---X--+     +------+           RUN cmd21 --&gt; not use cache because there<span class="string">&#x27;s no child node</span></span><br><span class="line"><span class="string">          / \                                        running cmd21, so we build a new image here</span></span><br><span class="line"><span class="string">         /   \</span></span><br><span class="line"><span class="string">RUN cmd11     RUN cmd12</span></span><br><span class="line"><span class="string">+-------+     +-------+</span></span><br><span class="line"><span class="string">|image11|     |image12|</span></span><br><span class="line"><span class="string">+-------+     +-------+</span></span><br></pre></td></tr></table></figure><p>大部分指令可以根据上述逻辑去寻找缓存，除了 ADD 和 COPY 。这两个指令会复制文件内容到镜像内，除了指令相同以外，Docker 还会检查每个文件内容校验(不包括最后修改时间和最后访问时间)，如果校验不一致，则不会使用缓存。</p><p>除了这两个命令，Docker 并不会去检查容器内的文件内容，比如 <code>RUN apt-get -y update</code>，每次执行时文件可能都不一样，但是 Docker 认为命令一致，会继续使用缓存。这样一来，以后构建时都不会再重新运行<code>apt-get -y update</code>。</p><p>如果 Docker 没有找到当前指令的缓存，则会构建一个新的镜像，并且之后的所有指令都不会再去寻找缓存。</p><h2 id="简单示例"><a href="#简单示例" class="headerlink" title="简单示例"></a>简单示例</h2><p>接下来用一个简单的示例来感受一下 Dockerfile 是如何用来构建镜像启动容器。我们以定制 nginx 镜像为例，在一个空白目录中，建立一个文本文件，并命名为 Dockerfile：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir mynginx</span><br><span class="line"><span class="built_in">cd</span> mynginx</span><br><span class="line">vi Dockerfile</span><br></pre></td></tr></table></figure><p>构建一个 Dockerfile 文件内容为：</p><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> nginx</span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> <span class="built_in">echo</span> <span class="string">&#x27;&lt;h1&gt;Hello, Docker!&lt;/h1&gt;&#x27;</span> &gt; /usr/share/nginx/html/index.html</span></span><br><span class="line">vi Dockerfile</span><br></pre></td></tr></table></figure><p>这个 Dockerfile 很简单，一共就两行涉及到了两条指令：FROM 和 RUN，FROM 表示获取指定基础镜像，RUN 执行命令，在执行的过程中重写了 nginx 的默认页面信息，将信息替换为：Hello, Docker!。</p><p>在 Dockerfile 文件所在目录执行：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker build -t nginx:v1 .</span><br></pre></td></tr></table></figure><p>命令最后有一个. 表示当前目录</p><p>构建完成之后，使用 <code>docker images</code> 命令查看所有镜像，如果存在 REPOSITORY 为 nginx 和 TAG 是 v1 的信息，就表示构建成功。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker images</span><br><span class="line">REPOSITORY                      TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">nginx                           v1                  8c92471de2cc        6 minutes ago       108.6 MB</span><br></pre></td></tr></table></figure><p>接下来使用 docker run 命令来启动容器</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run  --name docker_nginx_v1   -d -p 80:80 nginx:v1</span><br></pre></td></tr></table></figure><p>这条命令会用 nginx 镜像启动一个容器，命名为<code>docker_nginx_v1</code>，并且映射了 80 端口，这样我们可以用浏览器去访问这个 nginx 服务器：<code>http://192.168.0.54/</code>，页面返回信息：</p><p><img src="https://github.com/cayzlh/git-img-repository/raw/master/blog/2019/09/19.png" alt="img"></p><p>这样一个简单使用 Dockerfile 构建镜像，运行容器的示例就完成了！</p><h2 id="修改容器内容"><a href="#修改容器内容" class="headerlink" title="修改容器内容"></a>修改容器内容</h2><p>容器启动后，需要对容器内的文件进行进一步的完善，可以使用<code>docker exec -it xx bash</code>命令再次进行修改，以上面的示例为基础，修改 nginx 启动页面内容：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker exec -it docker_nginx_v1   bash</span><br><span class="line">root@3729b97e8226:&#x2F;# echo &#39;&lt;h1&gt;Hello, Docker neo!&lt;&#x2F;h1&gt;&#39; &gt; &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;index.html</span><br><span class="line">root@3729b97e8226:&#x2F;# exit</span><br><span class="line">exit</span><br></pre></td></tr></table></figure><p>以交互式终端方式进入 docker_nginx_v1 容器，并执行了 bash 命令，也就是获得一个可操作的 Shell。然后，我们用<code>&lt;h1&gt;Hello, Docker neo!&lt;/h1&gt;</code>覆盖了 <code>/usr/share/nginx/html/index.html</code> 的内容。</p><p>再次刷新浏览器，会发现内容被改变。</p><p><img src="https://github.com/cayzlh/git-img-repository/raw/master/blog/2019/09/20.png" alt="img"></p><p>修改了容器的文件，也就是改动了容器的存储层，可以通过 docker diff 命令看到具体的改动。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker diff docker_nginx_v1 </span><br><span class="line">... </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记本 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
            <tag> Dockerfile </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis的使用场景</title>
      <link href="post/3351059309/"/>
      <url>post/3351059309/</url>
      
        <content type="html"><![CDATA[<blockquote><p>转自：<a href="https://juejin.im/entry/5c4e6153e51d452d7b70daf9?utm_source=gold_browser_extension">使用过Redis，我竟然还不知道Rdb</a></p></blockquote><p>整理Redis的使用场景</p><h2 id="字符串缓存"><a href="#字符串缓存" class="headerlink" title="字符串缓存"></a>字符串缓存</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">redis-&gt;<span class="built_in">set</span>();</span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">redis-&gt;get();</span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">redis-&gt;hset();</span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">redis-&gt;hget();</span></span><br></pre></td></tr></table></figure><h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">redis-&gt;rpush();</span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">redis-&gt;lpop();</span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">redis-&gt;lrange();</span></span><br></pre></td></tr></table></figure><h2 id="发布订阅"><a href="#发布订阅" class="headerlink" title="发布订阅"></a>发布订阅</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">redis-&gt;publish();</span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">redis-&gt;subscribe();</span></span><br></pre></td></tr></table></figure><h2 id="计数器"><a href="#计数器" class="headerlink" title="计数器"></a>计数器</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">redis-&gt;<span class="built_in">set</span>();</span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">redis-&gt;incr();</span></span><br></pre></td></tr></table></figure><h2 id="排行榜"><a href="#排行榜" class="headerlink" title="排行榜"></a>排行榜</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">redis-&gt;zadd();</span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">redis-&gt;zrevrange();</span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">redis-&gt;zrange();</span></span><br></pre></td></tr></table></figure><h2 id="集合间操作"><a href="#集合间操作" class="headerlink" title="集合间操作"></a>集合间操作</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">redis-&gt;sadd();</span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">redis-&gt;spop();</span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">redis-&gt;sinter();</span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">redis-&gt;sunion();</span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">redis-&gt;sdiff();</span></span><br></pre></td></tr></table></figure><h2 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h2><p>解释：悲观锁(Pessimistic Lock), 顾名思义，就是很悲观。</p><p>每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁。</p><p>场景：如果项目中使用了缓存且对缓存设置了超时时间。</p><p>当并发量比较大的时候，如果没有锁机制，那么缓存过期的瞬间，</p><p>大量并发请求会穿透缓存直接查询数据库，造成雪崩效应。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"></span><br><span class="line"> * 获取锁</span><br><span class="line"></span><br><span class="line"> * @param  String  $key    锁标识</span><br><span class="line"></span><br><span class="line"> * @param  Int     $expire 锁过期时间</span><br><span class="line"></span><br><span class="line"> * @return Boolean</span><br><span class="line"></span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">public function lock($key = &#x27;&#x27;, $expire = 5) &#123;</span><br><span class="line"></span><br><span class="line">    $is_lock = $this-&gt;_redis-&gt;setnx($key, time()+$expire);</span><br><span class="line"></span><br><span class="line">    //不能获取锁</span><br><span class="line"></span><br><span class="line">    if(!$is_lock)&#123;</span><br><span class="line"></span><br><span class="line">        //判断锁是否过期</span><br><span class="line"></span><br><span class="line">        $lock_time = $this-&gt;_redis-&gt;get($key);</span><br><span class="line"></span><br><span class="line">        //锁已过期，删除锁，重新获取</span><br><span class="line"></span><br><span class="line">        if (time() &gt; $lock_time) &#123;</span><br><span class="line"></span><br><span class="line">            unlock($key);</span><br><span class="line"></span><br><span class="line">            $is_lock = $this-&gt;_redis-&gt;setnx($key, time() + $expire);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return $is_lock? true : false;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"></span><br><span class="line"> * 释放锁</span><br><span class="line"></span><br><span class="line"> * @param  String  $key 锁标识</span><br><span class="line"></span><br><span class="line"> * @return Boolean</span><br><span class="line"></span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">public function unlock($key = &#x27;&#x27;)&#123;</span><br><span class="line"></span><br><span class="line">    return $this-&gt;_redis-&gt;del($key);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 定义锁标识</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">key = <span class="string">&#x27;test_lock&#x27;</span>;</span></span><br><span class="line"></span><br><span class="line">// 获取锁</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">is_lock = lock(<span class="variable">$key</span>, 10);</span></span><br><span class="line"></span><br><span class="line">if ($is_lock) &#123;</span><br><span class="line"></span><br><span class="line">    echo &#x27;get lock success&lt;br&gt;&#x27;;</span><br><span class="line"></span><br><span class="line">    echo &#x27;do sth..&lt;br&gt;&#x27;;</span><br><span class="line"></span><br><span class="line">    sleep(5);</span><br><span class="line"></span><br><span class="line">    echo &#x27;success&lt;br&gt;&#x27;;</span><br><span class="line"></span><br><span class="line">    unlock($key);</span><br><span class="line"></span><br><span class="line">&#125; else &#123; //获取锁失败</span><br><span class="line"></span><br><span class="line">    echo &#x27;request too frequently&lt;br&gt;&#x27;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h2><p>解释：乐观锁(Optimistic Lock), 顾名思义，就是很乐观。</p><p>每次去拿数据的时候都认为别人不会修改，所以不会上锁。</p><p>watch命令会监视给定的key，当exec时候如果监视的key从调用watch后发生过变化，则整个事务会失败。</p><p>也可以调用watch多次监视多个key。这样就可以对指定的key加乐观锁了。</p><p>注意watch的key是对整个连接有效的，事务也一样。</p><p>如果连接断开，监视和事务都会被自动清除。</p><p>当然了exec，discard，unwatch命令都会清除连接中的所有监视。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">strKey = <span class="string">&#x27;test_age&#x27;</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">redis-&gt;<span class="built_in">set</span>(<span class="variable">$strKey</span>,10);</span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">age = <span class="variable">$redis</span>-&gt;get(<span class="variable">$strKey</span>);</span></span><br><span class="line"></span><br><span class="line">echo &quot;---- Current Age:&#123;$age&#125; ---- &lt;br/&gt;&lt;br/&gt;&quot;;</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">redis-&gt;watch(<span class="variable">$strKey</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 开启事务</span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">redis-&gt;multi();</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 在这个时候新开了一个新会话执行</span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">redis-&gt;<span class="built_in">set</span>(<span class="variable">$strKey</span>,30);  <span class="comment">#新会话</span></span></span><br><span class="line"></span><br><span class="line">echo &quot;---- Current Age:&#123;$age&#125; ---- &lt;br/&gt;&lt;br/&gt;&quot;; # 30</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">redis-&gt;<span class="built_in">set</span>(<span class="variable">$strKey</span>,20);</span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">redis-&gt;<span class="built_in">exec</span>();</span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">age = <span class="variable">$redis</span>-&gt;get(<span class="variable">$strKey</span>);</span></span><br><span class="line"></span><br><span class="line">echo &quot;---- Current Age:&#123;$age&#125; ---- &lt;br/&gt;&lt;br/&gt;&quot;; # 30</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 当<span class="built_in">exec</span>时候如果监视的key从调用watch后发生过变化，则整个事务会失败</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记本 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JDK8特性一览</title>
      <link href="post/1abc3648/"/>
      <url>post/1abc3648/</url>
      
        <content type="html"><![CDATA[<blockquote><p>转自：<a href="https://github.com/winterbe/java8-tutorial">https://github.com/winterbe/java8-tutorial</a></p><p>转自：<a href="https://juejin.im/post/5c3d7c8a51882525dd591ac7?utm_source=gold_browser_extension#%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3-Functional-Interface">Java8 新特性指导手册</a></p></blockquote><h2 id="接口内允许添加默认实现的方法"><a href="#接口内允许添加默认实现的方法" class="headerlink" title="接口内允许添加默认实现的方法"></a>接口内允许添加默认实现的方法</h2><p>Java 8 允许我们通过 <code>default</code> 关键字对接口中定义的抽象方法提供一个默认的实现。</p><p>请看下面示例代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义一个公式接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Formula</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 计算</span></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">calculate</span><span class="params">(<span class="keyword">int</span> a)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 求平方根</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">double</span> <span class="title">sqrt</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Math.sqrt(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面这个接口中，我们除了定义了一个抽象方法 <code>calculate</code>，还定义了一个带有默认实现的方法 <code>sqrt</code>。 我们在实现这个接口时，可以只需要实现 <code>calculate</code> 方法，默认方法 <code>sqrt</code> 可以直接调用即可，也就是说我们可以不必强制实现 <code>sqrt</code> 方法。</p><blockquote><p>补充：通过 <code>default</code> 关键字这个新特性，可以非常方便地对之前的接口做拓展，而此接口的实现类不必做任何改动。</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Formula formula = <span class="keyword">new</span> Formula() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">calculate</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sqrt(a * <span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">formula.calculate(<span class="number">100</span>);     <span class="comment">// 100.0</span></span><br><span class="line">formula.sqrt(<span class="number">16</span>);           <span class="comment">// 4.0</span></span><br></pre></td></tr></table></figure><p>上面通过匿名对象实现了 <code>Formula</code> 接口。但是即使是这样，我们为了完成一个 <code>sqrt(a * 100)</code>简单计算，就写了 6 行代码，很是冗余。</p><h2 id="Lamdba表达式"><a href="#Lamdba表达式" class="headerlink" title="Lamdba表达式"></a>Lamdba表达式</h2><p>在学习 <code>Lambda</code> 表达式之前，我们先来看一段老版本的示例代码，其对一个含有字符串的集合进行排序：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; names = Arrays.asList(<span class="string">&quot;peter&quot;</span>, <span class="string">&quot;anna&quot;</span>, <span class="string">&quot;mike&quot;</span>, <span class="string">&quot;xenia&quot;</span>);</span><br><span class="line"></span><br><span class="line">Collections.sort(names, <span class="keyword">new</span> Comparator&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String a, String b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> b.compareTo(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>Collections</code> 工具类提供了静态方法 <code>sort</code> 方法，入参是一个 <code>List</code> 集合，和一个 <code>Comparator</code> 比较器，以便对给定的 <code>List</code> 集合进行 排序。上面的示例代码创建了一个匿名内部类作为入参，这种类似的操作在我们日常的工作中随处可见。</p><p>Java 8 中不再推荐这种写法，而是推荐使用 Lambda 表达：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Collections.sort(names, (String a, String b) -&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> b.compareTo(a);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>正如你看到的，上面这段代码变得简短很多而且易于阅读。但是我们还可以再精炼一点：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Collections.sort(names, (String a, String b) -&gt; b.compareTo(a));</span><br></pre></td></tr></table></figure><p><code>List</code> 集合现在已经添加了 <code>sort</code> 方法。而且 Java 编译器能够根据<strong>类型推断机制</strong>判断出参数类型，这样，连入参的类型都可以省略了！</p><h2 id="函数式接口-Functional-Interface"><a href="#函数式接口-Functional-Interface" class="headerlink" title="函数式接口 Functional Interface"></a>函数式接口 Functional Interface</h2><p>抛出一个疑问：在我们书写一段 Lambda 表达式后（比如上一章节中匿名内部类的 Lambda 表达式缩写形式），Java 编译器是如何进行类型推断的，它又是怎么知道重写的哪个方法的？</p><p>需要说明的是，不是每个接口都可以缩写成 Lambda 表达式。只有那些函数式接口（Functional Interface）才能缩写成 Lambda 表示式。</p><p>那么什么是函数式接口（Functional Interface）呢？</p><p>所谓函数式接口（Functional Interface）就是只包含一个抽象方法的声明。针对该接口类型的所有 Lambda 表达式都会与这个抽象方法匹配。</p><blockquote><p>注意：你可能会有疑问，Java 8 中不是允许通过 defualt 关键字来为接口添加默认方法吗？那它算不算抽象方法呢？答案是：不算。因此，你可以毫无顾忌的添加默认方法，它并不违反函数式接口（Functional Interface）的定义。</p></blockquote><p>总结一下：只要接口中仅仅包含一个抽象方法，我们就可以将其改写为 Lambda 表达式。为了保证一个接口明确的被定义为一个函数式接口（Functional Interface），我们需要为该接口添加注解：<code>@FunctionalInterface</code>。这样，一旦你添加了第二个抽象方法，编译器会立刻抛出错误提示。</p><p>示例代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Converter</span>&lt;<span class="title">F</span>, <span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">T <span class="title">convert</span><span class="params">(F from)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例代码2：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Converter&lt;String, Integer&gt; converter = (from) -&gt; Integer.valueOf(from);</span><br><span class="line">Integer converted = converter.convert(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">System.out.println(converted);    <span class="comment">// 123</span></span><br></pre></td></tr></table></figure><blockquote><p>注意：上面的示例代码，即使去掉 <code>@FunctionalInterface</code> 也是好使的，它仅仅是一种约束而已。</p></blockquote><h2 id="便捷的引用类的构造器及方法"><a href="#便捷的引用类的构造器及方法" class="headerlink" title="便捷的引用类的构造器及方法"></a>便捷的引用类的构造器及方法</h2><p>小伙伴们，还记得上一个章节这段示例代码么：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Converter</span>&lt;<span class="title">F</span>, <span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">T <span class="title">convert</span><span class="params">(F from)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Converter&lt;String, Integer&gt; converter = (from) -&gt; Integer.valueOf(from);</span><br><span class="line">Integer converted = converter.convert(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">System.out.println(converted);    <span class="comment">// 123</span></span><br></pre></td></tr></table></figure><p>上面这段代码，通过 Java 8 的新特性，进一步简化上面的代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Converter&lt;String, Integer&gt; converter = Integer::valueOf;</span><br><span class="line">Integer converted = converter.convert(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">System.out.println(converted);   <span class="comment">// 123</span></span><br></pre></td></tr></table></figure><p>Java 8 中允许你通过 <code>::</code> 关键字来引用类的方法或构造器。上面的代码简单的示例了如何引用静态方法，当然，除了静态方法，我们还可以引用普通方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Something</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">startsWith</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> String.valueOf(s.charAt(<span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Something something = <span class="keyword">new</span> Something();</span><br><span class="line">Converter&lt;String, String&gt; converter = something::startsWith;</span><br><span class="line">String converted = converter.convert(<span class="string">&quot;Java&quot;</span>);</span><br><span class="line">System.out.println(converted);    <span class="comment">// &quot;J&quot;</span></span><br></pre></td></tr></table></figure><p>接下来，我们再来看看如何通过 <code>::</code> 关键字来引用类的构造器。首先，我们先来定义一个示例类，在类中声明两个构造器：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    String firstName;</span><br><span class="line">    String lastName;</span><br><span class="line"></span><br><span class="line">    Person() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    Person(String firstName, String lastName) &#123;</span><br><span class="line">        <span class="keyword">this</span>.firstName = firstName;</span><br><span class="line">        <span class="keyword">this</span>.lastName = lastName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，我们再定义一个工厂接口，用来生成 <code>Person</code> 类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Person 工厂</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">PersonFactory</span>&lt;<span class="title">P</span> <span class="keyword">extends</span> <span class="title">Person</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">P <span class="title">create</span><span class="params">(String firstName, String lastName)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以通过 <code>::</code> 关键字来引用 <code>Person</code> 类的构造器，来代替手动去实现这个工厂接口：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 直接引用 Person 构造器</span></span><br><span class="line">PersonFactory&lt;Person&gt; personFactory = Person::<span class="keyword">new</span>;</span><br><span class="line">Person person = personFactory.create(<span class="string">&quot;Peter&quot;</span>, <span class="string">&quot;Parker&quot;</span>);</span><br></pre></td></tr></table></figure><p><code>Person::new</code> 这段代码，能够直接引用 <code>Person</code> 类的构造器。然后 Java 编译器能够根据上下文选中正确的构造器去实现 <code>PersonFactory.create</code> 方法。</p><h2 id="Lamdba访问外部变量及接口默认方法"><a href="#Lamdba访问外部变量及接口默认方法" class="headerlink" title="Lamdba访问外部变量及接口默认方法"></a>Lamdba访问外部变量及接口默认方法</h2><p>在本章节中，我们将会讨论如何在 lambda 表达式中访问外部变量（包括：局部变量，成员变量，静态变量，接口的默认方法.），它与匿名内部类访问外部变量很相似。</p><h3 id="访问局部变量"><a href="#访问局部变量" class="headerlink" title="访问局部变量"></a>访问局部变量</h3><p>在 Lambda 表达式中，我们可以访问外部的 <code>final</code> 类型变量，如下面的示例代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 转换器</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Converter</span>&lt;<span class="title">F</span>, <span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">T <span class="title">convert</span><span class="params">(F from)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line">Converter&lt;Integer, String&gt; stringConverter =</span><br><span class="line">        (from) -&gt; String.valueOf(from + num);</span><br><span class="line"></span><br><span class="line">stringConverter.convert(<span class="number">2</span>);     <span class="comment">// 3</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>与匿名内部类不同的是，我们不必显式声明 <code>num</code> 变量为 <code>final</code> 类型，下面这段代码同样有效：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line">Converter&lt;Integer, String&gt; stringConverter =</span><br><span class="line">        (from) -&gt; String.valueOf(from + num);</span><br><span class="line"></span><br><span class="line">stringConverter.convert(<span class="number">2</span>);     <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>但是 <code>num</code> 变量必须为隐式的 <code>final</code> 类型，何为隐式的 <code>final</code> 呢？就是说到编译期为止，<code>num</code> 对象是不能被改变的，如下面这段代码，就不能被编译通过：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line">Converter&lt;Integer, String&gt; stringConverter =</span><br><span class="line">        (from) -&gt; String.valueOf(from + num);</span><br><span class="line">num = <span class="number">3</span>;</span><br></pre></td></tr></table></figure><p>在 lambda 表达式内部改变 <code>num</code> 值同样编译不通过，需要注意, 比如下面的示例代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line">Converter&lt;Integer, String&gt; converter = (from) -&gt; &#123;</span><br><span class="line">String value = String.valueOf(from + num);</span><br><span class="line">num = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">return</span> value;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="访问成员变量和静态变量"><a href="#访问成员变量和静态变量" class="headerlink" title="访问成员变量和静态变量"></a>访问成员变量和静态变量</h3><p>上一章节中，了解了如何在 Lambda 表达式中访问局部变量。与局部变量相比，在 Lambda 表达式中对成员变量和静态变量拥有读写权限：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Converter</span>&lt;<span class="title">F</span>, <span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">T <span class="title">convert</span><span class="params">(F from)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lambda4</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 静态变量</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> outerStaticNum;</span><br><span class="line">    <span class="comment">// 成员变量</span></span><br><span class="line">    <span class="keyword">int</span> outerNum;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">testScopes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Converter&lt;Integer, String&gt; stringConverter1 = (from) -&gt; &#123;</span><br><span class="line">            <span class="comment">// 对成员变量赋值</span></span><br><span class="line">            outerNum = <span class="number">23</span>;</span><br><span class="line">            <span class="keyword">return</span> String.valueOf(from);</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Converter&lt;Integer, String&gt; stringConverter2 = (from) -&gt; &#123;</span><br><span class="line">            <span class="comment">// 对静态变量赋值</span></span><br><span class="line">            outerStaticNum = <span class="number">72</span>;</span><br><span class="line">            <span class="keyword">return</span> String.valueOf(from);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="访问接口的默认方法"><a href="#访问接口的默认方法" class="headerlink" title="访问接口的默认方法"></a>访问接口的默认方法</h3><p>还记得第一章节中定义的那个 <code>Formula</code> (公式) 接口吗？</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Formula</span> </span>&#123;</span><br><span class="line"><span class="comment">// 计算</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">calculate</span><span class="params">(<span class="keyword">int</span> a)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求平方根</span></span><br><span class="line"><span class="function"><span class="keyword">default</span> <span class="keyword">double</span> <span class="title">sqrt</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> Math.sqrt(a);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当时，我们在接口中定义了一个带有默认实现的 <code>sqrt</code> 求平方根方法，在匿名内部类中我们可以很方便的访问此方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Formula formula = <span class="keyword">new</span> Formula() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">calculate</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> sqrt(a * <span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>但是在 lambda 表达式中可不行：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Formula formula = (a) -&gt; sqrt(a * <span class="number">100</span>);</span><br></pre></td></tr></table></figure><p>带有默认实现的接口方法，是<strong>不能</strong>在 lambda 表达式中访问的，上面这段代码将无法被编译通过。</p><h2 id="内置的函数式接口"><a href="#内置的函数式接口" class="headerlink" title="内置的函数式接口"></a>内置的函数式接口</h2><p>JDK 1.8 API 包含了很多内置的函数式接口。其中就包括我们在老版本中经常见到的 Comparator 和 Runnable，Java 8 为他们都添加了 @FunctionalInterface 注解，以用来支持 Lambda 表达式。</p><p>值得一提的是，除了 Comparator 和 Runnable 外，还有一些新的函数式接口，它们很多都借鉴于知名的 <a href="https://link.juejin.im/?target=https://github.com/google/guava">Google Guava</a> 库。</p><h3 id="Predicate断言"><a href="#Predicate断言" class="headerlink" title="Predicate断言"></a>Predicate断言</h3><p><code>Predicate</code> 是一个可以指定入参类型，并返回 boolean 值的函数式接口。它内部提供了一些带有默认实现的方法，可以 被用来组合一个复杂的逻辑判断（<code>and</code>, <code>or</code>, <code>negate</code>）：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Predicate&lt;String&gt; predicate = (s) -&gt; s.length() &gt; <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">predicate.test(<span class="string">&quot;foo&quot;</span>);              <span class="comment">// true</span></span><br><span class="line">predicate.negate().test(<span class="string">&quot;foo&quot;</span>);     <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">Predicate&lt;Boolean&gt; nonNull = Objects::nonNull;</span><br><span class="line">Predicate&lt;Boolean&gt; isNull = Objects::isNull;</span><br><span class="line"></span><br><span class="line">Predicate&lt;String&gt; isEmpty = String::isEmpty;</span><br><span class="line">Predicate&lt;String&gt; isNotEmpty = isEmpty.negate();</span><br></pre></td></tr></table></figure><h3 id="Function"><a href="#Function" class="headerlink" title="Function"></a>Function</h3><p><code>Function</code> 函数式接口的作用是，我们可以为其提供一个原料，他给生产一个最终的产品。通过它提供的默认方法，组合,链行处理(<code>compose</code>, <code>andThen</code>)：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Function&lt;String, Integer&gt; toInteger = Integer::valueOf;</span><br><span class="line">Function&lt;String, String&gt; backToString = toInteger.andThen(String::valueOf);</span><br><span class="line"></span><br><span class="line">backToString.apply(<span class="string">&quot;123&quot;</span>);     <span class="comment">// &quot;123&quot;</span></span><br></pre></td></tr></table></figure><h3 id="Supplier生产者"><a href="#Supplier生产者" class="headerlink" title="Supplier生产者"></a>Supplier生产者</h3><p><code>Supplier</code> 与 <code>Function</code> 不同，它不接受入参，直接为我们生产一个指定的结果，有点像生产者模式：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    String firstName;</span><br><span class="line">    String lastName;</span><br><span class="line"></span><br><span class="line">    Person() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    Person(String firstName, String lastName) &#123;</span><br><span class="line">        <span class="keyword">this</span>.firstName = firstName;</span><br><span class="line">        <span class="keyword">this</span>.lastName = lastName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Supplier&lt;Person&gt; personSupplier = Person::<span class="keyword">new</span>;</span><br><span class="line">personSupplier.get();   <span class="comment">// new Person</span></span><br></pre></td></tr></table></figure><p>###Consumer消费者</p><p>对于 <code>Consumer</code>，我们需要提供入参，用来被消费，如下面这段示例代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    String firstName;</span><br><span class="line">    String lastName;</span><br><span class="line"></span><br><span class="line">    Person() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    Person(String firstName, String lastName) &#123;</span><br><span class="line">        <span class="keyword">this</span>.firstName = firstName;</span><br><span class="line">        <span class="keyword">this</span>.lastName = lastName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Consumer&lt;Person&gt; greeter = (p) -&gt; System.out.println(<span class="string">&quot;Hello, &quot;</span> + p.firstName);</span><br><span class="line">greeter.accept(<span class="keyword">new</span> Person(<span class="string">&quot;Luke&quot;</span>, <span class="string">&quot;Skywalker&quot;</span>));</span><br></pre></td></tr></table></figure><h3 id="Comparator"><a href="#Comparator" class="headerlink" title="Comparator"></a>Comparator</h3><p><code>Comparator</code> 在 Java 8 之前是使用比较普遍的。Java 8 中除了将其升级成了函数式接口，还为它拓展了一些默认方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Comparator&lt;Person&gt; comparator = (p1, p2) -&gt; p1.firstName.compareTo(p2.firstName);</span><br><span class="line"></span><br><span class="line">Person p1 = <span class="keyword">new</span> Person(<span class="string">&quot;John&quot;</span>, <span class="string">&quot;Doe&quot;</span>);</span><br><span class="line">Person p2 = <span class="keyword">new</span> Person(<span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;Wonderland&quot;</span>);</span><br><span class="line"></span><br><span class="line">comparator.compare(p1, p2);             <span class="comment">// &gt; 0</span></span><br><span class="line">comparator.reversed().compare(p1, p2);  <span class="comment">// &lt; 0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Optional"><a href="#Optional" class="headerlink" title="Optional"></a>Optional</h2><p>首先，<code>Optional</code> 它不是一个函数式接口，设计它的目的是为了防止空指针异常（<code>NullPointerException</code>），要知道在 Java 编程中， 空指针异常可是臭名昭著的。</p><p>让我们来快速了解一下 <code>Optional</code> 要如何使用！你可以将 <code>Optional</code> 看做是包装对象（可能是 <code>null</code>, 也有可能非 <code>null</code>）的容器。当你定义了 一个方法，这个方法返回的对象可能是空，也有可能非空的时候，你就可以考虑用 <code>Optional</code> 来包装它，这也是在 Java 8 被推荐使用的做法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Optional&lt;String&gt; optional = Optional.of(<span class="string">&quot;bam&quot;</span>);</span><br><span class="line"></span><br><span class="line">optional.isPresent();           <span class="comment">// true</span></span><br><span class="line">optional.get();                 <span class="comment">// &quot;bam&quot;</span></span><br><span class="line">optional.orElse(<span class="string">&quot;fallback&quot;</span>);    <span class="comment">// &quot;bam&quot;</span></span><br><span class="line"></span><br><span class="line">optional.ifPresent((s) -&gt; System.out.println(s.charAt(<span class="number">0</span>)));     <span class="comment">// &quot;b&quot;</span></span><br></pre></td></tr></table></figure><h2 id="Stream流"><a href="#Stream流" class="headerlink" title="Stream流"></a>Stream流</h2><p><em>什么是 Stream 流？</em></p><p>简单来说，我们可以使用 <code>java.util.Stream</code> 对一个包含一个或多个元素的集合做各种操作。这些操作可能是 <em>中间操作</em> 亦或是 <em>终端操作</em>。 终端操作会返回一个结果，而中间操作会返回一个 <code>Stream</code> 流。</p><p>需要注意的是，你只能对实现了 <code>java.util.Collection</code> 接口的类做流的操作。</p><blockquote><p><code>Map</code> 不支持 <code>Stream</code> 流。</p></blockquote><p><code>Stream</code> 流支持同步执行，也支持并发执行。</p><h3 id="Filter过滤"><a href="#Filter过滤" class="headerlink" title="Filter过滤"></a>Filter过滤</h3><p>首先，我们创建一个 <code>List</code> 集合：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; stringCollection = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">stringCollection.add(<span class="string">&quot;ddd2&quot;</span>);</span><br><span class="line">stringCollection.add(<span class="string">&quot;aaa2&quot;</span>);</span><br><span class="line">stringCollection.add(<span class="string">&quot;bbb1&quot;</span>);</span><br><span class="line">stringCollection.add(<span class="string">&quot;aaa1&quot;</span>);</span><br><span class="line">stringCollection.add(<span class="string">&quot;bbb3&quot;</span>);</span><br><span class="line">stringCollection.add(<span class="string">&quot;ccc&quot;</span>);</span><br><span class="line">stringCollection.add(<span class="string">&quot;bbb2&quot;</span>);</span><br><span class="line">stringCollection.add(<span class="string">&quot;ddd1&quot;</span>);</span><br></pre></td></tr></table></figure><p><code>Filter</code> 的入参是一个 <code>Predicate</code>, 上面已经说到，<code>Predicate</code> 是一个断言的中间操作，它能够帮我们筛选出我们需要的集合元素。它的返参同样 是一个 <code>Stream</code> 流，我们可以通过 <code>foreach</code>终端操作，来打印被筛选的元素：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">stringCollection</span><br><span class="line">    .stream()</span><br><span class="line">    .filter((s) -&gt; s.startsWith(<span class="string">&quot;a&quot;</span>))</span><br><span class="line">    .forEach(System.out::println);</span><br><span class="line"></span><br><span class="line"><span class="comment">// &quot;aaa2&quot;, &quot;aaa1&quot;</span></span><br></pre></td></tr></table></figure><blockquote><p>注意：<code>foreach</code> 是一个终端操作，它的返参是 <code>void</code>, 我们无法对其再次进行流操作。</p></blockquote><h3 id="Sorted排序"><a href="#Sorted排序" class="headerlink" title="Sorted排序"></a>Sorted排序</h3><p><code>Sorted</code> 同样是一个中间操作，它的返参是一个 <code>Stream</code> 流。另外，我们可以传入一个 <code>Comparator</code> 用来自定义排序，如果不传，则使用默认的排序规则。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">stringCollection</span><br><span class="line">    .stream()</span><br><span class="line">    .sorted()</span><br><span class="line">    .filter((s) -&gt; s.startsWith(<span class="string">&quot;a&quot;</span>))</span><br><span class="line">    .forEach(System.out::println);</span><br><span class="line"></span><br><span class="line"><span class="comment">// &quot;aaa1&quot;, &quot;aaa2&quot;</span></span><br></pre></td></tr></table></figure><p>需要注意，<code>sorted</code> 不会对 <code>stringCollection</code> 做出任何改变，<code>stringCollection</code> 还是原有的那些个元素，且顺序不变：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(stringCollection);</span><br><span class="line"><span class="comment">// ddd2, aaa2, bbb1, aaa1, bbb3, ccc, bbb2, ddd1</span></span><br></pre></td></tr></table></figure><h3 id="Map转换"><a href="#Map转换" class="headerlink" title="Map转换"></a>Map转换</h3><p>中间操作 <code>Map</code> 能够帮助我们将 <code>List</code> 中的每一个元素做功能处理。例如下面的示例，通过 <code>map</code>我们将每一个 <code>string</code> 转成大写：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">stringCollection</span><br><span class="line">    .stream()</span><br><span class="line">    .map(String::toUpperCase)</span><br><span class="line">    .sorted((a, b) -&gt; b.compareTo(a))</span><br><span class="line">    .forEach(System.out::println);</span><br><span class="line"></span><br><span class="line"><span class="comment">// &quot;DDD2&quot;, &quot;DDD1&quot;, &quot;CCC&quot;, &quot;BBB3&quot;, &quot;BBB2&quot;, &quot;AAA2&quot;, &quot;AAA1&quot;</span></span><br></pre></td></tr></table></figure><p>另外，我们还可以做对象之间的转换，业务中比较常用的是将 <code>DO</code>（数据库对象） 转换成 <code>BO</code>（业务对象） 。</p><h3 id="Match匹配"><a href="#Match匹配" class="headerlink" title="Match匹配"></a>Match匹配</h3><p>顾名思义，<code>match</code> 用来做匹配操作，它的返回值是一个 <code>boolean</code> 类型。通过 <code>match</code>, 我们可以方便的验证一个 <code>list</code> 中是否存在某个类型的元素。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 验证 list 中 string 是否有以 a 开头的, 匹配到第一个，即返回 true</span></span><br><span class="line"><span class="keyword">boolean</span> anyStartsWithA =</span><br><span class="line">    stringCollection</span><br><span class="line">        .stream()</span><br><span class="line">        .anyMatch((s) -&gt; s.startsWith(<span class="string">&quot;a&quot;</span>));</span><br><span class="line"></span><br><span class="line">System.out.println(anyStartsWithA);      <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 验证 list 中 string 是否都是以 a 开头的</span></span><br><span class="line"><span class="keyword">boolean</span> allStartsWithA =</span><br><span class="line">    stringCollection</span><br><span class="line">        .stream()</span><br><span class="line">        .allMatch((s) -&gt; s.startsWith(<span class="string">&quot;a&quot;</span>));</span><br><span class="line"></span><br><span class="line">System.out.println(allStartsWithA);      <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 验证 list 中 string 是否都不是以 z 开头的,</span></span><br><span class="line"><span class="keyword">boolean</span> noneStartsWithZ =</span><br><span class="line">    stringCollection</span><br><span class="line">        .stream()</span><br><span class="line">        .noneMatch((s) -&gt; s.startsWith(<span class="string">&quot;z&quot;</span>));</span><br><span class="line"></span><br><span class="line">System.out.println(noneStartsWithZ);      <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h3 id="Count计数"><a href="#Count计数" class="headerlink" title="Count计数"></a>Count计数</h3><p><code>count</code> 是一个终端操作，它能够统计 <code>stream</code> 流中的元素总数，返回值是 <code>long</code> 类型。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 先对 list 中字符串开头为 b 进行过滤，让后统计数量</span></span><br><span class="line"><span class="keyword">long</span> startsWithB =</span><br><span class="line">    stringCollection</span><br><span class="line">        .stream()</span><br><span class="line">        .filter((s) -&gt; s.startsWith(<span class="string">&quot;b&quot;</span>))</span><br><span class="line">        .count();</span><br><span class="line"></span><br><span class="line">System.out.println(startsWithB);    <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><h3 id="Reduce汇聚"><a href="#Reduce汇聚" class="headerlink" title="Reduce汇聚"></a>Reduce汇聚</h3><p><code>Reduce</code> 中文翻译为：<em>减少、缩小</em>。通过入参的 <code>Function</code>，我们能够将 <code>list</code> 归约成一个值。它的返回类型是 <code>Optional</code> 类型。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Optional&lt;String&gt; reduced =</span><br><span class="line">    stringCollection</span><br><span class="line">        .stream()</span><br><span class="line">        .sorted()</span><br><span class="line">        .reduce((s1, s2) -&gt; s1 + <span class="string">&quot;#&quot;</span> + s2);</span><br><span class="line"></span><br><span class="line">reduced.ifPresent(System.out::println);</span><br><span class="line"><span class="comment">// &quot;aaa1#aaa2#bbb1#bbb2#bbb3#ccc#ddd1#ddd2&quot;</span></span><br></pre></td></tr></table></figure><p>##Parallel Streams并行流</p><p>前面章节我们说过，<code>stream</code> 流是支持<strong>顺序</strong>和<strong>并行</strong>的。顺序流操作是单线程操作，而并行流是通过多线程来处理的，能够充分利用物理机 多核 CPU 的优势，同时处理速度更快。</p><p>首先，我们创建一个包含 1000000 UUID list 集合。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> max = <span class="number">1000000</span>;</span><br><span class="line">List&lt;String&gt; values = <span class="keyword">new</span> ArrayList&lt;&gt;(max);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; max; i++) &#123;</span><br><span class="line">    UUID uuid = UUID.randomUUID();</span><br><span class="line">    values.add(uuid.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分别通过顺序流和并行流，对这个 list 进行排序，测算耗时:</p><h3 id="顺序流排序"><a href="#顺序流排序" class="headerlink" title="顺序流排序"></a>顺序流排序</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 纳秒</span></span><br><span class="line"><span class="keyword">long</span> t0 = System.nanoTime();</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> count = values.stream().sorted().count();</span><br><span class="line">System.out.println(count);</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 纳秒转微秒</span></span><br><span class="line"><span class="keyword">long</span> millis = TimeUnit.NANOSECONDS.toMillis(t1 - t0);</span><br><span class="line">System.out.println(String.format(<span class="string">&quot;顺序流排序耗时: %d ms&quot;</span>, millis));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 顺序流排序耗时: 899 ms</span></span><br></pre></td></tr></table></figure><h3 id="并行流排序"><a href="#并行流排序" class="headerlink" title="并行流排序"></a>并行流排序</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 纳秒</span></span><br><span class="line"><span class="keyword">long</span> t0 = System.nanoTime();</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> count = values.parallelStream().sorted().count();</span><br><span class="line">System.out.println(count);</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 纳秒转微秒</span></span><br><span class="line"><span class="keyword">long</span> millis = TimeUnit.NANOSECONDS.toMillis(t1 - t0);</span><br><span class="line">System.out.println(String.format(<span class="string">&quot;并行流排序耗时: %d ms&quot;</span>, millis));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 并行流排序耗时: 472 ms</span></span><br></pre></td></tr></table></figure><p>正如你所见，同样的逻辑处理，通过并行流，我们的性能提升了近 **50%**。完成这一切，我们需要做的仅仅是将 <code>stream</code> 改成了 <code>parallelStream</code>。</p><h2 id="Map集合"><a href="#Map集合" class="headerlink" title="Map集合"></a>Map集合</h2><p>前面已经提到过 <code>Map</code> 是不支持 <code>Stream</code> 流的，因为 <code>Map</code> 接口并没有像 <code>Collection</code> 接口那样，定义了 <code>stream()</code> 方法。但是，我们可以对其 <code>key</code>, <code>values</code>, <code>entry</code> 使用 流操作，如 <code>map.keySet().stream()</code>, <code>map.values().stream()</code> 和 <code>map.entrySet().stream()</code>.</p><p>另外, JDK 8 中对 <code>map</code> 提供了一些其他新特性:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;Integer, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="comment">// 与老版不同的是，putIfAbent() 方法在 put 之前，</span></span><br><span class="line">    <span class="comment">// 会判断 key 是否已经存在，存在则直接返回 value, 否则 put, 再返回 value</span></span><br><span class="line">    map.putIfAbsent(i, <span class="string">&quot;val&quot;</span> + i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// forEach 可以很方便地对 map 进行遍历操作</span></span><br><span class="line">map.forEach((key, value) -&gt; System.out.println(value));</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>除了上面的 <code>putIfAbsent()</code> 和 <code>forEach()</code> 外，我们还可以很方便地对某个 <code>key</code> 的值做相关操作：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// computeIfPresent(), 当 key 存在时，才会做相关处理</span></span><br><span class="line"><span class="comment">// 如下：对 key 为 3 的值，内部会先判断值是否存在，存在，则做 value + key 的拼接操作</span></span><br><span class="line">map.computeIfPresent(<span class="number">3</span>, (num, val) -&gt; val + num);</span><br><span class="line">map.get(<span class="number">3</span>);             <span class="comment">// val33</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 先判断 key 为 9 的元素是否存在，存在，则做删除操作</span></span><br><span class="line">map.computeIfPresent(<span class="number">9</span>, (num, val) -&gt; <span class="keyword">null</span>);</span><br><span class="line">map.containsKey(<span class="number">9</span>);     <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// computeIfAbsent(), 当 key 不存在时，才会做相关处理</span></span><br><span class="line"><span class="comment">// 如下：先判断 key 为 23 的元素是否存在，不存在，则添加</span></span><br><span class="line">map.computeIfAbsent(<span class="number">23</span>, num -&gt; <span class="string">&quot;val&quot;</span> + num);</span><br><span class="line">map.containsKey(<span class="number">23</span>);    <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 先判断 key 为 3 的元素是否存在，存在，则不做任何处理</span></span><br><span class="line">map.computeIfAbsent(<span class="number">3</span>, num -&gt; <span class="string">&quot;bam&quot;</span>);</span><br><span class="line">map.get(<span class="number">3</span>);             <span class="comment">// val33</span></span><br></pre></td></tr></table></figure><p>关于删除操作，JDK 8 中提供了能够新的 <code>remove()</code> API:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">map.remove(<span class="number">3</span>, <span class="string">&quot;val3&quot;</span>);</span><br><span class="line">map.get(<span class="number">3</span>);             <span class="comment">// val33</span></span><br><span class="line"></span><br><span class="line">map.remove(<span class="number">3</span>, <span class="string">&quot;val33&quot;</span>);</span><br><span class="line">map.get(<span class="number">3</span>);             <span class="comment">// null</span></span><br></pre></td></tr></table></figure><p>如上代码，只有当给定的 <code>key</code> 和 <code>value</code> 完全匹配时，才会执行删除操作。</p><p>关于添加方法，JDK 8 中提供了带有默认值的 <code>getOrDefault()</code> 方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 若 key 42 不存在，则返回 not found</span></span><br><span class="line">map.getOrDefault(<span class="number">42</span>, <span class="string">&quot;not found&quot;</span>);  <span class="comment">// not found</span></span><br></pre></td></tr></table></figure><p>对于 <code>value</code> 的合并操作也变得更加简单：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// merge 方法，会先判断进行合并的 key 是否存在，不存在，则会添加元素</span></span><br><span class="line">map.merge(<span class="number">9</span>, <span class="string">&quot;val9&quot;</span>, (value, newValue) -&gt; value.concat(newValue));</span><br><span class="line">map.get(<span class="number">9</span>);             <span class="comment">// val9</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 若 key 的元素存在，则对 value 执行拼接操作</span></span><br><span class="line">map.merge(<span class="number">9</span>, <span class="string">&quot;concat&quot;</span>, (value, newValue) -&gt; value.concat(newValue));</span><br><span class="line">map.get(<span class="number">9</span>);             <span class="comment">// val9concat</span></span><br></pre></td></tr></table></figure><h2 id="新的日期API"><a href="#新的日期API" class="headerlink" title="新的日期API"></a>新的日期API</h2><p>Java 8 中在包 <code>java.time</code> 下添加了新的日期 API. 它和 <a href="https://link.juejin.im/?target=http://www.joda.org/joda-time/">Joda-Time</a> 库相似，但又不完全相同。</p><h3 id="Clock"><a href="#Clock" class="headerlink" title="Clock"></a>Clock</h3><p><code>Clock</code> 提供对当前日期和时间的访问。我们可以利用它来替代 <code>System.currentTimeMillis()</code> 方法。另外，通过 <code>clock.instant()</code> 能够获取一个 <code>instant</code> 实例， 此实例能够方便地转换成老版本中的 <code>java.util.Date</code> 对象。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Clock clock = Clock.systemDefaultZone();</span><br><span class="line"><span class="keyword">long</span> millis = clock.millis();</span><br><span class="line"></span><br><span class="line">Instant instant = clock.instant();</span><br><span class="line">Date legacyDate = Date.from(instant);   <span class="comment">// 老版本 java.util.Date</span></span><br></pre></td></tr></table></figure><h3 id="Timezones时区"><a href="#Timezones时区" class="headerlink" title="Timezones时区"></a>Timezones时区</h3><p><code>ZoneId</code> 代表时区类。通过静态工厂方法方便地获取它，入参我们可以传入某个时区编码。另外，时区类还定义了一个偏移量，用来在当前时刻或某时间 与目标时区时间之间进行转换。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(ZoneId.getAvailableZoneIds());</span><br><span class="line"><span class="comment">// prints all available timezone ids</span></span><br><span class="line"></span><br><span class="line">ZoneId zone1 = ZoneId.of(<span class="string">&quot;Europe/Berlin&quot;</span>);</span><br><span class="line">ZoneId zone2 = ZoneId.of(<span class="string">&quot;Brazil/East&quot;</span>);</span><br><span class="line">System.out.println(zone1.getRules());</span><br><span class="line">System.out.println(zone2.getRules());</span><br><span class="line"></span><br><span class="line"><span class="comment">// ZoneRules[currentStandardOffset=+01:00]</span></span><br><span class="line"><span class="comment">// ZoneRules[currentStandardOffset=-03:00]</span></span><br></pre></td></tr></table></figure><h3 id="LocalTime"><a href="#LocalTime" class="headerlink" title="LocalTime"></a>LocalTime</h3><p><code>LocalTime</code> 表示一个没有指定时区的时间类，例如，<code>10 p.m</code>.或者 <code>17：30:15</code>，下面示例代码中，将会使用上面创建的 时区对象创建两个 <code>LocalTime</code>。然后我们会比较两个时间，并计算它们之间的小时和分钟的不同。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LocalTime now1 = LocalTime.now(zone1);</span><br><span class="line">LocalTime now2 = LocalTime.now(zone2);</span><br><span class="line"></span><br><span class="line">System.out.println(now1.isBefore(now2));  <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> hoursBetween = ChronoUnit.HOURS.between(now1, now2);</span><br><span class="line"><span class="keyword">long</span> minutesBetween = ChronoUnit.MINUTES.between(now1, now2);</span><br><span class="line"></span><br><span class="line">System.out.println(hoursBetween);       <span class="comment">// -3</span></span><br><span class="line">System.out.println(minutesBetween);     <span class="comment">// -239</span></span><br></pre></td></tr></table></figure><p><code>LocalTime</code> 提供多个静态工厂方法，目的是为了简化对时间对象实例的创建和操作，包括对时间字符串进行解析的操作等。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LocalTime late = LocalTime.of(<span class="number">23</span>, <span class="number">59</span>, <span class="number">59</span>);</span><br><span class="line">System.out.println(late);       <span class="comment">// 23:59:59</span></span><br><span class="line"></span><br><span class="line">DateTimeFormatter germanFormatter =</span><br><span class="line">    DateTimeFormatter</span><br><span class="line">        .ofLocalizedTime(FormatStyle.SHORT)</span><br><span class="line">        .withLocale(Locale.GERMAN);</span><br><span class="line"></span><br><span class="line">LocalTime leetTime = LocalTime.parse(<span class="string">&quot;13:37&quot;</span>, germanFormatter);</span><br><span class="line">System.out.println(leetTime);   <span class="comment">// 13:37</span></span><br></pre></td></tr></table></figure><h3 id="LocalDate"><a href="#LocalDate" class="headerlink" title="LocalDate"></a>LocalDate</h3><p><code>LocalDate</code> 是一个日期对象，例如：<code>2014-03-11</code>。它和 <code>LocalTime</code> 一样是个 <code>final</code> 类型对象。下面的例子演示了如何通过加减日，月，年等来计算一个新的日期。</p><blockquote><p><code>LocalDate</code>, <code>LocalTime</code>, 因为是 <code>final</code> 类型的对象，每一次操作都会返回一个新的时间对象。</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LocalDate today = LocalDate.now();</span><br><span class="line"><span class="comment">// 今天加一天</span></span><br><span class="line">LocalDate tomorrow = today.plus(<span class="number">1</span>, ChronoUnit.DAYS);</span><br><span class="line"><span class="comment">// 明天减两天</span></span><br><span class="line">LocalDate yesterday = tomorrow.minusDays(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2014 年七月的第四天</span></span><br><span class="line">LocalDate independenceDay = LocalDate.of(<span class="number">2014</span>, Month.JULY, <span class="number">4</span>);</span><br><span class="line">DayOfWeek dayOfWeek = independenceDay.getDayOfWeek();</span><br><span class="line">System.out.println(dayOfWeek);    <span class="comment">// 星期五</span></span><br></pre></td></tr></table></figure><p>也可以直接解析日期字符串，生成 <code>LocalDate</code> 实例。（和 <code>LocalTime</code> 操作一样简单）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DateTimeFormatter germanFormatter =</span><br><span class="line">    DateTimeFormatter</span><br><span class="line">        .ofLocalizedDate(FormatStyle.MEDIUM)</span><br><span class="line">        .withLocale(Locale.GERMAN);</span><br><span class="line"></span><br><span class="line">LocalDate xmas = LocalDate.parse(<span class="string">&quot;24.12.2014&quot;</span>, germanFormatter);</span><br><span class="line">System.out.println(xmas);   <span class="comment">// 2014-12-24</span></span><br></pre></td></tr></table></figure><h3 id="LocalDateTime"><a href="#LocalDateTime" class="headerlink" title="LocalDateTime"></a>LocalDateTime</h3><p><code>LocalDateTime</code> 是一个<strong>日期-时间</strong>对象。你也可以将其看成是 <code>LocalDate</code> 和 <code>LocalTime</code> 的结合体。操作上，也大致相同。</p><blockquote><p><code>LocalDateTime</code> 同样是一个 <code>final</code> 类型对象。</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LocalDateTime sylvester = LocalDateTime.of(<span class="number">2014</span>, Month.DECEMBER, <span class="number">31</span>, <span class="number">23</span>, <span class="number">59</span>, <span class="number">59</span>);</span><br><span class="line"></span><br><span class="line">DayOfWeek dayOfWeek = sylvester.getDayOfWeek();</span><br><span class="line">System.out.println(dayOfWeek);      <span class="comment">// 星期三</span></span><br><span class="line"></span><br><span class="line">Month month = sylvester.getMonth();</span><br><span class="line">System.out.println(month);          <span class="comment">// 十二月</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取改时间是该天中的第几分钟</span></span><br><span class="line"><span class="keyword">long</span> minuteOfDay = sylvester.getLong(ChronoField.MINUTE_OF_DAY);</span><br><span class="line">System.out.println(minuteOfDay);    <span class="comment">// 1439</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如果再加上的时区信息，<code>LocalDateTime</code> 还能够被转换成 <code>Instance</code> 实例。<code>Instance</code> 能够被转换成老版本中 <code>java.util.Date</code> 对象。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Instant instant = sylvester</span><br><span class="line">        .atZone(ZoneId.systemDefault())</span><br><span class="line">        .toInstant();</span><br><span class="line"></span><br><span class="line">Date legacyDate = Date.from(instant);</span><br><span class="line">System.out.println(legacyDate);     <span class="comment">// Wed Dec 31 23:59:59 CET 2014</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>格式化 <code>LocalDateTime</code> 对象就和格式化 LocalDate 或者 LocalTime 一样。除了使用预定义的格式以外，也可以自定义格式化输出。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DateTimeFormatter formatter =</span><br><span class="line">    DateTimeFormatter</span><br><span class="line">        .ofPattern(<span class="string">&quot;MMM dd, yyyy - HH:mm&quot;</span>);</span><br><span class="line"></span><br><span class="line">LocalDateTime parsed = LocalDateTime.parse(<span class="string">&quot;Nov 03, 2014 - 07:13&quot;</span>, formatter);</span><br><span class="line">String string = formatter.format(parsed);</span><br><span class="line">System.out.println(string);     <span class="comment">// Nov 03, 2014 - 07:13</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>注意：和 <code>java.text.NumberFormat</code> 不同，新的 <code>DateTimeFormatter</code> 类是 <code>final</code> 类型的，同时也是线程安全的。</p></blockquote><h2 id="Annotations注解"><a href="#Annotations注解" class="headerlink" title="Annotations注解"></a>Annotations注解</h2><p>在 Java 8 中，注解是可以重复的。让我通过下面的示例代码，来看看到底是咋回事。</p><p>首先，我们定义一个包装注解，里面包含了一个有着实际注解的数组：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@interface</span> Hints &#123;</span><br><span class="line">    Hint[] value();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Repeatable(Hints.class)</span></span><br><span class="line"><span class="meta">@interface</span> Hint &#123;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Java 8 中，通过 <code>@Repeatable</code>，允许我们对同一个类使用多重注解：</p><p>第一种形态：使用注解容器（老方法）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Hints(&#123;@Hint(&quot;hint1&quot;), @Hint(&quot;hint2&quot;)&#125;)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>第二种形态：使用可重复注解（新方法）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Hint(&quot;hint1&quot;)</span></span><br><span class="line"><span class="meta">@Hint(&quot;hint2&quot;)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>使用第二种形态，Java 编译器能够在内部自动对 <code>@Hint</code> 进行设置。这对于需要通过反射来读取注解信息时，是非常重要的。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Hint hint = Person.class.getAnnotation(Hint.class);</span><br><span class="line">System.out.println(hint);                   <span class="comment">// null</span></span><br><span class="line"></span><br><span class="line">Hints hints1 = Person.class.getAnnotation(Hints.class);</span><br><span class="line">System.out.println(hints1.value().length);  <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">Hint[] hints2 = Person.class.getAnnotationsByType(Hint.class);</span><br><span class="line">System.out.println(hints2.length);          <span class="comment">// 2</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>尽管我们绝对不会在 <code>Person</code> 类上声明 <code>@Hints</code> 注解，但是它的信息仍然是可以通过 <code>getAnnotation(Hints.class)</code> 来读取的。 并且，<code>getAnnotationsByType</code> 方法会更方便，因为它赋予了所有 <code>@Hints</code> 注解标注的方法直接的访问权限。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE_PARAMETER, ElementType.TYPE_USE&#125;)</span></span><br><span class="line"><span class="meta">@interface</span> MyAnnotation &#123;&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用markdown画流程图、时序图</title>
      <link href="post/913648702/"/>
      <url>post/913648702/</url>
      
        <content type="html"><![CDATA[<blockquote><p>使用<code>markdown</code>来写文章，做笔记是非常方便的，这里记录一些高级用法，使用<code>markdown</code>画流程图、时序图、甘特图。</p><p>工具：<code>Typora</code></p></blockquote><h2 id="UML时序图"><a href="#UML时序图" class="headerlink" title="UML时序图"></a>UML时序图</h2><p>在<code>hexo</code>中需要配合使用<code>hexo-filter-sequence</code>以及<code>hexo-filter-mermaid-diagrams</code>插件支持渲染，具体参考：<a href="/2018/06/23/2018062301/">Hexo常用插件</a></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install --save hexo-filter-mermaid-diagrams</span><br><span class="line">npm install --save hexo-filter-sequence</span><br><span class="line">npm install --save hexo-filter-flowchart</span><br></pre></td></tr></table></figure><h3 id="简单示例"><a href="#简单示例" class="headerlink" title="简单示例"></a>简单示例</h3><p>源代码(<strong>反斜杠用于转义，实际不需要</strong>)：</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">\<span class="code">`\`</span>\`sequence</span><br><span class="line">A-&gt;B: Hello B(请求)?</span><br><span class="line">Note right of B: 对B的一些描述信息</span><br><span class="line">Note left of A: 对A的一些描述</span><br><span class="line">B--&gt;A: I&#x27;m find(响应)!两杠是虚线</span><br><span class="line">A-&gt;B: I&#x27;m really find.</span><br><span class="line">B-B: I&#x27;m touch myself.</span><br><span class="line">\<span class="code">`\`</span>\`</span><br></pre></td></tr></table></figure><p>效果：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A-&gt;B: Hello B(请求)?</span><br><span class="line">Note right of B: 对B的一些描述信息</span><br><span class="line">Note left of A: 对A的一些描述</span><br><span class="line">B--&gt;A: I&#39;m find(响应)!两杠是虚线</span><br><span class="line">A-&gt;B: I&#39;m really find.</span><br><span class="line">B-B: I&#39;m touch myself.</span><br></pre></td></tr></table></figure><h3 id="复杂示例"><a href="#复杂示例" class="headerlink" title="复杂示例"></a>复杂示例</h3><p>源代码：</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">\<span class="code">`\`</span>\`sequence</span><br><span class="line">Title: 使用：复杂使用</span><br><span class="line">A-&gt;B: Hello B?（请求）</span><br><span class="line">Note right of B: 对B的描述</span><br><span class="line">Note left of A: 对A的描述(提示)</span><br><span class="line">B--&gt;A: I&#x27;m Find!(响应)</span><br><span class="line">B-&gt;C: How are you?</span><br><span class="line">C--&gt;&gt;A: B touch me</span><br><span class="line">A-&gt;B: are you sure？</span><br><span class="line">Note over C,B: We are friend</span><br><span class="line">participant C</span><br><span class="line">Note right of C: 没人陪我玩</span><br><span class="line">\<span class="code">`\`</span>\`</span><br></pre></td></tr></table></figure><p>效果：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Title: 使用：复杂使用</span><br><span class="line">A-&gt;B: Hello B?（请求）</span><br><span class="line">Note right of B: 对B的描述</span><br><span class="line">Note left of A: 对A的描述(提示)</span><br><span class="line">B--&gt;A: I&#39;m Find!(响应)</span><br><span class="line">B-&gt;C: How are you?</span><br><span class="line">C--&gt;&gt;A: B touch me</span><br><span class="line">A-&gt;B: are you sure？</span><br><span class="line">Note over C,B: We are friend</span><br><span class="line">participant C</span><br><span class="line">Note right of C: 没人陪我玩</span><br></pre></td></tr></table></figure><h3 id="标准示例（使用mermaid标签）"><a href="#标准示例（使用mermaid标签）" class="headerlink" title="标准示例（使用mermaid标签）"></a>标准示例（使用mermaid标签）</h3><p>以下是标准的<code>UML</code>时序图示例：</p><p>源码：</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">\<span class="code">`\`</span>\`mermaid</span><br><span class="line">%% 时序图例子,-&gt; 直线，--&gt;虚线，-&gt;&gt;实线箭头</span><br><span class="line"></span><br><span class="line">sequenceDiagram</span><br><span class="line"></span><br><span class="line">participant 张三</span><br><span class="line"></span><br><span class="line">participant 李四</span><br><span class="line"></span><br><span class="line">张三-&gt;王五: 王五你好吗？</span><br><span class="line"></span><br><span class="line">loop 健康检查</span><br><span class="line"></span><br><span class="line">王五-&gt;王五: 与疾病战斗</span><br><span class="line"></span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">Note right of 王五: 合理 食物 <span class="xml"><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span>看医生...</span><br><span class="line"></span><br><span class="line">李四--&gt;&gt;张三: 很好!</span><br><span class="line"></span><br><span class="line">王五-&gt;李四: 你怎么样?</span><br><span class="line"></span><br><span class="line">李四--&gt;王五: 很好!</span><br><span class="line">\<span class="code">`\`</span>\`</span><br></pre></td></tr></table></figure><p>效果：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">%% 时序图例子,-&gt; 直线，--&gt;虚线，-&gt;&gt;实线箭头</span><br><span class="line"></span><br><span class="line">sequenceDiagram</span><br><span class="line"></span><br><span class="line">participant 张三</span><br><span class="line"></span><br><span class="line">participant 李四</span><br><span class="line"></span><br><span class="line">张三-&gt;王五: 王五你好吗？</span><br><span class="line"></span><br><span class="line">loop 健康检查</span><br><span class="line"></span><br><span class="line">王五-&gt;王五: 与疾病战斗</span><br><span class="line"></span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">Note right of 王五: 合理 食物 &lt;br&#x2F;&gt;看医生...</span><br><span class="line"></span><br><span class="line">李四--&gt;&gt;张三: 很好!</span><br><span class="line"></span><br><span class="line">王五-&gt;李四: 你怎么样?</span><br><span class="line"></span><br><span class="line">李四--&gt;王五: 很好!</span><br></pre></td></tr></table></figure><h2 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h2><h3 id="横向流程图"><a href="#横向流程图" class="headerlink" title="横向流程图"></a>横向流程图</h3><p>源码：</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">\<span class="code">`\`</span>\`mermaid</span><br><span class="line">graph LR</span><br><span class="line"></span><br><span class="line">A[方形] --&gt;B(圆角)</span><br><span class="line"></span><br><span class="line">B --&gt; C&#123;条件a&#125;</span><br><span class="line"></span><br><span class="line">C --&gt;|a=1| D[结果1]</span><br><span class="line"></span><br><span class="line">C --&gt;|a=2| E[结果2]</span><br><span class="line"></span><br><span class="line">F[横向流程图]</span><br><span class="line">\<span class="code">`\`</span>\`</span><br></pre></td></tr></table></figure><p>效果：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line"></span><br><span class="line">A[方形] --&gt;B(圆角)</span><br><span class="line"></span><br><span class="line">B --&gt; C&#123;条件a&#125;</span><br><span class="line"></span><br><span class="line">C --&gt;|a&#x3D;1| D[结果1]</span><br><span class="line"></span><br><span class="line">C --&gt;|a&#x3D;2| E[结果2]</span><br><span class="line"></span><br><span class="line">F[横向流程图]</span><br></pre></td></tr></table></figure><h3 id="纵向流程图"><a href="#纵向流程图" class="headerlink" title="纵向流程图"></a>纵向流程图</h3><p>源码：</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">\<span class="code">`\`</span>\`mermaid</span><br><span class="line">graph TD</span><br><span class="line"></span><br><span class="line">A[方形] --&gt;B(圆角)</span><br><span class="line"></span><br><span class="line">B --&gt; C&#123;条件a&#125;</span><br><span class="line"></span><br><span class="line">C --&gt;|a=1| D[结果1]</span><br><span class="line"></span><br><span class="line">C --&gt;|a=2| E[结果2]</span><br><span class="line"></span><br><span class="line">F[竖向流程图]</span><br><span class="line">\<span class="code">`\`</span>\`</span><br></pre></td></tr></table></figure><p>效果：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">graph TD</span><br><span class="line"></span><br><span class="line">A[方形] --&gt;B(圆角)</span><br><span class="line"></span><br><span class="line">B --&gt; C&#123;条件a&#125;</span><br><span class="line"></span><br><span class="line">C --&gt;|a&#x3D;1| D[结果1]</span><br><span class="line"></span><br><span class="line">C --&gt;|a&#x3D;2| E[结果2]</span><br><span class="line"></span><br><span class="line">F[竖向流程图]</span><br></pre></td></tr></table></figure><h3 id="标准流程图-flow"><a href="#标准流程图-flow" class="headerlink" title="标准流程图(flow)"></a>标准流程图(flow)</h3><p>源码：</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">\<span class="code">`\`</span>\`flow</span><br><span class="line">st=&gt;start: 开始框</span><br><span class="line">op=&gt;operation: 处理框</span><br><span class="line">cond=&gt;condition: 判断框(是或否?)</span><br><span class="line">sub1=&gt;subroutine: 子流程</span><br><span class="line">io=&gt;inputoutput: 输入输出框</span><br><span class="line">e=&gt;end: 结束框</span><br><span class="line">st-&gt;op-&gt;cond</span><br><span class="line">cond(yes)-&gt;io-&gt;e</span><br><span class="line">cond(no)-&gt;sub1(right)-&gt;op</span><br><span class="line">\<span class="code">`\`</span>\`</span><br></pre></td></tr></table></figure><p>效果：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">st&#x3D;&gt;start: 开始框</span><br><span class="line">op&#x3D;&gt;operation: 处理框</span><br><span class="line">cond&#x3D;&gt;condition: 判断框(是或否?)</span><br><span class="line">sub1&#x3D;&gt;subroutine: 子流程</span><br><span class="line">io&#x3D;&gt;inputoutput: 输入输出框</span><br><span class="line">e&#x3D;&gt;end: 结束框</span><br><span class="line">st-&gt;op-&gt;cond</span><br><span class="line">cond(yes)-&gt;io-&gt;e</span><br><span class="line">cond(no)-&gt;sub1(right)-&gt;op</span><br></pre></td></tr></table></figure><h2 id="甘特图"><a href="#甘特图" class="headerlink" title="甘特图"></a>甘特图</h2><p>源码：</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">\<span class="code">`\`</span>\`mermaid</span><br><span class="line">%% 语法示例</span><br><span class="line"></span><br><span class="line">gantt</span><br><span class="line"></span><br><span class="line">dateFormat  YYYY-MM-DD</span><br><span class="line"></span><br><span class="line">title 软件开发甘特图</span><br><span class="line"></span><br><span class="line">section 设计</span><br><span class="line"></span><br><span class="line">需求                      :done,    des1, 2018-01-06,2014-01-08</span><br><span class="line"></span><br><span class="line">原型                      :active,  des2, 2018-01-09, 3d</span><br><span class="line"></span><br><span class="line">UI设计                     :         des3, after des2, 5d</span><br><span class="line"></span><br><span class="line">未来任务                     :         des4, after des3, 5d</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">section 开发</span><br><span class="line"></span><br><span class="line">学习准备理解需求                      :crit, done, 2018-01-06,24h</span><br><span class="line"></span><br><span class="line">设计框架                             :crit, done, after des2, 2d</span><br><span class="line"></span><br><span class="line">开发                                 :crit, active, 3d</span><br><span class="line"></span><br><span class="line">未来任务                              :crit, 5d</span><br><span class="line"></span><br><span class="line">耍                                   :2d</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">section 测试</span><br><span class="line"></span><br><span class="line">功能测试                              :active, a1, after des3, 3d</span><br><span class="line"></span><br><span class="line">压力测试                               :after a1  , 20h</span><br><span class="line"></span><br><span class="line">测试报告                               : 48h</span><br><span class="line">\<span class="code">`\`</span>\`</span><br></pre></td></tr></table></figure><p>效果：</p><p>当前在<code>hexo</code>中渲染不出来，在<code>Typora</code>能展示如下，后续解决<code>Hexo</code>展示问题：</p><p><img src="https://cdn.jsdelivr.net/gh/cayzlh/git-img-repository@master/uPic/1.png" alt="1"></p>]]></content>
      
      
      <categories>
          
          <category> 笔记本 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Github上传大文件</title>
      <link href="post/1301075481/"/>
      <url>post/1301075481/</url>
      
        <content type="html"><![CDATA[<p>往<code>GitHub</code>上<code>push</code>单个超过<code>100M</code>文件的时候，会报一下错误：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">remote: Resolving deltas: 100% (472/472), done.</span><br><span class="line">remote: error: GH001: Large files detected.</span><br><span class="line">You may want to try Git Large File Storage - https://git-lfs.github.com.</span><br></pre></td></tr></table></figure><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>根据提示，访问<a href="https://link.jianshu.com/?t=https://git-lfs.github.com">https://git-lfs.github.com</a>，通过安装<code>git-lfs</code>来上传大文件。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ul><li><p>直接在官网下载安装</p></li><li><p><code>Homebrew</code>安装：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">brew install git-lfs</span><br></pre></td></tr></table></figure></li><li><p><code>MacPorts</code>安装：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">port install git-lfs</span><br></pre></td></tr></table></figure></li></ul><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><ul><li><p>在项目根目录执行一次</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git lfs install</span><br></pre></td></tr></table></figure></li><li><p>选择希望<code>Git LFS</code>管理（或直接编辑<code>.gitattributes</code>）的文件类型。可以随时配置其他文件扩展名。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git lfs track &quot;*.psd&quot;</span><br></pre></td></tr></table></figure></li><li><p>将<code>.gitattributes</code>文件加入到版本控制</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git add .gitattributes</span><br></pre></td></tr></table></figure></li><li><p>像往常一样提交并推送到GitHub。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git add file.psd</span><br><span class="line">git commit -m &quot;Add design file&quot;</span><br><span class="line">git push origin master</span><br></pre></td></tr></table></figure></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>当需要用<code>GitHub</code>来保存一些电子书等文件的时候，就可以使用这种方式来<code>push</code>。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记本 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Github </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker的网络模式</title>
      <link href="post/2907325745/"/>
      <url>post/2907325745/</url>
      
        <content type="html"><![CDATA[<p><code>Docker</code>在创建容器的时候，可以使用<code>--net</code>选项指定容器的的网络模式。</p><h2 id="网络模式"><a href="#网络模式" class="headerlink" title="网络模式"></a>网络模式</h2><p><code>Docker</code>支持4种网络模式供大家选择：</p><ul><li><strong>host</strong>模式，使用<code>- -net=host</code>指定。</li><li><strong>container</strong>模式，使用<code>- -net=container:NAME_or_ID</code>指定。</li><li><strong>none</strong>模式，使用<code>- -net=none</code>指定。</li><li><strong>bridge</strong>模式，使用<code>- -net=bridge</code>指定，默认设置。</li></ul><h2 id="host模式"><a href="#host模式" class="headerlink" title="host模式"></a>host模式</h2><p>众所周知，<code>Docker</code>使用了<code>Linux</code>的<code>Namespaces</code>技术来进行资源隔离，如<code>PID Namespace</code>隔离进程，<code>Mount Namespace</code>隔离文件系统，<code>Network Namespace</code>隔离网络等。一个<code>Network Namespace</code>提供了一份独立的网络环境，包括<strong>网卡</strong>、<strong>路由</strong>、<strong>Iptable</strong>规则等都与其他的<code>Network Namespace</code>隔离。一个<code>Docker</code>容器一般会分配一个独立的<code>Network Namespace</code>。但如果启动容器的时候使用ho<code>st</code>模式，那么这个容器将不会获得一个独立的<code>Network Namespace</code>，而是和宿主机共用一个<code>Network Namespace</code>。容器将不会虚拟出自己的网卡，配置自己的<code>IP</code>等，而是使用宿主机的<code>IP</code>和端口。</p><p>例如，我们在<code>10.10.101.105/24</code>的机器上用<code>host</code>模式启动一个含有<code>web</code>应用的<code>Docker</code>容器，监听<code>tcp80</code>端口。当我们在容器中执行任何类似<code>ifconfig</code>命令查看网络环境时，看到的都是宿主机上的信息。而外界访问容器中的应用，则直接使用<code>10.10.101.105:80</code>即可，不用任何<code>NAT</code>转换，就如直接跑在宿主机中一样。但是，容器的其他方面，如文件系统、进程列表等还是和宿主机隔离的。</p><h2 id="container模式"><a href="#container模式" class="headerlink" title="container模式"></a>container模式</h2><p>在理解了<code>host</code>模式后，这个模式也就好理解了。这个模式指定新创建的容器和已经存在的一个容器共享一个<code>Network Namespace</code>，而不是和宿主机共享。新创建的容器不会创建自己的网卡，配置自己的<code>IP</code>，而是和一个指定的<strong>容器共享IP</strong>、<strong>端口范围</strong>等。同样，两个容器除了网络方面，其他的如文件系统、进程列表等还是隔离的。两个容器的进程可以通过lo网卡设备通信。</p><h2 id="none模式"><a href="#none模式" class="headerlink" title="none模式"></a>none模式</h2><p>这个模式和前两个不同。在这种模式下，<code>Docker</code>容器拥有自己的<code>Network Namespace</code>，但是，并不为<code>Docker</code>容器进行任何网络配置。也就是说，这个<code>Docker</code>容器没有网卡、IP、路由等信息。需要我们自己为<code>Docker</code>容器添加网卡、配置<code>IP</code>等。</p><h2 id="bridge模式"><a href="#bridge模式" class="headerlink" title="bridge模式"></a>bridge模式</h2><p><code>bridge</code>模式是<code>Docker</code>默认的网络设置，此模式会为每一个容器分配<code>Network Namespace</code>、设置<code>IP</code>等，并将一个主机上的<code>Docker</code>容器连接到一个虚拟网桥上。</p><h3 id="bridge模式的拓扑"><a href="#bridge模式的拓扑" class="headerlink" title="bridge模式的拓扑"></a>bridge模式的拓扑</h3><p>当<code>Docker server</code>启动时，会在主机上创建一个名为<code>docker0</code>的虚拟网桥，此主机上启动的<code>Docker</code>容器会连接到这个虚拟网桥上。虚拟网桥的工作方式和物理交换机类似，这样主机上的所有容器就通过交换机连在了一个二层网络中。接下来就要为容器分配IP了，<code>Docker</code>会从<code>RFC1918</code>所定义的私有<code>IP</code>网段中，选择一个和宿主机不同的IP地址和子网分配给<code>docker0</code>，连接到<code>docker0</code>的容器就从这个子网中选择一个未占用的IP使用。如一般<code>Docker</code>会使用<code>172.17.0.0/16</code>这个网段，并将<code>172.17.42.1/16</code>分配给<code>docker0</code>网桥（在主机上使用<code>ifconfig</code>命令是可以看到<code>docker0</code>的，可以认为它是网桥的管理接口，在宿主机上作为一块虚拟网卡使用）。单机环境下的网络拓扑如下，主机地址为<code>10.10.101.105/24</code>。</p><p><img src="https://github.com/cayzlh/git-img-repository/raw/master/blog/2019/01/05/1.png" alt="bridge的拓扑"></p><p>-</p><p><img src="https://github.com/cayzlh/git-img-repository/raw/master/blog/2019/01/05/2.png" alt="bridge的拓扑"></p><p>-</p><h3 id="默认模式"><a href="#默认模式" class="headerlink" title="默认模式"></a>默认模式</h3><p>安装完<code>Docker</code>的时候，会自动创建三个网络。使用<code>docker network ls</code>命令可以查看这些网络：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker network ls</span>               </span><br><span class="line"></span><br><span class="line">NETWORK ID          NAME                DRIVER              SCOPE</span><br><span class="line">75b73b341642        bridge              bridge              local</span><br><span class="line">dbef3961eb84        host                host                local</span><br><span class="line">90741a2555ee        none                null                local</span><br></pre></td></tr></table></figure><p>这三个网络都建在<code>Docker</code>中。运行容器时，可以使用该<code>--network</code>标志来指定容器应连接到的网络。</p><h3 id="默认网桥"><a href="#默认网桥" class="headerlink" title="默认网桥"></a>默认网桥</h3><p><code>Docker</code> 服务启动后默认会创建一个 <code>docker0</code> 网桥（其上有一个 <code>docker0</code> 内部接口），它在内核层连通了其他的物理或虚拟网卡，这就将所有容器和本地主机都放到同一个物理网络。</p><p><code>Docker</code> 默认指定了 <code>docker0</code> 接口 的 <code>IP</code> 地址和子网掩码，让主机和容器之间可以通过网桥相互通信，它还给出了 <code>MTU</code>（接口允许接收的最大传输单元），通常是 <code>1500 Bytes</code>，或宿主主机网络路由上支持的默认值。这些值都可以在服务启动的时候进行配置。</p><p><code>bridge</code>所有<code>Docker</code>主机上都存在默认网络。如果您不指定其他网络，则新的容器会自动连接到默认<code>bridge</code>网络。</p><p>使用<code>docker network inspect</code>命令可以查看相关的网络信息：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker network inspect 75b73b341642</span></span><br><span class="line"></span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;Name&quot;: &quot;bridge&quot;,</span><br><span class="line">        &quot;Id&quot;: &quot;75b73b3416429364a268ba6db607cb6bffbc921241714228d22fd95c15cde76f&quot;,</span><br><span class="line">        &quot;Created&quot;: &quot;2019-01-01T05:13:00.609463Z&quot;,</span><br><span class="line">        &quot;Scope&quot;: &quot;local&quot;,</span><br><span class="line">        &quot;Driver&quot;: &quot;bridge&quot;,</span><br><span class="line">        &quot;EnableIPv6&quot;: false,</span><br><span class="line">        &quot;IPAM&quot;: &#123;</span><br><span class="line">            &quot;Driver&quot;: &quot;default&quot;,</span><br><span class="line">            &quot;Options&quot;: null,</span><br><span class="line">            &quot;Config&quot;: [</span><br><span class="line">                &#123;</span><br><span class="line">                    &quot;Subnet&quot;: &quot;172.17.0.0/16&quot;,</span><br><span class="line">                    &quot;Gateway&quot;: &quot;172.17.0.1&quot;</span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;Internal&quot;: false,</span><br><span class="line">        &quot;Attachable&quot;: false,</span><br><span class="line">        &quot;Ingress&quot;: false,</span><br><span class="line">        &quot;ConfigFrom&quot;: &#123;</span><br><span class="line">            &quot;Network&quot;: &quot;&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;ConfigOnly&quot;: false,</span><br><span class="line">        &quot;Containers&quot;: &#123;</span><br><span class="line">            &quot;1bd6dc5dbb7c6a73801ce682d4fe590cff14ba046837c75de70b7a2f756cdd21&quot;: &#123;</span><br><span class="line">                &quot;Name&quot;: &quot;boring_nash&quot;,</span><br><span class="line">                &quot;EndpointID&quot;: &quot;060084e59605428932e9862193ede495b23459d4d8039b1ef4e0f25099726599&quot;,</span><br><span class="line">                &quot;MacAddress&quot;: &quot;02:42:ac:11:00:03&quot;,</span><br><span class="line">                &quot;IPv4Address&quot;: &quot;172.17.0.3/16&quot;,</span><br><span class="line">                &quot;IPv6Address&quot;: &quot;&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;3dc606b07fbbbc2e2040104764b81cf6fbccf1594f4da99fcf03264ad2fcb9d6&quot;: &#123;</span><br><span class="line">                &quot;Name&quot;: &quot;rabbitmq&quot;,</span><br><span class="line">                &quot;EndpointID&quot;: &quot;08031fb6659f74caa2940d473f3c5ccbc849a5af485361705e63c3df66927e8c&quot;,</span><br><span class="line">                &quot;MacAddress&quot;: &quot;02:42:ac:11:00:02&quot;,</span><br><span class="line">                &quot;IPv4Address&quot;: &quot;172.17.0.2/16&quot;,</span><br><span class="line">                &quot;IPv6Address&quot;: &quot;&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;4b8887d1cf1cbe7c8d17990d2c91dce95f7099e9a9f178b6feed525b7879a369&quot;: &#123;</span><br><span class="line">                &quot;Name&quot;: &quot;objective-mysql&quot;,</span><br><span class="line">                &quot;EndpointID&quot;: &quot;9732e3b010e7053cf8e3d0f0985e5e26557d75a4930d100452ac71c5e97ecc15&quot;,</span><br><span class="line">                &quot;MacAddress&quot;: &quot;02:42:ac:11:00:04&quot;,</span><br><span class="line">                &quot;IPv4Address&quot;: &quot;172.17.0.4/16&quot;,</span><br><span class="line">                &quot;IPv6Address&quot;: &quot;&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;Options&quot;: &#123;</span><br><span class="line">            &quot;com.docker.network.bridge.default_bridge&quot;: &quot;true&quot;,</span><br><span class="line">            &quot;com.docker.network.bridge.enable_icc&quot;: &quot;true&quot;,</span><br><span class="line">            &quot;com.docker.network.bridge.enable_ip_masquerade&quot;: &quot;true&quot;,</span><br><span class="line">            &quot;com.docker.network.bridge.host_binding_ipv4&quot;: &quot;0.0.0.0&quot;,</span><br><span class="line">            &quot;com.docker.network.bridge.name&quot;: &quot;docker0&quot;,</span><br><span class="line">            &quot;com.docker.network.driver.mtu&quot;: &quot;1500&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;Labels&quot;: &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记本 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker使用rabbitmq</title>
      <link href="post/2495347071/"/>
      <url>post/2495347071/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是RabbitMQ？"><a href="#什么是RabbitMQ？" class="headerlink" title="什么是RabbitMQ？"></a>什么是RabbitMQ？</h2><p>RabbitMQ是开源消息代理软件（有时称为面向消息的中间件），它实现了高级消息队列协议（AMQP）。RabbitMQ服务器采用Erlang编程语言编写，构建于Open Telecom Platform框架之上，用于集群和故障转移。与代理接口的客户端库可用于所有主要编程语言。</p><h2 id="如何在Docker使用RabbitMQ镜像"><a href="#如何在Docker使用RabbitMQ镜像" class="headerlink" title="如何在Docker使用RabbitMQ镜像"></a>如何在Docker使用RabbitMQ镜像</h2><h3 id="运行守护进程"><a href="#运行守护进程" class="headerlink" title="运行守护进程"></a>运行守护进程</h3><p>关于RabbitMQ的一个重要注意事项是它根据所谓的“节点名称”存储数据，默认为主机名。这对于在Docker中的使用意味着我们应该为每个守护进程指定<code>-h</code>/ <code>--hostname</code>explicit，这样我们就不会获得随机主机名并且可以跟踪我们的数据：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker run -d --hostname my-rabbit --name some-rabbit rabbitmq:3</span></span><br></pre></td></tr></table></figure><p>这将启动一个侦听默认端口5672的RabbitMQ容器。如果你给它一分钟，那么<code>docker logs some-rabbit</code>你会在输出中看到类似于的块：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">=INFO REPORT==== 6-Jul-2015::20:47:02 ===</span><br><span class="line">node           : rabbit@my-rabbit</span><br><span class="line">home dir       : /var/lib/rabbitmq</span><br><span class="line">config file(s) : /etc/rabbitmq/rabbitmq.config</span><br><span class="line">cookie hash    : UoNOcDhfxW9uoZ92wh6BjA==</span><br><span class="line">log            : tty</span><br><span class="line">sasl log       : tty</span><br><span class="line">database dir   : /var/lib/rabbitmq/mnesia/rabbit@my-rabbit</span><br></pre></td></tr></table></figure><p>请注意<code>database dir</code>那里，特别是它的“节点名称”附加到文件存储的末尾。<code>/var/lib/rabbitmq</code>默认情况下，此图像会生成所有卷。</p><h3 id="内存限制"><a href="#内存限制" class="headerlink" title="内存限制"></a>内存限制</h3><p>RabbitMQ包含明确跟踪和管理内存使用的功能，因此需要了解cgroup强加的限制。</p><p>上游配置设置为<code>vm_memory_high_watermark</code>，文档中的<a href="https://www.rabbitmq.com/memory.html">“Memory Alarms”</a>中对此进行了描述。</p><p>在此图像中，此值通过设置<code>RABBITMQ_VM_MEMORY_HIGH_WATERMARK</code>。此环境变量的值解释如下：</p><ul><li><code>0.49</code>被视为<code>49%</code>，就像上游（<code>&#123; vm_memory_high_watermark, 0.49 &#125;</code>）</li><li><code>56%</code>被视为<code>56%</code>（<code>0.56</code>; <code>&#123; vm_memory_high_watermark, 0.56 &#125;</code>）</li><li><code>1073741824</code>被视为绝对字节数（<code>&#123; vm_memory_high_watermark, &#123; absolute, 1073741824 &#125; &#125;</code>）</li><li><code>1024MiB</code>被视为具有unit（<code>&#123; vm_memory_high_watermark, &#123; absolute, &quot;1024MiB&quot; &#125; &#125;</code>）的绝对字节数</li></ul><p>主要的行为差异在于如何处理百分比。如果当前容器具有内存限制（<code>--memory</code>/ <code>-m</code>），则将根据内存限制将百分比值计算为绝对字节值，而不是按原样传递给RabbitMQ。例如，对于一个容器运行<code>--memory 2048m</code>（以及隐含的上游默认<code>RABBITMQ_VM_MEMORY_HIGH_WATERMARK</code>的<code>40%</code>）将设置有效限制<code>819MB</code>（这是<code>40%</code>的<code>2048MB</code>）。</p><h3 id="管理插件"><a href="#管理插件" class="headerlink" title="管理插件"></a>管理插件</h3><p>默认情况下安装并启用了<a href="https://www.rabbitmq.com/management.html">管理插件</a>提供的第二组标签，可在标准管理端口15672上使用，默认用户名和密码为<code>guest</code>/ <code>guest</code>：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker run -d --hostname my-rabbit --name some-rabbit rabbitmq:3-management</span></span><br></pre></td></tr></table></figure><p>您可以通过<code>http://container-ip:15672</code>浏览器访问它，或者如果您需要在主机外部访问，请访问端口8080：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker run -d --hostname my-rabbit --name some-rabbit -p 8080:15672 \</span></span><br><span class="line"><span class="bash">rabbitmq:3-management</span></span><br></pre></td></tr></table></figure><p>然后，您可以转到<code>http://localhost:8080</code>或<code>http://host-ip:8080</code>在浏览器中。</p><h3 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h3><p>Dockerfile中定义了一小部分可能的环境变量，这些变量将通过docker引擎传递（如下所示）。有关RabbitMQ本身支持的环境变量列表，请参阅：<a href="https://www.rabbitmq.com/configure.html">https</a>：<a href="https://www.rabbitmq.com/configure.html">//www.rabbitmq.com/configure.html</a></p><p>对于没有管理插件的SSL配置：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">RABBITMQ_SSL_CACERTFILE</span><br><span class="line">RABBITMQ_SSL_CERTFILE</span><br><span class="line">RABBITMQ_SSL_DEPTH</span><br><span class="line">RABBITMQ_SSL_FAIL_IF_NO_PEER_CERT</span><br><span class="line">RABBITMQ_SSL_KEYFILE</span><br><span class="line">RABBITMQ_SSL_VERIFY</span><br></pre></td></tr></table></figure><p>对于使用管理插件的SSL配置：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">RABBITMQ_MANAGEMENT_SSL_CACERTFILE</span><br><span class="line">RABBITMQ_MANAGEMENT_SSL_CERTFILE</span><br><span class="line">RABBITMQ_MANAGEMENT_SSL_DEPTH</span><br><span class="line">RABBITMQ_MANAGEMENT_SSL_FAIL_IF_NO_PEER_CERT</span><br><span class="line">RABBITMQ_MANAGEMENT_SSL_KEYFILE</span><br><span class="line">RABBITMQ_MANAGEMENT_SSL_VERIFY</span><br></pre></td></tr></table></figure><h3 id="设置默认用户和密码"><a href="#设置默认用户和密码" class="headerlink" title="设置默认用户和密码"></a>设置默认用户和密码</h3><p>如果你想改变默认的用户名和密码<code>guest</code>/ <code>guest</code>，你可以用这样做<code>RABBITMQ_DEFAULT_USER</code>和<code>RABBITMQ_DEFAULT_PASS</code>环境变量：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker run -d --hostname my-rabbit --name some-rabbit \</span></span><br><span class="line"><span class="bash">-e RABBITMQ_DEFAULT_USER=user \</span></span><br><span class="line"><span class="bash">-e RABBITMQ_DEFAULT_PASS=password rabbitmq:3-management</span></span><br></pre></td></tr></table></figure><p>然后，您可以转到<code>http://localhost:8080</code>或<code>http://host-ip:8080</code>在浏览器中使用<code>user</code>/ <code>password</code>来访问管理控制台</p><p>要从文件而不是环境变量中获取用户名和密码<code>_FILE</code>，请在环境变量名称中添加后缀（例如，<code>RABBITMQ_DEFAULT_USER_FILE=/run/secrets/xxx</code>使用<a href="https://docs.docker.com/engine/swarm/secrets/">Docker Secrets</a>）。</p><h3 id="设置默认vhost"><a href="#设置默认vhost" class="headerlink" title="设置默认vhost"></a>设置默认vhost</h3><p>如果要更改默认vhost，可以使用<code>RABBITMQ_DEFAULT_VHOST</code>环境变量：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker run -d --hostname my-rabbit --name some-rabbit\ -e RABBITMQ_DEFAULT_VHOST=my_vhost rabbitmq:3-management</span></span><br></pre></td></tr></table></figure><h3 id="启用HiPE"><a href="#启用HiPE" class="headerlink" title="启用HiPE"></a>启用HiPE</h3><p>有关各种配置选项的更多信息，请参见<a href="http://www.rabbitmq.com/configure.html#config-items">RabbitMQ“配置”</a>。</p><p>要在启动时启用HiPE编译器，请使用<code>RABBITMQ_HIPE_COMPILE</code>set to <code>1</code>。根据官方文件：</p><blockquote><p>设置为true以使用HiPE预编译RabbitMQ的部分，HiPE是Erlang的即时编译器。这将以增加启动时间为代价来增加服务器吞吐量。您可能会在启动时延迟几分钟后看到20-50％的性能提升。</p></blockquote><p>因此，在配置运行状况检查，自动群集等时考虑启动延迟非常重要。</p><h3 id="启用插件"><a href="#启用插件" class="headerlink" title="启用插件"></a>启用插件</h3><p>例 <code>enabled_plugins</code></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[rabbitmq_federation_management,rabbitmq_management,rabbitmq_mqtt,rabbitmq_stomp].</span><br></pre></td></tr></table></figure><h3 id="附加配置"><a href="#附加配置" class="headerlink" title="附加配置"></a>附加配置</h3><p>如果需要其他配置，建议提供适当的<code>/etc/rabbitmq/rabbitmq.conf</code>文件（<a href="https://www.rabbitmq.com/configure.html#configuration-files">有关详细信息</a>，请参阅<a href="https://www.rabbitmq.com/configure.html#configuration-files">RabbitMQ文档的“配置文件”部分</a>），例如通过bind-mount，<a href="https://docs.docker.com/engine/swarm/configs/">Docker Configs</a>或<code>Dockerfile</code>带有<code>COPY</code>指令的short 。</p><p>或者，可以使用<code>RABBITMQ_SERVER_ADDITIONAL_ERL_ARGS</code>环境变量，其语法<a href="http://erlang.org/doc/design_principles/applications.html#id81887">在Erlang OTP设计原则用户指南的7.8节（“配置应用程序”）中</a>描述<a href="http://erlang.org/doc/design_principles/applications.html#id81887">（</a><code>-ApplName</code> is 的适当值<code>-rabbit</code>），此方法需要稍微不同的再现相当于<code>rabbitmq.conf</code>。例如，配置<a href="https://www.rabbitmq.com/configure.html#config-items"><code>channel_max</code></a>看起来像<code>-e RABBITMQ_SERVER_ADDITIONAL_ERL_ARGS=&quot;-rabbit channel_max 4007&quot;</code>。变量<code>channel_max</code>与其值之间的空间在<code>4007</code>环境中翻译时正确变为逗号的位置。</p><p>其他配置键将被指定为列表。例如，配置两者<a href="https://www.rabbitmq.com/configure.html#config-items"><code>channel_max</code></a>并<a href="https://www.rabbitmq.com/ldap.html#overview"><code>auth_backends</code></a>看起来像<code>-e RABBITMQ_SERVER_ADDITIONAL_ERL_ARGS=&quot;-rabbit channel_max 4007 auth_backends [rabbit_auth_backend_ldap,rabbit_auth_backend_internal]&quot;</code>。请注意，某些变量（例如for）<code>auth_backends</code>要求将其值括在括号中，并将多个值明确地包括在逗号中作为分隔符。</p><h2 id="连接到守护进程"><a href="#连接到守护进程" class="headerlink" title="连接到守护进程"></a>连接到守护进程</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker run --name some-app --link some-rabbit:rabbit \</span></span><br><span class="line"><span class="bash">-d application-that-uses-rabbitmq</span></span><br></pre></td></tr></table></figure><h2 id="spring-cloud-bus中使用"><a href="#spring-cloud-bus中使用" class="headerlink" title="spring cloud bus中使用"></a>spring cloud bus中使用</h2><h3 id="拉取rabbitmq镜像"><a href="#拉取rabbitmq镜像" class="headerlink" title="拉取rabbitmq镜像"></a>拉取rabbitmq镜像</h3><p>执行以下命令，拉取<code>latest</code>版官方镜像：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull rabbitmq:management</span><br></pre></td></tr></table></figure><p>使用带管理界面的镜像。</p><p><img src="https://github.com/cayzlh/git-img-repository/raw/master/blog/2019/01/01/2.png" alt="docker-rabbitmq"></p><h3 id="使用镜像"><a href="#使用镜像" class="headerlink" title="使用镜像"></a>使用镜像</h3><p>执行以下命令，使用镜像：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d --name rabbitmq --publish 5671:5671 \</span><br><span class="line"> --publish 5672:5672 --publish 4369:4369 \</span><br><span class="line"> --publish 25672:25672 --publish 15671:15671 --publish 15672:15672 \</span><br><span class="line">rabbitmq:management</span><br></pre></td></tr></table></figure><p>启动之后访问<a href="http://localhost:15672/">http://localhost:15672/</a>能够看到<code>Web</code>管理界面，使用<strong>guest / guest</strong>登录之后看到如下界面，说明镜像已经运行。</p><p><img src="https://github.com/cayzlh/git-img-repository/raw/master/blog/2019/01/01/3.png" alt="docker-rabbitmq"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://hub.docker.com/_/rabbitmq">rabbitmq</a></li><li><a href="https://blog.cayzlh.com/2019/01/01/2019010101/">https://blog.cayzlh.com/2019/01/01/2019010101/</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 笔记本 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
            <tag> rabbitmq </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>easyexcel在Safari浏览器导出文件格式有问题</title>
      <link href="post/3864213278/"/>
      <url>post/3864213278/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>JAVA解析Excel工具easyexcel</strong></p><p>Java解析、生成Excel比较有名的框架有Apache poi、jxl。但他们都存在一个严重的问题就是非常的耗内存，poi有一套SAX模式的API可以一定程度的解决一些内存溢出的问题，但POI还是有一些缺陷，比如07版Excel解压缩以及解压后存储都是在内存中完成的，内存消耗依然很大。easyexcel重写了poi对07版Excel的解析，能够原本一个3M的excel用POI sax依然需要100M左右内存降低到KB级别，并且再大的excel不会出现内存溢出，03版依赖POI的sax模式。在上层做了模型转换的封装，让使用者更加简单方便。</p></blockquote><h2 id="小坑"><a href="#小坑" class="headerlink" title="小坑"></a>小坑</h2><p>最近在使用easyexcel的时候，碰到一个小坑：</p><p>在使用<code>Safari</code>浏览器进行导出的时候，导出的文件会自动增加一个<code>.xlw</code>后缀，很烦。。</p><p>后来通过搜索解决了问题，在这里记录一波。</p><p>将原来的代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">response.setContentType(<span class="string">&quot;application/vnd.ms-excel&quot;</span>);</span><br></pre></td></tr></table></figure><p>改成：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">response.setContentType(</span><br><span class="line">    <span class="string">&quot;application/vnd.openxmlformats-officedocument.spreadsheetml.sheet&quot;</span>);</span><br></pre></td></tr></table></figure><p>然后所有浏览器都没有问题了。</p><h2 id="工具类"><a href="#工具类" class="headerlink" title="工具类"></a>工具类</h2><p>贴一下easyexcel导出的工具类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExcelUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Logger logger = LoggerFactory.getLogger(ExcelUtil.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 导出</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> list 导出数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> excelName excel名称</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> response response</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> clazz clazz</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">export</span><span class="params">(List&lt;? extends BaseRowModel&gt; list, </span></span></span><br><span class="line"><span class="function"><span class="params">            String excelName, HttpServletResponse response,</span></span></span><br><span class="line"><span class="function"><span class="params">            Class&lt;? extends BaseRowModel&gt; clazz)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        ServletOutputStream out = <span class="keyword">null</span>;</span><br><span class="line">        ExcelWriter writer = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            out = response.getOutputStream();</span><br><span class="line">            writer = <span class="keyword">new</span> ExcelWriter(out, ExcelTypeEnum.XLSX, <span class="keyword">true</span>);</span><br><span class="line">            String fileName = excelName + </span><br><span class="line">                <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd&quot;</span>).format(<span class="keyword">new</span> Date());</span><br><span class="line"></span><br><span class="line">            Sheet sheet2 = <span class="keyword">new</span> Sheet(<span class="number">2</span>, <span class="number">3</span>, clazz, <span class="string">&quot;sheet&quot;</span>, <span class="keyword">null</span>);</span><br><span class="line">            writer.write(list, sheet2);</span><br><span class="line">            response.setCharacterEncoding(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line"><span class="comment">//            response.setContentType(&quot;application/vnd.ms-excel&quot;);</span></span><br><span class="line">            response.setContentType(</span><br><span class="line">            <span class="string">&quot;application/vnd.openxmlformats-officedocument.spreadsheetml.sheet&quot;</span>);</span><br><span class="line"></span><br><span class="line">            setFileDownloadHeader(response, fileName);</span><br><span class="line"></span><br><span class="line">            out.flush();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> != writer) &#123;</span><br><span class="line">                writer.finish();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> != out) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    out.flush();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    logger.error(<span class="string">&quot;excel导出出错&quot;</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setFileDownloadHeader</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        HttpServletResponse response, String filename)</span> </span>&#123;</span><br><span class="line">        String headerValue = <span class="string">&quot;attachment;&quot;</span>;</span><br><span class="line">        headerValue += <span class="string">&quot; filename=\&quot;&quot;</span> </span><br><span class="line">            + encodeURIComponent(filename) + <span class="string">&quot;\&quot;;&quot;</span>;</span><br><span class="line">        headerValue += <span class="string">&quot; filename*=utf-8&#x27;&#x27;&quot;</span> </span><br><span class="line">            + encodeURIComponent(filename + <span class="string">&quot;.xlsx&quot;</span>);</span><br><span class="line">        response.setHeader(<span class="string">&quot;Content-Disposition&quot;</span>, headerValue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">encodeURIComponent</span><span class="params">(String value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> URLEncoder.encode(value, <span class="string">&quot;UTF-8&quot;</span>)</span><br><span class="line">                .replaceAll(<span class="string">&quot;\\+&quot;</span>, <span class="string">&quot;%20&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记本 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> easyexcel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微服务的优缺点</title>
      <link href="post/ded3e7ee/"/>
      <url>post/ded3e7ee/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文来自Nginx官方博客，是微服务系列文章的第一篇，主要探讨了传统的单体式应用的不足，以及微服务架构的优势与挑战。正如作者所说，微服务架构更适合用于构建复杂的应用，尽管它也有自己的不足。</p><p>转自：<a href="http://dockone.io/article/394">微服务实战（一）：微服务架构的优势与不足</a></p></blockquote><h2 id="单体式应用的不足"><a href="#单体式应用的不足" class="headerlink" title="单体式应用的不足"></a>单体式应用的不足</h2><p>单体式应用开发简单却有很大的局限性。一个简单的应用会随着时间推移逐渐变大。在每次的<strong>sprint</strong>中，开发团队都会面对新“故事”，然后开发许多新代码。几年后，这个小而简单的应用会变成了一个巨大的怪物。</p><p>一旦你的应用变成一个又大又复杂的怪物，那开发团队肯定很痛苦。敏捷开发和部署举步维艰，其中最主要问题就是这个应用太复杂，以至于任何单个开发者都不可能搞懂它。因此，修正bug和正确的添加新功能变的非常困难，并且很耗时。另外，团队士气也会走下坡路。如果代码难于理解，就不可能被正确的修改。最终会走向巨大的、不可理解的泥潭。</p><p>单体式应用也会降低开发速度。应用越大，启动时间会越长。比如，最近的一个调查表明，有时候应用的启动时间居然超过了12分钟。我还听说某些应用需要40分钟启动时间。如果开发者需要经常重启应用，那么大部分时间就要在等待中渡过，生产效率受到极大影响。</p><p>另外，复杂而巨大的单体式应用也不利于持续性开发。今天，SaaS应用常态就是每天会改变很多次，而这对于单体式应用模式非常困难。另外，这种变化带来的影响并没有很好的被理解，所以不得不做很多手工测试。那么接下来，持续部署也会很艰难。</p><p>单体式应用在不同模块发生资源冲突时，扩展将会非常困难。比如，一个模块完成一个CPU敏感逻辑，应该部署在AWS EC2 Compute Optimized instances，而另外一个内存数据库模块更合适于EC2 Memory-optimized instances。然而，由于这些模块部署在一起，因此不得不在硬件选择上做一个妥协。</p><p>单体式应用另外一个问题是可靠性。因为所有模块都运行在一个进程中，任何一个模块中的一个bug，比如内存泄露，将会有可能弄垮整个进程。除此之外，因为所有应用实例都是唯一的，这个bug将会影响到整个应用的可靠性。</p><p>最后，单体式应用使得采用新架构和语言非常困难。比如，设想你有两百万行采用XYZ框架写的代码。如果想改成ABC框架，无论是时间还是成本都是非常昂贵的，即使ABC框架更好。因此，这是一个无法逾越的鸿沟。你不得不在最初选择面前低头。</p><p><strong>总结一下：</strong>一开始你有一个很成功的关键业务应用，后来就变成了一个巨大的，无法理解的怪物。因为采用过时的，效率低的技术，使得雇佣有潜力的开发者很困难。应用无法扩展，可靠性很低，最终，敏捷性开发和部署变的无法完成。</p><h2 id="微处理架构——处理复杂事物"><a href="#微处理架构——处理复杂事物" class="headerlink" title="微处理架构——处理复杂事物"></a>微处理架构——处理复杂事物</h2><p>许多公司，比如Amazon、eBay和NetFlix，通过采用微处理结构模式解决了上述问题。其思路不是开发一个巨大的单体式的应用，而是将应用分解为小的、互相连接的微服务。</p><p>一个微服务一般完成某个特定的功能，比如下单管理、客户管理等等。每一个微服务都是微型六角形应用，都有自己的业务逻辑和适配器。一些微服务还会发布API给其它微服务和应用客户端使用。其它微服务完成一个Web UI，运行时，每一个实例可能是一个云VM或者是Docker容器。</p><p><img src="https://github.com/cayzlh/git-img-repository/raw/master/blog/2018/12/15/1.png"></p><p>微服务架构模式在上图中对应于代表可扩展Scale Cube的Y轴，这是一个在《The Art of Scalability》书中描述过的三维扩展模型。另外两个可扩展轴，X轴由负载均衡器后端运行的多个应用副本组成，Z轴是将需求路由到相关服务。</p><p>应用基本可以用以上三个维度来表示，Y轴代表将应用分解为微服务。运行时，X轴代表运行多个隐藏在负载均衡器之后的实例，提供吞吐能力。一些应用可能还是用Z轴将服务分区。下面的图演示行程管理服务如何部署在运行于AWS EC2上的Docker上。</p><p><img src="https://github.com/cayzlh/git-img-repository/raw/master/blog/2018/12/15/2.png"></p><p>运行时，行程管理服务由多个服务实例构成。每一个服务实例都是一个Docker容器。为了保证高可用，这些容器一般都运行在多个云VM上。服务实例前是一层诸如NGINX的负载均衡器，他们负责在各个实例间分发请求。负载均衡器也同时处理其它请求，例如缓存、权限控制、API统计和监控。</p><p>这种微服务架构模式深刻影响了应用和数据库之间的关系，<strong>不像传统多个服务共享一个数据库，微服务架构每个服务都有自己的数据库</strong>。另外，这种思路也影响到了企业级数据模式。同时，这种模式意味着多份数据，但是，如果你想获得微服务带来的好处，每个服务独有一个数据库是必须的，因为这种架构需要这种松耦合。下面的图演示示例应用数据库架构。</p><p><img src="https://github.com/cayzlh/git-img-repository/raw/master/blog/2018/12/15/3.png"></p><p>每种服务都有自己的数据库，另外，每种服务可以用更适合自己的数据库类型，也被称作多语言一致性架构。比如，驾驶员管理（发现哪个驾驶员更靠近乘客），必须使用支持地理信息查询的数据库。</p><p>表面上看来，微服务架构模式有点像SOA，他们都由多个服务构成。但是，可以从另外一个角度看此问题，微服务架构模式是一个不包含Web服务（WS-）和ESB服务的SOA。微服务应用乐于采用简单轻量级协议，比如REST，而不是WS-，在微服务内部避免使用ESB以及ESB类似功能。微服务架构模式也拒绝使用canonical schema等SOA概念。</p><h2 id="微服务的好处"><a href="#微服务的好处" class="headerlink" title="微服务的好处"></a>微服务的好处</h2><p>微服务架构模式有很多好处。首先，通过分解巨大单体式应用为多个服务方法解决了复杂性问题。在功能不变的情况下，应用被分解为多个可管理的分支或服务。每个服务都有一个用RPC-或者消息驱动API定义清楚的边界。微服务架构模式给采用单体式编码方式很难实现的功能提供了模块化的解决方案，由此，单个服务很容易开发、理解和维护。</p><p>第二，这种架构使得每个服务都可以有专门开发团队来开发。开发者可以自由选择开发技术，提供API服务。当然，许多公司试图避免混乱，只提供某些技术选择。然后，这种自由意味着开发者不需要被迫使用某项目开始时采用的过时技术，他们可以选择现在的技术。甚至于，因为服务都是相对简单，即使用现在技术重写以前代码也不是很困难的事情。</p><p>第三，微服务架构模式是每个微服务独立的部署。开发者不再需要协调其它服务部署对本服务的影响。这种改变可以加快部署速度。UI团队可以采用AB测试，快速的部署变化。微服务架构模式使得持续化部署成为可能。</p><p>最后，微服务架构模式使得每个服务独立扩展。你可以根据每个服务的规模来部署满足需求的规模。甚至于，你可以使用更适合于服务资源需求的硬件。比如，你可以在EC2 Compute Optimized instances上部署CPU敏感的服务，而在EC2 memory-optimized instances上部署内存数据库。</p><h2 id="微服务的不足"><a href="#微服务的不足" class="headerlink" title="微服务的不足"></a>微服务的不足</h2><p>Fred Brooks在30年前写道，“there are no silver bullets”，像任何其它科技一样，微服务架构也有不足。其中一个跟他的名字类似，『微服务』强调了服务大小，实际上，有一些开发者鼓吹建立稍微大一些的，10-100 LOC服务组。尽管小服务更乐于被采用，但是不要忘了这只是终端的选择而不是最终的目的。微服务的目的是有效的拆分应用，实现敏捷开发和部署。</p><p>另外一个主要的不足是，微服务应用是分布式系统，由此会带来固有的复杂性。开发者需要在RPC或者消息传递之间选择并完成进程间通讯机制。更甚于，他们必须写代码来处理消息传递中速度过慢或者不可用等局部失效问题。当然这并不是什么难事，但相对于单体式应用中通过语言层级的方法或者进程调用，微服务下这种技术显得更复杂一些。</p><p>另外一个关于微服务的挑战来自于分区的数据库架构。商业交易中同时给多个业务分主体更新消息很普遍。这种交易对于单体式应用来说很容易，因为只有一个数据库。在微服务架构应用中，需要更新不同服务所使用的不同的数据库。使用分布式交易并不一定是好的选择，不仅仅是因为CAP理论，还因为今天高扩展性的NoSQL数据库和消息传递中间件并不支持这一需求。最终你不得不使用一个最终一致性的方法，从而对开发者提出了更高的要求和挑战。</p><p>测试一个基于微服务架构的应用也是很复杂的任务。比如，采用流行的Spring Boot架构，对一个单体式web应用，测试它的REST API，是很容易的事情。反过来，同样的服务测试需要启动和它有关的所有服务（至少需要这些服务的stubs）。再重申一次，不能低估了采用微服务架构带来的复杂性。</p><p>另外一个挑战在于，微服务架构模式应用的改变将会波及多个服务。比如，假设你在完成一个案例，需要修改服务A、B、C，而A依赖B，B依赖C。在单体式应用中，你只需要改变相关模块，整合变化，部署就好了。对比之下，微服务架构模式就需要考虑相关改变对不同服务的影响。比如，你需要更新服务C，然后是B，最后才是A，幸运的是，许多改变一般只影响一个服务，而需要协调多服务的改变很少。</p><p>部署一个微服务应用也很复杂，一个分布式应用只需要简单在复杂均衡器后面部署各自的服务器就好了。每个应用实例是需要配置诸如数据库和消息中间件等基础服务。相对比，一个微服务应用一般由大批服务构成。例如，根据Adrian Cockcroft，<a href="https://sudo.hailoapp.com/services/2015/03/09/journey-into-a-microservice-world-part-3/">Hailo有160个不同服务构成</a>，NetFlix有大约600个服务。每个服务都有多个实例。这就造成许多需要配置、部署、扩展和监控的部分，除此之外，你还需要完成一个服务发现机制（后续文章中发表），以用来发现与它通讯服务的地址（包括服务器地址和端口）。传统的解决问题办法不能用于解决这么复杂的问题。接续而来，成功部署一个微服务应用需要开发者有足够的控制部署方法，并高度自动化。</p><p>一种自动化方法是使用PaaS服务，例如<a href="http://www.cloudfoundry.org/">Cloud Foundry</a>。PaaS给开发者提供一个部署和管理微服务的简单方法，它把所有这些问题都打包内置解决了。同时，配置PaaS的系统和网络专家可以采用最佳实践和策略来简化这些问题。另外一个自动部署微服务应用的方法是开发对于你来说最基础的PaaS系统。一个典型的开始点是使用一个集群化方案，比如配合Docker使用Mesos或者Kubernetes。后面的系列我们会看看如何基于软件部署方法例如NGINX，可以方便的在微服务层面提供缓存、权限控制、API统计和监控。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>构建复杂的应用真的是非常困难。单体式的架构更适合轻量级的简单应用。如果你用它来开发复杂应用，那真的会很糟糕。微服务架构模式可以用来构建复杂应用，当然，这种架构模型也有自己的缺点和挑战。</p>]]></content>
      
      
      <categories>
          
          <category> 编程技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 转载 </tag>
            
            <tag> 微服务 </tag>
            
            <tag> Spring </tag>
            
            <tag> SpringCloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring统一异常返回</title>
      <link href="post/1239641408/"/>
      <url>post/1239641408/</url>
      
        <content type="html"><![CDATA[<blockquote><p>记录一次在Spring中处理统一异常处理的方法</p></blockquote><h2 id="RestControllerAdvice"><a href="#RestControllerAdvice" class="headerlink" title="@RestControllerAdvice"></a>@RestControllerAdvice</h2><p><code>@ControllerAdvice</code>，是Spring3.2提供的新注解，从名字上可以看出大体意思是控制器增强。</p><h2 id="ExceptionHandler"><a href="#ExceptionHandler" class="headerlink" title="@ExceptionHandler"></a>@ExceptionHandler</h2><p><code>@ExceptionHandler</code>用来与<code>@RestControllerAdvice</code>配合使用，当捕获到指定的异常时，可以作出相应处理。</p><p>这里展示当参数签名失败时的异常处理：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SignatureExceptionHandler</span> <span class="keyword">extends</span> <span class="title">ResponseEntityExceptionHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SignatureExceptionHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler(SignatureExpireException.class)</span></span><br><span class="line">    <span class="keyword">public</span> RestResponse&lt;?&gt; handleSignatureExpireException(SignatureExpireException ex) &#123;</span><br><span class="line"><span class="comment">// 当然， 这是最简单的处理，还可以有多种拓展方式，这里只展示一下怎么使用</span></span><br><span class="line">        <span class="keyword">return</span> ResultBuilder.signatureError(ErrorCodeEnum.SIGNATURE_ERROR, </span><br><span class="line">                                            ex.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时， 当捕获到<code>SignatureExpireException</code>异常的时候， 就会进入这个<code>handler</code>里面来处理。</p>]]></content>
      
      
      <categories>
          
          <category> 编程技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>签名参数Map字典排序</title>
      <link href="post/1792286158/"/>
      <url>post/1792286158/</url>
      
        <content type="html"><![CDATA[<blockquote><p>由于业务需要，需要对请求进行的签名，其中有一部分的算法就是需要对所有参数进行字典排序</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 方法用途: 对所有传入参数按照字段名的 ASCII 码从小到大排序（字典序），并且生成url参数串</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> paramsMap  要排序的Map对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> urlEncode  是否需要URLENCODE</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> keyToLower 是否需要将Key转换为全小写 true:key转化成小写，false:不转化</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">formatUrlMap</span><span class="params">(Map&lt;String, Object&gt; paramsMap, </span></span></span><br><span class="line"><span class="function"><span class="params">                                  <span class="keyword">boolean</span> urlEncode, <span class="keyword">boolean</span> keyToLower)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    String buff = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    Map&lt;String, Object&gt; tmpMap = paramsMap;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        List&lt;Map.Entry&lt;String, Object&gt;&gt; infoIds = </span><br><span class="line">            <span class="keyword">new</span> ArrayList&lt;Map.Entry&lt;String, Object&gt;&gt;(tmpMap.entrySet());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//对所有传入参数按照字段名的ASCII码从小到大排序（字典序）</span></span><br><span class="line">        Collections.sort(infoIds, <span class="keyword">new</span> Comparator&lt;Map.Entry&lt;String, Object&gt;&gt;() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Map.Entry&lt;String, Object&gt; o1, </span></span></span><br><span class="line"><span class="function"><span class="params">                               Map.Entry&lt;String, Object&gt; o2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> (o1.getKey()).toString().compareTo(o2.getKey());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//构造URL 键值对的格式</span></span><br><span class="line">        StringBuffer buf = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, Object&gt; item : infoIds) &#123;</span><br><span class="line">            <span class="keyword">if</span> (StringUtils.isNotBlank(item.getKey())) &#123;</span><br><span class="line">                String key = item.getKey();</span><br><span class="line">                String value = item.getValue().toString();</span><br><span class="line">                <span class="keyword">if</span> (urlEncode) &#123;</span><br><span class="line">                    value = URLEncoder.encode(value, <span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (keyToLower) &#123;</span><br><span class="line">                    buf.append(key.toLowerCase() + <span class="string">&quot;=&quot;</span> + value);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    buf.append(key + <span class="string">&quot;=&quot;</span> + value);</span><br><span class="line">                &#125;</span><br><span class="line">                buf.append(<span class="string">&quot;&amp;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        buff = buf.toString();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isNotEmpty(buff)) &#123;</span><br><span class="line">            buff = buff.substring(<span class="number">0</span>, buff.length() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> buff;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>排序后可以进行其他处理，比如拼上<code>nonce</code>、时间戳等；</p>]]></content>
      
      
      <categories>
          
          <category> 编程技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Map </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Maven中dependencyManagement的作用</title>
      <link href="post/3157433927/"/>
      <url>post/3157433927/</url>
      
        <content type="html"><![CDATA[<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>使用<code>dependencyManagement</code>可以统一管理项目的版本号，确保应用的各个项目的依赖和版本一致，不用每个模块项目都弄一个版本号，不利于管理，当需要变更版本号的时候只需要在父类容器里更新，不需要任何一个子项目的修改；如果某个子项目需要另外一个特殊的版本号时，只需要在自己的模块<code>dependencies</code>中声明一个版本号即可。子类就会使用子类声明的版本号，不继承于父类版本号。</p><p>##dependencyManagement与dependencys的区别</p><p>1)<code>Dependencies</code>相对于<code>dependencyManagement</code>，所有生命在<code>dependencies</code>里的依赖都会自动引入，并默认被所有的子项目继承。</p><p>2)<code>dependencyManagement</code>里只是声明依赖，并不自动实现引入，因此子项目需要显示的声明需要用的依赖。如果不在子项目中声明依赖，是不会从父项目中继承下来的；只有在子项目中写了该依赖项，并且没有指定具体版本，才会从父项目中继承该项，并且<code>version</code>和<code>scope</code>都读取自父<code>pom</code>;另外如果子项目中指定了版本号，那么会使用子项目中指定的jar<code>版本</code>。</p><h2 id="示例说明"><a href="#示例说明" class="headerlink" title="示例说明"></a>示例说明</h2><p>在父模块中：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.44<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在子模块中：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>只需要指定<code>groupId</code>和<code>artifactId</code>即可，不需要额外指定版本号；</p><p>在<code>Maven</code>多模块的时候，管理依赖关系是非常重要的，各种依赖包冲突，查询问题起来非常复杂，使用<code>dependencyManagement</code>可以有效的管理。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记本 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Maven </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux下find与exec的使用</title>
      <link href="post/424495342/"/>
      <url>post/424495342/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>exec命令</strong>用于调用并执行指令的命令。exec命令通常用在shell脚本程序中，可以调用其他的命令。如果在当前终端中使用命令，则当指定的命令执行完毕后会立即退出终端。</p></blockquote><h3 id="exec的基本用法"><a href="#exec的基本用法" class="headerlink" title="exec的基本用法"></a>exec的基本用法</h3><p><code>-exec</code>参数后面跟的就是我们想进一步操作的命令，比如<code>rm</code>，<code>mv</code>等等。<code>exec</code>是以分号”<code>;</code>“作为结束标识符的，考虑到各个系统平台对分号的不同解释，我们在分号前再加个反斜杠，便于移植。而在分号前，通常也会有一对花括号**{}**，代表前面<code>find</code>命令查找出来的文件名。</p><h3 id="Example-1-使用find命令查找相关文件后，再使用ls命令将它们的详细信息列出来"><a href="#Example-1-使用find命令查找相关文件后，再使用ls命令将它们的详细信息列出来" class="headerlink" title="Example 1 使用find命令查找相关文件后，再使用ls命令将它们的详细信息列出来"></a>Example 1 使用find命令查找相关文件后，再使用ls命令将它们的详细信息列出来</h3><p>想把当前目录下所有的.o文件全部找出来，并用 <code>ls -l</code> 命令将它们列出来。实现这个需求的命令如下：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">find . -name &quot;*.o&quot; -type f -exec ls -l &#123;&#125; \;</span><br></pre></td></tr></table></figure><p>在这里，我们用<code>find</code> 命令匹配到了当前目录下的所有<code>.o</code>文件，并在 <code>-exec</code> 选项中使用 <code>ls -l</code> 命令将它们的详细信息列出来。</p><h3 id="Example-2-使用find命令查找相关文件后，再使用rm命令将它们删除"><a href="#Example-2-使用find命令查找相关文件后，再使用rm命令将它们删除" class="headerlink" title="Example 2 使用find命令查找相关文件后，再使用rm命令将它们删除"></a>Example 2 使用find命令查找相关文件后，再使用rm命令将它们删除</h3><p>想把当前目录下所有的.o文件全部找出来，并用rm命令将它们删除。实现这个需求的命令如下：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">find . -name &quot;*.o&quot; -exec rm &#123;&#125; \;</span><br></pre></td></tr></table></figure><p>执行完这个命令后，该目录下所有的.o文件都被删除。</p><h3 id="Example-3-使用-exec选项的安全模式，将对每个匹配到的文件进行操作之前提示用户"><a href="#Example-3-使用-exec选项的安全模式，将对每个匹配到的文件进行操作之前提示用户" class="headerlink" title="Example 3 使用-exec选项的安全模式，将对每个匹配到的文件进行操作之前提示用户"></a>Example 3 使用-exec选项的安全模式，将对每个匹配到的文件进行操作之前提示用户</h3><p>在实例2中，匹配到文件后就立刻执行<code>rm</code>命令，这样操作有些危险，因为如果一旦误操作，有可能会引起灾难性的后果。</p><p><code>exec</code>的安全模式就是为了避免这个问题而产生。它会在匹配到某个文件后，在进行操作之前会先问一下你，经过确认它才会进行相应操作。</p><p>同样的实例2的需求，如果采用安全模式的话，命令是这样的：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">find . -name &quot;*.o&quot; -ok rm &#123;&#125; \;</span><br></pre></td></tr></table></figure><h3 id="Example-4-搜索匹配到的文件中的关键内容"><a href="#Example-4-搜索匹配到的文件中的关键内容" class="headerlink" title="Example 4 搜索匹配到的文件中的关键内容"></a>Example 4 搜索匹配到的文件中的关键内容</h3><p>假如现在有个很大型的项目（如<code>Linux</code>内核），想在里面搜索一个含有某关键字的文件。可以使用<code>grep</code>命令检索所有的文件。这样做肯定是可以的，但如果项目很大的话，这样太耗时了，效率太低。</p><p>可以先用<code>find</code>命令找到所以相关文件，然后再用<code>grep</code>命令检索那些文件即可。因为已经使用<code>find</code>过滤一遍了，所以这样操作会节约很多时间，提高效率。</p><p>命令如下：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">find . -name &quot;*.h&quot; -exec grep -rns &quot;hello&quot; &#123;&#125; \;</span><br></pre></td></tr></table></figure><h3 id="Example-5-查找文件并移动到指定目录"><a href="#Example-5-查找文件并移动到指定目录" class="headerlink" title="Example 5 查找文件并移动到指定目录"></a>Example 5 查找文件并移动到指定目录</h3><p>这个需求就比较简单了。比如现在想把所有的<code>.o</code>文件找出来，然后新他们<code>mv</code>到<code>buil</code>目录。命令如下：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">find . -name &quot;*.o&quot; -exec cp &#123;&#125; build \;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记本 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> exec </tag>
            
            <tag> find </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java使用Optional优雅地判空</title>
      <link href="post/3451676695/"/>
      <url>post/3451676695/</url>
      
        <content type="html"><![CDATA[<p>Java8特性中的<code>Optional</code>可以用来优雅的判空，<code>Optional</code>来自官方的介绍如下：</p><blockquote><p>A container object which may or may not contain a non-null value. If a value is present, isPresent() will return true and get() will return the value.</p></blockquote><p><strong>一个可能包含也可能不包含非<code>null</code>值的容器对象。 如果存在值，<code>isPresent()</code>将返回<code>true</code>，<code>get()</code>将返回该值。</strong></p><p>如下代码，需要获得<code>Test2</code>中的<code>Info</code>信息，但是参数为<code>Test4</code>，我们要一层层的申请，每一层都获得的对象都可能是空，最后的代码看起来就像这样。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testSimple</span><span class="params">(Test4 test)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (test == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (test.getTest3() == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (test.getTest3().getTest2() == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (test.getTest3().getTest2().getInfo() == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> test.getTest3().getTest2().getInfo();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用<code>Optional</code>：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testOptional</span><span class="params">(Test test)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Optional.ofNullable(test).flatMap(Test::getTest3)</span><br><span class="line">        .flatMap(Test3::getTest2)</span><br><span class="line">        .map(Test2::getInfo)</span><br><span class="line">        .orElse(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1、<code>Optional.ofNullable(test)</code>，如果test为空，则返回一个单例空<code>Optional</code>对象，如果非空则返回一个<code>Optional</code>包装对象，<code>Optional</code>将<code>test</code>包装；</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Optional&lt;T&gt; <span class="title">ofNullable</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value == <span class="keyword">null</span> ? empty() : of(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、f<code>latMap(Test::getTest3)</code>判断<code>test</code>是否为空，如果为空，继续返回第一步中的单例<code>Optional</code>对象，否则调用<code>Test</code>的<code>getTest3</code>方法；</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span>&lt;U&gt; Optional&lt;U&gt; <span class="title">flatMap</span><span class="params">(Function&lt;? <span class="keyword">super</span> T, Optional&lt;U&gt;&gt; mapper)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(mapper);</span><br><span class="line">    <span class="keyword">if</span> (!isPresent())</span><br><span class="line">        <span class="keyword">return</span> empty();</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.requireNonNull(mapper.apply(value));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、<code>flatMap(Test3::getTest2)</code>同上调用<code>Test3</code>的<code>getTest2</code>方法；</p><p>4、<code>map(Test2::getInfo)</code>同<code>flatMap</code>类似，但是<code>flatMap</code>要求<code>Test3::getTest2</code>返回值为<code>Optional</code>类型，而<code>map</code>不需要，<code>flatMap</code>不会多层包装，map返回会再次包装<code>Optional</code>；</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span>&lt;U&gt; Optional&lt;U&gt; <span class="title">map</span><span class="params">(Function&lt;? <span class="keyword">super</span> T, ? extends U&gt; mapper)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(mapper);</span><br><span class="line">    <span class="keyword">if</span> (!isPresent())</span><br><span class="line">        <span class="keyword">return</span> empty();</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Optional.ofNullable(mapper.apply(value));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5、<code>orElse(&quot;&quot;);</code>获得<code>map</code>中的<code>value</code>，不为空则直接返回<code>value</code>，为空则返回传入的参数作为默认值。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">orElse</span><span class="params">(T other)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value != <span class="keyword">null</span> ? value : other;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用<code>Optional</code>后的代码是不是瞬间变得非常整洁，或许看到这段代码你会有很多疑问，针对复杂的一长串判空，Optional有它的优势，但是对于简单的判空使用<code>Optional</code>也会增加代码的阅读成本、编码量以及团队新成员的学习成本。毕竟<code>Optional</code>在现在还并没有那样流行，它还拥有一定的局限性。</p><hr><p><strong>文章内容来源</strong></p><ul><li><a href="http://blog.imuxuan.com/">http://blog.imuxuan.com</a></li><li>Java知音 微信公众号</li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Optional </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux排查Java问题工具单</title>
      <link href="post/2012147641/"/>
      <url>post/2012147641/</url>
      
        <content type="html"><![CDATA[<blockquote><p>记录一些在Linux中排查Java问题的工具，可以让后续忘记了可快速翻阅</p></blockquote><h1 id="Linux命令"><a href="#Linux命令" class="headerlink" title="Linux命令"></a>Linux命令</h1><h2 id="tail"><a href="#tail" class="headerlink" title="tail"></a>tail</h2><p>最常用的<code>tail -f</code></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tail -200f error.log # 倒数200行并进入实时监听文件写入模式</span><br></pre></td></tr></table></figure><h2 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grep forest f.txt     #文件查找</span><br><span class="line">grep forest f.txt cpf.txt #多文件查找</span><br><span class="line">grep &#x27;log&#x27; /home/admin -r -n #目录下查找所有符合关键字的文件</span><br><span class="line">cat f.txt | grep -i shopbase    </span><br><span class="line">grep &#x27;shopbase&#x27; /home/admin -r -n --include *.&#123;vm,java&#125; #指定文件后缀</span><br><span class="line">grep &#x27;shopbase&#x27; /home/admin -r -n --exclude *.&#123;vm,java&#125; #反匹配</span><br><span class="line">seq 10 | grep 5 -A 3    #上匹配</span><br><span class="line">seq 10 | grep 5 -B 3    #下匹配</span><br><span class="line">seq 10 | grep 5 -C 3    #上下匹配，平时用这个就妥了</span><br><span class="line">cat f.txt | grep -c &#x27;SHOPBASE&#x27;</span><br></pre></td></tr></table></figure><h2 id="awk"><a href="#awk" class="headerlink" title="awk"></a>awk</h2><h3 id="基础命令"><a href="#基础命令" class="headerlink" title="基础命令"></a>基础命令</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grep forest f.txt     #文件查找</span><br><span class="line">grep forest f.txt cpf.txt #多文件查找</span><br><span class="line">grep &#x27;log&#x27; /home/admin -r -n #目录下查找所有符合关键字的文件</span><br><span class="line">cat f.txt | grep -i shopbase    </span><br><span class="line">grep &#x27;shopbase&#x27; /home/admin -r -n --include *.&#123;vm,java&#125; #指定文件后缀</span><br><span class="line">grep &#x27;shopbase&#x27; /home/admin -r -n --exclude *.&#123;vm,java&#125; #反匹配</span><br><span class="line">seq 10 | grep 5 -A 3    #上匹配</span><br><span class="line">seq 10 | grep 5 -B 3    #下匹配</span><br><span class="line">seq 10 | grep 5 -C 3    #上下匹配，平时用这个就妥了</span><br><span class="line">cat f.txt | grep -c &#x27;SHOPBASE&#x27;</span><br></pre></td></tr></table></figure><h3 id="匹配"><a href="#匹配" class="headerlink" title="匹配"></a>匹配</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">awk &#x27;/ldb/ &#123;print&#125;&#x27; f.txt   #匹配ldb</span><br><span class="line">awk &#x27;!/ldb/ &#123;print&#125;&#x27; f.txt  #不匹配ldb</span><br><span class="line">awk &#x27;/ldb/ &amp;&amp; /LISTEN/ &#123;print&#125;&#x27; f.txt   #匹配ldb和LISTEN</span><br><span class="line">awk &#x27;$5 ~ /ldb/ &#123;print&#125;&#x27; f.txt #第五列匹配ldb</span><br></pre></td></tr></table></figure><h3 id="内建变量"><a href="#内建变量" class="headerlink" title="内建变量"></a>内建变量</h3><p>NR:NR表示从awk开始执行后，按照记录分隔符读取的数据次数，默认的记录分隔符为换行符，因此默认的就是读取的数据行数，NR可以理解为Number of Record的缩写。</p><p>FNR:在awk处理多个输入文件的时候，在处理完第一个文件后，NR并不会从1开始，而是继续累加，因此就出现了FNR，每当处理一个新文件的时候，FNR就从1开始计数，FNR可以理解为File Number of Record。</p><p>NF: NF表示目前的记录被分割的字段的数目，NF可以理解为Number of Field。</p><h2 id="find"><a href="#find" class="headerlink" title="find"></a>find</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo -u admin find /home/admin /tmp /usr -name \*.log(多个目录去找)</span><br><span class="line">find . -iname \*.txt(大小写都匹配)</span><br><span class="line">find . -type d(当前目录下的所有子目录)</span><br><span class="line">find /usr -type l(当前目录下所有的符号链接)</span><br><span class="line">find /usr -type l -name &quot;z*&quot; -ls(符号链接的详细信息 eg:inode,目录)</span><br><span class="line">find /home/admin -size +250000k(超过250000k的文件，当然+改成-就是小于了)</span><br><span class="line">find /home/admin f -perm 777 -exec ls -l &#123;&#125; \; (按照权限查询文件)</span><br><span class="line">find /home/admin -atime -1  1天内访问过的文件</span><br><span class="line">find /home/admin -ctime -1  1天内状态改变过的文件    </span><br><span class="line">find /home/admin -mtime -1  1天内修改过的文件</span><br><span class="line">find /home/admin -amin -1  1分钟内访问过的文件</span><br><span class="line">find /home/admin -cmin -1  1分钟内状态改变过的文件    </span><br><span class="line">find /home/admin -mmin -1  1分钟内修改过的文件</span><br></pre></td></tr></table></figure><h2 id="pgm"><a href="#pgm" class="headerlink" title="pgm"></a>pgm</h2><p>批量查询vm-shopbase满足条件的日志</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pgm -A -f vm-shopbase \</span><br><span class="line">&#x27;cat /home/admin/shopbase/logs/shopbase.log.2017-01-17|grep 2069861630&#x27;</span><br></pre></td></tr></table></figure><h2 id="top"><a href="#top" class="headerlink" title="top"></a>top</h2><p>top除了看一些基本信息之外，剩下的就是配合来查询vm的各种问题了</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ps -ef | grep java</span><br><span class="line">top -H -p pid</span><br></pre></td></tr></table></figure><p>获得线程10进制转16进制后jstack去抓看这个线程到底在干啥</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">netstat -nat|awk  &#x27;&#123;print $6&#125;&#x27;|sort|uniq -c|sort -rn </span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看当前连接</span></span><br></pre></td></tr></table></figure><h1 id="Java自带工具"><a href="#Java自带工具" class="headerlink" title="Java自带工具"></a>Java自带工具</h1><h2 id="jps"><a href="#jps" class="headerlink" title="jps"></a>jps</h2><p>用一条命令：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo -u admin /opt/taobao/java/bin/jps -mlvV</span><br></pre></td></tr></table></figure><h2 id="jstack"><a href="#jstack" class="headerlink" title="jstack"></a>jstack</h2><h3 id="普通用法："><a href="#普通用法：" class="headerlink" title="普通用法："></a>普通用法：</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo -u admin /opt/taobao/install/ajdk-8_1_1_fp1-b52/bin/jstack 2815</span><br></pre></td></tr></table></figure><h3 id="native-java栈："><a href="#native-java栈：" class="headerlink" title="native + java栈："></a>native + java栈：</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo -u admin /opt/taobao/install/ajdk-8_1_1_fp1-b52/bin/jstack -m 2815</span><br></pre></td></tr></table></figure><h2 id="jinfo"><a href="#jinfo" class="headerlink" title="jinfo"></a>jinfo</h2><p>可看系统启动的参数</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo -u admin /opt/install/ajdk-8_1_1_fp1-b52/bin/jinfo -flags 2815</span><br></pre></td></tr></table></figure><h2 id="jamp"><a href="#jamp" class="headerlink" title="jamp"></a>jamp</h2><ol><li><p>查看堆的情况</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo -u admin /opt/install/ajdk-8_1_1_fp1-b52/bin/jmap -heap 2815</span><br></pre></td></tr></table></figure></li><li><p>dump</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo -u admin /opt/install/ajdk-8_1_1_fp1-b52/bin/jmap \</span><br><span class="line">-dump:live,format=b,file=/tmp/heap2.bin 2815</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo -u admin /opt/install/ajdk-8_1_1_fp1-b52/bin/jmap \</span><br><span class="line">-dump:format=b,file=/tmp/heap3.bin 2815</span><br></pre></td></tr></table></figure></li><li><p>查看堆被谁占用，配合<code>zprofiler</code>和<code>btrace</code>，更方便的排查问题</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo -u admin /opt/install/ajdk-8_1_1_fp1-b52/bin/jmap \</span><br><span class="line">-histo 2815 | head -10</span><br></pre></td></tr></table></figure></li></ol><h2 id="jstat"><a href="#jstat" class="headerlink" title="jstat"></a>jstat</h2><p>jstat参数众多，但是使用一个就够了</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo -u admin /opt/install/ajdk-8_1_1_fp1-b52/bin/jstat \ </span><br><span class="line">-gcutil 2815 1000 </span><br></pre></td></tr></table></figure><h2 id="jdb"><a href="#jdb" class="headerlink" title="jdb"></a>jdb</h2><p>jdb可以用来预发debug,假设你预发的java_home是/opt/taobao/java/，远程调试端口是8000，那么：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo -u admin /opt/java/bin/jdb -attach 8000</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记本 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Shell脚本简明教程</title>
      <link href="post/1847503891/"/>
      <url>post/1847503891/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Shell脚本,就是利用Shell的命令解释的功能，对一个纯文本的文件进行解析，然后执行这些功能，也可以说Shell脚本就是一系列命令的集合。</p><p>Shell可以直接使用在win/Unix/Linux上面，并且可以调用大量系统内部的功能来解释执行程序，如果熟练掌握Shell脚本，可以让我们操作计算机变得更加轻松，也会节省很多时间。</p></blockquote><h2 id="Shell的应用场景"><a href="#Shell的应用场景" class="headerlink" title="Shell的应用场景"></a>Shell的应用场景</h2><h3 id="Shell能做什么"><a href="#Shell能做什么" class="headerlink" title="Shell能做什么"></a>Shell能做什么</h3><ul><li>将一些复杂的命令简单化(平时我们提交一次github代码可能需要很多步骤，但是可以用Shell简化成一步)</li><li>可以写一些脚本自动实现一个工程中自动更换最新的sdk(库)</li><li>自动打包、编译、发布等功能</li><li>清理磁盘中空文件夹</li><li>总之一切有规律的活脚本都可以尝试一下</li></ul><h3 id="Shell不能做什么"><a href="#Shell不能做什么" class="headerlink" title="Shell不能做什么"></a>Shell不能做什么</h3><ul><li>需要精密的运算的时候</li><li>需要语言效率很高的时候</li><li>需要一些网络操作的时候</li><li>总之Shell就是可以快速开发一个脚本简化开发流程，并不可以用来替代高级语言</li></ul><h3 id="Shell工作原理"><a href="#Shell工作原理" class="headerlink" title="Shell工作原理"></a>Shell工作原理</h3><p>Shell可以被称作是脚本语言，因为它本身是不需要编译的，而是通过解释器解释之后再编译执行，和传统语言相比多了解释的过程所以效率会略差于传统的直接编译的语言。</p><h2 id="如何编写Shell脚本"><a href="#如何编写Shell脚本" class="headerlink" title="如何编写Shell脚本"></a>如何编写Shell脚本</h2><p><strong>最简单的脚本：</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">echo &quot;Hello World.&quot;</span><br></pre></td></tr></table></figure><p>只需要打开文本编辑工具，编辑成以上的样子,然后保存成test.sh</p><p><strong>运行脚本：</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chmod +x ./test.sh</span><br><span class="line">./test.sh</span><br><span class="line"></span><br><span class="line">Hello World.</span><br></pre></td></tr></table></figure><blockquote><p>关于第一行中的<code>#!/bin/bash</code>：</p><p>比较常见的说法是：<strong>第一行的内容指定了shell脚本解释器的路径，而且这个指定路径只能放在文件的第一行</strong></p></blockquote><h3 id="Shell中的变量"><a href="#Shell中的变量" class="headerlink" title="Shell中的变量"></a>Shell中的变量</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">myText=&quot;hello world&quot;</span><br><span class="line">muNum=100</span><br></pre></td></tr></table></figure><p><strong>这里面需要注意的就是，“=”前后不能有空格，命名规则就和其它语言一样了。</strong></p><h3 id="访问变量"><a href="#访问变量" class="headerlink" title="访问变量"></a>访问变量</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">myText=&quot;hello world&quot;</span><br><span class="line">muNum=100</span><br><span class="line">echo $myText</span><br><span class="line">echo muNum</span><br></pre></td></tr></table></figure><p><strong>当想要访问变量的时候，需要使用$，否则输出的将是纯文本内容。</strong></p><h3 id="Shell中的四则运算"><a href="#Shell中的四则运算" class="headerlink" title="Shell中的四则运算"></a>Shell中的四则运算</h3><table><thead><tr><th>运算符</th><th>含义</th></tr></thead><tbody><tr><td>+</td><td>加法运算</td></tr><tr><td>-</td><td>减法运算</td></tr><tr><td>*</td><td>乘法运算</td></tr><tr><td>/</td><td>除法运算</td></tr></tbody></table><h4 id="例子："><a href="#例子：" class="headerlink" title="例子："></a>例子：</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">echo &quot;Hello World !&quot;</span><br><span class="line">a=3</span><br><span class="line">b=5</span><br><span class="line">val=`expr $a + $b`</span><br><span class="line">echo &quot;Total value : $val&quot;</span><br><span class="line"></span><br><span class="line">val=`expr $a - $b`</span><br><span class="line">echo &quot;Total value : $val&quot;</span><br><span class="line"></span><br><span class="line">val=`expr $a \* $b`</span><br><span class="line">echo &quot;Total value : $val&quot;</span><br><span class="line"></span><br><span class="line">val=`expr $a / $b`</span><br><span class="line">echo &quot;Total value : $val&quot;</span><br></pre></td></tr></table></figure><p>这里面需要注意的就是，<strong>定义变量的时候“=”前后是不能有空格的，但是进行四则运算的时候运算符号前后一定要有空格，乘法的时候需要进行转义。</strong></p><h3 id="其它运算符-、-、-、！、-o、-a"><a href="#其它运算符-、-、-、！、-o、-a" class="headerlink" title="其它运算符 =、==、!=、！、-o、-a"></a>其它运算符 =、==、!=、！、-o、-a</h3><table><thead><tr><th>运算符</th><th>含义</th></tr></thead><tbody><tr><td>%</td><td>求余</td></tr><tr><td>==</td><td>相等</td></tr><tr><td>=</td><td>赋值</td></tr><tr><td>!=</td><td>不相等</td></tr><tr><td>!</td><td>与</td></tr><tr><td>-o</td><td>或</td></tr><tr><td>-a</td><td>非</td></tr></tbody></table><h4 id="例子：-1"><a href="#例子：-1" class="headerlink" title="例子："></a>例子：</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">a=3</span><br><span class="line">b=5</span><br><span class="line">val=`expr $a / $b`</span><br><span class="line">echo &quot;Total value : $val&quot;</span><br><span class="line"></span><br><span class="line">val=`expr $a % $b`</span><br><span class="line">echo &quot;Total value : $val&quot;</span><br><span class="line"></span><br><span class="line">if [ $a == $b ]</span><br><span class="line">then</span><br><span class="line">   echo &quot;a is equal to b&quot;</span><br><span class="line">fi</span><br><span class="line">if [ $a != $b ]</span><br><span class="line">then</span><br><span class="line">   echo &quot;a is not equal to b&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><h3 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h3><table><thead><tr><th>运算符</th><th>含义</th></tr></thead><tbody><tr><td>-eq</td><td>两个数相等返回true</td></tr><tr><td>-ne</td><td>两个数不相等返回true</td></tr><tr><td>-gt</td><td>左侧数大于右侧数返回true</td></tr><tr><td>-It</td><td>左侧数小于右侧数返回true</td></tr><tr><td>-ge</td><td>左侧数大于等于右侧数返回true</td></tr><tr><td>-le</td><td>左侧数小于等于右侧数返回true</td></tr></tbody></table><h4 id="例子：-2"><a href="#例子：-2" class="headerlink" title="例子："></a>例子：</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/sh</span></span><br><span class="line">a=10</span><br><span class="line">b=20</span><br><span class="line">if [ $a -eq $b ]</span><br><span class="line">then</span><br><span class="line">   echo &quot;true&quot;</span><br><span class="line">else</span><br><span class="line">   echo &quot;false&quot;</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">if [ $a -ne $b ]</span><br><span class="line">then</span><br><span class="line">   echo &quot;true&quot;</span><br><span class="line">else</span><br><span class="line">   echo &quot;false&quot;</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">if [ $a -gt $b ]</span><br><span class="line">then</span><br><span class="line">   echo &quot;true&quot;</span><br><span class="line">else</span><br><span class="line">   echo &quot;false&quot;</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">if [ $a -lt $b ]</span><br><span class="line">then</span><br><span class="line">   echo &quot;true&quot;</span><br><span class="line">else</span><br><span class="line">   echo &quot;false&quot;</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">if [ $a -ge $b ]</span><br><span class="line">then</span><br><span class="line">   echo &quot;true&quot;</span><br><span class="line">else</span><br><span class="line">   echo &quot;false&quot;</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">if [ $a -le $b ]</span><br><span class="line">then</span><br><span class="line">   echo &quot;true&quot;</span><br><span class="line">else</span><br><span class="line">   echo &quot;false&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><h3 id="字符串运算符"><a href="#字符串运算符" class="headerlink" title="字符串运算符"></a>字符串运算符</h3><table><thead><tr><th>运算符</th><th>含义</th></tr></thead><tbody><tr><td>=</td><td>两个字符串相等返回true</td></tr><tr><td>!=</td><td>两个字符串不相等返回true</td></tr><tr><td>-z</td><td>字符串长度为0返回true</td></tr><tr><td>-n</td><td>字符串长度不为0返回true</td></tr></tbody></table><p>还有：</p><table><thead><tr><th>运算符</th><th>含义</th></tr></thead><tbody><tr><td>-d file</td><td>检测文件是否是目录，如果是，则返回 true</td></tr><tr><td>-r file</td><td>检测文件是否可读，如果是，则返回 true</td></tr><tr><td>-w file</td><td>检测文件是否可写，如果是，则返回 true</td></tr><tr><td>-x file</td><td>检测文件是否可执行，如果是，则返回 true</td></tr><tr><td>-s file</td><td>检测文件是否为空（文件大小是否大于0，不为空返回 true</td></tr><tr><td>-e file</td><td>检测文件（包括目录）是否存在，如果是，则返回 true</td></tr></tbody></table><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/sh</span></span><br><span class="line">mtext=&quot;hello&quot;  #定义字符串</span><br><span class="line">mtext2=&quot;world&quot;</span><br><span class="line">mtext3=$mtext&quot; &quot;$mtext2  #字符串的拼接</span><br><span class="line">echo $mtext3  #输出字符串</span><br><span class="line">echo $&#123;#mtext3&#125;  #输出字符串长度</span><br><span class="line">echo $&#123;mtext3:1:4&#125;  #截取字符串</span><br></pre></td></tr></table></figure><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/sh</span></span><br><span class="line">array=(1 2 3 4 5)  #定义数组</span><br><span class="line">array2=(aa bb cc dd ee)  #定义数组</span><br><span class="line">value=$&#123;array[3]&#125;  #找到某一个下标的数，然后赋值</span><br><span class="line">echo $value  #打印</span><br><span class="line">value2=$&#123;array2[3]&#125;  #找到某一个下标的数，然后赋值</span><br><span class="line">echo $value2  #打印</span><br><span class="line">length=$&#123;#array[*]&#125;  #获取数组长度</span><br><span class="line">echo $length</span><br></pre></td></tr></table></figure><h3 id="输出程序"><a href="#输出程序" class="headerlink" title="输出程序"></a>输出程序</h3><p><strong>echo</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/sh</span></span><br><span class="line">echo &quot;hello world&quot;  </span><br><span class="line">echo hello world  </span><br><span class="line"></span><br><span class="line">text=&quot;hello world&quot;</span><br><span class="line">echo $text</span><br><span class="line">echo -e &quot;hello world&quot;  #输出并且换行</span><br><span class="line">echo &quot;hello world&quot; &gt; a.txt  #重定向到文件</span><br><span class="line">echo `date`  #输出当前系统时间</span><br></pre></td></tr></table></figure><h3 id="判断语句"><a href="#判断语句" class="headerlink" title="判断语句"></a>判断语句</h3><ul><li>if</li><li>if-else</li><li>if-elseIf</li><li>case</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/sh</span></span><br><span class="line">a=10</span><br><span class="line">b=20</span><br><span class="line">if [ $a == $b ]</span><br><span class="line">then</span><br><span class="line">   echo &quot;true&quot;</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if [ $a == $b ]</span><br><span class="line">then</span><br><span class="line">   echo &quot;true&quot;</span><br><span class="line">else</span><br><span class="line">   echo &quot;false&quot;</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if [ $a == $b ]</span><br><span class="line">then</span><br><span class="line">   echo &quot;a is equal to b&quot;</span><br><span class="line">elif [ $a -gt $b ]</span><br><span class="line">then</span><br><span class="line">   echo &quot;a is greater than b&quot;</span><br><span class="line">elif [ $a -lt $b ]</span><br><span class="line">then</span><br><span class="line">   echo &quot;a is less than b&quot;</span><br><span class="line">else</span><br><span class="line">   echo &quot;None of the condition met&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><h3 id="test命令"><a href="#test命令" class="headerlink" title="test命令"></a>test命令</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">test $[num1] -eq $[num2]  #判断两个变量是否相等</span><br><span class="line">test num1=num2  #判断两个数字是否相等</span><br></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>-e file</td><td>文件存在则返回真</td></tr><tr><td>-r file</td><td>文件存在并且可读则返回真</td></tr><tr><td>-w file</td><td>文件存在并且可写则返回真</td></tr><tr><td>-x file</td><td>文件存在并且可执行则返回真</td></tr><tr><td>-s file</td><td>文件存在并且内容不为空则返回真</td></tr><tr><td>-d file</td><td>文件目录存在则返回真</td></tr></tbody></table><h3 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/sh</span></span><br><span class="line"></span><br><span class="line">for i in &#123;1..5&#125;</span><br><span class="line">do</span><br><span class="line">    echo $i</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">for i in 5 6 7 8 9</span><br><span class="line">do</span><br><span class="line">    echo $i</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">for FILE in $HOME/.bash*</span><br><span class="line">do</span><br><span class="line">   echo $FILE</span><br><span class="line">done</span><br></pre></td></tr></table></figure><h3 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/sh</span></span><br><span class="line">COUNTER=0</span><br><span class="line">while [ $COUNTER -lt 5 ]</span><br><span class="line">do</span><br><span class="line">    COUNTER=`expr $COUNTER + 1`</span><br><span class="line">    echo $COUNTER</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">echo &#x27;请输入。。。&#x27;</span><br><span class="line">echo &#x27;ctrl + d 即可停止该程序&#x27;</span><br><span class="line">while read FILM</span><br><span class="line">do</span><br><span class="line">    echo &quot;Yeah! great film the $FILM&quot;</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>以上是while循环的两种用法，第一种是比较常规的，执行循环，然后每次都把控制的数加1，就可以让while循环有退出的条件了。第二种是用户从键盘数据，然后把用户输入的文字输出出来。</p><h3 id="跳出循环"><a href="#跳出循环" class="headerlink" title="跳出循环"></a>跳出循环</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">break  #跳出所有循环</span><br><span class="line">break n  #跳出第n层f循环</span><br><span class="line">continue  #跳出当前循环</span><br></pre></td></tr></table></figure><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/sh</span></span><br><span class="line"></span><br><span class="line">sysout()&#123;</span><br><span class="line">    echo &quot;hello world&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sysout</span><br></pre></td></tr></table></figure><p>定义一个没有返回值的函数，然后调用该函数。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/sh</span></span><br><span class="line"></span><br><span class="line">test()&#123;</span><br><span class="line"></span><br><span class="line">    aNum=3</span><br><span class="line">    anotherNum=5</span><br><span class="line">    return $(($aNum+$anotherNum))</span><br><span class="line">&#125;</span><br><span class="line">test</span><br><span class="line">result=$?</span><br><span class="line">echo $result</span><br></pre></td></tr></table></figure><p>定义一个有返回值的函数，调用该函数，输出结果。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/sh</span></span><br><span class="line"></span><br><span class="line">test()&#123;</span><br><span class="line">    echo $1  #接收第一个参数</span><br><span class="line">    echo $2  #接收第二个参数</span><br><span class="line">    echo $3  #接收第三个参数</span><br><span class="line">    echo $#  #接收到参数的个数</span><br><span class="line">    echo $*  #接收到的所有参数</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test aa bb cc</span><br></pre></td></tr></table></figure><p>定义了一个需要传递参数的函数。</p><h3 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo result &gt; file  #将结果写入文件，结果不会在控制台展示，而是在文件中，覆盖写</span><br><span class="line">echo result &gt;&gt; file  #将结果写入文件，结果不会在控制台展示，而是在文件中，追加写</span><br><span class="line">echo input &lt; file  #获取输入流</span><br></pre></td></tr></table></figure><h3 id="写一个自动输入命令的脚本"><a href="#写一个自动输入命令的脚本" class="headerlink" title="写一个自动输入命令的脚本"></a>写一个自动输入命令的脚本</h3><p><strong>自动提交github的脚本</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">echo &quot;-------Begin-------&quot;</span><br><span class="line">git add .</span><br><span class="line">git commit -m $1</span><br><span class="line">echo $1</span><br><span class="line">git push origin master</span><br><span class="line">echo &quot;--------End--------&quot;</span><br></pre></td></tr></table></figure><h2 id="IntelliJ-IDEA中编写Shell脚本"><a href="#IntelliJ-IDEA中编写Shell脚本" class="headerlink" title="IntelliJ IDEA中编写Shell脚本"></a>IntelliJ IDEA中编写Shell脚本</h2><p>使用<code>bashsupport</code>插件。</p><p>具体参考这个链接：<a href="https://blog.csdn.net/u012443641/article/details/81295999">IDEA中编写脚本并运行shell脚本</a></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li> [程序猿] 微信公众号</li><li><a href="https://www.jianshu.com/p/71cb62f08768"><strong>关玮琳linSir</strong></a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 笔记本 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>搭建Git服务器</title>
      <link href="post/3721444167/"/>
      <url>post/3721444167/</url>
      
        <content type="html"><![CDATA[<blockquote><p>虽然以前也搭过，但是重新搭建一次的时候还要重新从网络上查找资料；</p><p>最近想着别把租来的服务器荒了，自己搭个<code>Git</code>服务器放点东西上去，顺路记录一波搭建过程。</p></blockquote><h2 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h2><p>在服务器上安装 <code>git</code>：</p><p><code>centos</code>：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo yum install git</span><br></pre></td></tr></table></figure><p><code>ubuntu</code>：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install git</span><br></pre></td></tr></table></figure><h2 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h2><p>创建 <code>git</code> 用户，用来运行<code>git</code>服务</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo adduser git</span><br></pre></td></tr></table></figure><p>可以同时为<code>git</code>用户修改密码</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo passwd git</span><br></pre></td></tr></table></figure><h2 id="第三步"><a href="#第三步" class="headerlink" title="第三步"></a>第三步</h2><p><strong>免密登录</strong></p><p>通过证书的方式来通过<code>ssh</code>使用<code>git</code>功能，需要创建证书，并收集需要登录的用户的公钥文件（<code>~/.ssh/id_rsa.pub</code>），导入到/<code>home/git/.ssh/authorized_keys</code>文件内，一行一个；</p><blockquote><p>公钥可以通过执行<code>ssh-keygen -t rsa -C &quot;yourname@mail.com&quot;</code>进行生成</p></blockquote><p><strong>修改<code>authorized_keys</code>文件的权限</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chmod 600 authorized_keys</span><br></pre></td></tr></table></figure><p><em>这一步必须要做，不然验证的时候还是会需要让你输入密码，具体原因不知；</em></p><h2 id="第四步"><a href="#第四步" class="headerlink" title="第四步"></a>第四步</h2><p>初始化<code>git</code>仓库，找个地放用来放你的<code>git</code>仓库，这里我选了<code>/data/repositorys</code>这个路径；</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git init --bare TestGit.git</span><br></pre></td></tr></table></figure><p><code>git</code>创建一个裸仓库，裸仓库没有工作区，因为服务器上的git仓库纯粹为了共享，所有不能让用户直接登录到服务器上去改工作区，并且服务器的<code>git</code>仓库通常以 <code>.git</code> 结尾。然后，修改<code>owner</code>改为<code>git</code>：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo chown -R git:git TestGit.git</span><br></pre></td></tr></table></figure><h2 id="第五步"><a href="#第五步" class="headerlink" title="第五步"></a>第五步</h2><p>禁用<code>shell</code>登录：<br>处于安全的考虑，第二步创建的git用户不允许登录<code>shell</code>，这可以通过编辑 <code>/etc/passwd</code>文件完成。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git:x:1003:1003::/home/git:/bin/bash</span><br></pre></td></tr></table></figure><p>改为：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git:x:1003:1003::/home/git:/usr/bin/git-shell</span><br></pre></td></tr></table></figure><p>这样，<code>git</code>用户可以正常通过<code>ssh</code>使用<code>git</code>，但无法登录<code>shell</code>，因为我们为git用户指定的<code>git-shell</code>每次一登录就自动退出。</p><h2 id="第六步"><a href="#第六步" class="headerlink" title="第六步"></a>第六步</h2><p>验证，克隆远程仓库：<br>现在，可以通过<code>git clone</code>命令克隆远程仓库了，在各自的电脑上运行：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone git@server:/data/repositorys/TestGit.git</span><br></pre></td></tr></table></figure><p>如果服务器<code>SSH</code>端口不是默认的22的话，可以这样：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone ssh://git@server:port/data/repositorys/TestGit.git</span><br></pre></td></tr></table></figure><p>运行完成后，正常的情况下会出现以下提示：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Cloning into &#x27;TestGit&#x27;...</span><br><span class="line">warning: You appear to have cloned an empty repository.</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://google.com/">Google</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 笔记本 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker使用redis镜像</title>
      <link href="post/3795648683/"/>
      <url>post/3795648683/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Redis是一个开源的，联网的，内存中的键值数据存储，具有可选的持久性。</p></blockquote><h1 id="安装redis"><a href="#安装redis" class="headerlink" title="安装redis"></a>安装redis</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull redis</span><br></pre></td></tr></table></figure><h1 id="启动Docker实例"><a href="#启动Docker实例" class="headerlink" title="启动Docker实例"></a>启动Docker实例</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run --name some-redis -d redis</span><br></pre></td></tr></table></figure><p>或者<strong>从持久存储开始：</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run --name some-redis -d redis redis-server --appendonly yes</span><br></pre></td></tr></table></figure><p>绑定本地端口：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run --name dev-redis -p 6379:6379 -d redis redis-server --appendonly yes</span><br></pre></td></tr></table></figure><p>或者<strong>通过redis-cli</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -it --link some-redis:redis --rm redis redis-cli -h redis -p 6379</span><br></pre></td></tr></table></figure><h2 id="另外，如果想使用自己的redis-conf-……"><a href="#另外，如果想使用自己的redis-conf-……" class="headerlink" title="另外，如果想使用自己的redis.conf ……"></a>另外，如果想使用自己的redis.conf ……</h2><p> 您可以创建自己的Dockerfile，将上下文中的redis.conf添加到/ data /中，就像这样：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">FROM redis</span><br><span class="line">COPY redis.conf /usr/local/etc/redis/redis.conf</span><br><span class="line">CMD [ &quot;redis-server&quot;, &quot;/usr/local/etc/redis/redis.conf&quot; ]</span><br></pre></td></tr></table></figure><p>或者，您可以使用<code>docker run</code>选项在相同的行中指定某些内容：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -v /myredis/conf/redis.conf:/usr/local/etc/redis/redis.conf \ </span><br><span class="line">--name myredis redis redis-server /usr/local/etc/redis/redis.conf</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记本 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker免sudo操作</title>
      <link href="post/6082d88c/"/>
      <url>post/6082d88c/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Docker命令默认在Linux默认使用root用户执行，官方原文：</p><p>The docker daemon binds to a Unix socket instead of a TCP port. By default that Unix socket is owned by the user root and other users can access it with sudo. For this reason, docker daemon always runs as the root user.<br>To avoid having to use sudo when you use the docker command, create a Unix group called docker and add users to it. When the docker daemon starts, it makes the ownership of the Unix socket read/writable by the docker group.</p><p>docker守护程序绑定到Unix套接字而不是TCP端口。 默认情况下，Unix套接字由用户root拥有，其他用户可以使用sudo访问它。 因此，docker守护程序始终以root用户身份运行。<br>要避免在使用docker命令时使用sudo，请创建一个名为docker的Unix组并向其添加用户。 当docker守护程序启动时，它会使docker组对Unix套接字的所有权进行读/写。</p></blockquote><p><strong>但是我们自己使用的时候通常会觉得比较麻烦，</strong>以下步骤将用户加入Docker用户组，不需要使用sudo命令来执行docker的命令。</p><h3 id="创建docker组"><a href="#创建docker组" class="headerlink" title="创建docker组"></a>创建docker组</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo groupadd docker</span><br></pre></td></tr></table></figure><h3 id="将当前用户加入docker组"><a href="#将当前用户加入docker组" class="headerlink" title="将当前用户加入docker组"></a>将当前用户加入docker组</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo gpasswd -a $&#123;USER&#125; docker</span><br></pre></td></tr></table></figure><h3 id="重新启动docker服务（下面是CentOS7的命令）"><a href="#重新启动docker服务（下面是CentOS7的命令）" class="headerlink" title="重新启动docker服务（下面是CentOS7的命令）"></a>重新启动docker服务（下面是CentOS7的命令）</h3> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure><h3 id="当前用户退出系统重新登陆"><a href="#当前用户退出系统重新登陆" class="headerlink" title="当前用户退出系统重新登陆"></a>当前用户退出系统重新登陆</h3><p> 重新登录后可以直接执行docker命令：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker ps</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记本 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
            <tag> 免sudo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux中方便的Bash别名</title>
      <link href="post/3554012870/"/>
      <url>post/3554012870/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Linux中通过alias创建别名, 可以将命令行上常用的长命令简化成一个易懂的短命令来使用;</p><p>要使用Bash别名, 需要将其添加到<code>.bash_profile</code>文件, 该文件位于 <code>~/</code>目录中.</p></blockquote><h3 id="解压tar文件"><a href="#解压tar文件" class="headerlink" title="解压tar文件"></a>解压tar文件</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">alias untar=&#x27;tar -zxvf &#x27;</span><br></pre></td></tr></table></figure><h3 id="下载出问题-恢复下载"><a href="#下载出问题-恢复下载" class="headerlink" title="下载出问题, 恢复下载"></a>下载出问题, 恢复下载</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">alias wget=&#x27;wget -c &#x27;</span><br></pre></td></tr></table></figure><h3 id="下载文件并测试校验和"><a href="#下载文件并测试校验和" class="headerlink" title="下载文件并测试校验和"></a>下载文件并测试校验和</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">alias sha=&#x27;shasum -a 256 &#x27;</span><br></pre></td></tr></table></figure><h3 id="ping命令限制在5个ping"><a href="#ping命令限制在5个ping" class="headerlink" title="ping命令限制在5个ping"></a>ping命令限制在5个ping</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">alias ping=&#x27;ping -c 5&#x27;</span><br></pre></td></tr></table></figure><h3 id="获取你的外部-IP-地址"><a href="#获取你的外部-IP-地址" class="headerlink" title="获取你的外部 IP 地址"></a>获取你的外部 IP 地址</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">alias ipe=&#x27;curl ipinfo.io/ip&#x27;</span><br></pre></td></tr></table></figure><h3 id="关于ls命令的别名："><a href="#关于ls命令的别名：" class="headerlink" title="关于ls命令的别名："></a>关于ls命令的别名：</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 带颜色的ls别名</span></span><br><span class="line">alias ls=&#x27;ls --color=auto&#x27;</span><br><span class="line"> </span><br><span class="line">alias ll=&#x27;ls -la&#x27;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示隐藏文件或目录的命令别名</span></span><br><span class="line">alias l.=&#x27;ls -d .* --color=auto&#x27;</span><br></pre></td></tr></table></figure><h3 id="关于cd命令的别名"><a href="#关于cd命令的别名" class="headerlink" title="关于cd命令的别名"></a>关于cd命令的别名</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 进入父目录</span></span><br><span class="line">alias cd..=&#x27;cd ..&#x27;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash"> 快速返回到父目录</span></span><br><span class="line">alias ..=&#x27;cd ..&#x27;</span><br><span class="line">alias ...=&#x27;cd ../../&#x27;</span><br><span class="line">alias ....=&#x27;cd ../../../&#x27;</span><br><span class="line">alias .....=&#x27;cd ../../../../&#x27;</span><br><span class="line">alias .4=&#x27;cd ../../../../&#x27;</span><br><span class="line">alias .5=&#x27;cd ../../../../../&#x27;</span><br></pre></td></tr></table></figure><h3 id="关于grep命令的别名"><a href="#关于grep命令的别名" class="headerlink" title="关于grep命令的别名"></a>关于grep命令的别名</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 加入颜色输出，在搜索<span class="built_in">log</span>文件时很有用</span></span><br><span class="line">alias grep=&#x27;grep --color=auto&#x27;</span><br><span class="line">alias egrep=&#x27;egrep --color=auto&#x27;</span><br><span class="line">alias fgrep=&#x27;fgrep --color=auto&#x27;</span><br></pre></td></tr></table></figure><h3 id="回收站功能"><a href="#回收站功能" class="headerlink" title="回收站功能"></a>回收站功能</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir -p ~/.trash</span><br><span class="line">alias rm=trash</span><br><span class="line">alias r=trash</span><br><span class="line">alias rl=&#x27;ls ~/.trash/&#x27;</span><br><span class="line">alias ur=undelfile</span><br><span class="line"></span><br><span class="line">undelfile()</span><br><span class="line">&#123;</span><br><span class="line">    mv -i ~/.trash/$@ ./</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">trash()</span><br><span class="line">&#123;</span><br><span class="line">    mv -i $@ ~/.trash/</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cleartrash()</span><br><span class="line">&#123;</span><br><span class="line">    read -p &quot;clear sure?[n]&quot; confirm</span><br><span class="line">    [ $confirm == &#x27;y&#x27; ] || [ $confirm == &#x27;Y&#x27; ] &amp;&amp; /bin/rm -rf ~/.trash/*</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里，我们是在家目录下建立一个 <code>.trash</code> 的隐藏文件夹，作为回收站。然后，我们对 rm 命令进行重定义。当我们执行 rm 或者 r 的时候，将执行 trash 函数。而在 trash 函数里，只做一件事：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mv -i $@ ~/.trash/</span><br></pre></td></tr></table></figure><p>就是将 rm 之后所有的文件移动到 .trash 目录下（即模拟丢进回收站）。<code>-i</code> 选项表示如果 .trash 目录有同名文件的话，将提示是否覆盖。</p><p>我们将 <code>rl</code> 定义为 <code>ls ~/.trash/</code> ，也就是说，我们可以通过 rl 来查看 .trash 目录下的文件，即被「删除」的文件。</p><p>如果要还原文件，可以执行 <code>ur</code> ，而 ur 将执行 <code>undelfile</code> 函数。在 undelfile 里，又将 ur 之后的文件从 .trash 目录移回到原目录，从而实现文件删除还原。</p><p>当过了一段时间后，回收站里文件太多了，我们可以使用 <code>cleartrash</code> 命令清空回收站。它将执行同名函数，调用 <code>/bin/rm</code> 命令将 .trash 目录清空。</p><h4 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">~/workspace/test » touch file1 file2 file3</span><br><span class="line">~/workspace/test » ls</span><br><span class="line">file1 file2 file3</span><br><span class="line">~/workspace/test » rm file1 file2</span><br><span class="line">~/workspace/test » r file3</span><br></pre></td></tr></table></figure><h4 id="查看回收站文件"><a href="#查看回收站文件" class="headerlink" title="查看回收站文件"></a>查看回收站文件</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">~/workspace/test » rl</span><br><span class="line"></span><br><span class="line">file1                          file2                                  file3 </span><br></pre></td></tr></table></figure><h4 id="还原被删除的文件"><a href="#还原被删除的文件" class="headerlink" title="还原被删除的文件"></a>还原被删除的文件</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">~/workspace/test » ur file1</span><br><span class="line">~/workspace/test » ur file2</span><br><span class="line">~/workspace/test » ur file3</span><br><span class="line">~/workspace/test » ls</span><br><span class="line">file1 file2 file3</span><br></pre></td></tr></table></figure><h4 id="清空回收站"><a href="#清空回收站" class="headerlink" title="清空回收站"></a>清空回收站</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">~/workspace/test » rm file1 file2 file3</span><br><span class="line">~/workspace/test » cleartrash</span><br><span class="line">clear sure?[n]y</span><br><span class="line">~/workspace/test » rl</span><br><span class="line">~/workspace/test » </span><br></pre></td></tr></table></figure><hr><p><strong>注意 :</strong></p><p>将以上命令编辑到到 <code>~/.bash_profile</code>后, 需要执行<code>source ~/.bash_profile</code>命令使其生效;</p>]]></content>
      
      
      <categories>
          
          <category> 笔记本 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Bash </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySql数据库优化细节</title>
      <link href="post/2814564083/"/>
      <url>post/2814564083/</url>
      
        <content type="html"><![CDATA[<blockquote><p>MySQL  数据库性能的优化是 MySQL  数据库发展的必经之路， MySQL  数据库性能的优化也是 MySQL  数据库前进的见证。记录一些MySQL优化的一些细节</p></blockquote><h3 id="选取最适用的字段属性（出处）"><a href="#选取最适用的字段属性（出处）" class="headerlink" title="选取最适用的字段属性（出处）"></a>选取最适用的字段属性（<a href="https://www.sojson.com/blog/41.html">出处</a>）</h3><p>MySQL  可以很好的支持大数据量的存取，但是一般说来，数据库中的表越小，在它上面执行的查询也就会越快。因此，在创建表的时候，为了获得更好的性能，我们可以将表中字段的宽度设得尽可能小。例如，在定义邮政编码这个字段时，如果将其设置为<code>CHAR(255)，</code>显然给数据库增加了不必要的空间，甚至使用<code>VARCHAR</code>这种类型也是多余的，因为<code>CHAR(6)</code>就可以很好的完成任务了。同样的，如果可以的话，我们应该使用<code>MEDIUMINT</code>而不是<code>BIGIN</code>来定义整型字段。</p><p>另外一个提高效率的方法是在可能的情况下，应该尽量把字段设置为<code>NOT NULL</code>，这样在将来执行查询的时候，数据库不用去比较<code>NULL</code>值。</p><p>对于某些文本字段，例如“省份”或者“性别”，我们可以将它们定义为<code>ENUM</code>类型。因为在 MySQL  中，<code>ENUM</code>类型被当作数值型数据来处理，而数值型数据被处理起来的速度要比文本类型快得多。这样，我们又可以提高数据库的性能。</p><h3 id="使用连接（JOIN）来代替子查询-Sub-Queries-（出处）"><a href="#使用连接（JOIN）来代替子查询-Sub-Queries-（出处）" class="headerlink" title="使用连接（JOIN）来代替子查询(Sub-Queries)（出处）"></a>使用连接（JOIN）来代替子查询(Sub-Queries)（<a href="https://www.sojson.com/blog/41.html">出处</a>）</h3><p>MySQL  从4.1开始支持 SQL  的子查询。这个技术可以使用<code>SELECT</code>语句来创建一个单列的查询结果，然后把这个结果作为过滤条件用在另一个查询中。例如，我们要将客户基本信息表中没有任何订单的客户删除掉，就可以利用子查询先从销售信息表中将所有发出订单的客户<code>ID</code>取出来，然后将结果传递给主查询，如下所示：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DELETE FROM customerinfo</span><br><span class="line">WHERE CustomerID NOT in (SELECT CustomerID FROM salesinfo );</span><br></pre></td></tr></table></figure><p>使用子查询可以一次性的完成很多逻辑上需要多个步骤才能完成的 SQL  操作，同时也可以避免事务或者表锁死，并且写起来也很容易。但是，有些情况下，子查询可以被更有效率的连接（<code>JOIN</code>）.. 替代。例如，假设我们要将所有没有订单记录的用户取出来，可以用下面这个查询完成：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM customerinfoWHERE CustomerID NOT in (SELECT CustomerID FROM salesinfo )</span><br></pre></td></tr></table></figure><p>如果使用连接（<code>JOIN</code>）.. 来完成这个查询工作，速度将会快很多。尤其是当<code>salesinfo</code>表中对<code>CustomerID</code>建有索引的话，性能将会更好，查询如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM customerinfoLEFT JOIN salesinfo ON customerinfo.CustomerID&#x3D;salesinfo.CustomerID</span><br><span class="line">WHERE salesinfo.CustomerID IS NULL</span><br></pre></td></tr></table></figure><p>连接（<code>JOIN</code>）.. 之所以更有效率一些，是因为  MySQL  不需要在内存中创建临时表来完成这个逻辑上的需要两个步骤的查询工作。</p><h3 id="使用联合-UNION-来代替手动创建的临时表（出处）"><a href="#使用联合-UNION-来代替手动创建的临时表（出处）" class="headerlink" title="使用联合(UNION)来代替手动创建的临时表（出处）"></a>使用联合(<code>UNION</code>)来代替手动创建的临时表（<a href="https://www.sojson.com/blog/41.html">出处</a>）</h3><p>MySQL  从 4.0 的版本开始支持 <code>UNION</code>查询，它可以把需要使用临时表的两条或更多的 <code>SELECT</code>查询合并的一个查询中。在客户端的查询会话结束的时候，临时表会被自动删除，从而保证数据库整齐、高效。使用 <code>UNION</code>来创建查询的时候，我们只需要用 <code>UNION</code>作为关键字把多个 <code>SELECT</code>语句连接起来就可以了，要注意的是所有 <code>SELECT</code>语句中的字段数目要想同。下面的例子就演示了一个使用 <code>UNION</code>的查询。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT Name, Phone FROM client</span><br><span class="line">UNION</span><br><span class="line">SELECT Name, BirthDate FROM author</span><br><span class="line">UNION</span><br><span class="line">SELECT Name, Supplier FROM product</span><br></pre></td></tr></table></figure><h3 id="事务（出处）"><a href="#事务（出处）" class="headerlink" title="事务（出处）"></a>事务（<a href="https://www.sojson.com/blog/41.html">出处</a>）</h3><p>尽管我们可以使用子查询（<code>Sub-Queries</code>）、连接（<code>JOIN</code>）和联合（<code>UNION</code>）来创建各种各样的查询，但不是所有的数据库操作都可以只用一条或少数几条 SQL  语句就可以完成的。更多的时候是需要用到一系列的语句来完成某种工作。但是在这种情况下，当这个语句块中的某一条语句运行出错的时候，整个语句块的操作就会变得不确定起来。设想一下，要把某个数据同时插入两个相关联的表中，可能会出现这样的情况：第一个表中成功更新后，数据库突然出现意外状况，造成第二个表中的操作没有完成，这样，就会造成数据的不完整，甚至会破坏数据库中的数据。要避免这种情况，就应该使用事务，它的作用是：要么语句块中每条语句都操作成功，要么都失败。换句话说，就是可以保持数据库中数据的一致性和完整性。事物以<code>BEGIN</code>关键字开始，<code>COMMIT</code>关键字结束。在这之间的一条 SQL  操作失败，那么，<code>ROLLBACK</code>命令就可以把数据库恢复到<code>BEGIN</code>开始之前的状态。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">BEGIN;</span><br><span class="line">INSERT INTO salesinfo SET CustomerID&#x3D;14;</span><br><span class="line">UPDATE inventory SET Quantity&#x3D;11</span><br><span class="line">WHERE item&#x3D;&#39;book&#39;;</span><br><span class="line">COMMIT;</span><br></pre></td></tr></table></figure><p>事务的另一个重要作用是当多个用户同时使用相同的数据源时，它可以利用锁定数据库的方法来为用户提供一种安全的访问方式，这样可以保证用户的操作不被其它的用户所干扰。</p><h3 id="不用以下操作"><a href="#不用以下操作" class="headerlink" title="不用以下操作"></a>不用以下操作</h3><ol><li><p>显示或隐式的类型转换</p><p>比如 <code>SELECT id FROM table WHERE id=&#39;1&#39;</code><br>再如在<code>WHERE</code>子句中<code>numeric</code> 型和<code>int</code>型的列相比较就属于隐式转换</p></li><li><p>使用非同类型的列进行等值查询</p></li><li><p>在WHERE子句中的<code>&quot;=&quot;</code>左边表达式进行函数、算术运算或其他表达式运算</p></li><li><p>使用前缀为<code>%</code>的<code>LIKE</code></p></li><li><p>使用负向查询，如<code>NOT</code>, <code>!=</code>, <code>&lt;&gt;</code>, <code>!&gt;</code>, <code>1&lt;</code>, <code>NOT EXISTS</code>, <code>NOT IN</code>以及<code>NOT LIKE</code></p><p>比如 <code>NOT IN</code>会把空和<code>NULL</code>给查出来</p></li><li><p>在数据库中跑大查询</p></li><li><p>单条<code>SQL</code>语句同时更新多个表</p></li><li><p>使用跨库查询</p></li></ol><p>建议拆分成单表简单查询，通过程序进行关联</p><h3 id="避免使用以下操作"><a href="#避免使用以下操作" class="headerlink" title="避免使用以下操作"></a>避免使用以下操作</h3><ol><li><p>避免大事务</p><p>事务要简单，整个事务的时间长度不要太长。<br>拆分复杂<code>SQL</code>为多个小<code>SQL</code>，避免大事务</p></li><li><p>避免使用：触发器、函数、存储过程、视图</p></li><li><p>避免在数据库中进数学运算</p><p><code>MySQL</code>不擅长数学运算和逻辑判断</p></li><li><p>避免取出大字段且无用的内容</p><p><code>SELECT</code>只获取必要的字段，尽量少使用<code>SELECT *</code></p></li><li><p>避免使用大表的<code>JOIN</code></p></li><li><p>避免一次更新太多数据</p><p>比如，对数据的更新要打散后批量更新</p></li><li><p>尽量避免使用子查询，建议将子查询转换成关联查询  </p><p>但由于子查询不使用索引，在关联查询也不使用索引的情况下，子查询是要优于关联查询的。因此至于是使用关联查询还是子查询则需要使用<code>EXPLAIN</code>对<code>SQL</code>进行分析才是万全之策</p></li></ol><h3 id="替换使用"><a href="#替换使用" class="headerlink" title="替换使用"></a>替换使用</h3><ol><li><p>用<code>IN</code>代替<code>OR</code></p><p><code>OR</code>的效率没有<code>IN</code>的效率高</p></li><li><p><code>IN</code>条件里面的数据的个数建议控制在500个以内</p><p>要学会使用<code>EXISTS</code>代替<code>IN</code>，<code>EXISTS</code>在一些场景查询会比<code>IN</code>快</p></li><li><p>用<code>UNION ALL</code>代替<code>UNION</code></p></li><li><p>使用<code>EXISTS</code>来判断记录是否存在，而不使用<code>SELECT COUNT(1)</code>来判断记录是否存在</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 笔记本 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> 优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Stream表达式语法</title>
      <link href="post/2675058551/"/>
      <url>post/2675058551/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文转自：<a href="http://ifeve.com/">ifeve.com</a></p></blockquote><h1 id="Stream初体验"><a href="#Stream初体验" class="headerlink" title="Stream初体验"></a>Stream初体验</h1><blockquote><p>A sequence of elements supporting sequential and parallel aggregate operations.</p><p>以上是Java里面是对Stream的定义，解读一下这句话：</p><ol><li><strong>Stream是元素的集合，这点让Stream看起来用些类似Iterator；</strong></li><li><strong>可以支持顺序和并行的对原Stream进行汇聚的操作；</strong></li></ol></blockquote><p><strong>可以把Stream当成一个高级版本的Iterator。</strong></p><p><strong>原始版本的Iterator，用户只能一个一个的遍历元素并对其执行某些操作；</strong></p><p><strong>高级版本的Stream，用户只要给出需要对其包含的元素执行什么操作，比如“过滤掉长度大于10的字符串”、“获取每个字符串的首字母”等，具体这些操作如何应用到每个元素上，就给Stream就好了！</strong></p><p>下面一段代码直观的认识一下Stream：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Lists是Guava中的一个工具类</span></span><br><span class="line">List&lt;Integer&gt; nums = Lists.newArrayList(<span class="number">1</span>,<span class="keyword">null</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="keyword">null</span>,<span class="number">6</span>);</span><br><span class="line">nums.stream().filter(num -&gt; num != <span class="keyword">null</span>).count();</span><br></pre></td></tr></table></figure><p>上面这段代码是获取一个List中，元素不为null的个数。我们现在开始深入解刨这个例子，完成以后你可能可以基本掌握Stream的用法！</p><h2 id="剖析Stream通用语法"><a href="#剖析Stream通用语法" class="headerlink" title="剖析Stream通用语法"></a>剖析Stream通用语法</h2><p><img src="https://gitee.com/cayzlh/img-repo/raw/master/2020/04/25/uBgJF4.jpg" alt="剖析Stream通用语法"></p><p>图片就是对于Stream例子的一个解析，可以很清楚的看见：原本一条语句被三种颜色的框分割成了三个部分。</p><p>红色框中的语句是一个Stream的生命开始的地方，负责创建一个Stream实例；</p><p>绿色框中的语句是赋予Stream灵魂的地方，把一个Stream转换成另外一个Stream，红框的语句生成的是一个包含所有nums变量的Stream，进过绿框的filter方法以后，重新生成了一个过滤掉原nums列表所有null以后的Stream；</p><p>蓝色框中的语句是丰收的地方，把Stream的里面包含的内容按照某种算法来汇聚成一个值，例子中是获取Stream中包含的元素个数。</p><p><img src="https://gitee.com/cayzlh/img-repo/raw/master/2020/04/25/Kz1wEs.jpg" alt="剖析Stream通用语法"></p><p>在此我们总结一下<strong>使用Stream的基本步骤：</strong></p><ol><li>创建Stream；</li><li>转换Stream，每次转换原有Stream对象不改变，返回一个新的Stream对象（<strong>可以有多次转换</strong>）；</li><li>对Stream进行聚合（Reduce）操作，获取想要的结果；</li></ol><h1 id="创建Stream"><a href="#创建Stream" class="headerlink" title="创建Stream"></a>创建Stream</h1><p>最常用的创建Stream有两种途径：</p><ol><li>通过Stream接口的静态工厂方法（注意：Java8里接口可以带静态方法）；</li><li>通过Collection接口的默认方法（默认方法：Default method，也是Java8中的一个新特性，就是接口中的一个带有实现的方法）–stream()，把一个Collection对象转换成Stream</li></ol><h2 id="使用Stream静态方法来创建Stream"><a href="#使用Stream静态方法来创建Stream" class="headerlink" title="使用Stream静态方法来创建Stream"></a>使用Stream静态方法来创建Stream</h2><ol><li><p>of方法：有两个overload方法，一个接受变长参数，一个接口单一值</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;Integer&gt; integerStream = Stream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line">Stream&lt;String&gt; stringStream = Stream.of(<span class="string">&quot;taobao&quot;</span>);</span><br></pre></td></tr></table></figure></li><li><p>generator方法：生成一个无限长度的Stream，其元素的生成是通过给定的Supplier（这个接口可以看成一个对象的工厂，每次调用返回一个给定类型的对象）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream.generate(<span class="keyword">new</span> Supplier&lt;Double&gt;() &#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Double <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> Math.random();</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">Stream.generate(() -&gt; Math.random());</span><br><span class="line">Stream.generate(Math::random);</span><br></pre></td></tr></table></figure><p>三条语句的作用都是一样的，只是使用了lambda表达式和方法引用的语法来简化代码。每条语句其实都是生成一个无限长度的Stream，其中值是随机的。<em>这个无限长度Stream是懒加载，一般这种无限长度的Stream都会配合Stream的limit()方法来用。</em></p></li><li><p>iterate方法：也是生成无限长度的Stream，和generator不同的是，其元素的生成是重复对给定的种子值(seed)调用用户指定函数来生成的。其中包含的元素可以认为是：seed，f(seed),f(f(seed))无限循环</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream.iterate(<span class="number">1</span>, item -&gt; item + <span class="number">1</span>).limit(<span class="number">10</span>).forEach(System.out::println);</span><br></pre></td></tr></table></figure><p>这段代码就是先获取一个无限长度的正整数集合的Stream，然后取出前10个打印。<strong>千万记住使用limit方法，不然会无限打印下去。</strong></p></li></ol><h2 id="通过Collection子类获取Stream"><a href="#通过Collection子类获取Stream" class="headerlink" title="通过Collection子类获取Stream"></a>通过Collection子类获取Stream</h2><p>查看Java doc就可以发现Collection接口有一个stream方法，所以其所有子类都都可以获取对应的Stream对象。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Collection</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Iterable</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//其他方法省略</span></span><br><span class="line"><span class="function"><span class="keyword">default</span> Stream&lt;E&gt; <span class="title">stream</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> StreamSupport.stream(spliterator(), <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="转换Stream"><a href="#转换Stream" class="headerlink" title="转换Stream"></a>转换Stream</h1><p>转换Stream其实就是把一个Stream通过某些行为转换成一个新的Stream。Stream接口中定义了几个常用的转换方法，下面挑选几个常用的转换方法来解释。</p><ol><li><p><code>distinct</code>: 对于Stream中包含的元素进行去重操作（去重逻辑依赖元素的equals方法），新生成的Stream中没有重复的元素；</p><p>distinct方法示意图：</p><p><img src="https://gitee.com/cayzlh/img-repo/raw/master/2020/04/25/EcOtNh.jpg" alt="distinct方法示意图"></p></li><li><p><code>filter</code>: 对于Stream中包含的元素使用给定的过滤函数进行过滤操作，新生成的Stream只包含符合条件的元素；</p><p>filter方法示意图：</p><p><img src="https://gitee.com/cayzlh/img-repo/raw/master/2020/04/25/H9VDBX.jpg" alt="filter方法示意图"></p></li><li><p><code>map</code>: 对于Stream中包含的元素使用给定的转换函数进行转换操作，新生成的Stream只包含转换生成的元素</p><p>这个方法有三个对于原始类型的变种方法，分别是：<code>mapToInt</code>，<code>mapToLong</code>和<code>mapToDouble</code>。这三个方法也比较好理解，比如<code>mapToInt</code>就是把原始<code>Stream</code>转换成一个新的<code>Stream</code>，这个新生成的<code>Stream</code>中的元素都是<code>int</code>类型。之所以会有这样三个变种方法，可以免除自动装箱/拆箱的额外消耗；</p><p>map方法示意图：</p><p><img src="https://gitee.com/cayzlh/img-repo/raw/master/2020/04/25/2JGFXm.jpg" alt="map方法示意图"></p></li><li><p><code>flatMap</code>：和<code>map</code>类似，不同的是其每个元素转换得到的是Stream对象，会把子Stream中的元素压缩到父集合中；</p><p>flatMap方法示意图：</p><p><img src="https://gitee.com/cayzlh/img-repo/raw/master/2020/04/25/e7TGdu.jpg" alt="`flatMap`方法示意图"></p></li><li><p><code>peek</code>: 生成一个包含原Stream的所有元素的新Stream，同时会提供一个消费函数（Consumer实例），新Stream每个元素被消费的时候都会执行给定的消费函数；</p><p>peek方法示意图：</p><p><img src="https://gitee.com/cayzlh/img-repo/raw/master/2020/04/25/iC3J2q.jpg" alt="peek方法示意图"></p></li><li><p><code>limit</code>: 对一个Stream进行截断操作，获取其前N个元素，如果原Stream中包含的元素个数小于N，那就获取其所有的元素；</p><p>limit方法示意图：</p><p><img src="https://gitee.com/cayzlh/img-repo/raw/master/2020/04/25/8grjYJ.jpg" alt="limit方法示意图"></p></li><li><p><code>skip</code>: 返回一个丢弃原Stream的前N个元素后剩下元素组成的新Stream，如果原Stream中包含的元素个数小于N，那么返回空Stream；</p><p>skip方法示意图：</p><p><img src="https://gitee.com/cayzlh/img-repo/raw/master/2020/04/25/F5wQkI.jpg" alt="skip方法示意图"></p></li><li><p>综合使用：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; nums = Lists.newArrayList(<span class="number">1</span>,<span class="number">1</span>,<span class="keyword">null</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="keyword">null</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>);</span><br><span class="line">System.out.println(“sum is:”+nums.stream().filter(num -&gt; num != <span class="keyword">null</span>).</span><br><span class="line">   distinct().mapToInt(num -&gt; num * <span class="number">2</span>).</span><br><span class="line">               peek(System.out::println).skip(<span class="number">2</span>).limit(<span class="number">4</span>).sum());   </span><br></pre></td></tr></table></figure><p>这段代码演示了上面介绍的所有转换方法（除了flatMap）。</p><p>简单解释一下这段代码的含义：给定一个<code>Integer</code>类型的<code>List</code>，获取其对应的Stream对象，然后进行过滤掉null，再去重，再每个元素乘以2，再每个元素被消费的时候打印自身，在跳过前两个元素，最后去前四个元素进行加和运算(解释一大堆，很像废话，因为基本看了方法名就知道要做什么了。这个就是声明式编程的一大好处！)。</p></li><li><p>性能问题</p><p>可能会有这样的疑问：在对于一个Stream进行多次转换操作，每次都对Stream的每个元素进行转换，而且是执行多次，这样时间复杂度就是一个for循环里把所有操作都做掉的N（转换的次数）倍啊。<strong>其实不是这样的，转换操作都是<code>lazy</code>的，多个转换操作只会在汇聚操作的时候融合起来，一次循环完成。可以这样简单的理解，Stream里有个操作函数的集合，每次转换操作就是把转换函数放入这个集合中，在汇聚操作的时候循环Stream对应的集合，然后对每个元素执行所有的函数。</strong></p></li></ol><h1 id="汇聚（Reduce）Stream"><a href="#汇聚（Reduce）Stream" class="headerlink" title="汇聚（Reduce）Stream"></a>汇聚（Reduce）Stream</h1><p><strong>Java doc中对于其定义：</strong></p><blockquote><p>A reduction operation (also called a fold) takes a sequence of input elements and combines them into a single summary result by repeated application of a combining operation, such as finding the sum or maximum of a set of numbers, or accumulating elements into a list. The streams classes have multiple forms of general reduction operations, called reduce() and collect(), as well as multiple specialized reduction forms such as sum(), max(), or count().</p><p>汇聚操作（也称为折叠）接受一个元素序列为输入，反复使用某个合并操作，把序列中的元素合并成一个汇总的结果。比如查找一个数字列表的总和或者最大值，或者把这些数字累积成一个List对象。Stream接口有一些通用的汇聚操作，比如reduce()和collect()；也有一些特定用途的汇聚操作，比如sum(),max()和count()。<strong>注意：sum方法不是所有的Stream对象都有的，只有IntStream、LongStream和DoubleStream是实例才有。</strong></p></blockquote><p>分两部分来介绍汇聚操作：</p><ol><li><strong>可变汇聚</strong>：把输入的元素们累积到一个可变的容器中，比如Collection或者StringBuilder；</li><li><strong>其他汇聚</strong>：除去可变汇聚剩下的，一般都不是通过反复修改某个可变对象，而是通过把前一次的汇聚结果当成下一次的入参，反复如此。比如reduce，count，allMatch；</li></ol><h2 id="可变汇聚"><a href="#可变汇聚" class="headerlink" title="可变汇聚"></a>可变汇聚</h2><p>可变汇聚对应的只有一个方法：collect，正如其名字显示的，它可以把Stream中的要有元素收集到一个结果容器中（比如Collection）。先看一下最通用的collect方法的定义（还有其他override方法）：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;R&gt; <span class="function">R <span class="title">collect</span><span class="params">(Supplier&lt;R&gt; supplier,</span></span></span><br><span class="line"><span class="function"><span class="params">                  BiConsumer&lt;R, ? <span class="keyword">super</span> T&gt; accumulator,</span></span></span><br><span class="line"><span class="function"><span class="params">                  BiConsumer&lt;R, R&gt; combiner)</span></span>;</span><br></pre></td></tr></table></figure><p>先来看看这三个参数的含义：</p><p><code>Supplier supplier</code>是一个工厂函数，用来生成一个新的容器；</p><p><code>BiConsumer accumulator</code>也是一个函数，用来把Stream中的元素添加到结果容器中；</p><p><code>BiConsumer combiner</code>还是一个函数，用来把中间状态的多个结果容器合并成为一个（并发的时候会用到）；</p><p>来段代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; nums = Lists.newArrayList(<span class="number">1</span>,<span class="number">1</span>,<span class="keyword">null</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="keyword">null</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>);</span><br><span class="line">       List&lt;Integer&gt; numsWithoutNull = nums.stream().filter(num -&gt; num != <span class="keyword">null</span>).</span><br><span class="line">               collect(() -&gt; <span class="keyword">new</span> ArrayList&lt;Integer&gt;(),</span><br><span class="line">                       (list, item) -&gt; list.add(item),</span><br><span class="line">                       (list1, list2) -&gt; list1.addAll(list2));</span><br></pre></td></tr></table></figure><p>上面这段代码就是对一个元素是Integer类型的List，先过滤掉全部的null，然后把剩下的元素收集到一个新的List中。进一步看一下collect方法的三个参数，都是lambda形式的函数。</p><ul><li>第一个函数生成一个新的ArrayList实例；</li><li>第二个函数接受两个参数，第一个是前面生成的ArrayList对象，二个是stream中包含的元素，函数体就是把stream中的元素加入ArrayList对象中。第二个函数被反复调用直到原stream的元素被消费完毕；</li><li>第三个函数也是接受两个参数，这两个都是ArrayList类型的，函数体就是把第二个ArrayList全部加入到第一个中；</li></ul><p>但是上面的collect方法调用也有点太复杂了，来看一下collect方法另外一个override的版本：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;R, A&gt; <span class="function">R <span class="title">collect</span><span class="params">(Collector&lt;? <span class="keyword">super</span> T, A, R&gt; collector)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>Java8还给我们提供了Collector的工具类，其中已经定义了一些静态工厂方法，比如：Collectors.toCollection()收集到Collection中, Collectors.toList()收集到List中和Collectors.toSet()收集到Set中。</strong></p><p>使用Collectors对于代码的简化：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; numsWithoutNull = nums.stream().filter(num -&gt; num != <span class="keyword">null</span>).</span><br><span class="line">                collect(Collectors.toList());</span><br></pre></td></tr></table></figure><h2 id="其他汇聚"><a href="#其他汇聚" class="headerlink" title="其他汇聚"></a>其他汇聚</h2><ul><li><strong>reduce方法：</strong>reduce方法非常的通用，后面介绍的count，sum等都可以使用其实现。</li></ul><p>reduce方法的第一种形式，其方法定义如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Optional&lt;T&gt; <span class="title">reduce</span><span class="params">(BinaryOperator&lt;T&gt; accumulator)</span></span>;</span><br></pre></td></tr></table></figure><p>接受一个BinaryOperator类型的参数，在使用的时候可以用lambda表达式来。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; ints = Lists.newArrayList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;ints sum is:&quot;</span> + ints.stream().reduce((sum, item) -&amp;gt; sum + item).get());</span><br></pre></td></tr></table></figure><p>可以看到reduce方法接受一个函数，这个函数有两个参数，第一个参数是上次函数执行的返回值（也称为中间结果），第二个参数是stream中的元素，这个函数把这两个值相加，得到的和会被赋值给下次执行这个函数的第一个参数。要注意的是：<strong>第一次执行的时候第一个参数的值是Stream的第一个元素，第二个参数是Stream的第二个元素</strong>。这个方法返回值类型是Optional，这是Java8防止出现NPE的一种可行方法，后面的文章会详细介绍，这里就简单的认为是一个容器，其中可能会包含0个或者1个对象。</p><p><strong>reduce方法还有一个很常用的变种：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">T <span class="title">reduce</span><span class="params">(T identity, BinaryOperator&lt;T&gt; accumulator)</span></span>;</span><br></pre></td></tr></table></figure><p>这个定义上上面已经介绍过的基本一致，不同的是：它允许用户提供一个循环计算的初始值，如果Stream为空，就直接返回该值。而且这个方法不会返回Optional，因为其不会出现null值。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; ints = Lists.newArrayList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;ints sum is:&quot;</span> + ints.stream().reduce(<span class="number">0</span>, (sum, item) -&gt; sum + item));</span><br></pre></td></tr></table></figure><ul><li><strong>count方法：</strong>获取Stream中元素的个数</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; ints = Lists.newArrayList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;ints sum is:&quot;</span> + ints.stream().count());</span><br></pre></td></tr></table></figure><hr><p>其他方法：</p><ul><li><strong>allMatch：</strong>是不是Stream中的所有元素都满足给定的匹配条件</li><li><strong>anyMatch：</strong>Stream中是否存在任何一个元素满足匹配条件</li><li><strong>findFirst：</strong> 返回Stream中的第一个元素，如果Stream为空，返回空Optional</li><li><strong>noneMatch：</strong>是不是Stream中的所有元素都不满足给定的匹配条件</li><li><strong>max和min：</strong>使用给定的比较器（Operator），返回Stream中的最大|最小值</li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="http://ifeve.com/">ifeve.com</a></li><li>《Java SE 8 for the Really Impatient》</li><li>Java 8 Tutorial</li><li>Java 8 API doc</li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Stream </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>lambda表达式语法</title>
      <link href="post/645430451/"/>
      <url>post/645430451/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文转自：<a href="http://ifeve.com/">ifeve.com</a></p></blockquote><h1 id="Lambda初体验"><a href="#Lambda初体验" class="headerlink" title="Lambda初体验"></a>Lambda初体验</h1><blockquote><p> a function (or a subroutine) defined, and possibly called, without being bound to an identifier。</p><p>以上是维基百科上对于“Lambda expression”的解释，简单来说就是：<strong>一个不用被绑定到一个标识符上，并且可能被调用的函数。</strong></p></blockquote><p>这个解释还不够通俗，lambda表达式可以这样定义（不精确）：<strong>一段带有输入参数的可执行语句块。</strong></p><p>先提供一个没用stream的lambda表达式的例子：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这里省略list的构造</span></span><br><span class="line">List&lt;String&gt; names = ...;</span><br><span class="line">Collections.sort(names, (o1, o2) -&gt; o1.compareTo(o2));</span><br></pre></td></tr></table></figure><p>-</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这里省略list的构造</span></span><br><span class="line">List&lt;String&gt; names = ...;</span><br><span class="line">Collections.sort(names, <span class="keyword">new</span> Comparator&lt;String&gt;() &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String o1, String o2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> o1.compareTo(o2);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面两段代码分别是：<strong>使用lambda表达式来排序和使用匿名内部类来排序。</strong></p><p>这个例子可以很明显的看出lambda表达式简化代码的效果。接下来展示lambda表达式和其好基友Stream的配合：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; names = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">names.add(<span class="string">&quot;TaoBao&quot;</span>);</span><br><span class="line">names.add(<span class="string">&quot;ZhiFuBao&quot;</span>);</span><br><span class="line">List&lt;String&gt; lowercaseNames = names.stream().map((String name) -&gt; &#123;<span class="keyword">return</span> name.toLowerCase();&#125;).collect(Collectors.toList());</span><br></pre></td></tr></table></figure><p>这段代码就是对一个字符串的列表，把其中包含的每个字符串都转换成全小写的字符串。注意代码第四行的map方法调用，这里map方法就是接受了一个lambda表达式（<em>其实是一个java.util.function.Function的实例</em>）。</p><p><strong>看看在Java8之前，如果我们想做上面代码的操作应该怎么办。</strong></p><ul><li><p>普通青年的代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; names = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">names.add(<span class="string">&quot;TaoBao&quot;</span>);</span><br><span class="line">names.add(<span class="string">&quot;ZhiFuBao&quot;</span>);</span><br><span class="line">List&lt;String&gt; lowercaseNames = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (String name : names) &#123;</span><br><span class="line">  lowercaseNames.add(name.toLowerCase());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>文艺青年的代码（借助Guava）:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; names = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">names.add(<span class="string">&quot;TaoBao&quot;</span>);</span><br><span class="line">names.add(<span class="string">&quot;ZhiFuBao&quot;</span>);</span><br><span class="line">List&lt;String&gt; lowercaseNames = FluentIterable.from(names).transform(<span class="keyword">new</span> Function&lt;String, String&gt;() &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">apply</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> name.toLowerCase();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;).toList();</span><br></pre></td></tr></table></figure></li></ul><p>在此，不再讨论普通青年和文艺青年的代码风格孰优孰劣（有兴趣的可以去google搜索“命令式编程vs声明式编程”）。</p><p>文艺青年代码初看起来看起来干扰信息有点多，Function匿名类的构造语法稍稍有点冗长。所以<strong>Java8的lambda表达式给我们提供了创建SAM（Single Abstract Method）接口更加简单的语法糖。</strong></p><h1 id="Lambda语法详解"><a href="#Lambda语法详解" class="headerlink" title="Lambda语法详解"></a>Lambda语法详解</h1><p><strong>抽象一下lambda表达式的一般语法：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">(Type1 param1, Type2 param2, ..., TypeN paramN) -&gt; &#123;</span><br><span class="line">  statment1;</span><br><span class="line">  statment2;</span><br><span class="line">  <span class="comment">//.............</span></span><br><span class="line">  <span class="keyword">return</span> statmentM;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从lambda表达式的一般语法可以看出来，还是挺符合上面给出的非精确版本的定义–<strong>“一段带有输入参数的可执行语句块”。</strong></p><p>上面的lambda表达式语法可以认为是最全的版本，写起来还是稍稍有些繁琐。别着急，下面陆续介绍一下lambda表达式的各种简化版：</p><ol><li><p>参数类型省略–绝大多数情况，编译器都可以从上下文环境中推断出lambda表达式的参数类型。这样lambda表达式就变成了：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">(param1,param2, ..., paramN) -&gt; &#123;</span><br><span class="line">  statment1;</span><br><span class="line">  statment2;</span><br><span class="line">  <span class="comment">//.............</span></span><br><span class="line">  <span class="keyword">return</span> statmentM;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>当lambda表达式的参数个数只有一个，可以省略小括号。lambda表达式简写为：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">param1 -&gt; &#123;</span><br><span class="line">  statment1;</span><br><span class="line">  statment2;</span><br><span class="line">  <span class="comment">//.............</span></span><br><span class="line">  <span class="keyword">return</span> statmentM;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以最开始的例子再次简化为：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; lowercaseNames = names.stream().map(name -&gt; &#123;<span class="keyword">return</span> name.toLowerCase();&#125;).collect(Collectors.toList());</span><br></pre></td></tr></table></figure></li><li><p>当lambda表达式只包含一条语句时，可以省略大括号、return和语句结尾的分号。lambda表达式简化为：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">param1 -&gt; statment</span><br></pre></td></tr></table></figure><p>所以最开始的例子再次简化为：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; lowercaseNames = names.stream().map(name -&gt; name.toLowerCase()).collect(Collectors.toList());</span><br></pre></td></tr></table></figure></li><li><p>使用Method Reference（方法引用）:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; lowercaseNames = names.stream().map(String::toLowerCase).collect(Collectors.toList());</span><br></pre></td></tr></table></figure></li></ol><h1 id="Lambda表达式眼中的外部世界"><a href="#Lambda表达式眼中的外部世界" class="headerlink" title="Lambda表达式眼中的外部世界"></a>Lambda表达式眼中的外部世界</h1><blockquote><p>lambda表达式其实是快速创建SAM接口的语法糖，原先的SAM接口都可以访问接口外部变量，lambda表达式肯定也是可以（不但可以，在java8中还做了一个小小的升级）。</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] array = &#123;<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(Integer i : Lists.newArrayList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>))&#123;</span><br><span class="line">  Stream.of(array).map(item -&gt; Strings.padEnd(item, i, <span class="string">&#x27;@&#x27;</span>)).forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的这个例子中，map中的lambda表达式访问外部变量Integer i。并且可以访问外部变量是lambda表达式的一个重要特性，这样我们可以看出来lambda表达式的三个重要组成部分：</p><ul><li>输入参数</li><li>可执行语句</li><li>存放外部变量的空间</li></ul><p>不过lambda表达式访问外部变量有一个非常重要的限制：<strong>变量不可变（只是引用不可变，而不是真正的不可变）。</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] array = &#123;<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i&lt;<span class="number">4</span>; i++)&#123;</span><br><span class="line">  Stream.of(array).map(item -&gt; Strings.padEnd(item, i, <span class="string">&#x27;@&#x27;</span>)).forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码，会报编译错误。因为变量i被lambda表达式引用，所以编译器会隐式的把其当成final来处理。</p><blockquote><p>以前java的匿名内部类在访问外部变量的时候，外部变量必须用final修饰。<strong>在java8对这个限制做了优化（前面说的小小优化），可以不用显示使用final修饰，但是编译器隐式当成final来处理。</strong></p></blockquote><h1 id="Lambda眼中的this"><a href="#Lambda眼中的this" class="headerlink" title="Lambda眼中的this"></a>Lambda眼中的this</h1><p>在lambda中，this不是指向lambda表达式产生的那个SAM对象，而是声明它的外部对象。</p><h1 id="方法引用（Method-reference）和构造器引用（construct-reference）"><a href="#方法引用（Method-reference）和构造器引用（construct-reference）" class="headerlink" title="方法引用（Method reference）和构造器引用（construct reference）"></a>方法引用（Method reference）和构造器引用（construct reference）</h1><h2 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h2><p>方法引用可以在某些条件成立的情况下，更加简化lambda表达式的声明。</p><p>方法引用语法格式有以下三种：</p><ul><li><strong>objectName::instanceMethod</strong></li><li><strong>ClassName::staticMethod</strong></li><li><strong>ClassName::instanceMethod</strong></li></ul><p>前两种方式类似，等同于把lambda表达式的参数直接当成<code>instanceMethod|staticMethod</code>的参数来调用。比如<code>System.out::println</code>等同于<code>x-&gt;System.out.println(x)</code>；<code>Math::max</code>等同于<code>(x, y)-&gt;Math.max(x,y)</code>。</p><p>最后一种方式，等同于把lambda表达式的第一个参数当成<code>instanceMethod</code>的目标对象，其他剩余参数当成该方法的参数。比如<code>String::toLowerCase</code>等同于<code>x-&gt;x.toLowerCase()</code>。</p><h2 id="构造器引用"><a href="#构造器引用" class="headerlink" title="构造器引用"></a>构造器引用</h2><p>构造器引用语法如下：<code>ClassName::new</code>，把lambda表达式的参数当成<code>ClassName</code>构造器的参数 。例如<code>BigDecimal::new</code>等同于<code>x-&gt;new BigDecimal(x)</code>。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="http://ifeve.com/">ifeve.com</a></li><li>《Java SE 8 for the Really Impatient》</li><li>Java 8 Tutorial</li><li>Java 8 API doc</li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> lambda </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis高逼格指令</title>
      <link href="post/4134566530/"/>
      <url>post/4134566530/</url>
      
        <content type="html"><![CDATA[<h1 id="keys"><a href="#keys" class="headerlink" title="keys"></a>keys</h1><p>过度使用<code>keys</code>这个命令，将会导致出现性能毛刺。这个命令的时间复杂度是O(N)，而且redis又是单线程执行，在执行keys时即使是时间复杂度只有O(1)例如SET或者GET这种简单命令也会堵塞，从而导致这个时间点性能抖动，甚至可能出现timeout。</p><blockquote><p><strong>强烈建议生产环境屏蔽keys命令</strong></p></blockquote><h1 id="scan"><a href="#scan" class="headerlink" title="scan"></a>scan</h1><p>既然<code>keys</code>命令不推荐使用，那就就用<code>scan</code>命令。如果把keys命令比作类似<code>select * from users where username like &#39;%afei%&#39;</code>这种SQL，那么scan应该是<code>select * from users where id&gt;? limit 10</code>这种命令。</p><p>官方文档用法如下：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">SCAN cursor [MATCH pattern] [COUNT count]</span><br></pre></td></tr></table></figure><p>初始执行scan命令例如<code>scan 0</code>。SCAN命令是一个基于游标的迭代器。这意味着命令每次被调用都需要使用上一次这个调用返回的游标作为该次调用的游标参数，以此来延续之前的迭代过程。当SCAN命令的游标参数被设置为0时，服务器将开始一次新的迭代，而<strong>当redis服务器向用户返回值为0的游标时，表示迭代已结束</strong>，这是唯一迭代结束的判定方式，而不能通过返回结果集是否为空判断迭代结束。</p><p>使用方式：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6380&gt; scan 0</span><br><span class="line">1) &quot;22&quot;</span><br><span class="line">2)  1) &quot;23&quot;</span><br><span class="line">    2) &quot;20&quot;</span><br><span class="line">    3) &quot;14&quot;</span><br><span class="line">    4) &quot;2&quot;</span><br><span class="line">    5) &quot;19&quot;</span><br><span class="line">    6) &quot;9&quot;</span><br><span class="line">    7) &quot;3&quot;</span><br><span class="line">    8) &quot;21&quot;</span><br><span class="line">    9) &quot;12&quot;</span><br><span class="line">   10) &quot;25&quot;</span><br><span class="line">   11) &quot;7&quot;</span><br></pre></td></tr></table></figure><p>返回结果分为两个部分：第一部分即1)就是下一次迭代游标，第二部分即2)就是本次迭代结果集。</p><h1 id="slowlog"><a href="#slowlog" class="headerlink" title="slowlog"></a>slowlog</h1><p>上面提到不能使用<code>keys</code>命令，如果就有开发这么做了呢，我们如何得知？与其他任意存储系统例如<code>mysql</code>，<code>mongodb</code>可以查看慢日志一样，redis也可以，即通过命令<code>slowlog</code>。用法如下：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">SLOWLOG subcommand [argument]</span><br></pre></td></tr></table></figure><p>subcommand主要有：</p><ul><li><strong>get</strong>，用法：<code>slowlog get [argument]</code>，获取<code>argument</code>参数指定数量的慢日志。</li><li><strong>len</strong>，用法：<code>slowlog len</code>，总慢日志数量。</li><li><strong>reset</strong>，用法：<code>slowlog reset</code>，清空慢日志。</li></ul><p>执行结果如下：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6380&gt; slowlog get 5</span><br><span class="line">1) 1) (integer) 2</span><br><span class="line">   2) (integer) 1532656201</span><br><span class="line">   3) (integer) 2033</span><br><span class="line">   4) 1) &quot;flushddbb&quot;</span><br><span class="line">2) 1) (integer) 1  ----  慢日志编码，一般不用care</span><br><span class="line">   2) (integer) 1532646897  ----  导致慢日志的命令执行的时间点，如果api有timeout，可以通过对比这个时间，判断可能是慢日志命令执行导致的</span><br><span class="line">   3) (integer) 26424  ----  导致慢日志执行的redis命令，通过4)可知，执行config rewrite导致慢日志，总耗时26ms+</span><br><span class="line">   4) 1) &quot;config&quot;</span><br><span class="line">      2) &quot;rewrite&quot;</span><br></pre></td></tr></table></figure><blockquote><p>命令耗时超过多少才会保存到<code>slowlog</code>中，可以通过命令<code>config set slowlog-log-slower-than 2000</code>配置并且不需要重启<code>redis</code>。注意：单位是微秒，2000微秒即2毫秒。</p></blockquote><h1 id="rename-command"><a href="#rename-command" class="headerlink" title="rename-command"></a>rename-command</h1><p>为了防止把问题带到生产环境，我们可以通过配置文件重命名一些危险命令，例如<code>keys</code>等一些高危命令。操作非常简单，只需要在conf配置文件增加如下所示配置即可：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rename-command flushdb flushddbb</span><br><span class="line">rename-command flushall flushallall</span><br><span class="line">rename-command keys keysys</span><br></pre></td></tr></table></figure><h1 id="bigkeys"><a href="#bigkeys" class="headerlink" title="bigkeys"></a>bigkeys</h1><p>随着项目越做越大，缓存使用越来越不规范。我们如何检查生产环境上一些有问题的数据。<code>bigkeys</code>就派上用场了，用法如下：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">redis-cli -p 6380 --bigkeys</span><br></pre></td></tr></table></figure><p>执行结果如下：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">... ...</span><br><span class="line">-------- summary -------</span><br><span class="line"></span><br><span class="line">Sampled 526 keys in the keyspace!</span><br><span class="line">Total key length in bytes is 1524 (avg len 2.90)</span><br><span class="line"></span><br><span class="line">Biggest string found &#x27;test&#x27; has 10005 bytes</span><br><span class="line">Biggest   list found &#x27;commentlist&#x27; has 13 items</span><br><span class="line"></span><br><span class="line">524 strings with 15181 bytes (99.62% of keys, avg size 28.97)</span><br><span class="line">2 lists with 19 items (00.38% of keys, avg size 9.50)</span><br><span class="line">0 sets with 0 members (00.00% of keys, avg size 0.00)</span><br><span class="line">0 hashs with 0 fields (00.00% of keys, avg size 0.00)</span><br><span class="line">0 zsets with 0 members (00.00% of keys, avg size 0.00)</span><br></pre></td></tr></table></figure><p>最后5行可知，没有<code>set</code>,<code>hash</code>,<code>zset</code>几种数据结构的数据。<code>string</code>类型有524个，list类型有两个；通过<code>Biggest ... ...</code>可知，最大<code>string</code>结构的key是<code>test</code>，最大list结构的key是<code>commentlist</code>。</p><p>需要注意的是，这个<strong>bigkeys得到的最大，不一定是最大</strong>。说明原因前，首先说明<code>bigkeys</code>的原理，非常简单，通过scan命令遍历，各种不同数据结构的key，分别通过不同的命令得到最大的key：</p><ul><li>如果是string结构，通过<code>strlen</code>判断；</li><li>如果是list结构，通过<code>llen</code>判断；</li><li>如果是hash结构，通过<code>hlen</code>判断；</li><li>如果是set结构，通过<code>scard</code>判断；</li><li>如果是sorted set结构，通过<code>zcard</code>判断。</li></ul><blockquote><p>正因为这样的判断方式，虽然string结构肯定可以正确的筛选出最占用缓存，也可以说最大的<code>key</code>。但是<code>list</code>不一定，例如，现在有两个<code>list</code>类型的<code>key</code>，分别是：<code>numberlist--[0,1,2]</code>，<code>stringlist--[&quot;123456789123456789&quot;]</code>，由于通过<code>llen</code>判断，所以<code>numberlist</code>要大于<code>stringlist</code>。而事实上<code>stringlist</code>更占用内存。其他三种数据结构<code>hash</code>，<code>set</code>，<code>sorted set都会存</code>在这个问题。使用<code>bigkeys</code>一定要注意这一点。</p></blockquote><h1 id="monitor"><a href="#monitor" class="headerlink" title="monitor"></a>monitor</h1><p>假设生产环境没有屏蔽<code>keys</code>等一些高危命令，并且<code>slowlog</code>中还不断有新的<code>keys</code>导致慢日志。那如何揪出这些命令是由谁执行的呢？这就是<code>monitor</code>的用处，用法如下：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">redis-cli -p 6380 monitor</span><br></pre></td></tr></table></figure><p>如果当前redis环境OPS比较高，那么建议结合linux管道命令优化，只输出keys命令的执行情况：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[afei@redis ~]# redis-cli -p 6380 monitor | grep keys </span><br><span class="line">1532645266.656525 [0 10.0.0.1:43544] &quot;keyss&quot; &quot;*&quot;</span><br><span class="line">1532645287.257657 [0 10.0.0.1:43544] &quot;keyss&quot; &quot;44*&quot;</span><br></pre></td></tr></table></figure><p>执行结果中很清楚的看到keys命名执行来源。通过输出的IP和端口信息，就能在目标服务器上找到执行这条命令的进程，揪出元凶，勒令整改。</p><h1 id="info"><a href="#info" class="headerlink" title="info"></a>info</h1><p>如果说哪个命令能最全面反映当前<code>redis</code>运行情况，那么非<code>info</code>莫属。用法如下：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">INFO [section]</span><br></pre></td></tr></table></figure><p><code>section</code>可选值有：</p><ul><li><strong>Server</strong>：运行的redis实例一些信息，包括：redis版本，操作系统信息，端口，GCC版本，配置文件路径等；</li><li><strong>Clients</strong>：redis客户端信息，包括：已连接客户端数量，阻塞客户端数量等；</li><li><strong>Memory</strong>：使用内存，峰值内存，内存碎片率，内存分配方式。这几个参数都非常重要；</li><li><strong>Persistence</strong>：AOF和RDB持久化信息；</li><li><strong>Stats</strong>：一些统计信息，最重要三个参数：OPS(<code>instantaneous_ops_per_sec</code>)，<code>keyspace_hits</code>和<code>keyspace_misses</code>两个参数反应缓存命中率；</li><li><strong>Replication</strong>：redis集群信息；</li><li><strong>CPU</strong>：CPU相关信息；</li><li><strong>Keyspace</strong>：redis中各个DB里key的信息；</li></ul><h1 id="config"><a href="#config" class="headerlink" title="config"></a>config</h1><p>config是一个非常有价值的命令，主要体现在对redis的运维。因为生产环境一般是不允许随意重启的，不能因为需要调优一些参数就修改<code>conf</code>配置文件并重启。<code>redis</code>作者早就想到了这一点，通过<code>config</code>命令能热修改一些配置，不需要重启redis实例，可以通过如下命令查看哪些参数可以热修改：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">config get *</span><br></pre></td></tr></table></figure><p>热修改就比较容易了，执行如下命令即可：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">config set </span><br></pre></td></tr></table></figure><p>例如：<code>config set slowlog-max-len 100</code>，<code>config set maxclients 1024</code></p><p>这样修改的话，如果以后由于某些原因<code>redis</code>实例故障需要重启，那通过<code>config</code>热修改的参数就会被配置文件中的参数覆盖，所以我们需要通过一个命令将<code>config</code>热修改的参数刷到<code>redis</code>配置文件中持久化，通过执行如下命令即可：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">config rewrite</span><br></pre></td></tr></table></figure><p>执行该命令后，我们能在<code>config</code>文件中看到类似这种信息：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 如果conf中本来就有这个参数，通过执行config <span class="built_in">set</span>，那么redis直接原地修改配置文件</span></span><br><span class="line">maxclients 1024</span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果conf中没有这个参数，通过执行config <span class="built_in">set</span>，那么redis会追加在Generated by CONFIG REWRITE字样后面</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Generated by CONFIG REWRITE</span></span><br><span class="line">save 600 60</span><br><span class="line">slowlog-max-len 100</span><br></pre></td></tr></table></figure><h1 id="set"><a href="#set" class="headerlink" title="set"></a>set</h1><p>官方文档介绍的用法如下：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">SET key value [EX seconds] [PX milliseconds] [NX|XX]</span><br></pre></td></tr></table></figure><p>你可能用的比较多的就是<code>set key value</code>，或者<code>SETEX key seconds value</code>，所以很多同学用<code>redis</code>实现分布式锁分为两步：首先执行<code>SETNX key value</code>，然后执行<code>EXPIRE key seconds</code>。很明显，这种实现有很严重的问题，因为两步执行不具备原子性，如果执行第一个命令后出现某些未知异常导致无法执行<code>EXPIRE key seconds</code>，那么分布式锁就会一直无法得到释放。</p><p>通过<code>SET</code>命令实现分布式锁的正式姿势应该是<code>SET key value EX seconds NX</code>（EX和PX任选，取决于对过期时间精度要求）。另外，value也有要求，最好是一个类似<code>UUID</code>这种具备唯一性的字符串。当然如果问你<code>redis</code>是否还有其他实现分布式锁的方案。你能说出<code>redlock</code>，那对方一定眼前一亮，心里对你竖起大拇指，但嘴上不会说。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li>阿飞的博客，公众号</li></ul>]]></content>
      
      
      <categories>
          
          <category> 笔记本 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> 指令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis配置认证密码</title>
      <link href="post/3508477588/"/>
      <url>post/3508477588/</url>
      
        <content type="html"><![CDATA[<h2 id="方法一，修改配置文件"><a href="#方法一，修改配置文件" class="headerlink" title="方法一，修改配置文件"></a>方法一，修改配置文件</h2><h3 id="修改redis-conf"><a href="#修改redis-conf" class="headerlink" title="修改redis.conf"></a>修改redis.conf</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vi redis.conf</span><br></pre></td></tr></table></figure><p>找到：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">requirepass myRedis</span><br></pre></td></tr></table></figure><p>将注释去掉，把<code>myRedis</code>换成你的密码。</p><h3 id="重启redis"><a href="#重启redis" class="headerlink" title="重启redis"></a>重启redis</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo service redis restart</span><br><span class="line"><span class="meta">#</span><span class="bash"> 或者</span></span><br><span class="line">sudo service redis stop</span><br><span class="line">sudo redis-server /etc/redis.conf</span><br></pre></td></tr></table></figure><h3 id="这个时候尝试登录redis，发现可以登上，但是执行具体命令是提示操作不允许"><a href="#这个时候尝试登录redis，发现可以登上，但是执行具体命令是提示操作不允许" class="headerlink" title="这个时候尝试登录redis，发现可以登上，但是执行具体命令是提示操作不允许"></a>这个时候尝试登录redis，发现可以登上，但是执行具体命令是提示操作不允许</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo redis-cli</span><br></pre></td></tr></table></figure><p><img src="https://github.com/cayzlh/git-img-repository/raw/master/blog/2018091302/1.png" alt="Redis配置认证密码"></p><h3 id="尝试用密码登录并执行具体的命令看到可以成功执行"><a href="#尝试用密码登录并执行具体的命令看到可以成功执行" class="headerlink" title="尝试用密码登录并执行具体的命令看到可以成功执行"></a>尝试用密码登录并执行具体的命令看到可以成功执行</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo redis-cli -a yourpasswd</span><br></pre></td></tr></table></figure><p><img src="https://github.com/cayzlh/git-img-repository/raw/master/blog/2018091302/2.png" alt="Redis配置认证密码"></p><h2 id="方法二，通过命令行进行配置"><a href="#方法二，通过命令行进行配置" class="headerlink" title="方法二，通过命令行进行配置"></a>方法二，通过命令行进行配置</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">redis 127.0.0.1:6379[1]&gt; config set requirepass my_redis</span><br><span class="line">OK</span><br><span class="line">redis 127.0.0.1:6379[1]&gt; config get requirepass</span><br><span class="line">1) &quot;requirepass&quot;</span><br><span class="line">2) &quot;my_redis&quot;</span><br></pre></td></tr></table></figure><p>无需重启redis , 使用修改后的密码登录redis，可以执行相应操作</p><blockquote><p>用这种方法修改密码，重启redis后，用新配置的密码登录redis执行操作，发现新的密码失效，redis重新使用了配置文件中的密码。</p></blockquote><p><em>除了在登录时通过 -a 参数制定密码外，还可以登录时不指定密码，而在执行操作前进行认证。</em></p><h2 id="master配置了密码，slave如何配置"><a href="#master配置了密码，slave如何配置" class="headerlink" title="master配置了密码，slave如何配置"></a>master配置了密码，slave如何配置</h2><p>若master配置了密码则slave也要配置相应的密码参数否则无法进行正常复制的。 slave中配置文件内找到如下行，移除注释，修改密码即可。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">masterauth  mstpassword</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记本 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Redis </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java集合框架</title>
      <link href="post/158677550/"/>
      <url>post/158677550/</url>
      
        <content type="html"><![CDATA[<h2 id="集合框架底层数据结构总结"><a href="#集合框架底层数据结构总结" class="headerlink" title="集合框架底层数据结构总结"></a>集合框架底层数据结构总结</h2><h3 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h3><h4 id="List"><a href="#List" class="headerlink" title="List"></a>List</h4><ul><li><strong>Arraylist：</strong> Object数组</li><li><strong>Vector：</strong> Object数组</li><li><strong>LinkedList：</strong> 双向循环链表</li></ul><h4 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h4><ul><li><strong>HashSet（无序，唯一）:</strong>  基于 HashMap 实现的，底层采用 HashMap 来保存元素</li><li><strong>LinkedHashSet：</strong> LinkedHashSet 继承与 HashSet，并且其内部是通过 LinkedHashMap 来实现的。有点类似于我们之前说的LinkedHashMap 其内部是基于 Hashmap 实现一样，不过还是有一点点区别的。</li><li><strong>TreeSet（有序，唯一）：</strong> 红黑树(自平衡的排序二叉树。)</li></ul><h4 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h4><ul><li><strong>HashMap：</strong> JDK1.8之前HashMap由数组+链表组成的，数组是HashMap的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）.JDK1.8以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间</li><li><strong>LinkedHashMap:</strong> LinkedHashMap 继承自 HashMap，所以它的底层仍然是基于拉链式散列结构即由数组和链表或红黑树组成。另外，LinkedHashMap 在上面结构的基础上，增加了一条双向链表，使得上面的结构可以保持键值对的插入顺序。同时通过对链表进行相应的操作，实现了访问顺序相关逻辑。</li><li><strong>HashTable:</strong> 数组+链表组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的</li><li><strong>TreeMap:</strong> 红黑树（自平衡的排序二叉树）</li></ul><h4 id="集合框架体系如图"><a href="#集合框架体系如图" class="headerlink" title="集合框架体系如图"></a>集合框架体系如图</h4><p><img src="https://github.com/cayzlh/git-img-repository/raw/master/blog/2018090501/3.png" alt="双向链表"></p><h2 id="集合接口"><a href="#集合接口" class="headerlink" title="集合接口"></a>集合接口</h2><blockquote><p>集合框架定义了一些接口。本节提供了每个接口的概述：</p></blockquote><table><thead><tr><th>序号</th><th>接口描述</th></tr></thead><tbody><tr><td>1</td><td>Collection 接口 Collection 是最基本的集合接口，一个 Collection 代表一组 Object，<br />即 Collection 的元素, Java不提供直接继承自Collection的类，<br />只提供继承于的子接口(如List和set)。Collection 接口存储一组不唯一，无序的对象。</td></tr><tr><td>2</td><td>List 接口 List接口是一个有序的 Collection<br />使用此接口能够精确的控制每个元素插入的位置，<br />能够通过索引(元素在List中位置，类似于数组的下标)来访问List中的元素，<br />第一个元素的索引为 0，而且允许有相同的元素。<br />List 接口存储一组不唯一，有序（插入顺序）的对象。</td></tr><tr><td>3</td><td>Set Set 具有与 Collection 完全一样的接口，<br />只是行为上不同，Set 不保存重复的元素。<br />Set 接口存储一组唯一，无序的对象。</td></tr><tr><td>4</td><td>SortedSet  继承于Set保存有序的集合。</td></tr><tr><td>5</td><td>Map Map 接口存储一组键值对象，提供key（键）到value（值）的映射。</td></tr><tr><td>6</td><td>Map.Entry  描述在一个Map中的一个元素（键/值对）。是一个Map的内部类。</td></tr><tr><td>7</td><td>SortedMap 继承于 Map，使 Key 保持在升序排列。</td></tr><tr><td>8</td><td>Enumeration 这是一个传统的接口和定义的方法，<br />通过它可以枚举（一次获得一个）对象集合中的元素。这个传统接口已被迭代器取代。</td></tr></tbody></table><h3 id="Set和List的区别"><a href="#Set和List的区别" class="headerlink" title="Set和List的区别"></a>Set和List的区别</h3><ul><li>Set 接口实例存储的是无序的，不重复的数据。List 接口实例存储的是有序的，可以重复的元素。</li><li>Set检索效率低下，删除和插入效率高，插入和删除不会引起元素位置改变 **&lt;实现类有HashSet,TreeSet&gt;**。</li><li>List和数组类似，可以动态增长，根据实际存储的数据的长度自动增长List的长度。查找元素效率高，插入删除效率低，因为会引起其他元素位置改变 <strong>&lt;实现类有ArrayList,LinkedList,Vector&gt;</strong> 。</li></ul><h2 id="集合实现类（集合类）"><a href="#集合实现类（集合类）" class="headerlink" title="集合实现类（集合类）"></a>集合实现类（集合类）</h2><blockquote><p>Java提供了一套实现了Collection接口的标准集合类。其中一些是具体类，这些类可以直接拿来使用，而另外一些是抽象类，提供了接口的部分实现。</p></blockquote><p>标准集合类汇总于下表：</p><table><thead><tr><th>序号</th><th>类描述</th></tr></thead><tbody><tr><td>1</td><td><strong>AbstractCollection</strong>  实现了大部分的集合接口。</td></tr><tr><td>2</td><td><strong>AbstractList</strong>  继承于AbstractCollection 并且实现了大部分List接口。</td></tr><tr><td>3</td><td><strong>AbstractSequentialList</strong>  继承于 AbstractList ，<br />提供了对数据元素的链式访问而不是随机访问。</td></tr><tr><td>4</td><td>LinkedList 该类实现了List接口，允许有null（空）元素。<br />主要用于创建链表数据结构，该类没有同步方法，如果多个线程同时访问一个List，<br />则必须自己实现访问同步，解决方法就是在创建List时候构造一个同步的List。<br />例如：<br /><code>Listlist=Collections.synchronizedList(newLinkedList(...));</code><br />LinkedList 查找效率低。</td></tr><tr><td>5</td><td>ArrayList 该类也是实现了List的接口.<br />实现了可变大小的数组，随机访问和遍历元素时，提供更好的性能。<br />该类也是非同步的,在多线程的情况下不要使用。ArrayList 增长当前长度的50%，插入删除效率低。</td></tr><tr><td>6</td><td><strong>AbstractSet</strong>  继承于AbstractCollection 并且实现了大部分Set接口。</td></tr><tr><td>7</td><td>HashSet 该类实现了Set接口，不允许出现重复元素，<br />不保证集合中元素的顺序，允许包含值为null的元素，但最多只能一个。</td></tr><tr><td>8</td><td>LinkedHashSet 具有可预知迭代顺序的 <code>Set</code> 接口的哈希表和链接列表实现。</td></tr><tr><td>9</td><td>TreeSet 该类实现了Set接口，可以实现排序等功能。</td></tr><tr><td>10</td><td><strong>AbstractMap</strong>  实现了大部分的Map接口。</td></tr><tr><td>11</td><td>HashMap  HashMap 是一个散列表，它存储的内容是键值对(key-value)映射。<br /> 该类实现了Map接口，根据键的HashCode值存储数据，<br />具有很快的访问速度，最多允许一条记录的键为null，不支持线程同步。</td></tr><tr><td>12</td><td>TreeMap  继承了AbstractMap，并且使用一颗树。</td></tr><tr><td>13</td><td>WeakHashMap  继承AbstractMap类，使用弱密钥的哈希表。</td></tr><tr><td>14</td><td>LinkedHashMap  继承于HashMap，使用元素的自然顺序对元素进行排序.</td></tr><tr><td>15</td><td>IdentityHashMap  继承AbstractMap类，比较文档时使用引用相等。</td></tr></tbody></table><p>通过java.util包中定义的类，如下所示：</p><table><thead><tr><th>序号</th><th>类描述</th></tr></thead><tbody><tr><td>1</td><td>Vector  该类和ArrayList非常相似，但是该类是同步的，<br />可以用在多线程的情况，该类允许设置默认的增长长度，默认扩容方式为原来的2倍。</td></tr><tr><td>2</td><td>Stack  栈是Vector的一个子类，它实现了一个标准的后进先出的栈。</td></tr><tr><td>3</td><td>Dictionary  Dictionary 类是一个抽象类，用来存储键/值对，作用和Map类相似。</td></tr><tr><td>4</td><td>Hashtable  Hashtable 是 Dictionary(字典) 类的子类，位于 java.util 包中。</td></tr><tr><td>5</td><td>Properties  Properties 继承于 Hashtable，表示一个持久的属性集，<br />属性列表中每个键及其对应值都是一个字符串。</td></tr><tr><td>6</td><td>BitSet 一个Bitset类创建一种特殊类型的数组来保存位值。BitSet中数组大小会随需要增加。</td></tr></tbody></table><h2 id="集合算法"><a href="#集合算法" class="headerlink" title="集合算法"></a>集合算法</h2><p>集合框架定义了几种算法，可用于集合和映射。这些算法被定义为集合类的静态方法。</p><p>在尝试比较不兼容的类型时，一些方法能够抛出 ClassCastException异常。当试图修改一个不可修改的集合时，抛出UnsupportedOperationException异常。</p><p>集合定义三个静态的变量：EMPTY_SET，EMPTY_LIST，EMPTY_MAP的。这些变量都不可改变。</p><table><thead><tr><th>序号</th><th>算法描述</th></tr></thead><tbody><tr><td>1</td><td>Collection Algorithms 这里是一个列表中的所有算法实现。</td></tr></tbody></table><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><blockquote><p>Java集合框架为程序员提供了预先包装的数据结构和算法来操纵他们。</p><p>集合是一个对象，可容纳其他对象的引用。集合接口声明对每一种类型的集合可以执行的操作。</p><p>集合框架的类和接口均在java.util包中。</p><p>任何对象加入集合类后，自动转变为Object类型，所以在取出的时候，需要进行强制类型转换。</p></blockquote><h2 id="Arraylist-与-LinkedList-异同"><a href="#Arraylist-与-LinkedList-异同" class="headerlink" title="Arraylist 与 LinkedList 异同"></a>Arraylist 与 LinkedList 异同</h2><p> <strong>1. 是否保证线程安全：</strong> ArrayList 和 LinkedList 都是不同步的，也就是不保证线程安全；</p><p><strong>2. 底层数据结构：</strong> Arraylist 底层使用的是Object数组；LinkedList 底层使用的是双向循环链表数据结构；</p><p><strong>3. 插入和删除是否受元素位置的影响：</strong> ① <strong>ArrayList 采用数组存储，所以插入和删除元素的时间复杂度受元素位置的影响。</strong> 比如：执行<code>add(E e)</code>方法的时候， ArrayList 会默认在将指定的元素追加到此列表的末尾，这种情况时间复杂度就是O(1)。但是如果要在指定位置 i 插入和删除元素的话（<code>add(int index, E element)</code>）时间复杂度就为 O(n-i)。因为在进行上述操作的时候集合中第 i 和第 i 个元素之后的(n-i)个元素都要执行向后位/向前移一位的操作。 ② <strong>LinkedList 采用链表存储，所以插入，删除元素时间复杂度不受元素位置的影响，都是近似 O（1）而数组为近似 O（n）。</strong></p><p><strong>4. 是否支持快速随机访问：</strong> LinkedList 不支持高效的随机元素访问，而ArrayList 实现了RandmoAccess 接口，所以有随机访问功能。快速随机访问就是通过元素的序号快速获取元素对象(对应于<code>get(int index)</code>方法)。</p><p><strong>5. 内存空间占用：</strong> ArrayList的空 间浪费主要体现在在list列表的结尾会预留一定的容量空间，而LinkedList的空间花费则体现在它的每一个元素都需要消耗比ArrayList更多的空间（因为要存放直接后继和直接前驱以及数据）。</p><blockquote><p><strong>数据结构基础之双向链表</strong>: </p><p>双向链表也叫双链表，是链表的一种，它的每个数据结点中都有两个指针，分别指向直接后继和直接前驱。所以，从双向链表中的任意一个结点开始，都可以很方便地访问它的前驱结点和后继结点。一般我们都构造双向循环链表，如下图所示，同时下图也是LinkedList 底层使用的是双向循环链表数据结构。</p><p><img src="https://github.com/cayzlh/git-img-repository/raw/master/blog/2018090501/1.png" alt="双向链表"></p></blockquote><h2 id="ArrayList-与-Vector-区别"><a href="#ArrayList-与-Vector-区别" class="headerlink" title="ArrayList 与 Vector 区别"></a>ArrayList 与 Vector 区别</h2><p>Vector类的所有方法都是同步的。可以由两个线程安全地访问一个Vector对象、但是一个线程访问Vector的话代码要在同步操作上耗费大量的时间。</p><p>Arraylist不是同步的，所以在不需要保证线程安全时时建议使用Arraylist。</p><h2 id="HashMap-和-Hashtable-的区别"><a href="#HashMap-和-Hashtable-的区别" class="headerlink" title="HashMap 和 Hashtable 的区别"></a>HashMap 和 Hashtable 的区别</h2><ol><li><strong>线程是否安全：</strong> HashMap 是非线程安全的，HashTable 是线程安全的；HashTable 内部的方法基本都经过  <code>synchronized</code>  修饰。（如果你要保证线程安全的话就使用 ConcurrentHashMap 吧！）；</li><li><strong>效率：</strong> 因为线程安全的问题，HashMap 要比 HashTable 效率高一点。另外，HashTable 基本被淘汰，不要在代码中使用它；</li><li><strong>对Null key 和Null value的支持：</strong> HashMap 中，null 可以作为键，这样的键只有一个，可以有一个或多个键所对应的值为 null。。但是在 HashTable 中 put 进的键值只要有一个 null，直接抛出 NullPointerException。</li><li><strong>初始容量大小和每次扩充容量大小的不同 ：</strong>   ①创建时如果不指定容量初始值，Hashtable 默认的初始大小为11，之后每次扩充，容量变为原来的2n+1。HashMap 默认的初始化大小为16。之后每次扩充，容量变为原来的2倍。②创建时如果给定了容量初始值，那么 Hashtable 会直接使用你给定的大小，而 HashMap 会将其扩充为2的幂次方大小。也就是说 HashMap 总是使用2的幂作为哈希表的大小,后面会介绍到为什么是2的幂次方。</li><li><strong>底层数据结构：</strong> JDK1.8 以后的 HashMap 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间。Hashtable 没有这样的机制。</li></ol><h2 id="HashSet-和-HashMap-区别"><a href="#HashSet-和-HashMap-区别" class="headerlink" title="HashSet 和 HashMap 区别"></a>HashSet 和 HashMap 区别</h2><p><img src="https://github.com/cayzlh/git-img-repository/raw/master/blog/2018090501/2.png" alt="HashSet 和 HashMap 区别"></p><h2 id="ConcurrentHashMap-和-Hashtable-的区别"><a href="#ConcurrentHashMap-和-Hashtable-的区别" class="headerlink" title="ConcurrentHashMap 和 Hashtable 的区别"></a>ConcurrentHashMap 和 Hashtable 的区别</h2><p>ConcurrentHashMap 和 Hashtable 的区别主要体现在实现线程安全的方式上不同。</p><ul><li><strong>底层数据结构：</strong> JDK1.7的 ConcurrentHashMap 底层采用 <strong>分段的数组+链表</strong> 实现，JDK1.8 采用的数据结构跟HashMap1.8的结构一样，数组+链表/红黑二叉树。Hashtable 和 JDK1.8 之前的 HashMap 的底层数据结构类似都是采用 <strong>数组+链表</strong> 的形式，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的；</li><li><strong>实现线程安全的方式（重要）：</strong> ① <strong>在JDK1.7的时候，ConcurrentHashMap（分段锁）</strong> 对整个桶数组进行了分割分段(Segment)，每一把锁只锁容器其中一部分数据，多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。（默认分配16个Segment，比Hashtable效率提高16倍。） <strong>到了 JDK1.8 的时候已经摒弃了Segment的概念，而是直接用 Node 数组+链表+红黑树的数据结构来实现，并发控制使用 synchronized 和 CAS 来操作。（JDK1.6以后 对 synchronized锁做了很多优化）</strong>  整个看起来就像是优化过且线程安全的 HashMap，虽然在JDK1.8中还能看到 Segment 的数据结构，但是已经简化了属性，只是为了兼容旧版本；② <strong>Hashtable(同一把锁)</strong> :使用 synchronized 来保证线程安全，效率非常低下。当一个线程访问同步方法时，其他线程也访问同步方法，可能会进入阻塞或轮询状态，如使用 put 添加元素，另一个线程不能使用 put 添加元素，也不能使用 get，竞争会越来越激烈效率越低。</li></ul><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><p><a href="https://juejin.im/post/5b7e955be51d4538de11550c">https://juejin.im/post/5b7e955be51d4538de11550c</a> </p></li><li><p><a href="http://www.runoob.com/java/java-tutorial.html">菜鸟教程</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 集合框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis基础知识总结</title>
      <link href="post/3447421152/"/>
      <url>post/3447421152/</url>
      
        <content type="html"><![CDATA[<h3 id="什么是redis"><a href="#什么是redis" class="headerlink" title="什么是redis?"></a>什么是redis?</h3><p>Redis 是一个基于内存的高性能key-value数据库。 </p><h3 id="Reids的特点"><a href="#Reids的特点" class="headerlink" title="Reids的特点"></a>Reids的特点</h3><p><code>Redis</code>本质上是一个<code>Key-Value</code>类型的内存数据库，很像<code>memcached</code>，整个数据库统统加载在内存当中进行操作，定期通过异步操作把数据库数据flush到硬盘上进行保存。</p><p>因为是纯内存操作，<code>Redis</code>的性能非常出色，每秒可以处理超过 10万次读写操作，是已知性能最快的<code>Key-Value DB</code>。</p><p>Redis的出色之处不仅仅是性能，Redis最大的魅力是支持保存多种数据结构，此外单个value的最大限制是1GB，不像 memcached只能保存1MB的数据，因此Redis可以用来实现很多有用的功能。</p><p>比方说用他的List来做FIFO双向链表，实现一个轻量级的高性 能消息队列服务，用他的Set可以做高性能的tag系统等等。另外Redis也可以对存入的Key-Value设置expire时间，因此也可以被当作一 个功能加强版的memcached来用。</p><p>Redis的主要缺点是数据库容量受到物理内存的限制，不能用作海量数据的高性能读写，因此Redis适合的场景主要局限在较小数据量的高性能操作和运算上。</p><h3 id="使用redis有哪些好处"><a href="#使用redis有哪些好处" class="headerlink" title="使用redis有哪些好处"></a>使用redis有哪些好处</h3><ol><li>速度快，因为数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1) </li><li>支持丰富数据类型，支持string，list，set，sorted set，hash </li><li>支持事务，操作都是原子性，所谓的原子性就是对数据的更改要么全部执行，要么全部不执行 </li><li>丰富的特性：可用于缓存，消息，按key设置过期时间，过期后将会自动删除</li></ol><h3 id="redis-支持哪些数据结构"><a href="#redis-支持哪些数据结构" class="headerlink" title="redis 支持哪些数据结构"></a>redis 支持哪些数据结构</h3><p>支持多种类型的数据结构，如字符串（String），散列（Hash），列表（List），集合（Set），有序集合（Sorted Set或者是ZSet）与范围查询，Bitmaps，Hyperloglogs 和地理空间（Geospatial）索引半径查询。其中常见的数据结构类型有：String、List、Set、Hash、ZSet这5种。</p><h4 id="Java中对Redis数据类型的操作"><a href="#Java中对Redis数据类型的操作" class="headerlink" title="Java中对Redis数据类型的操作"></a>Java中对Redis数据类型的操作</h4><h5 id="String"><a href="#String" class="headerlink" title="String"></a>String</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span>  Jedis jedis = JedisPoolUtil.getJedis();</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="comment">//添加和获取</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span>&#123;</span><br><span class="line">        jedis.set(<span class="string">&quot;num&quot;</span>,<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        System.out.println(jedis.get(<span class="string">&quot;num&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="comment">//删除值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        jedis.del(<span class="string">&quot;num&quot;</span>);</span><br><span class="line">        System.out.println(jedis.get(<span class="string">&quot;num&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="comment">//自减和自减</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        jedis.set(<span class="string">&quot;num&quot;</span>,<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        System.out.println(jedis.get(<span class="string">&quot;num&quot;</span>));</span><br><span class="line">        jedis.decr(<span class="string">&quot;num&quot;</span>);</span><br><span class="line">        System.out.println(jedis.get(<span class="string">&quot;num&quot;</span>));</span><br><span class="line">        jedis.incr(<span class="string">&quot;num&quot;</span>);</span><br><span class="line">        jedis.incr(<span class="string">&quot;num&quot;</span>);</span><br><span class="line">        System.out.println(jedis.get(<span class="string">&quot;num&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="comment">//加上/减去 一个数</span></span><br><span class="line">    <span class="comment">//incrBy 返回的是修改之后的值如果原值是字符串不是数字，则会抛出异常</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun3</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Long num = jedis.incrBy(<span class="string">&quot;num&quot;</span>, <span class="number">3</span>);</span><br><span class="line">        System.out.println(num);</span><br><span class="line">        jedis.decrBy(<span class="string">&quot;num&quot;</span>,<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(jedis.get(<span class="string">&quot;num&quot;</span>));</span><br><span class="line">        jedis.set(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;caopengfei&quot;</span>);</span><br><span class="line">        <span class="comment">//jedis.decrBy(&quot;name&quot;,1);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="comment">//字符串拼接</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun4</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Long len = jedis.append(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;123&quot;</span>);</span><br><span class="line">        System.out.println(len);</span><br><span class="line">        System.out.println(jedis.get(<span class="string">&quot;name&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> Jedis jedis = JedisPoolUtil.getJedis();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//    hash 操作的是map对象</span></span><br><span class="line"><span class="comment">//    适合存储键值对象的信息</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="comment">//存值 参数第一个变量的名称， map键名(key)， map键值(value)</span></span><br><span class="line"><span class="comment">//    调用hset</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Long num = jedis.hset(<span class="string">&quot;hash1&quot;</span>, <span class="string">&quot;username&quot;</span>, <span class="string">&quot;caopengfei&quot;</span>);</span><br><span class="line">        System.out.println(num);</span><br><span class="line">        String hget = jedis.hget(<span class="string">&quot;hash1&quot;</span>, <span class="string">&quot;username&quot;</span>);</span><br><span class="line">        System.out.println(hget);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="comment">//也可以存多个key</span></span><br><span class="line"><span class="comment">//    调用hmset</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;username&quot;</span>, <span class="string">&quot;caopengfei&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;age&quot;</span>, <span class="string">&quot;25&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;sex&quot;</span>, <span class="string">&quot;男&quot;</span>);</span><br><span class="line">        String res = jedis.hmset(<span class="string">&quot;hash2&quot;</span>, map);</span><br><span class="line">        System.out.println(res);<span class="comment">//ok</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="comment">//获取hash中所有的值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Map&lt;String, String&gt; map2 = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">        map2 = jedis.hgetAll(<span class="string">&quot;hash2&quot;</span>);</span><br><span class="line">        System.out.println(map2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line"><span class="comment">//    删除hash中的键 可以删除一个也可以删除多个，返回的是删除的个数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Long num = jedis.hdel(<span class="string">&quot;hash2&quot;</span>, <span class="string">&quot;username&quot;</span>, <span class="string">&quot;age&quot;</span>);</span><br><span class="line">        System.out.println(num);</span><br><span class="line">        Map&lt;String, String&gt; map2 = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">        map2 = jedis.hgetAll(<span class="string">&quot;hash2&quot;</span>);</span><br><span class="line">        System.out.println(map2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="comment">//增加hash中的键值对</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Map&lt;String, String&gt; map2 = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">        map2 = jedis.hgetAll(<span class="string">&quot;hash2&quot;</span>);</span><br><span class="line">        System.out.println(map2);</span><br><span class="line">        jedis.hincrBy(<span class="string">&quot;hash2&quot;</span>, <span class="string">&quot;age&quot;</span>, <span class="number">10</span>);</span><br><span class="line">        map2 = jedis.hgetAll(<span class="string">&quot;hash2&quot;</span>);</span><br><span class="line">        System.out.println(map2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="comment">//判断hash是否存在某个值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun5</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(jedis.hexists(<span class="string">&quot;hash2&quot;</span>, <span class="string">&quot;username&quot;</span>));</span><br><span class="line">        System.out.println(jedis.hexists(<span class="string">&quot;hash2&quot;</span>, <span class="string">&quot;age&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="comment">//获取hash中键值对的个数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun6</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(jedis.hlen(<span class="string">&quot;hash2&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//    获取一个hash中所有的key值</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun7</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Set&lt;String&gt; hash2 = jedis.hkeys(<span class="string">&quot;hash2&quot;</span>);</span><br><span class="line">        System.out.println(hash2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//    获取所有的value值</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun8</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; hash2 = jedis.hvals(<span class="string">&quot;hash2&quot;</span>);</span><br><span class="line">        System.out.println(hash2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="List操作"><a href="#List操作" class="headerlink" title="List操作"></a>List操作</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testList</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    jedis.flushDB();</span><br><span class="line">    System.out.println(<span class="string">&quot;===========添加一个list===========&quot;</span>);</span><br><span class="line">    jedis.lpush(<span class="string">&quot;collections&quot;</span>, <span class="string">&quot;ArrayList&quot;</span>, <span class="string">&quot;Vector&quot;</span>, <span class="string">&quot;Stack&quot;</span>, <span class="string">&quot;HashMap&quot;</span>, <span class="string">&quot;WeakHashMap&quot;</span>, <span class="string">&quot;LinkedHashMap&quot;</span>);</span><br><span class="line">    jedis.lpush(<span class="string">&quot;collections&quot;</span>, <span class="string">&quot;HashSet&quot;</span>);</span><br><span class="line">    jedis.lpush(<span class="string">&quot;collections&quot;</span>, <span class="string">&quot;TreeSet&quot;</span>);</span><br><span class="line">    jedis.lpush(<span class="string">&quot;collections&quot;</span>, <span class="string">&quot;TreeMap&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;collections的内容：&quot;</span>+jedis.lrange(<span class="string">&quot;collections&quot;</span>, <span class="number">0</span>, -<span class="number">1</span>));<span class="comment">//-1代表倒数第一个元素，-2代表倒数第二个元素</span></span><br><span class="line">    System.out.println(<span class="string">&quot;collections区间0-3的元素：&quot;</span>+jedis.lrange(<span class="string">&quot;collections&quot;</span>,<span class="number">0</span>,<span class="number">3</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;===============================&quot;</span>);</span><br><span class="line">    <span class="comment">// 删除列表指定的值 ，第二个参数为删除的个数（有重复时），后add进去的值先被删，类似于出栈</span></span><br><span class="line">    System.out.println(<span class="string">&quot;删除指定元素个数：&quot;</span>+jedis.lrem(<span class="string">&quot;collections&quot;</span>, <span class="number">2</span>, <span class="string">&quot;HashMap&quot;</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;collections的内容：&quot;</span>+jedis.lrange(<span class="string">&quot;collections&quot;</span>, <span class="number">0</span>, -<span class="number">1</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;删除下表0-3区间之外的元素：&quot;</span>+jedis.ltrim(<span class="string">&quot;collections&quot;</span>, <span class="number">0</span>, <span class="number">3</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;collections的内容：&quot;</span>+jedis.lrange(<span class="string">&quot;collections&quot;</span>, <span class="number">0</span>, -<span class="number">1</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;collections列表出栈（左端）：&quot;</span>+jedis.lpop(<span class="string">&quot;collections&quot;</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;collections的内容：&quot;</span>+jedis.lrange(<span class="string">&quot;collections&quot;</span>, <span class="number">0</span>, -<span class="number">1</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;collections添加元素，从列表右端，与lpush相对应：&quot;</span>+jedis.rpush(<span class="string">&quot;collections&quot;</span>, <span class="string">&quot;EnumMap&quot;</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;collections的内容：&quot;</span>+jedis.lrange(<span class="string">&quot;collections&quot;</span>, <span class="number">0</span>, -<span class="number">1</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;collections列表出栈（右端）：&quot;</span>+jedis.rpop(<span class="string">&quot;collections&quot;</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;collections的内容：&quot;</span>+jedis.lrange(<span class="string">&quot;collections&quot;</span>, <span class="number">0</span>, -<span class="number">1</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;修改collections指定下标1的内容：&quot;</span>+jedis.lset(<span class="string">&quot;collections&quot;</span>, <span class="number">1</span>, <span class="string">&quot;LinkedArrayList&quot;</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;collections的内容：&quot;</span>+jedis.lrange(<span class="string">&quot;collections&quot;</span>, <span class="number">0</span>, -<span class="number">1</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;===============================&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;collections的长度：&quot;</span>+jedis.llen(<span class="string">&quot;collections&quot;</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;获取collections下标为2的元素：&quot;</span>+jedis.lindex(<span class="string">&quot;collections&quot;</span>, <span class="number">2</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;===============================&quot;</span>);</span><br><span class="line">    jedis.lpush(<span class="string">&quot;sortedList&quot;</span>, <span class="string">&quot;3&quot;</span>,<span class="string">&quot;6&quot;</span>,<span class="string">&quot;2&quot;</span>,<span class="string">&quot;0&quot;</span>,<span class="string">&quot;7&quot;</span>,<span class="string">&quot;4&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;sortedList排序前：&quot;</span>+jedis.lrange(<span class="string">&quot;sortedList&quot;</span>, <span class="number">0</span>, -<span class="number">1</span>));</span><br><span class="line">    System.out.println(jedis.sort(<span class="string">&quot;sortedList&quot;</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;sortedList排序后：&quot;</span>+jedis.lrange(<span class="string">&quot;sortedList&quot;</span>, <span class="number">0</span>, -<span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Set操作"><a href="#Set操作" class="headerlink" title="Set操作"></a>Set操作</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* Set集合，和List类的区别就是</span></span><br><span class="line"><span class="comment">* set中不会出现重复的数据</span></span><br><span class="line"><span class="comment">* 他可以进行聚合操作效率比较高</span></span><br><span class="line"><span class="comment">* 其余的操作基本上和list相同</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SetTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span>  Jedis jedis = JedisPoolUtil.getJedis();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="comment">/*添加元素删除元素*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Long num = jedis.sadd(<span class="string">&quot;myset&quot;</span>, <span class="string">&quot;a&quot;</span>, <span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>,<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">        System.out.println(num);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="comment">/*获得元素*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Set&lt;String&gt; myset = jedis.smembers(<span class="string">&quot;myset&quot;</span>);</span><br><span class="line">        System.out.println(myset);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="comment">/*移除元素*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        jedis.srem(<span class="string">&quot;myset&quot;</span>,<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        Set&lt;String&gt; myset = jedis.smembers(<span class="string">&quot;myset&quot;</span>);</span><br><span class="line">        System.out.println(myset);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="comment">//判断是否这个set中存在某个值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun3</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Boolean sismember = jedis.sismember(<span class="string">&quot;myset&quot;</span>, <span class="string">&quot;a&quot;</span>);</span><br><span class="line">        System.out.println(sismember);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="comment">//获得A-B 获得差集合</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun4</span><span class="params">()</span></span>&#123;</span><br><span class="line">        jedis.sadd(<span class="string">&quot;myset1&quot;</span>,<span class="string">&quot;123&quot;</span>,<span class="string">&quot;32&quot;</span>,<span class="string">&quot;abc&quot;</span>,<span class="string">&quot;def&quot;</span>,<span class="string">&quot;123456&quot;</span>,<span class="string">&quot;sdfasd&quot;</span>);</span><br><span class="line">        jedis.sadd(<span class="string">&quot;myset2&quot;</span>,<span class="string">&quot;abc&quot;</span>,<span class="string">&quot;345&quot;</span>,<span class="string">&quot;123&quot;</span>,<span class="string">&quot;fda&quot;</span>);</span><br><span class="line">        Set&lt;String&gt; sdiff = jedis.sdiff(<span class="string">&quot;myset1&quot;</span>, <span class="string">&quot;myset2&quot;</span>);</span><br><span class="line">        System.out.println(sdiff);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="comment">//获得交集</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun5</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Set&lt;String&gt; sinter = jedis.sinter(<span class="string">&quot;myset1&quot;</span>, <span class="string">&quot;myset2&quot;</span>);</span><br><span class="line">        System.out.println(sinter);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line"><span class="comment">//    获得并集合</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun6</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Set&lt;String&gt; sunion = jedis.sunion(<span class="string">&quot;myset1&quot;</span>, <span class="string">&quot;myset2&quot;</span>);</span><br><span class="line">        System.out.println(sunion);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line"><span class="comment">//    成员数量</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun7</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(jedis.scard(<span class="string">&quot;myset1&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line"><span class="comment">//    获得随机的一个成员</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun8</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(jedis.srandmember(<span class="string">&quot;myset1&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line"><span class="comment">//    将相差的成员放到一个新的set中同理交集和并集都可以后面均</span></span><br><span class="line"><span class="comment">//    加上一个store即可</span></span><br><span class="line"><span class="comment">//    并返回新的长度</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun9</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(jedis.sdiffstore(<span class="string">&quot;myset3&quot;</span>,<span class="string">&quot;myset1&quot;</span>,<span class="string">&quot;myset2&quot;</span>));</span><br><span class="line">        System.out.println(jedis.smembers(<span class="string">&quot;myset3&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="SortedSet-操作"><a href="#SortedSet-操作" class="headerlink" title="SortedSet 操作"></a>SortedSet 操作</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">和set极为的类似，他们是字符串的集合，没有重复的数据</span></span><br><span class="line"><span class="comment">差别是sortedset每个成员中都会有一个分数（score）与之关联</span></span><br><span class="line"><span class="comment">，redis正是通过分数来为集合中的成员进行从小到大的排序</span></span><br><span class="line"><span class="comment">sortedset中数据必须单一但是他的score可以是重复的</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SortedsetTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span>  Jedis jedis = JedisPoolUtil.getJedis();</span><br><span class="line"><span class="comment">//    添加元素</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span>&#123;</span><br><span class="line">        jedis.zadd(<span class="string">&quot;mysort&quot;</span>,<span class="number">100.0</span>, <span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line">        jedis.zadd(<span class="string">&quot;mysort&quot;</span>,<span class="number">200.0</span>,<span class="string">&quot;lisi&quot;</span>);</span><br><span class="line">        jedis.zadd(<span class="string">&quot;mysort&quot;</span>,<span class="number">50.0</span>,<span class="string">&quot;wangwu&quot;</span>);</span><br><span class="line">        Map&lt;String ,Double&gt;map = <span class="keyword">new</span> HashMap&lt;String ,Double&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;mutouliu&quot;</span>,<span class="number">70.0</span>);</span><br><span class="line"></span><br><span class="line">        jedis.zadd(<span class="string">&quot;mysort&quot;</span>,map);</span><br><span class="line">        Set&lt;String&gt; mysort = jedis.zrange(<span class="string">&quot;mysort&quot;</span>, <span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line">        System.out.println(mysort);</span><br><span class="line">        Set&lt;String&gt; mysort1 = jedis.zrange(<span class="string">&quot;mysort&quot;</span>, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">        System.out.println(mysort1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h3 id="redis相比memcached有哪些优势"><a href="#redis相比memcached有哪些优势" class="headerlink" title="redis相比memcached有哪些优势"></a>redis相比memcached有哪些优势</h3><ol><li>memcached所有的值均是简单的字符串，redis作为其替代者，支持更为丰富的数据类型 </li><li>redis的速度比memcached快很多</li><li>redis可以持久化其数据</li></ol><h3 id="Memcache与Redis的区别都有哪些"><a href="#Memcache与Redis的区别都有哪些" class="headerlink" title="Memcache与Redis的区别都有哪些"></a>Memcache与Redis的区别都有哪些</h3><ol><li>存储方式 Memecache把数据全部存在内存之中，断电后会挂掉，数据不能超过内存大小。 Redis有部份存在硬盘上，这样能保证数据的持久性。 </li><li>数据支持类型 Memcache对数据类型支持相对简单。 Redis有复杂的数据类型。 </li><li>使用底层模型不同 它们之间底层实现方式 以及与客户端之间通信的应用协议不一样。 Redis直接自己构建了VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求。 </li></ol><h3 id="redis常见性能问题和解决方案"><a href="#redis常见性能问题和解决方案" class="headerlink" title="redis常见性能问题和解决方案:"></a>redis常见性能问题和解决方案:</h3><ol><li>Master写内存快照，save命令调度rdbSave函数，会阻塞主线程的工作，当快照比较大时对性能影响是非常大的，会间断性暂停服务，所以Master最好不要写内存快照。</li><li>Master AOF持久化，如果不重写AOF文件，这个持久化方式对性能的影响是最小的，但是AOF文件会不断增大，AOF文件过大会影响Master重启的恢复速度。Master最好不要做任何持久化工作，包括内存快照和AOF日志文件，特别是不要启用内存快照做持久化,如果数据比较关键，某个Slave开启AOF备份数据，策略为每秒同步一次。</li><li>Master调用BGREWRITEAOF重写AOF文件，AOF在重写的时候会占大量的CPU和内存资源，导致服务load过高，出现短暂服务暂停现象。</li><li>Redis主从复制的性能问题，为了主从复制的速度和连接的稳定性，Slave和Master最好在同一个局域网内</li></ol><h3 id="mySQL里有2000w数据，redis中只存20w的数据，如何保证redis中的数据都是热点数据"><a href="#mySQL里有2000w数据，redis中只存20w的数据，如何保证redis中的数据都是热点数据" class="headerlink" title="mySQL里有2000w数据，redis中只存20w的数据，如何保证redis中的数据都是热点数据"></a>mySQL里有2000w数据，redis中只存20w的数据，如何保证redis中的数据都是热点数据</h3><blockquote><p><em>redis 内存数据集大小上升到一定大小的时候，就会施行数据淘汰策略（回收策略）。</em></p></blockquote><p><strong>redis 提供 6种数据淘汰策略：</strong></p><ol><li>volatile-lru：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰</li><li>volatile-ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰</li><li>volatile-random：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰</li><li>allkeys-lru：从数据集（server.db[i].dict）中挑选最近最少使用的数据淘汰</li><li>allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰</li><li>no-enviction（驱逐）：禁止驱逐数据</li></ol><h3 id="为什么redis需要把所有数据放到内存中"><a href="#为什么redis需要把所有数据放到内存中" class="headerlink" title="为什么redis需要把所有数据放到内存中"></a>为什么redis需要把所有数据放到内存中</h3><p>Redis为了达到最快的读写速度将数据都读到内存中，并通过异步的方式将数据写入磁盘。所以redis具有快速和数据持久化的特征。如果不将数据放在内存中，磁盘I/O速度为严重影响redis的性能。在内存越来越便宜的今天，redis将会越来越受欢迎。</p><p><strong>如果设置了最大使用的内存，则数据已有记录数达到内存限值后不能继续插入新值。</strong></p><h3 id="Redis是单进程单线程的"><a href="#Redis是单进程单线程的" class="headerlink" title="Redis是单进程单线程的"></a>Redis是单进程单线程的</h3><p>redis利用队列技术将并发访问变为串行访问，消除了传统数据库串行控制的开销</p><h3 id="redis的并发竞争问题如何解决"><a href="#redis的并发竞争问题如何解决" class="headerlink" title="redis的并发竞争问题如何解决"></a>redis的并发竞争问题如何解决</h3><p>Redis为单进程单线程模式，采用队列模式将并发访问变为串行访问。Redis本身没有锁的概念，Redis对于多个客户端连接并不存在竞争，但是在Jedis客户端对Redis进行并发访问时会发生连接超时、数据转换错误、阻塞、客户端关闭连接等问题，这些问题均是由于客户端连接混乱造成。</p><p><strong>对此有2种解决方法：</strong></p><p>1.客户端角度，为保证每个客户端间正常有序与Redis进行通信，对连接进行池化，同时对客户端读写Redis操作采用内部锁synchronized。</p><p>2.服务器角度，利用setnx实现锁。</p><blockquote><p> <em>注：对于第一种，需要应用程序自己处理资源的同步，可以使用的方法比较通俗，可以使用synchronized也可以使用lock；第二种需要用到Redis的setnx命令，但是需要注意一些问题。</em></p></blockquote><h3 id="redis持久化的几种方式"><a href="#redis持久化的几种方式" class="headerlink" title="redis持久化的几种方式"></a>redis持久化的几种方式</h3><h4 id="快照（snapshots）"><a href="#快照（snapshots）" class="headerlink" title="快照（snapshots）"></a><strong>快照（snapshots）</strong></h4><p>缺省情况情况下，Redis把数据快照存放在磁盘上的二进制文件中，文件名为dump.rdb。你可以配置Redis的持久化策略，例如数据集中每N秒钟有超过M次更新，就将数据写入磁盘；或者你可以手工调用命令SAVE或BGSAVE。</p><p><strong>工作原理</strong></p><ul><li>Redis forks.</li><li>子进程开始将数据写到临时RDB文件中。</li><li>当子进程完成写RDB文件，用新文件替换老文件。</li><li>这种方式可以使Redis使用copy-on-write技术。</li></ul><h4 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a><strong>AOF</strong></h4><p>快照模式并不十分健壮，当系统停止，或者无意中Redis被kill掉，最后写入Redis的数据就会丢失。</p><p>这对某些应用也许不是大问题，但对于要求高可靠性的应用来说，Redis就不是一个合适的选择。Append-only文件模式是另一种选择。你可以在配置文件中打开AOF模式</p><h4 id="虚拟内存方式"><a href="#虚拟内存方式" class="headerlink" title="虚拟内存方式"></a><strong>虚拟内存方式</strong></h4><p>当你的key很小而value很大时,使用VM的效果会比较好.因为这样节约的内存比较大.</p><p>当你的key不小时,可以考虑使用一些非常方法将很大的key变成很大的value,比如你可以考虑将key,value组合成一个新的value.</p><p>vm-max-threads这个参数,可以设置访问swap文件的线程数,设置最好不要超过机器的核数,如果设置为0,那么所有对swap文件的操作都是串行的.可能会造成比较长时间的延迟,但是对数据完整性有很好的保证.</p><p>自己测试的时候发现用虚拟内存性能也不错。如果数据量很大，可以考虑分布式或者其他数据库。</p><h3 id="redis的缓存失效策略和主键失效机制"><a href="#redis的缓存失效策略和主键失效机制" class="headerlink" title="redis的缓存失效策略和主键失效机制"></a><strong>redis的缓存失效策略和主键失效机制</strong></h3><p>作为缓存系统都要定期清理无效数据，就需要一个主键失效和淘汰策略.</p><p>在Redis当中，有生存期的key被称为volatile。在创建缓存时，要为给定的key设置生存期，当key过期的时候（生存期为0），它可能会被删除。</p><h4 id="1、影响生存时间的一些操作"><a href="#1、影响生存时间的一些操作" class="headerlink" title="1、影响生存时间的一些操作"></a><strong>1、影响生存时间的一些操作</strong></h4><p>生存时间可以通过使用 DEL 命令来删除整个 key 来移除，或者被 SET 和 GETSET 命令覆盖原来的数据，也就是说，修改key对应的value和使用另外相同的key和value来覆盖以后，当前数据的生存时间不同。</p><p>比如说，对一个 key 执行INCR命令，对一个列表进行LPUSH命令，或者对一个哈希表执行HSET命令，这类操作都不会修改 key 本身的生存时间。另一方面，如果使用RENAME对一个 key 进行改名，那么改名后的 key的生存时间和改名前一样。</p><p>RENAME命令的另一种可能是，尝试将一个带生存时间的 key 改名成另一个带生存时间的 another_key ，这时旧的 another_key (以及它的生存时间)会被删除，然后旧的 key 会改名为 another_key ，因此，新的 another_key 的生存时间也和原本的 key 一样。使用PERSIST命令可以在不删除 key 的情况下，移除 key 的生存时间，让 key 重新成为一个persistent key 。</p><h4 id="如何更新生存时间"><a href="#如何更新生存时间" class="headerlink" title="如何更新生存时间"></a><strong>如何更新生存时间</strong></h4><p>可以对一个已经带有生存时间的 key 执行EXPIRE命令，新指定的生存时间会取代旧的生存时间。过期时间的精度已经被控制在1ms之内，主键失效的时间复杂度是O（1），EXPIRE和TTL命令搭配使用，TTL可以查看key的当前生存时间。设置成功返回 1；当 key 不存在或者不能为 key 设置生存时间时，返回 0 。</p><h4 id="最大缓存配置："><a href="#最大缓存配置：" class="headerlink" title="最大缓存配置："></a><strong>最大缓存配置：</strong></h4><p>在 redis 中，允许用户设置最大使用内存大小，server.maxmemory默认为0，没有指定最大缓存，如果有新的数据添加，超过最大内存，则会使redis崩溃，所以一定要设置。redis 内存数据集大小上升到一定大小的时候，就会实行数据淘汰策略。</p><p><strong>redis 提供 6种数据淘汰策略：</strong></p><ol><li>volatile-lru：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰</li><li>volatile-ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰</li><li> volatile-random：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰</li><li>allkeys-lru：从数据集（server.db[i].dict）中挑选最近最少使用的数据淘汰</li><li>allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰</li><li>no-enviction（驱逐）：禁止驱逐数据</li></ol><p>注意这里的6种机制，volatile和allkeys规定了是对已设置过期时间的数据集淘汰数据还是从全部数据集淘汰数据，后面的lru、ttl以及random是三种不同的淘汰策略，再加上一种no-enviction永不回收的策略。</p><p><strong>使用策略规则：</strong></p><ol><li>如果数据呈现幂律分布，也就是一部分数据访问频率高，一部分数据访问频率低，则使用allkeys-lru</li><li>如果数据呈现平等分布，也就是所有的数据访问频率都相同，则使用allkeys-random</li></ol><h4 id="三种数据淘汰策略："><a href="#三种数据淘汰策略：" class="headerlink" title="三种数据淘汰策略："></a><strong>三种数据淘汰策略：</strong></h4><p>ttl和random比较容易理解，实现也会比较简单。主要是Lru最近最少使用淘汰策略，设计上会对key 按失效时间排序，然后取最先失效的key进行淘汰</p><h3 id="redis-适合的场景"><a href="#redis-适合的场景" class="headerlink" title="redis 适合的场景"></a><strong>redis 适合的场景</strong></h3><p>Redis最适合所有数据in-momory的场景，虽然Redis也提供持久化功能，但实际更多的是一个disk-backed的功能，跟传统意义上的持久化有比较大的差别，那么可能大家就会有疑问，似乎Redis更像一个加强版的Memcached，那么何时使用Memcached，何时使用Redis呢?</p><p>如果简单地比较Redis与Memcached的区别，大多数都会得到以下观点：</p><ol><li>Redis不仅仅支持简单的k/v类型的数据，同时还提供list，set，zset，hash等数据结构的存储。</li><li>Redis支持数据的备份，即master-slave模式的数据备份。</li><li>Redis支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用。</li></ol><h4 id="会话缓存（Session-Cache）"><a href="#会话缓存（Session-Cache）" class="headerlink" title="会话缓存（Session Cache）"></a><strong>会话缓存（Session Cache）</strong></h4><p>最常用的一种使用Redis的情景是会话缓存（session cache）。用Redis缓存会话比其他存储（如Memcached）的优势在于：Redis提供持久化。当维护一个不是严格要求一致性的缓存时，如果用户的购物车信息全部丢失，大部分人都会不高兴的，现在，他们还会这样吗？</p><p>幸运的是，随着 Redis 这些年的改进，很容易找到怎么恰当的使用Redis来缓存会话的文档。甚至广为人知的商业平台Magento也提供Redis的插件。</p><h4 id="全页缓存（FPC）"><a href="#全页缓存（FPC）" class="headerlink" title="全页缓存（FPC）"></a><strong>全页缓存（FPC）</strong></h4><p>除基本的会话token之外，Redis还提供很简便的FPC平台。回到一致性问题，即使重启了Redis实例，因为有磁盘的持久化，用户也不会看到页面加载速度的下降，这是一个极大改进，类似PHP本地FPC。</p><p>再次以Magento为例，Magento提供一个插件来使用Redis作为全页缓存后端。</p><p>此外，对WordPress的用户来说，Pantheon有一个非常好的插件 wp-redis，这个插件能帮助你以最快速度加载你曾浏览过的页面。</p><h4 id="队列"><a href="#队列" class="headerlink" title="队列"></a><strong>队列</strong></h4><p>Reids在内存存储引擎领域的一大优点是提供 list 和 set 操作，这使得Redis能作为一个很好的消息队列平台来使用。Redis作为队列使用的操作，就类似于本地程序语言（如Python）对 list 的 push/pop 操作。</p><p>如果你快速的在Google中搜索“Redis queues”，你马上就能找到大量的开源项目，这些项目的目的就是利用Redis创建非常好的后端工具，以满足各种队列需求。例如，Celery有一个后台就是使用Redis作为broker，你可以从这里去查看。</p><h4 id="排行榜-计数器"><a href="#排行榜-计数器" class="headerlink" title="排行榜/计数器"></a><strong>排行榜/计数器</strong></h4><p>Redis在内存中对数字进行递增或递减的操作实现的非常好。集合（Set）和有序集合（Sorted Set）也使得我们在执行这些操作的时候变的非常简单，Redis只是正好提供了这两种数据结构。</p><p>所以，我们要从排序集合中获取到排名最靠前的10个用户–我们称之为“user_scores”，我们只需要像下面一样执行即可：</p><p>当然，这是假定你是根据你用户的分数做递增的排序。如果你想返回用户及用户的分数，你需要这样执行：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ZRANGE user_scores 0 10 WITHSCORES</span><br></pre></td></tr></table></figure><p>Agora Games就是一个很好的例子，用Ruby实现的，它的排行榜就是使用Redis来存储数据的，你可以在这里看到。</p><h4 id="发布-订阅"><a href="#发布-订阅" class="headerlink" title="发布/订阅"></a><strong>发布/订阅</strong></h4><p>最后（但肯定不是最不重要的）是Redis的发布/订阅功能。发布/订阅的使用场景确实非常多。我已看见人们在社交网络连接中使用，还可作为基于发布/订阅的脚本触发器，甚至用Redis的发布/订阅功能来建立聊天系统！</p><p>Redis提供的所有特性中，我感觉这个是喜欢的人最少的一个，虽然它为用户提供如果此多功能。</p><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ul><li><a href="https://juejin.im/entry/5b7cfe976fb9a01a13366d95?utm_source=gold_browser_extension">https://juejin.im/entry/5b7cfe976fb9a01a13366d95?utm_source=gold_browser_extension</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzI4Njc5NjM1NQ==&mid=2247486252&idx=1&sn=d72ee144765b3b16964dc4ce0f54ccd7&chksm=ebd63400dca1bd16fada25e175c052fc7528f85750d2e0c4bfd9bd561c8aa49fe019f32c21ae&mpshare=1&scene=24&srcid=09020vky9fT4UYZG8JpeePdz#rd">Redis的那些最常见面试问题</a></li><li><a href="https://www.cnblogs.com/whcwkw1314/p/8922031.html">java中Redis5大基本类型的用法</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 笔记本 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring事务管理</title>
      <link href="post/762945f0/"/>
      <url>post/762945f0/</url>
      
        <content type="html"><![CDATA[<blockquote><p>事务是逻辑上的一组操作，要么都执行，要么都不执行.</p></blockquote><h3 id="事务的特性-ACID"><a href="#事务的特性-ACID" class="headerlink" title="事务的特性(ACID)"></a>事务的特性(ACID)</h3><p><img src="https://github.com/cayzlh/git-img-repository/raw/master/blog/2018090301/1.png" alt="ACID"></p><p><strong>原子性：</strong> 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；</p><p><strong>一致性：</strong> 执行事务前后，数据保持一致；</p><p><strong>隔离性：</strong> 并发访问数据库时，一个用户的事物不被其他事物所干扰，各并发事务之间数据库是独立的；</p><p><strong>持久性:</strong>  一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。</p><h3 id="Spring事务管理接口"><a href="#Spring事务管理接口" class="headerlink" title="Spring事务管理接口"></a>Spring事务管理接口</h3><h4 id="PlatformTransactionManager：-（平台）事务管理器"><a href="#PlatformTransactionManager：-（平台）事务管理器" class="headerlink" title="PlatformTransactionManager： （平台）事务管理器"></a><strong>PlatformTransactionManager：</strong> （平台）事务管理器</h4><p><strong>Spring并不直接管理事务，而是提供了多种事务管理器</strong> ，他们将事务管理的职责委托给Hibernate或者JTA等持久化机制所提供的相关平台框架的事务来实现。 Spring事务管理器的接口是： <strong>org.springframework.transaction.PlatformTransactionManager</strong> ，通过这个接口，Spring为各个平台如JDBC、Hibernate等都提供了对应的事务管理器，但是具体的实现就是各个平台自己的事情了。</p><p>PlatformTransactionManager接口中定义了三个方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Public interface <span class="title">PlatformTransactionManager</span><span class="params">()</span>...</span>&#123;  </span><br><span class="line">    <span class="comment">// Return a currently active transaction or create a new one, according to the specified propagation behavior（根据指定的传播行为，返回当前活动的事务或创建一个新事务。）</span></span><br><span class="line">    <span class="function">TransactionStatus <span class="title">getTransaction</span><span class="params">(TransactionDefinition definition)</span> <span class="keyword">throws</span> TransactionException</span>; </span><br><span class="line">    <span class="comment">// Commit the given transaction, with regard to its status（使用事务目前的状态提交事务）</span></span><br><span class="line">    <span class="function">Void <span class="title">commit</span><span class="params">(TransactionStatus status)</span> <span class="keyword">throws</span> TransactionException</span>;  </span><br><span class="line">    <span class="comment">// Perform a rollback of the given transaction（对执行的事务进行回滚）</span></span><br><span class="line">    <span class="function">Void <span class="title">rollback</span><span class="params">(TransactionStatus status)</span> <span class="keyword">throws</span> TransactionException</span>;  </span><br><span class="line">    &#125; </span><br></pre></td></tr></table></figure><blockquote><p>Spring中PlatformTransactionManager根据不同持久层框架所对应的接口实现类</p></blockquote><p><img src="https://github.com/cayzlh/git-img-repository/raw/master/blog/2018090301/2.png" alt="ACID"></p><h4 id="TransactionDefinition：-事务定义信息-事务隔离级别、传播行为、超时、只读、回滚规则"><a href="#TransactionDefinition：-事务定义信息-事务隔离级别、传播行为、超时、只读、回滚规则" class="headerlink" title="TransactionDefinition： 事务定义信息(事务隔离级别、传播行为、超时、只读、回滚规则)"></a><strong>TransactionDefinition：</strong> 事务定义信息(事务隔离级别、传播行为、超时、只读、回滚规则)</h4><p>事务管理器接口 <strong>PlatformTransactionManager</strong> 通过 <strong>getTransaction(TransactionDefinition definition)</strong> 方法来得到一个事务，这个方法里面的参数是 <strong>TransactionDefinition类</strong> ，这个类就定义了一些基本的事务属性。</p><p><strong>那么什么是事务属性呢？</strong></p><p>事务属性可以理解成事务的一些基本配置，描述了事务策略如何应用到方法上。事务属性包含了5个方面。</p><p><img src="https://github.com/cayzlh/git-img-repository/raw/master/blog/2018090301/3.png" alt="ACID"></p><p>TransactionDefinition接口中的方法如下：</p><p>TransactionDefinition接口中定义了5个方法以及一些表示事务属性的常量比如隔离级别、传播行为等等的常量。</p><p>我下面只是列出了TransactionDefinition接口中的方法而没有给出接口中定义的常量</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TransactionDefinition</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 返回事务的传播行为</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getPropagationBehavior</span><span class="params">()</span></span>; </span><br><span class="line">    <span class="comment">// 返回事务的隔离级别，事务管理器根据它来控制另外一个事务可以看到本事务内的哪些数据</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getIsolationLevel</span><span class="params">()</span></span>; </span><br><span class="line">    <span class="comment">// 返回事务必须在多少秒内完成</span></span><br><span class="line">    <span class="comment">//返回事务的名字</span></span><br><span class="line">    <span class="function">String <span class="title">getName</span><span class="params">()</span>；</span></span><br><span class="line"><span class="function">    <span class="keyword">int</span> <span class="title">getTimeout</span><span class="params">()</span></span>;  </span><br><span class="line">    <span class="comment">// 返回是否优化为只读事务。</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isReadOnly</span><span class="params">()</span></span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h4 id="TransactionStatus：-事务运行状态"><a href="#TransactionStatus：-事务运行状态" class="headerlink" title="TransactionStatus： 事务运行状态"></a><strong>TransactionStatus：</strong> 事务运行状态</h4><p>TransactionStatus接口用来记录事务的状态 该接口定义了一组方法,用来获取或判断事务的相应状态信息.</p><p>PlatformTransactionManager.getTransaction(…) 方法返回一个 TransactionStatus 对象。返回的TransactionStatus 对象可能代表一个新的或已经存在的事务（如果在当前调用堆栈有一个符合条件的事务）。</p><p>TransactionStatus接口接口内容如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TransactionStatus</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isNewTransaction</span><span class="params">()</span></span>; <span class="comment">// 是否是新的事物</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">hasSavepoint</span><span class="params">()</span></span>; <span class="comment">// 是否有恢复点</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setRollbackOnly</span><span class="params">()</span></span>;  <span class="comment">// 设置为只回滚</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isRollbackOnly</span><span class="params">()</span></span>; <span class="comment">// 是否为只回滚</span></span><br><span class="line">    <span class="keyword">boolean</span> isCompleted; <span class="comment">// 是否已完成</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p><strong>所谓事务管理，其实就是“按照给定的事务规则来执行提交或者回滚操作”</strong>。</p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://juejin.im/post/5b00c52ef265da0b95276091">https://juejin.im/post/5b00c52ef265da0b95276091</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 转载 </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>volatile</title>
      <link href="post/fe4c9cb6/"/>
      <url>post/fe4c9cb6/</url>
      
        <content type="html"><![CDATA[<h3 id="volatile的用法"><a href="#volatile的用法" class="headerlink" title="volatile的用法"></a>volatile的用法</h3><p><code>volatile</code>通常被比喻成”轻量级的<code>synchronized</code>“，也是Java并发编程中比较重要的一个关键字。和<code>synchronized</code>不同，<code>volatile</code>是一个变量修饰符，只能用来修饰变量。无法修饰方法及代码块等。</p><p><code>volatile</code>的用法比较简单，只需要在声明一个可能被多线程同时访问的变量时，使用<code>volatile</code>修饰就可以了。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton singleton;  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getSingleton</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;  </span><br><span class="line">        <span class="keyword">synchronized</span> (Singleton.class) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;  </span><br><span class="line">            singleton = <span class="keyword">new</span> Singleton();  </span><br><span class="line">        &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> singleton;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>如以上代码，是一个比较典型的使用双重锁校验的形式实现单例的，其中使用<code>volatile</code>关键字修饰可能被多个线程同时访问到的singleton。</p><h3 id="volatile的原理"><a href="#volatile的原理" class="headerlink" title="volatile的原理"></a>volatile的原理</h3><blockquote><p>为了提高处理器的执行速度，在处理器和内存之间增加了多级缓存来提升。但是由于引入了多级缓存，就存在缓存数据不一致问题。</p><p>但是，对于<code>volatile</code>变量，当对<code>volatile</code>变量进行写操作的时候，JVM会向处理器发送一条lock前缀的指令，将这个缓存中的变量回写到系统主存中。</p><p>但是就算写回到内存，如果其他处理器缓存的值还是旧的，再执行计算操作就会有问题，所以在多处理器下，为了保证各个处理器的缓存是一致的，就会实现<code>缓存一致性协议</code></p></blockquote><h4 id="缓存一致性协议"><a href="#缓存一致性协议" class="headerlink" title="缓存一致性协议"></a>缓存一致性协议</h4><p>每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，当处理器要对这个数据进行修改操作的时候，会强制重新从系统内存里把数据读到处理器缓存里。</p><p>所以，如果一个变量被<code>volatile</code>所修饰的话，在每次数据变化之后，其值都会被强制刷入主存。而其他处理器的缓存由于遵守了缓存一致性协议，也会把这个变量的值从主存加载到自己的缓存中。这就保证了一个<code>volatile</code>在并发编程中，其值在多个缓存中是可见的。</p><h3 id="volatile与可见性"><a href="#volatile与可见性" class="headerlink" title="volatile与可见性"></a>volatile与可见性</h3><p><strong>可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。</strong></p><p><a href="https://blog.cayzlh.com/2018/08/28/2018082801/">Java内存模型</a>规定了所有的变量都存储在主内存中，每条线程还有自己的工作内存，线程的工作内存中保存了该线程中是用到的变量的主内存副本拷贝，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存。不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量的传递均需要自己的工作内存和主存之间进行数据同步进行。所以，就可能出现线程1改了某个变量的值，但是线程2不可见的情况。</p><blockquote><p>Java中的<code>volatile</code>关键字提供了一个功能，那就是被其修饰的变量在被修改后可以立即同步到主内存，被其修饰的变量在每次是用之前都从主内存刷新。因此，可以使用<code>volatile</code>来保证多线程操作时变量的可见性。</p></blockquote><p>volatile对于可见性的实现，<strong>内存屏障</strong>也起着至关重要的作用。因为内存屏障相当于一个数据同步点，他要保证在这个同步点之后的读写操作必须在这个点之前的读写操作都执行完之后才可以执行。并且在遇到内存屏障的时候，缓存数据会和主存进行同步，或者把缓存数据写入主存、或者从主存把数据读取到缓存。</p><p><em>内存一致性模型的实现可以通过缓存一致性协议来实现。同时，留了一个问题：已经有了缓存一致性协议，为什么还需要volatile？</em></p><blockquote><p>1、并不是所有的硬件架构都提供了相同的一致性保证，Java作为一门跨平台语言，JVM需要提供一个统一的语义。</p><p>2、操作系统中的缓存和JVM中线程的本地内存并不是一回事，通常我们可以认为：MESI可以解决缓存层面的可见性问题。使用volatile关键字，可以解决JVM层面的可见性问题。</p><p>3、缓存可见性问题的延伸：由于传统的MESI协议的执行成本比较大。所以CPU通过Store Buffer和Invalidate Queue组件来解决，但是由于这两个组件的引入，也导致缓存和主存之间的通信并不是实时的。也就是说，<strong>缓存一致性模型只能保证缓存变更可以保证其他缓存也跟着改变，但是不能保证立刻、马上执行。</strong></p></blockquote><p><em>写内存屏障（Store Memory Barrier）</em>可以促使处理器将当前store buffer（存储缓存）的值写回主存。</p><p><em>读内存屏障（Load Memory Barrier）</em>可以促使处理器处理invalidate queue（失效队列）。</p><p><strong>所以，内存屏障也是保证可见性的重要手段，操作系统通过内存屏障保证缓存间的可见性，JVM通过给volatile变量加入内存屏障保证线程之间的可见性。</strong>进而避免由于Store Buffer和Invalidate Queue的非实时性带来的问题。</p><h4 id="内存屏障"><a href="#内存屏障" class="headerlink" title="内存屏障"></a>内存屏障</h4><p>Java中的内存屏障：用于控制特定条件下的重排序和内存可见性问题。Java编译器也会根据内存屏障的规则禁止重排序。</p><h3 id="volatile与有序性"><a href="#volatile与有序性" class="headerlink" title="volatile与有序性"></a>volatile与有序性</h3><blockquote><p>有序性即程序执行的顺序按照代码的先后顺序执行。 </p></blockquote><p><a href="https://blog.cayzlh.com/2018/08/28/2018082801/">除了引入了时间片以外，由于处理器优化和指令重排等，CPU还可能对输入代码进行乱序执行，比如<code>load-&gt;add-&gt;save</code> 有可能被优化成<code>load-&gt;save-&gt;add</code> 。这就是可能存在有序性问题</a>。</p><p>而<code>volatile</code>除了可以保证数据的可见性之外，还有一个强大的功能，那就是他可以<strong>禁止指令重排优化</strong>等。</p><p>普通的变量仅仅会保证在该方法的执行过程中所依赖的赋值结果的地方都能获得正确的结果，而不能保证变量的赋值操作的顺序与程序代码中的执行顺序一致。</p><p>volatile可以禁止指令重排，这就保证了代码的程序会严格按照代码的先后顺序执行。这就保证了有序性。被<code>volatile</code>修饰的变量的操作，会严格按照代码顺序执行，<code>load-&gt;add-&gt;save</code> 的执行顺序就是：load、add、save。</p><p><strong>volatile是通过<em>内存屏障</em>来来禁止指令重排的。</strong></p><p><strong>内存屏障（Memory Barrier）</strong>是一类同步屏障指令，是CPU或编译器在对内存随机访问的操作中的一个同步点，使得此点之前的所有读写操作都执行后才可以开始执行此点之后的操作。下表描述了和volatile有关的指令重排禁止行为：</p><p><img src="https://github.com/cayzlh/git-img-repository/raw/master/blog/2018083001/1.png" alt="内存屏障"></p><p>可以看出：</p><blockquote><p>当第二个操作是volatile写时，不管第一个操作是什么，都不能重排序。这个规则确保volatile写之前的操作不会被编译器重排序到volatile写之后。</p><p>当第一个操作是volatile读时，不管第二个操作是什么，都不能重排序。这个规则确保volatile读之后的操作不会被编译器重排序到volatile读之前。</p><p>当第一个操作是volatile写，第二个操作是volatile读时，不能重排序。</p></blockquote><p>具体实现方式是在编译期生成字节码时，会在指令序列中增加内存屏障来保证，下面是基于保守策略的JMM内存屏障插入策略：</p><ul><li><p>在每个volatile写操作的前面插入一个<code>StoreStore</code>屏障。</p></li><li><ul><li>对于这样的语句Store1; StoreLoad; Store2，在Store2及后续写入操作执行前，保证Store1的写入操作对其它处理器可见。</li></ul></li><li><p>在每个volatile写操作的后面插入一个<code>StoreLoad</code>屏障。</p></li><li><ul><li>对于这样的语句Store1; StoreLoad; Load2，在Load2及后续所有读取操作执行前，保证Store1的写入对所有处理器可见。</li></ul></li><li><p>在每个volatile读操作的后面插入一个<code>LoadLoad</code>屏障。</p></li><li><ul><li>对于这样的语句Load1;LoadLoad; Load2，在Load2及后续读取操作要读取的数据被访问前，保证Load1要读取的数据被读取完毕。</li></ul></li><li><p>在每个volatile读操作的后面插入一个<code>LoadStore</code>屏障。</p></li><li><ul><li>对于这样的语句Load1; LoadStore; Store2，在Store2及后续写入操作被刷出前，保证Load1要读取的数据被读取完毕。</li></ul></li></ul><p><img src="https://github.com/cayzlh/git-img-repository/raw/master/blog/2018083001/2.png" alt="内存屏障"></p><p>所以，volatile通过在volatile变量的操作前后插入内存屏障的方式，来禁止指令重排，进而保证多线程情况下对共享变量的有序性。</p><h3 id="volatile与原子性"><a href="#volatile与原子性" class="headerlink" title="volatile与原子性"></a>volatile与原子性</h3><blockquote><p>原子性是指一个操作是不可中断的，要全部执行完成，要不就都不执行。 </p></blockquote><p><strong>线程是CPU调度的基本单位。CPU有时间片的概念，会根据不同的调度算法进行线程调度。当一个线程获得时间片之后开始执行，在时间片耗尽之后，就会失去CPU使用权。所以在多线程场景下，由于时间片在线程间轮换，就会发生原子性问题。</strong></p><p><a href="https://blog.cayzlh.com/2018/08/28/2018082802/">synchronized</a>提到过，为了保证原子性，需要通过字节码指令<code>monitorenter</code>和<code>monitorexit</code>，但是<code>volatile</code>和这两个指令之间是没有任何关系的。</p><p><strong>所以，volatile是不能保证原子性的。</strong></p><p>在以下两个场景中可以使用<code>volatile</code>来代替<code>synchronized</code>：</p><blockquote><p>1、运算结果并不依赖变量的当前值，或者能够确保只有单一的线程会修改变量的值。</p><p>2、变量不需要与其他状态变量共同参与不变约束。</p></blockquote><p>除以上场景外，都需要使用其他方式来保证原子性，如<code>synchronized</code>或者<code>concurrent包</code>。 </p><p>看如下代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increase</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Test test = <span class="keyword">new</span> Test();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">1000</span>;j++)</span><br><span class="line">                        test.increase();</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;.start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(Thread.activeCount()&gt;<span class="number">1</span>)  <span class="comment">//保证前面的线程都执行完</span></span><br><span class="line">            Thread.yield();</span><br><span class="line">        System.out.println(test.i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码比较简单，就是创建10个线程，然后分别执行1000次<code>i++</code>操作。正常情况下，程序的输出结果应该是10000，但是，多次执行的结果都小于10000。这其实就是<code>volatile</code>无法满足原子性的原因。</p><p>为什么会出现这种情况呢，那就是因为虽然volatile可以保证<code>i</code>在多个线程之间的可见性。但是无法保证<code>i++</code>的原子性。</p><p><code>i++</code>操作，一共有三个步骤：<code>load i</code> ，<code>add i</code> ,<code>save i</code>。在多线程场景中，如果这三个步骤无法按照顺序执行的话，那么就会出现问题。</p><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p>由于CPU按照时间片来进行线程调度的，只要是包含多个步骤的操作的执行，天然就是无法保证原子性的。因为这种线程执行，又不像数据库一样可以回滚。如果一个线程要执行的步骤有5步，执行完3步就失去了CPU了，失去后就可能再也不会被调度，这怎么可能保证原子性呢。</p><p>为什么<code>synchronized</code>可以保证原子性 ，因为被<code>synchronized</code>修饰的代码片段，在进入之前加了锁，只要他没执行完，其他线程是无法获得锁执行这段代码片段的，就可以保证他内部的代码可以全部被执行。进而保证原子性。</p><p>但是<code>synchronized</code>对原子性保证也不绝对，一旦代码运行异常，也没办法回滚。所以呢，在并发编程中，原子性的定义不应该和事务中的原子性一样。他应该定义为：<strong>一段代码，或者一个变量的操作，在没有执行完之前，不能被其他线程执行。</strong></p><p>那么，为什么<code>volatile</code>不能保证原子性呢？因为他不是锁，他没做任何可以保证原子性的处理。当然就不能保证原子性了。</p>]]></content>
      
      
      <categories>
          
          <category> 编程技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>synchronized</title>
      <link href="post/edea11bc/"/>
      <url>post/edea11bc/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Java语言为了解决并发编程中存在的原子性、可见性和有序性问题，提供了一系列和并发处理相关的关键字，比如synchronized、volatile、final、concurren包等。</p></blockquote><p>在《深入理解Java虚拟机》中，有这样一段话：</p><blockquote><p><code>synchronized</code>关键字在需要原子性、可见性和有序性这三种特性的时候都可以作为其中一种解决方案，看起来是“万能”的。的确，大部分并发控制操作都能使用synchronized来完成。</p></blockquote><p><code>synchronized</code>只是个关键字而已，用起来很简单。之所以我们可以在处理多线程问题时可以不用考虑太多，就是因为这个关键字帮我们屏蔽了很多细节。</p><p>本文主要介绍<code>synchronized</code>的用法、原理，以及如何提供原子性、可见性和有序性保障的等。</p><h3 id="synchronized的用法"><a href="#synchronized的用法" class="headerlink" title="synchronized的用法"></a>synchronized的用法</h3><p><code>synchronized</code>是Java提供的一个并发控制的关键字。主要有两种用法，分别是同步方法和同步代码块。</p><p>也就是说，<code>synchronized</code>既可以修饰方法也可以修饰代码块。代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedDemo</span> </span>&#123;</span><br><span class="line">     <span class="comment">//同步方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">doSomeThing</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//同步代码块</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doOtherThing</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (SynchronizedDemo.class)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>被<code>synchronized</code>修饰的代码块及方法，在同一时间，只能被单个线程访问。 </p><h3 id="synchronized的实现原理"><a href="#synchronized的实现原理" class="headerlink" title="synchronized的实现原理"></a>synchronized的实现原理</h3><blockquote><p><code>synchronized</code>，是Java中用于解决并发情况下数据同步访问的一个很重要的关键字。当我们想要保证一个共享资源在同一时间只会被一个线程访问到时，我们可以在代码中使用<code>synchronized</code>关键字对类或者对象加锁。</p></blockquote><p>我们对上面的代码进行反编译，可以得到如下代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">cayzlh</span>.<span class="title">SynchronizedDemo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> com.cayzlh.SynchronizedDemo();</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0</span><br><span class="line">       1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">       <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">doSomeThing</span><span class="params">()</span></span>;</span><br><span class="line">    Code:</span><br><span class="line">       0: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">       3: ldc           #3                  // String Hello World</span><br><span class="line">       5: invokevirtual #4                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">       <span class="number">8</span>: <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doOtherThing</span><span class="params">()</span></span>;</span><br><span class="line">    Code:</span><br><span class="line">       0: ldc           #5                  // class com/cayzlh/SynchronizedDemo</span><br><span class="line">       <span class="number">2</span>: dup</span><br><span class="line">       <span class="number">3</span>: astore_1</span><br><span class="line">       <span class="number">4</span>: monitorenter</span><br><span class="line">       5: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">       8: ldc           #3                  // String Hello World</span><br><span class="line">      10: invokevirtual #4                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">      <span class="number">13</span>: aload_1</span><br><span class="line">      <span class="number">14</span>: monitorexit</span><br><span class="line">      <span class="number">15</span>: goto          <span class="number">23</span></span><br><span class="line">      <span class="number">18</span>: astore_2</span><br><span class="line">      <span class="number">19</span>: aload_1</span><br><span class="line">      <span class="number">20</span>: monitorexit</span><br><span class="line">      <span class="number">21</span>: aload_2</span><br><span class="line">      <span class="number">22</span>: athrow</span><br><span class="line">      <span class="number">23</span>: <span class="keyword">return</span></span><br><span class="line">    Exception table:</span><br><span class="line">       from    to  target type</span><br><span class="line">           <span class="number">5</span>    <span class="number">15</span>    <span class="number">18</span>   any</span><br><span class="line">          <span class="number">18</span>    <span class="number">21</span>    <span class="number">18</span>   any</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出：</p><p>对于同步方法，JVM采用<code>ACC_SYNCHRONIZED</code>标记符来实现同步。 </p><p>对于同步代码块。JVM采用<code>monitorenter</code>、<code>monitorexit</code>两个指令来实现同步。</p><p>在The Java® Virtual Machine Specification中有关于同步方法和同步代码块的实现原理的介绍:</p><blockquote><p>Method-level synchronization is performed implicitly, as part of method invocation and return. A synchronized method is distinguished in the run-time constant pool’s method<em>info structure by the ACC</em>SYNCHRONIZED flag, which is checked by the method invocation instructions. When invoking a method for which ACC_SYNCHRONIZED is set, the executing thread enters a monitor, invokes the method itself, and exits the monitor whether the method invocation completes normally or abruptly. During the time the executing thread owns the monitor, no other thread may enter it. If an exception is thrown during invocation of the synchronized method and the synchronized method does not handle the exception, the monitor for the method is automatically exited before the exception is rethrown out of the synchronized method.</p><p>方法级的同步是隐式的。同步方法的常量池中会有一个<code>ACC_SYNCHRONIZED</code>标志。当某个线程要访问某个方法的时候，会检查是否有<code>ACC_SYNCHRONIZED</code>，如果有设置，则需要先获得监视器锁，然后开始执行方法，方法执行之后再释放监视器锁。这时如果其他线程来请求执行方法，会因为无法获得监视器锁而被阻断住。值得注意的是，<strong>如果在方法执行过程中，发生了异常，并且方法内部并没有处理该异常，那么在异常被抛到方法外面之前监视器锁会被自动释放。</strong></p><p>同步代码块使用<code>monitorenter</code>和<code>monitorexit</code>两个指令实现。可以把执行<code>monitorenter</code>指令理解为加锁，执行<code>monitorexit</code>理解为释放锁。 每个对象维护着一个记录着被锁次数的计数器。未被锁定的对象的该计数器为0，当一个线程获得锁（执行<code>monitorenter</code>）后，该计数器自增变为 1 ，当同一个线程再次获得该对象的锁的时候，计数器再次自增。当同一个线程释放锁（执行<code>monitorexit</code>指令）的时候，计数器再自减。当计数器为0的时候。锁将被释放，其他线程便可以获得锁。</p></blockquote><p>无论是<code>ACC_SYNCHRONIZED</code>还是<code>monitorenter</code>、<code>monitorexit</code>都是基于Monitor实现的，在Java虚拟机(HotSpot)中，Monitor是基于C++实现的，由ObjectMonitor实现。</p><p><code>ObjectMonitor</code>类中提供了几个方法，如<code>enter</code>、<code>exit</code>、<code>wait</code>、<code>notify</code>、<code>notifyAll</code>等。<code>sychronized</code>加锁的时候，会调用<code>objectMonitor</code>的<code>enter</code>方法，解锁的时候会调用<code>exit</code>方法。</p><h3 id="synchronized与有序性"><a href="#synchronized与有序性" class="headerlink" title="synchronized与有序性"></a>synchronized与有序性</h3><p>有序性即程序执行的顺序按照代码的先后顺序执行。</p><blockquote><p>由于处理器优化和指令重排等，CPU还可能对输入代码进行乱序执行，比如load-&gt;add-&gt;save 有可能被优化成load-&gt;save-&gt;add 。这就是可能存在有序性问题。</p></blockquote><p>这里需要注意的是，<code>synchronized</code>是无法禁止指令重排和处理器优化的。也就是说，<code>synchronized</code>无法避免上述提到的问题。</p><p><em>那么，为什么还说<code>synchronized</code>也提供了有序性保证呢？</em></p><p><strong>Java程序中天然的有序性可以总结为一句话：如果在本线程内观察，所有操作都是天然有序的。如果在一个线程中观察另一个线程，所有操作都是无序的。</strong></p><p>以上这句话也是《深入理解Java虚拟机》中的原句，这和<code>as-if-serial语义</code>有关。</p><p><code>as-if-serial</code>语义的意思指：不管怎么重排序（编译器和处理器为了提高并行度），单线程程序的执行结果都不能被改变。编译器和处理器无论如何优化，都必须遵守<code>as-if-serial</code>语义。</p><p>简单说就是，<code>as-if-serial语义</code>保证了单线程中，指令重排是有一定的限制的，而只要编译器和处理器都遵守了这个语义，那么就可以认为单线程程序是按照顺序执行的。当然，实际上还是有重排的，只不过我们无须关心这种重排的干扰。</p><p><strong>所以呢，由于synchronized修饰的代码，同一时间只能被同一线程访问。那么也就是单线程执行的。所以，可以保证其有序性。</strong></p><h3 id="synchronized与锁优化"><a href="#synchronized与锁优化" class="headerlink" title="synchronized与锁优化"></a><strong>synchronized与锁优化</strong></h3><p><code>synchronized</code>其实是借助Monitor实现的，在加锁时会调用objectMonitor的<code>enter</code>方法，解锁的时候会调用<code>exit</code>方法。事实上，只有在JDK1.6之前，synchronized的实现才会直接调用ObjectMonitor的<code>enter</code>和<code>exit</code>，这种锁被称之为重量级锁。</p><p>所以，在JDK1.6中出现对锁进行了很多的优化，进而出现轻量级锁，偏向锁，锁消除，适应性自旋锁，锁粗化(自旋锁在1.4就有，只不过默认的是关闭的，jdk1.6是默认开启的)，这些操作都是为了在线程之间更高效的共享数据 ，解决竞争问题。</p>]]></content>
      
      
      <categories>
          
          <category> 编程技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java内存模型的实现</title>
      <link href="post/2e82a2db/"/>
      <url>post/2e82a2db/</url>
      
        <content type="html"><![CDATA[<blockquote><p>在Java中提供了一系列和并发处理相关的关键字，比如<code>volatile</code>、<code>synchronized</code>、<code>final</code>、<code>concurren</code>包等。其实这些就是Java内存模型封装了底层的实现后提供给程序员使用的一些关键字。</p></blockquote><h3 id="什么是内存模型-？"><a href="#什么是内存模型-？" class="headerlink" title="什么是内存模型 ？"></a>什么是内存模型 ？</h3><p>缓存一致性问题、处理器器优化的指令重排问题是硬件的不断升级导致的。那么，有没有什么机制可以很好的解决上面的这些问题呢？</p><p>最简单直接的做法就是废除处理器和处理器的优化技术、废除CPU缓存，让CPU直接和主存交互。但是，这么做虽然可以保证多线程下的并发问题。但是，这就有点因噎废食了。</p><p>所以，为了保证并发编程中可以满足原子性、可见性及有序性。有一个重要的概念，那就是——内存模型。</p><p><strong>为了保证共享内存的正确性（可见性、有序性、原子性），内存模型定义了共享内存系统中多线程程序读写操作行为的规范。</strong>通过这些规则来规范对内存的读写操作，从而保证指令执行的正确性。它与处理器有关、与缓存有关、与并发有关、与编译器也有关。他解决了CPU多级缓存、处理器优化、指令重排等导致的内存访问问题，保证了并发场景下的一致性、原子性和有序性。</p><hr><p>在开发多线程的代码的时候，可以直接使用<code>synchronized</code>等关键字来控制并发，从来就不需要关心底层的编译器优化、缓存一致性等问题。所以，<strong>Java内存模型，除了定义了一套规范，还提供了一系列原语，封装了底层实现后，供开发者直接使用。</strong></p><h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h3><blockquote><p>在一个操作中就是cpu不可以在中途暂停然后再调度，既不被中断操作，要不执行完成，要不就不执行</p></blockquote><p>在Java中，为了保证原子性，提供了两个高级的字节码指令<code>monitorenter</code>和<code>monitorexit</code>。这两个字节码，在Java中对应的关键字就是<code>synchronized</code>。</p><p>因此，在Java中可以使用<code>synchronized</code>来保证方法和代码块内的操作是原子性的。</p><h3 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h3><blockquote><p>当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值</p></blockquote><p>Java内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值的这种依赖主内存作为传递媒介的方式来实现的。</p><p>Java中的<code>volatile</code>关键字提供了一个功能，那就是<strong>被其修饰的变量在被修改后可以立即同步到主内存</strong>，被其修饰的变量在每次是用之前都从主内存刷新。因此，可以使用<code>volatile</code>来保证多线程操作时变量的可见性。</p><p>除了<code>volatile</code>，Java中的<code>synchronized</code>和<code>final</code>两个关键字也可以实现可见性。只不过实现方式不同，这里不再展开了。</p><h3 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h3><blockquote><p>程序执行的顺序按照代码的先后顺序执行</p></blockquote><p>在Java中，可以使用<code>synchronized</code>和<code>volatile</code>来保证多线程之间操作的有序性。实现方式有所区别：</p><p><code>volatile</code>关键字会禁止指令重排。<code>synchronized</code>关键字保证同一时刻只允许一条线程操作。</p><h3 id="END"><a href="#END" class="headerlink" title="END"></a>END</h3><p><a href="https://blog.cayzlh.com/2018/08/28/2018082802/">synchronized的一些记录</a>。</p>]]></content>
      
      
      <categories>
          
          <category> 编程技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 转载 </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis为什么这么快</title>
      <link href="post/2337557361/"/>
      <url>post/2337557361/</url>
      
        <content type="html"><![CDATA[<h3 id="Redis简介"><a href="#Redis简介" class="headerlink" title="Redis简介"></a>Redis简介</h3><p><code>Redis</code>是一个开源的内存中的数据结构存储系统，它可以用作：数据库、缓存和消息中间件。</p><p>它支持多种类型的数据结构，如字符串（<code>String</code>），散列（<code>Hash</code>），列表（<code>List</code>），集合（<code>Set</code>），<br>有序集合（<code>Sorted Set</code>或者是<code>ZSet</code>）与范围查询，<code>Bitmaps</code>，<code>Hyperloglogs</code> 和地理空间（Geospatial）索引半径查询。<br>其中常见的数据结构类型有：<code>String</code>、<code>List</code>、<code>Set</code>、<code>Hash</code>、<code>ZSet</code>这5种。</p><p>Redis 内置了复制（Replication），LUA脚本（Lua scripting）， LRU驱动事件（LRU eviction），<br>事务（Transactions） 和不同级别的磁盘持久化（Persistence），<br>并通过 Redis哨兵（Sentinel）和自动分区（Cluster）提供高可用性（High Availability）。</p><blockquote><p>Redis也提供了持久化的选项，这些选项可以让用户将自己的数据保存到磁盘上面进行存储。<br>根据实际情况，可以每隔一定时间将数据集导出到磁盘（快照），或者追加到命令日志中（AOF只追加文件），<br>他会在执行写命令时，将被执行的写命令复制到硬盘里面。您也可以关闭持久化功能，将Redis作为一个高效的网络的缓存数据功能使用。</p></blockquote><p>Redis不使用表，他的数据库不会预定义或者强制去要求用户对Redis存储的不同数据进行关联。</p><p>数据库的工作模式按存储方式可分为：硬盘数据库和内存数据库。<code>Redis 将数据储存在内存里面，读写数据的时候都不会受到硬盘 I/O 速度的限制，所以速度极快</code>。</p><h3 id="Redis为什么这么快"><a href="#Redis为什么这么快" class="headerlink" title="Redis为什么这么快"></a>Redis为什么这么快</h3><ul><li><ol><li>完全基于内存，绝大部分请求是纯粹的内存操作，非常快速。数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1)；</li></ol></li><li><ol start="2"><li>数据结构简单，对数据操作也简单，Redis中的数据结构是专门进行设计的；</li></ol></li><li><ol start="3"><li>采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗；</li></ol></li><li><ol start="4"><li>使用多路I/O复用模型，非阻塞IO；</li></ol></li><li><ol start="5"><li>使用底层模型不同，它们之间底层实现方式以及与客户端之间通信的应用协议不一样，Redis直接自己构建了VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求；</li></ol></li></ul><h4 id="多路-I-O-复用模型"><a href="#多路-I-O-复用模型" class="headerlink" title="多路 I/O 复用模型"></a>多路 I/O 复用模型</h4><p>多路I/O复用模型是利用 select、poll、epoll 可以同时监察多个流的 I/O 事件的能力，在空闲的时候，会把当前线程阻塞掉，当有一个或多个流有 I/O 事件时，就从阻塞态中唤醒，于是程序就会轮询一遍所有的流（epoll 是只轮询那些真正发出了事件的流），并且只依次顺序的处理就绪的流，这种做法就避免了大量的无用操作。</p><p>这里“多路”指的是多个网络连接，“复用”指的是复用同一个线程。</p><p>采用多路 I/O 复用技术可以让单个线程高效的处理多个连接请求（尽量减少网络 IO 的时间消耗），且 Redis 在内存中操作数据的速度非常快，也就是说内存内的操作不会成为影响Redis性能的瓶颈，主要由以上几点造就了 Redis 具有很高的吞吐量。</p><h3 id="Redis为什么是单线程的"><a href="#Redis为什么是单线程的" class="headerlink" title="Redis为什么是单线程的"></a>Redis为什么是单线程的</h3><blockquote><p>官方FAQ表示，因为Redis是基于内存的操作，CPU不是Redis的瓶颈，Redis的瓶颈最有可能是机器内存的大小或者网络带宽。既然单线程容易实现，而且CPU不会成为瓶颈，那就顺理成章地采用单线程的方案了（毕竟采用多线程会有很多麻烦！）。</p></blockquote><p><code>注1</code>：这里我们一直在强调的单线程，只是在<code>处理我们的网络请求</code>的时候只有一个线程来处理，一个正式的Redis Server运行的时候肯定是不止一个线程的，这里需要大家明确的注意一下！<br>例如Redis进行持久化的时候会以子进程或者子线程的方式执行（具体是子线程还是子进程待读者深入研究）</p><p><code>注2</code>：从Redis 4.0版本开始会支持多线程的方式，但是，只是在某一些操作上进行多线程的操作！以后的版本中是否还是单线程的方式需要考证！</p>]]></content>
      
      
      <categories>
          
          <category> 笔记本 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> 原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>利用GitHub做图床</title>
      <link href="post/669728936/"/>
      <url>post/669728936/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关于<code>GitHub</code>的骚操作一直以来都有很多，这篇文章记录一下使用<code>github</code>的<code>raw</code>做一个基于GitHub的<code>MarkDown</code>图床，免费还不限流量，还很<code>Geek</code></p></blockquote><h3 id="在GitHub上新建一个repository"><a href="#在GitHub上新建一个repository" class="headerlink" title="在GitHub上新建一个repository"></a>在GitHub上新建一个repository</h3><p>首先，在<code>Github</code>上新建一个专门用来放图片的<code>repository</code>。</p><p><img src="https://cdn.jsdelivr.net/gh/cayzlh/git-img-repository@master/2020/04/25/s7Rw7W.png" alt="新建一个repository"></p><h3 id="利用GitHub-Desktop上传图片"><a href="#利用GitHub-Desktop上传图片" class="headerlink" title="利用GitHub Desktop上传图片"></a>利用GitHub Desktop上传图片</h3><p><img src="https://gitee.com/cayzlh/img-repo/raw/master/2020/04/25/EWnrnY.png" alt="新建一个repository"></p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>上传到GitHub上之后的图片连接如下所示：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">https://github.com/yourname/imgRepository/raw/master/youDirectory/1.png</span><br></pre></td></tr></table></figure><h3 id="配合uPic使用"><a href="#配合uPic使用" class="headerlink" title="配合uPic使用"></a>配合uPic使用</h3><p>使用<code>uPic</code>(Mac)快速上传到<code>GitHub</code>图床。</p><blockquote><p>除了GitHub还支持其他多种图床</p></blockquote><p><img src="https://gitee.com/cayzlh/img-repo/raw/master/2020/04/25/JBNFMM.png" alt="image-20200425074922010"></p><p>设置好图床之后，只需要根据快捷键或选择文件上传，即可获得<code>markdown</code>格式的链接或其他格式的链接，非常方便。</p><p><img src="https://cdn.jsdelivr.net/gh/cayzlh/git-img-repository@master/2020/04/25/7HnlRK.png" alt="image-20200425075205584"></p><p>上传完成之后，Markdown格式的链接就自动的保存到你的剪贴板当中。</p><h3 id="配合typora使用"><a href="#配合typora使用" class="headerlink" title="配合typora使用"></a>配合typora使用</h3><p>在<code>typora</code>的设置中开启图片自动上传，当在typora插入图片之后，自动将图片上传到图床。</p><p><img src="https://cdn.jsdelivr.net/gh/cayzlh/git-img-repository@master/2020/04/25/iQMV0z.png" alt="image-20200425075355415"></p>]]></content>
      
      
      <categories>
          
          <category> 笔记本 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Github </tag>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM (垃圾收集)</title>
      <link href="post/99ebe472/"/>
      <url>post/99ebe472/</url>
      
        <content type="html"><![CDATA[<h2 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h2><p>经典的垃圾回收算法以下几种：</p><h3 id="标记–清除算法-Mark-Sweep"><a href="#标记–清除算法-Mark-Sweep" class="headerlink" title="标记–清除算法(Mark-Sweep)"></a>标记–清除算法(Mark-Sweep)</h3><p>回收前状态：</p><p><img src="https://github.com/cayzlh/git-img-repository/raw/master/blog/before.png" alt="回收前"></p><p>回收后状态：</p><p><img src="https://github.com/cayzlh/git-img-repository/raw/master/blog/before.png" alt="回收后"></p><h4 id="优缺点："><a href="#优缺点：" class="headerlink" title="优缺点："></a>优缺点：</h4><p>优点：算法执行分为两个阶段标记与清除，所有的回收算法，基本都基于标记回收算法做了深度优化</p><p>缺点：效率问题，内存空间碎片（不连续的空间）</p><h3 id="复制算法-Copying"><a href="#复制算法-Copying" class="headerlink" title="复制算法(Copying)"></a>复制算法(Copying)</h3><p>回收前状态：</p><p>Eden内存空间 8</p><p><img src="https://github.com/cayzlh/git-img-repository/raw/master/blog/Eden8.png" alt="Eden内存空间 8"></p><p>Survivor1空间（From空间）1</p><p><img src="https://github.com/cayzlh/git-img-repository/raw/master/blog/Survivor1.png" alt="Survivor1空间（From空间）1"></p><p>Survivor2空间(To空间) 1</p><p><img src="https://github.com/cayzlh/git-img-repository/raw/master/blog/Survivor2.png" alt="Survivor2空间(To空间) 1"></p><p>Eden内存空间与Survivor空间 8:1</p><p><img src="https://github.com/cayzlh/git-img-repository/raw/master/blog/Eden_Survivor_8-1.png" alt="Eden内存空间与Survivor空间 8:1"></p><p>回收后状态：</p><p><img src="https://github.com/cayzlh/git-img-repository/raw/master/blog/aftergc.png" alt="回收后状态"></p><p>Survivor1空间（From空间）1</p><p><img src="https://github.com/cayzlh/git-img-repository/raw/master/blog/Survivor11.png" alt="Survivor1空间（From空间）1"></p><p>Eden内存空间与Survivor空间 8:1</p><p><img src="https://github.com/cayzlh/git-img-repository/raw/master/blog/EdenSurvivor8-1.png" alt="Eden内存空间与Survivor空间 8:1"></p><h4 id="优缺点：-1"><a href="#优缺点：-1" class="headerlink" title="优缺点："></a>优缺点：</h4><p>优点比较标记清除算法，避免了回收造成的内存碎片问题</p><p>缺点：以局部的内存空间牺牲为代价，不过空间的浪费比较小，默认8:1的比例1是浪费的。复制也有一定的效率与空间成本</p><h3 id="标记整理算法-Mark-Compact"><a href="#标记整理算法-Mark-Compact" class="headerlink" title="标记整理算法(Mark-Compact)"></a>标记整理算法(Mark-Compact)</h3><p>回收前状态：</p><p><img src="https://github.com/cayzlh/git-img-repository/raw/master/blog/201808190401.png" alt="回收前状态"></p><p>回收后状态：</p><p><img src="https://github.com/cayzlh/git-img-repository/raw/master/blog/201808190402.png" alt="回收前状态"></p><h4 id="优缺点：-2"><a href="#优缺点：-2" class="headerlink" title="优缺点："></a>优缺点：</h4><p>优点：避免了，空间的浪费，与内存碎片问题。</p><p>缺点：整理时复制有效率成本。<br>​     </p><h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h2><h3 id="七种垃圾收集器"><a href="#七种垃圾收集器" class="headerlink" title="七种垃圾收集器"></a>七种垃圾收集器</h3><ul><li>1、 Serial（串行GC）-XX:+UseSerialGC</li><li>2、 ParNew（并行GC）-XX:+UseParNewGC</li><li>3、 Parallel Scavenge（并行回收GC）</li><li>4、 Serial Old（MSC）（串行GC）-XX:+UseSerialGC</li><li>5、 CMS（并发GC）-XX:+UseConcMarkSweepGC</li><li>6、 Parallel Old（并行GC）-XX:+UseParallelOldGC</li><li>7、 G1（JDK1.7update14才可以正式商用）</li></ul><p><img src="https://github.com/cayzlh/git-img-repository/raw/master/blog/201808190403.png" alt="七种垃圾收集器"></p><h3 id="调优方法"><a href="#调优方法" class="headerlink" title="调优方法"></a>调优方法</h3><h4 id="新对象预留新生代"><a href="#新对象预留新生代" class="headerlink" title="新对象预留新生代"></a>新对象预留新生代</h4><p>由于fullGC(老年代)的成本远比minorGC（新生代和老年代）的成本大，所以给应用分配一个合理的新生代空间，尽量将对象分配到新生代减小fullGC的频率</p><h4 id="大对象进入老年代"><a href="#大对象进入老年代" class="headerlink" title="大对象进入老年代"></a>大对象进入老年代</h4><p>将大对象直接分配到老年代，保持新生代对象的结构的完整性，以提高GC效率， 以通过-XX:PretenureSizeThreshold设置进入老年代的阀值</p><h4 id="稳定与震荡的堆大小"><a href="#稳定与震荡的堆大小" class="headerlink" title="稳定与震荡的堆大小"></a>稳定与震荡的堆大小</h4><p>稳定的对大小是对垃圾回收有利的，方法将-Xms和-Xmx的大小一致</p><h4 id="吞吐量优先"><a href="#吞吐量优先" class="headerlink" title="吞吐量优先"></a>吞吐量优先</h4><p>尽可能减少系统执行垃圾回收的总时间，故采用并行垃圾回收器</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-XX:+UseParallelGC或使用-XX:+UseParallelOldGC</span><br></pre></td></tr></table></figure><h4 id="降低停顿"><a href="#降低停顿" class="headerlink" title="降低停顿"></a>降低停顿</h4><p>使用CMS回收器,同时减少fullGC的次数</p><h3 id="获取gc信息的方法"><a href="#获取gc信息的方法" class="headerlink" title="获取gc信息的方法"></a>获取gc信息的方法</h3><ul><li> <code>-verbose:gc或者-XX:+PrintGC</code>　　获取gc信息</li><li> <code>-XX:+PrintGCDetails</code>　　获取更加详细的gc信息</li><li> <code>-XX:+PrintGCTimeStamps</code>　　获取GC的频率和间隔</li><li> <code>-XX:+PrintHeapAtGC</code>　　获取堆的使用情况</li><li> <code>-Xloggc:D:\gc.log</code>　　指定日志情况的保存路径</li></ul><h3 id="jvm调优实战-tomcat启动加速"><a href="#jvm调优实战-tomcat启动加速" class="headerlink" title="jvm调优实战-tomcat启动加速"></a>jvm调优实战-tomcat启动加速</h3><p>在tomcat的bin/catalina.bat文件的开头添加相关的配置</p>]]></content>
      
      
      <categories>
          
          <category> 编程技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM (内存区域控制参数及对应溢出异常)</title>
      <link href="post/95c0309a/"/>
      <url>post/95c0309a/</url>
      
        <content type="html"><![CDATA[<blockquote><p>开发过程中，或程序运行过程中每次遇到OutOfMemory异常或GC异常或StackOverflowError异常我们都是一堆参数乱配，<br>都把值调大，只是大体知道是跟jvm内存分配有关, 具体应该怎么调，对应的异常应该调整那些参数，<br>或者换句话说，jvm内存分配区域中都分别对应那些参数大多数情况下都是不知道的，只是把相关的参数跳上去，预期结果都是应该起作用，到底能不能起作用，自己心里也没底。<br>下面就来说一下jvm堆、栈、方法区等内存区域对应的参数，及每个区域可能抛出的异常类型，发生异常的场景分析。 </p></blockquote><h3 id="参数类型"><a href="#参数类型" class="headerlink" title="参数类型"></a>参数类型</h3><ul><li>堆空间参数</li><li>栈空间参数</li><li>方法区空间参数</li><li>本机直接内存参数</li></ul><h3 id="异常类型"><a href="#异常类型" class="headerlink" title="异常类型"></a>异常类型</h3><ul><li>1.OutOfMemory异常</li><li>2.StackOverflowError异常</li></ul><h3 id="辅助参数说明"><a href="#辅助参数说明" class="headerlink" title="辅助参数说明"></a>辅助参数说明</h3><ul><li>-XX:+HeapDumpOnOutOfMemoryError 打印堆内存异常时打印出快照信息</li><li>-XX:+HeapDumpPath 快照输出路径</li><li>-Xmn指定eden区的大小</li><li>-XX:SurvirorRation来调整幸存区的大小</li><li>-XX:PretenureSizeThreshold设置进入老年代的阀值</li></ul><h3 id="参数说明、对应场景的异常"><a href="#参数说明、对应场景的异常" class="headerlink" title="参数说明、对应场景的异常"></a>参数说明、对应场景的异常</h3><h4 id="堆内存参数"><a href="#堆内存参数" class="headerlink" title="堆内存参数"></a>堆内存参数</h4><p>-Xms：堆最小值（新生代和老年代之和）</p><p>-Xmx：堆最大值（新生代和老年代之和）</p><p>当最小值=最大值时，这时堆内存是不可扩展的。</p><p>例：-Xms80M -Xmx80M</p><p>通常将-Xmx和-Xms设置为一样的大小来减少gc的次数，堆内存不足时抛出OutOfMemoryError异常。</p><h4 id="栈内存参数"><a href="#栈内存参数" class="headerlink" title="栈内存参数"></a>栈内存参数</h4><p>-Xss</p><p>例：-Xss128k</p><p>单线程下无论栈帧太大还是栈容量太小，及引用深度超过虚拟机允许深度都会抛出StackOverflowError每个方法压入栈的帧大小是不一致的。<br>多线程下当每个线程分配栈帧太大内存不能够扩展时抛出OutOfMemoryError异常线程栈帧越大，可创建的线程越少。</p><h4 id="方法区参数"><a href="#方法区参数" class="headerlink" title="方法区参数"></a>方法区参数</h4><p>-XX:PermSize方法区内存最小值</p><p>-XX:MaxPermSize 方法区内存最大值</p><p>各个线程共享的内存区域，主要用来存储类的元数据、常量、静态变量、即时编译器编译后的代码等数据</p><p>例：-XX:PermSize=20M -XX:MaxPermSize=20M</p><p>异常类型 OutOfMemoryError :</p><p>原因：常量过多，或代理反射等使用频繁</p><h4 id="本机直接内存参数"><a href="#本机直接内存参数" class="headerlink" title="本机直接内存参数"></a>本机直接内存参数</h4><p>-XX:MaxDirectMemorySize</p><p>例：-XX:MaxDirectMemorySize=10M</p><p>不足时抛出OutOfMemory异常</p>]]></content>
      
      
      <categories>
          
          <category> 编程技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM (对象访问内部实现过程)</title>
      <link href="post/e43d0ef1/"/>
      <url>post/e43d0ef1/</url>
      
        <content type="html"><![CDATA[<blockquote><p>对象访问 涉及到对象的地址变更状态变更，内存地址移动，变量、接口、实现类、方法、父类型等。</p></blockquote><h3 id="句柄方式-访问"><a href="#句柄方式-访问" class="headerlink" title="句柄方式 (访问)"></a>句柄方式 (访问)</h3><p><img src="https://github.com/cayzlh/git-img-repository/raw/master/blog/jubing.png" alt="句柄方式"></p><h3 id="指针方式-访问"><a href="#指针方式-访问" class="headerlink" title="指针方式 (访问)"></a>指针方式 (访问)</h3><p><img src="https://github.com/cayzlh/git-img-repository/raw/master/blog/zhizhen.png" alt="指针方式"></p><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p>句柄访问方式：reference中存储的是稳定的地址，对象变更时只会改变句柄实例数据指针，引用本身不需要修改。</p><p>指针访问方式：优点速度快，节省了指针定位时间开销。</p>]]></content>
      
      
      <categories>
          
          <category> 编程技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM (虚拟机内存)</title>
      <link href="post/b8276f2d/"/>
      <url>post/b8276f2d/</url>
      
        <content type="html"><![CDATA[<blockquote><p>JAVA程序运行与虚拟机之上，运行时需要内存空间。虚拟机执行JAVA程序的过程中会把它管理的内存划分为不同的数据区域方便管理。</p></blockquote><p>虚拟机管理内存数据区域划分如下图：</p><p><img src="https://github.com/cayzlh/git-img-repository/raw/master/blog/Runtime-data-area.png" alt="虚拟机管理内存数据区域划分"></p><h3 id="数据区域分类"><a href="#数据区域分类" class="headerlink" title="数据区域分类:"></a>数据区域分类:</h3><ul><li>方法区：(Method Area)</li><li>虚拟机栈：(VM Stack)</li><li>本地方法栈 ：(Native Method Stack)</li><li>堆：(Heap)</li><li>程序计数器 ：(Program Counter Register)</li><li>直接内存：(Direct Memory)</li></ul><p>说明：</p><h4 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h4><p>行号指示器，字节码指令的分支、循环、跳转、异常处理、线程恢复(CPU切换)，每条线程都需要一个独立的计数器，线程私有内存互不影响,该区域不会发生内存溢出异常。</p><h4 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h4><p>是线程私有的，声明周期与线程相同，虚拟机栈是Java方法执行的内存模型，每个方法被执行时都会创建一个栈帧，即方法运行期间的基础数据结构。<br>栈帧用于存储：局部变量表、操作数栈、动态链接、方法出口等，每个方法执行中都对应虚拟机栈帧从入栈到处栈的过程。</p><p>是一种数据结构，是虚拟机中的局部变量表，对应物理层之上的程序数据模型。</p><p>局部变量表，是一种程序运行数据模型，存放了编译期可知的各种数据类型例如：</p><p>Boolean、byte、char、short、int、float、long、double、对象引用类型(对象内存地址变量，指针或句柄)。<br>程序运行时，根据局部变量表分配栈帧空间大小，在运行中，大小是不变的异常类型：stackOverFlowError 线程请求栈深度大于虚拟机允许深度 OutOfMemory 内存空间耗尽无法进行扩展。</p><h4 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h4><p>与虚拟机栈类似，虚拟机栈为Java程序服务，本地方法栈支持虚拟机的运行服务，具体实现由虚拟机厂商决定，也会抛出 stackOverFlowError、OutOfMemory异常。</p><h4 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h4><p>是虚拟机管理内存中最大的一部分，被所有线程共享，用于存放对象实例(对象、数组)，物理上不连续的内存空间，由于GC收集器，分代收集。<br>所以划分为：新生代 Eden、From SurVivor空间、To SurVivor空间，allot buffer(分配空间)，可能会划分出多个线程私有的缓冲区，老年代。</p><h4 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h4><p>与堆一样属于线程共享的内存区域，用于存储虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码（动态加载OSGI）等数据。理论上属于java虚拟机的一部分，为了区分开来叫做 Non-Heap非堆。</p><p>这个区域可以选择不进行垃圾回收，该区域回收目的主要是常量池的回收，及类型的卸载class,内存区不足时会抛出OutOfMemory异常</p><p>运行时常量池：</p><p>方法区的一部分，Class的版本、字段、接口、方法等，及编译期生成的各种字面量、符号引用，编译类加载后存放在该区域。会抛出OutOfMemory异常。</p><h4 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h4><p>直接内存不属于虚拟内存区域，是一种基于通道与缓冲区的IO方式，可以使用本地函数直接分配堆外内存，在堆中存储引用的外部内存地址，通过引用完成对直接引用内存的操作。<br>1.4之后提供的NIO显著提高效率，避免了堆内存与Native内存的来回复制操作，不受虚拟机内存控制，会抛出OUtOfMemory异常。</p>]]></content>
      
      
      <categories>
          
          <category> 编程技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tomcat的三种接收请求处理方式</title>
      <link href="post/2815697354/"/>
      <url>post/2815697354/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Tomcat的三种接收请求方式处理: BIO、NIO、APR</p></blockquote><h3 id="BIO模式"><a href="#BIO模式" class="headerlink" title="BIO模式"></a>BIO模式</h3><p>阻塞式I/O操作，表示Tomcat使用的是传统Java I/O操作(即java.io包及其子包)。Tomcat7以下版本默认情况下是以bio模式运行的，由于每个请求都要创建一个线程来处理，线程开销较大，不能处理高并发的场景，在三种模式中性能也最低.<br>启动tomcat看到如下日志，表示使用的是BIO模式：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">06-Jul-2018 06:04:38.909 INFO [main] org.apache.coyote.AbstractProtocol.start Starting ProtocolHandler [&quot;http-bio-8080&quot;]</span><br><span class="line">06-Jul-2018 06:04:38.939 INFO [main] org.apache.coyote.AbstractProtocol.start Starting ProtocolHandler [&quot;ajp-bio-8009&quot;]</span><br></pre></td></tr></table></figure><h3 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h3><p>是Java SE 1.4及后续版本提供的一种新的I/O操作方式(即java.nio包及其子包)。是一个基于缓冲区、并能提供非阻塞I/O操作的Java API，它拥有比传统I/O操作(bio)更好的并发运行性能。要让Tomcat以nio模式来运行比较简单，只需要在Tomcat安装目录/conf/server.xml文件中将如下配置：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Connector</span> <span class="attr">port</span>=<span class="string">&quot;8080&quot;</span> <span class="attr">protocol</span>=<span class="string">&quot;HTTP/1.1&quot;</span> <span class="attr">connectionTimeout</span>=<span class="string">&quot;20000&quot;</span> <span class="attr">redirectPort</span>=<span class="string">&quot;8443&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>修改成:</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Connector</span> <span class="attr">port</span>=<span class="string">&quot;8080&quot;</span> <span class="attr">protocol</span>=<span class="string">&quot;org.apache.coyote.http11.Http11NioProtocol&quot;</span> <span class="attr">connectionTimeout</span>=<span class="string">&quot;20000&quot;</span> <span class="attr">redirectPort</span>=<span class="string">&quot;8443&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>注意：Tomcat8以上版本，默认使用的就是NIO模式，不需要额外修改 </p><h3 id="APR模式"><a href="#APR模式" class="headerlink" title="APR模式"></a>APR模式</h3><p>简单理解，就是从操作系统级别解决异步IO问题，大幅度的提高服务器的处理和响应性能， 也是Tomcat运行高并发应用的首选模式。</p><p>启用这种模式稍微麻烦一些，需要安装一些依赖库: </p><ul><li>APR 1.2+ development headers (libapr1-dev package) </li><li>OpenSSL 0.9.7+ development headers (libssl-dev package) </li><li>JNI headers from Java compatible JDK 1.4+ </li><li>GNU development environment (gcc, make)</li></ul><h4 id="启用APR模式步骤"><a href="#启用APR模式步骤" class="headerlink" title="启用APR模式步骤"></a>启用APR模式步骤</h4><h5 id="因为apr模式本质是使用JNI技术调用操作系统IO接口，需要用到相关API的头文件"><a href="#因为apr模式本质是使用JNI技术调用操作系统IO接口，需要用到相关API的头文件" class="headerlink" title="因为apr模式本质是使用JNI技术调用操作系统IO接口，需要用到相关API的头文件"></a>因为apr模式本质是使用JNI技术调用操作系统IO接口，需要用到相关API的头文件</h5><p>CentOS:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install apr-devel </span><br><span class="line">yum install openssl-devel </span><br><span class="line">yum install gcc </span><br><span class="line">yum install make</span><br></pre></td></tr></table></figure><p>Ubuntu:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install libapr1 libapr1-dev</span><br><span class="line">sudo apt-get install openssl </span><br><span class="line">sudo apt-get install libssl-dev</span><br><span class="line">sudo apt-get install gcc</span><br><span class="line">sudo apt-get install make</span><br></pre></td></tr></table></figure><h5 id="安装apr动态库"><a href="#安装apr动态库" class="headerlink" title="安装apr动态库"></a>安装apr动态库</h5><p>进入<code>tomcat</code>的<code>bin</code>目录，解压<code>tomcat-native.tar.gz</code>文件，并进入<code>tomcat-native-1.2.7-src/native</code>目录，<br>执行<code>./configure &amp;&amp; make &amp;&amp; make install</code> 命令，动态库默认安装在<code>/usr/local/apr/lib</code>目录下</p><h5 id="配置apr动态库到系统共享库搜索路径中"><a href="#配置apr动态库到系统共享库搜索路径中" class="headerlink" title="配置apr动态库到系统共享库搜索路径中"></a>配置apr动态库到系统共享库搜索路径中</h5><ul><li>方式1:</li></ul><p>设置<code>LD_LIBRARY_PATH</code>和<code>LD_RUN_PATH</code>环境变量，指向<code>/usr/local/apr/lib</code>目录，可配置到<code>$HOME/.profile</code>文件中</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/usr/local/apr/lib </span><br><span class="line">export LD_RUN_PATH=$LD_RUN_PATH:/usr/local/apr/lib</span><br></pre></td></tr></table></figure><ul><li>方式2:</li></ul><p>拷贝<code>/usr/local/apr/lib</code>目录下所有动态库到<code>/usr/lib</code>或<code>/lib</code>系统共享库搜索目录下即可。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cp /usr/local/apr/lib/libtcnative* /usr/lib/</span><br></pre></td></tr></table></figure><ul><li>方式3(推荐):</li></ul><p>编辑<code>$TOMCAT_HOME/bin/catalina.sh</code>文件，在虚拟机启动参数<code>JAVA_OPTS</code>中添加<code>java.library.path</code>参数，指定<code>apr</code>库的路径:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">JAVA_OPTS=&quot;$JAVA_OPTS -Djava.library.path=/usr/local/apr/lib&quot;</span><br></pre></td></tr></table></figure><p>Tomcat8以下版本，需要指定运行模式，将protocol从HTTP/1.1改成org.apache.coyote.http11.Http11AprProtocol</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&lt;Connector port=&quot;8080&quot; protocol=&quot;org.apache.coyote.http11.Http11AprProtocol&quot; connectionTimeout=&quot;20000&quot; redirectPort=&quot;8443&quot; /&gt;</span><br></pre></td></tr></table></figure><p><code>注意</code>:</p><p>如果没有配置<code>SSL</code>相关参数，并且开启了<code>SSL</code>，启动时会发生<code>org.apache.tomcat.jni.Error: 70023: This function has not been implemented on this platform</code>异常。</p><p>这时:</p><p>如果不想启用<code>SSL</code>，将<code>server.xml</code>中<code>apr</code>模式下<code>ssl</code>关闭即可：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&lt;Listener className=&quot;org.apache.catalina.core.AprLifecycleListener&quot; SSLEngine=&quot;on&quot; /&gt;</span><br></pre></td></tr></table></figure><p>将<code>SSLEngine</code>的值从<code>on</code>改成<code>off</code>即可：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&lt;Listener className=&quot;org.apache.catalina.core.AprLifecycleListener&quot; SSLEngine=&quot;off&quot; /&gt;</span><br></pre></td></tr></table></figure><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>Tomcat 6.x版本从6.0.32开始就默认支持apr。<br>Tomcat 7.x版本从7.0.30开始就默认支持apr。 </p>]]></content>
      
      
      <categories>
          
          <category> 笔记本 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Tomcat </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker使用MySQL</title>
      <link href="post/58787038/"/>
      <url>post/58787038/</url>
      
        <content type="html"><![CDATA[<blockquote><p>MySQL是一个广泛使用的开源关系数据库管理系统（RDBMS）。<br>记录Docker里面使用MySQL的方法</p></blockquote><h3 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull mysql</span><br></pre></td></tr></table></figure><h3 id="启用一个MySQL服务器实例"><a href="#启用一个MySQL服务器实例" class="headerlink" title="启用一个MySQL服务器实例"></a>启用一个MySQL服务器实例</h3><p>启动一个<code>MySQL</code>实例很简单:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run --name some-mysql -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql:tag</span><br></pre></td></tr></table></figure><p>some-mysql您想要分配给您的容器的名称在哪里，<code>my-secret-pw</code>是为<code>MySQL</code>根用户设置的密码，是<code>tag</code>指定您想要的<code>MySQL</code>版本的标记。</p><p>这里可以加上<code>-p</code>参数把端口映射到主机端口:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run --name some-mysql -p 3306:3306 -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql:tag</span><br></pre></td></tr></table></figure><p>这样, 就把容器的3306端口映射到宿主机器的3306端口上了, 并且可以使用<code>Navicat</code>等工具来连接<code>MySQL</code>数据库(<code>127.0.0.1:3306</code>).</p><h3 id="从另一个Docker容器中的应用程序连接到MySQL"><a href="#从另一个Docker容器中的应用程序连接到MySQL" class="headerlink" title="从另一个Docker容器中的应用程序连接到MySQL"></a>从另一个Docker容器中的应用程序连接到MySQL</h3><p>该映像公开了标准的MySQL端口（3306），因此容器链接使MySQL实例可用于其他应用程序容器。像这样启动您的应用程序容器，以便将其链接到MySQL容器：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run --name some-app --link some-mysql:mysql -d application-that-uses-mysql</span><br></pre></td></tr></table></figure><h3 id="从MySQL命令行客户端连接到MySQL"><a href="#从MySQL命令行客户端连接到MySQL" class="headerlink" title="从MySQL命令行客户端连接到MySQL"></a>从MySQL命令行客户端连接到MySQL</h3><p>以下命令将启动另一个<code>MySQL</code>容器实例，并<code>MySQL</code>针对原始<code>MySQL</code>容器运行命令行客户端，从而允许您针对数据库实例执行<code>SQL</code>语句：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -it --link some-mysql:mysql --rm mysql sh \</span><br><span class="line">-c &#x27;exec mysql -h&quot;$MYSQL_PORT_3306_TCP_ADDR&quot; -P&quot;$MYSQL_PORT_3306_TCP_PORT&quot; \</span><br><span class="line">-uroot -p&quot;$MYSQL_ENV_MYSQL_ROOT_PASSWORD&quot;&#x27;</span><br></pre></td></tr></table></figure><p><code>some-mysql</code>是你指定的<code>MySQL</code>容器名.</p><p>该映像也可以用作非Docker或远程MySQL实例的客户端：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -it --rm mysql mysql -hsome.mysql.host -usome-mysql-user -p</span><br></pre></td></tr></table></figure><p>有关MySQL命令行客户端的更多信息可以在<a href="https://dev.mysql.com/doc/refman/8.0/en/mysql.html">MySQL文档</a>中找到</p><h3 id="查看日志"><a href="#查看日志" class="headerlink" title="查看日志"></a>查看日志</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker logs some-mysql</span><br></pre></td></tr></table></figure><h3 id="进入容器"><a href="#进入容器" class="headerlink" title="进入容器"></a>进入容器</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker exec -it app_mysql  bash</span><br></pre></td></tr></table></figure><h3 id="END"><a href="#END" class="headerlink" title="END"></a>END</h3><p><a href="https://hub.docker.com/_/mysql/">https://hub.docker.com/_/mysql/</a></p>]]></content>
      
      
      <categories>
          
          <category> 笔记本 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker使用zookeeper</title>
      <link href="post/1403556454/"/>
      <url>post/1403556454/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Apache ZooKeeper是一个开源的服务器，可以实现高度可靠的分布式协调。<br>记录Docker里面使用zookeeper的方法</p></blockquote><h3 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull zookeeper</span><br></pre></td></tr></table></figure><h3 id="启动一个Zookeeper服务器实例"><a href="#启动一个Zookeeper服务器实例" class="headerlink" title="启动一个Zookeeper服务器实例"></a>启动一个Zookeeper服务器实例</h3><p>启动一个<code>zookeeper</code>实例很简单:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run --name some-zookeeper --restart always -d zookeeper</span><br></pre></td></tr></table></figure><p>由于Zookeeper “fails fast”，最好始终重新启动它。</p><p>这里可以加上<code>-p</code>参数把端口映射到主机端口:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run --name some-zookeeper -p 2181:2181 --restart always -d zookeeper</span><br></pre></td></tr></table></figure><p>这样, 就把容器的2181端口映射到宿主机器的2181端口上了, java程序等可以直接连接(127.0.0.1:2181)</p><h3 id="从另一个Docker容器中的应用程序连接到Zookeeper"><a href="#从另一个Docker容器中的应用程序连接到Zookeeper" class="headerlink" title="从另一个Docker容器中的应用程序连接到Zookeeper"></a>从另一个Docker容器中的应用程序连接到Zookeeper</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run --name some-app --link some-zookeeper:zookeeper \</span><br><span class="line">-d application-that-uses-zookeeper</span><br></pre></td></tr></table></figure><h3 id="从Zookeeper命令行客户端连接到Zookeeper"><a href="#从Zookeeper命令行客户端连接到Zookeeper" class="headerlink" title="从Zookeeper命令行客户端连接到Zookeeper"></a>从Zookeeper命令行客户端连接到Zookeeper</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -it --rm --link some-zookeeper:zookeeper zookeeper zkCli.sh -server zookeeper</span><br></pre></td></tr></table></figure><h3 id="查看日志"><a href="#查看日志" class="headerlink" title="查看日志"></a>查看日志</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker logs -f e36790ea5c5e</span><br></pre></td></tr></table></figure><p>其中<code>e36790ea5c5e</code>是容器的<code>ID</code>, 可以通过<code>docker container ls</code> 来查看.</p><h3 id="END"><a href="#END" class="headerlink" title="END"></a>END</h3><p><a href="https://hub.docker.com/_/zookeeper/">https://hub.docker.com/_/zookeeper/</a></p>]]></content>
      
      
      <categories>
          
          <category> 笔记本 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
            <tag> zookeeper </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker知识扫盲</title>
      <link href="post/3773573700/"/>
      <url>post/3773573700/</url>
      
        <content type="html"><![CDATA[<h2 id="Docker与传统虚拟机区别"><a href="#Docker与传统虚拟机区别" class="headerlink" title="Docker与传统虚拟机区别"></a>Docker与传统虚拟机区别</h2><p>容器和 <code>VM</code>（虚拟机）的主要区别是:</p><ul><li>容器提供了基于进程的隔离，而虚拟机提供了资源的完全隔离。</li><li>虚拟机可能需要一分钟来启动，而容器只需要一秒钟或更短。</li><li>容器使用宿主操作系统的内核，而虚拟机使用独立的内核。</li></ul><h2 id="Dokcer平台的基本构成"><a href="#Dokcer平台的基本构成" class="headerlink" title="Dokcer平台的基本构成"></a>Dokcer平台的基本构成</h2><ul><li>客户端：用户使用 <code>Docker</code> 提供的工具（<code>CLI</code> 以及 <code>API</code> 等）来构建，上传镜像并发布命令来创建和启动容器</li><li><code>Docker</code> 主机：从 <code>Docker registry</code> 上下载镜像并启动容器</li><li><code>Docker registry</code>：<code>Docker</code> 镜像仓库，用于保存镜像，并提供镜像上传和下载</li></ul><h2 id="Docker容器的状态机"><a href="#Docker容器的状态机" class="headerlink" title="Docker容器的状态机"></a>Docker容器的状态机</h2><p>一个容器在某个时刻可能处于以下几种状态之一：</p><ul><li><code>created</code>：已经被创建 （使用 docker ps -a 命令可以列出）但是还没有被启动 （使用 docker ps 命令还无法列出）</li><li><code>running</code>：运行中</li><li><code>paused</code>：容器的进程被暂停了</li><li><code>restarting</code>：容器的进程正在重启过程中</li><li><code>exited</code>：上图中的 stopped 状态，表示容器之前运行过但是现在处于停止状态（要区别于 <code>created</code> 状态，它是指一个新创出的尚未运行过的容器）。可以通过 <code>start</code> 命令使其重新进入 <code>running</code> 状态</li><li><code>destroyed</code>：容器被删除了，再也不存在了</li></ul><h2 id="Dokcer命令"><a href="#Dokcer命令" class="headerlink" title="Dokcer命令"></a>Dokcer命令</h2><p>把<code>Docker</code>的命令大概分类。</p><h3 id="镜像操作"><a href="#镜像操作" class="headerlink" title="镜像操作"></a>镜像操作</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">build     Build an image from a Dockerfile</span><br><span class="line">commit    Create a new image from a container&#39;s changes</span><br><span class="line">images    List images</span><br><span class="line">load      Load an image from a tar archive or STDIN</span><br><span class="line">pull      Pull an image or a repository from a registry</span><br><span class="line">push      Push an image or a repository to a registry</span><br><span class="line">rmi       Remove one or more images</span><br><span class="line">search    Search the Docker Hub for images</span><br><span class="line">tag       Tag an image into a repository</span><br><span class="line">save      Save one or more images to a tar archive </span><br><span class="line">history   显示某镜像的历史</span><br><span class="line">inspect   获取镜像的详细信息</span><br></pre></td></tr></table></figure><h3 id="容器及其中应用的生命周期操作"><a href="#容器及其中应用的生命周期操作" class="headerlink" title="容器及其中应用的生命周期操作"></a>容器及其中应用的生命周期操作</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">create    创建一个容器</span><br><span class="line">kill      Kill one or more running containers</span><br><span class="line">inspect   Return low-level information on a container, image or task</span><br><span class="line">pause     Pause all processes within one or more containers</span><br><span class="line">ps        List containers</span><br><span class="line">rm        删除一个或者多个容器</span><br><span class="line">rename    Rename a container</span><br><span class="line">restart   Restart a container</span><br><span class="line">run       创建并启动一个容器</span><br><span class="line">start     启动一个处于停止状态的容器</span><br><span class="line">stats     显示容器实时的资源消耗信息</span><br><span class="line">stop      停止一个处于运行状态的容器</span><br><span class="line">top       Display the running processes of a container</span><br><span class="line">unpause   Unpause all processes within one or more containers</span><br><span class="line">update    Update configuration of one or more containers</span><br><span class="line">wait      Block until a container stops, then print its exit code</span><br><span class="line">attach    Attach to a running container</span><br><span class="line">exec      Run a command in a running container</span><br><span class="line">port      List port mappings or a specific mapping for the container</span><br><span class="line">logs      获取容器的日志</span><br></pre></td></tr></table></figure><h3 id="容器文件系统操作"><a href="#容器文件系统操作" class="headerlink" title="容器文件系统操作"></a>容器文件系统操作</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cp        Copy files&#x2F;folders between a container and the local filesystem</span><br><span class="line">diff      Inspect changes on a container&#39;s filesystem</span><br><span class="line">export    Export a container&#39;s filesystem as a tar archive</span><br><span class="line">import    Import the contents from a tarball to create a filesystem image</span><br></pre></td></tr></table></figure><h3 id="Docker-registry操作"><a href="#Docker-registry操作" class="headerlink" title="Docker registry操作"></a>Docker registry操作</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">login     Log in to a Docker registry.</span><br><span class="line">logout    Log out from a Docker registry.</span><br></pre></td></tr></table></figure><h3 id="Volume操作"><a href="#Volume操作" class="headerlink" title="Volume操作"></a>Volume操作</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">volume    Manage Docker volumes</span><br></pre></td></tr></table></figure><h3 id="网络操作"><a href="#网络操作" class="headerlink" title="网络操作"></a>网络操作</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">network   Manage Docker networks</span><br></pre></td></tr></table></figure><h3 id="Swarm相关操作"><a href="#Swarm相关操作" class="headerlink" title="Swarm相关操作"></a>Swarm相关操作</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">swarm     Manage Docker Swarm</span><br><span class="line">service   Manage Docker services</span><br><span class="line">node      Manage Docker Swarm nodes</span><br></pre></td></tr></table></figure><h3 id="系统操作"><a href="#系统操作" class="headerlink" title="系统操作"></a>系统操作</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">version   Show the Docker version information</span><br><span class="line">events    持续返回docker 事件</span><br><span class="line">info      显示Docker 主机系统范围内的信息</span><br></pre></td></tr></table></figure><h3 id="容器相关"><a href="#容器相关" class="headerlink" title="容器相关"></a>容器相关</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看运行中的容器</span></span><br><span class="line">docker ps</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看所有容器</span></span><br><span class="line">docker ps -a</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 退出容器</span></span><br><span class="line">按Ctrl+D 即可退出当前容器【但退出后会停止容器】</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 退出不停止容器：</span></span><br><span class="line">组合键：Ctrl+P+Q</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动容器</span></span><br><span class="line">docker start 容器名或ID</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 进入容器</span></span><br><span class="line">docker attach 容器名或ID</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 停止容器</span></span><br><span class="line">docker stop 容器名或ID</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 暂停容器</span></span><br><span class="line">docker pause 容器名或ID</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">继续容器</span></span><br><span class="line">docker unpause 容器名或ID</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除容器</span></span><br><span class="line">docker rm 容器名或ID</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除全部容器--慎用</span></span><br><span class="line">docker stop $(docker ps -q) &amp; docker rm $(docker ps -aq)</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">保存容器，生成镜像</span></span><br><span class="line">docker commit 容器ID 镜像名称</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">从 host 拷贝文件到 container 里面</span></span><br><span class="line">docker cp /home/soft centos:/webapp</span><br></pre></td></tr></table></figure><h2 id="docker-run-和start的区别"><a href="#docker-run-和start的区别" class="headerlink" title="docker run 和start的区别"></a>docker run 和start的区别</h2><p><code>docker run</code> 只在第一次运行时使用，将镜像放到容器中，以后再次启动这个容器时，只需要使用命令<code>docker start</code> 即可。</p><ul><li><p><code>docker run</code>相当于执行了两步操作：将镜像放入容器中（<code>docker create</code>）,然后将容器启动，使之变成运行时容器（<code>docker start</code>）。</p></li><li><p><code>docker start</code>的作用是，重新启动已存在的镜像。也就是说，如果使用这个命令，我们必须事先知道这个容器的<code>ID</code>，或者这个容器的名字，我们可以使用<code>docker ps</code>找到这个容器的信息。</p></li></ul><h2 id="docker配置"><a href="#docker配置" class="headerlink" title="docker配置"></a>docker配置</h2><p>更改存储目录：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">复制docker存储目录</span></span><br><span class="line">rsync -aXS /var/lib/docker/. /home/docker</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">更改 docker 存储文件目录</span></span><br><span class="line">ln -s  /home/docker  /var/lib/docker</span><br></pre></td></tr></table></figure><p>获取ip：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker inspect &lt;container id&gt;</span><br></pre></td></tr></table></figure><p>要获取所有容器名称及其IP地址只需一个命令：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker inspect -f &#x27;&#123;&#123;.Name&#125;&#125; - &#123;&#123;.NetworkSettings.IPAddress &#125;&#125;&#x27; $(docker ps -aq)</span><br><span class="line"></span><br><span class="line">docker inspect --format=&#x27;&#123;&#123;.Name&#125;&#125; - &#123;&#123;range .NetworkSettings.Networks&#125;&#125;&#123;&#123;.IPAddress&#125;&#125;&#123;&#123;end&#125;&#125;&#x27; $(docker ps -aq)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记本 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux配置ssh使用公钥登录远程服务器</title>
      <link href="post/1568854505/"/>
      <url>post/1568854505/</url>
      
        <content type="html"><![CDATA[<h3 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h3><p><code>Windows</code>更新了<code>Ubuntu18.04</code>子系统, 于是就下载下来体验一波, 结果发现, 稍微设置一下, 很合我的胃口…</p><p>对我来说, 用虚拟机来做开发服务器的, 什么<code>Vmware</code>、<code>VirtureBox</code>之类的, 统统可以卸载了啊…</p><p><img src="https://github.com/cayzlh/git-img-repository/raw/master/blog/ubuntu18.04.png" alt="Ubuntu18.04子系统"></p><p>用了一段时间之后, 就想着, 这个界面挺不错的, 那直接拿这个来当<code>ssh</code>客户端好了, 什么<code>XShell</code>之类的也可以卸载了啊…</p><p>但是为题来, 每次使用<code>ssh</code>连接远程服务器, 都有输入密码, 有些密码及其复杂, 根本不可能记得住, 这咋搞, 于是乎….</p><p>来折腾一波<code>ssh</code>直接连接远程服务器的配置过程…</p><h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><h4 id="安装openssh-server"><a href="#安装openssh-server" class="headerlink" title="安装openssh-server"></a>安装openssh-server</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install openssh-server</span><br></pre></td></tr></table></figure><p>依次执行以上命令, 安装<code>ssh</code>服务, 通常情况下, 子系统下已经安装好了这个服务了, 那就可以忽略这一步.</p><h4 id="生成公钥和密钥"><a href="#生成公钥和密钥" class="headerlink" title="生成公钥和密钥"></a>生成公钥和密钥</h4><p>使用当前用户执行</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh-keygen</span><br></pre></td></tr></table></figure><p>一直安回车,生成的公钥和密钥在用户文件夹下的 <code>~/.ssh</code>.</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat ~/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure><p>执行上面的命令, 将公钥的内容复制到粘贴板</p><h4 id="在远程服务器上操作-远程服务器ssh服务装好的情况"><a href="#在远程服务器上操作-远程服务器ssh服务装好的情况" class="headerlink" title="在远程服务器上操作(远程服务器ssh服务装好的情况)"></a>在远程服务器上操作(远程服务器ssh服务装好的情况)</h4><h5 id="登录远程服务器执行"><a href="#登录远程服务器执行" class="headerlink" title="登录远程服务器执行:"></a>登录远程服务器执行:</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vi ~/.ssh/authorized_keys</span><br></pre></td></tr></table></figure><p>将粘贴板的内容复制到文件中,或者利用<code>sftp</code>工具, 将本地的<code>id_rsa.pub</code>上传到远程服务器,执行</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys</span><br></pre></td></tr></table></figure><h5 id="用vi打开-etc-ssh-sshd-config这个文件"><a href="#用vi打开-etc-ssh-sshd-config这个文件" class="headerlink" title="用vi打开/etc/ssh/sshd_config这个文件"></a>用vi打开/etc/ssh/sshd_config这个文件</h5><p>将下面几行前面“#”注释取掉</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">RSAAuthentication yes </span><br><span class="line">PubkeyAuthentication yes </span><br><span class="line">AuthorizedKeysFile .ssh/authorized_keys</span><br></pre></td></tr></table></figure><h5 id="重启ssh服务"><a href="#重启ssh服务" class="headerlink" title="重启ssh服务"></a>重启ssh服务</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">service sshd restart</span><br></pre></td></tr></table></figure><h3 id="本地操作"><a href="#本地操作" class="headerlink" title="本地操作"></a>本地操作</h3><h4 id="在-ssh-中创建config文件"><a href="#在-ssh-中创建config文件" class="headerlink" title="在~/.ssh/中创建config文件"></a>在~/.ssh/中创建config文件</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vi ~/.ssh/config</span><br></pre></td></tr></table></figure><p>填入如下内容:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Host AAAAAA</span><br><span class="line">HostName youipaddress</span><br><span class="line">User root</span><br><span class="line">Port 22</span><br><span class="line">IdentityFile /home/yourusername/.ssh/id_rsa</span><br></pre></td></tr></table></figure><p>其中</p><ol><li>Host 是别名</li><li>HostName ip地址</li><li>User 远程服务器的登录用户名</li><li>Port 远程登录的ssh端口与</li><li>IdentityFile 本地服务器的私钥地址</li></ol><p><img src="https://github.com/cayzlh/git-img-repository/raw/master/blog/sshconfig.png" alt="config配置"></p><h4 id="修改config文件的权限"><a href="#修改config文件的权限" class="headerlink" title="修改config文件的权限"></a>修改config文件的权限</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chmod 700 ~/.ssh/config</span><br></pre></td></tr></table></figure><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>输入以下命令, 就可以直接连接远程服务器了, 其中<code>AAAAAA</code>是<code>config</code>文件中指定的<code>Host</code>的值…</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh AAAAAA</span><br></pre></td></tr></table></figure><p><img src="https://github.com/cayzlh/git-img-repository/raw/master/blog/sshlink.png" alt="ssh连接"></p><h3 id="END"><a href="#END" class="headerlink" title="END"></a>END</h3><p> emmmmmmmmmmmm,  Enjoy it !!</p>]]></content>
      
      
      <categories>
          
          <category> 笔记本 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> ssh </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>利用Github做Maven私服</title>
      <link href="post/3486685421/"/>
      <url>post/3486685421/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关于GitHub的骚操作一直以来都有很多，这篇文章记录一下使用GitHub来做免费maven 私服的方法。</p></blockquote><h2 id="发布到GitHub"><a href="#发布到GitHub" class="headerlink" title="发布到GitHub"></a>发布到GitHub</h2><h3 id="修改setting-xml"><a href="#修改setting-xml" class="headerlink" title="修改setting.xml"></a>修改setting.xml</h3><p>修改<code>maven</code>的<code>setting.xml</code>文件，在<code>servers</code>节点下添加</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">server</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">id</span>&gt;</span>github<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">username</span>&gt;</span>yourname<span class="tag">&lt;/<span class="name">username</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">password</span>&gt;</span>yourpassword<span class="tag">&lt;/<span class="name">password</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">server</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="使用maven插件"><a href="#使用maven插件" class="headerlink" title="使用maven插件"></a>使用maven插件</h3><p>修改项目工程的<code>pom.xml</code>文件，添加以下两个插件：</p><h4 id="maven-deploy-plugin"><a href="#maven-deploy-plugin" class="headerlink" title="maven-deploy-plugin"></a>maven-deploy-plugin</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-deploy-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.8.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">altDeploymentRepository</span>&gt;</span></span><br><span class="line">      internal.repo::default::file://$&#123;project.build.directory&#125;/maven-repo</span><br><span class="line">    <span class="tag">&lt;/<span class="name">altDeploymentRepository</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="site-maven-plugin"><a href="#site-maven-plugin" class="headerlink" title="site-maven-plugin"></a>site-maven-plugin</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.github<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>site-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">message</span>&gt;</span>🐳 deploy maven artifacts, version: $&#123;project.version&#125;<span class="tag">&lt;/<span class="name">message</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">noJekyll</span>&gt;</span>true<span class="tag">&lt;/<span class="name">noJekyll</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">outputDirectory</span>&gt;</span>$&#123;project.build.directory&#125;/maven-repo<span class="tag">&lt;/<span class="name">outputDirectory</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--本地jar地址--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">branch</span>&gt;</span>refs/heads/master<span class="tag">&lt;/<span class="name">branch</span>&gt;</span><span class="comment">&lt;!--分支的名称--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">merge</span>&gt;</span>true<span class="tag">&lt;/<span class="name">merge</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">repositoryName</span>&gt;</span>maven-repo<span class="tag">&lt;/<span class="name">repositoryName</span>&gt;</span><span class="comment">&lt;!--对应github上创建的仓库名称 name--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">repositoryOwner</span>&gt;</span>cayzlh<span class="tag">&lt;/<span class="name">repositoryOwner</span>&gt;</span><span class="comment">&lt;!--github 仓库所有者即登录用户名--&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">goal</span>&gt;</span>site<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">phase</span>&gt;</span>deploy<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure><p>###deploy</p><p>执行命令进行打包：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mvn clean package</span><br></pre></td></tr></table></figure><blockquote><p>好像可以不用打包</p></blockquote><p>在<code>idea</code>左侧<code>lifecycle</code>中双击<code>deploy</code>：</p><p><img src="https://gitee.com/cayzlh/img-repo/raw/master/2020/04/23/FNGZ7J.png" alt="image-20200423221908456"></p><p>静静等待…..</p><p><img src="https://gitee.com/cayzlh/img-repo/raw/master/2020/04/23/uPEUku.png" alt="image-20200423222621366"></p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>在需要使用到私服的项目<code>pom.xml</code>文件中添加：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">repositories</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>maven-repo<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://raw.githubusercontent.com/yourname/maven-repo/master/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">releases</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">releases</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">snapshots</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>false<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="Enjoy-it"><a href="#Enjoy-it" class="headerlink" title="Enjoy it."></a>Enjoy it.</h3>]]></content>
      
      
      <categories>
          
          <category> 笔记本 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Github </tag>
            
            <tag> Maven </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot实现Jwt单点登录</title>
      <link href="post/1568928662/"/>
      <url>post/1568928662/</url>
      
        <content type="html"><![CDATA[<blockquote><p>安全管理是应用系统不可缺少的功能. 本文主要分享借助JWT的token技术实现分布式系统的安全管理.</p></blockquote><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>JSON Web Tokens(JWT)是一种开放的、行业标准(RFC 7519)，用于网络应用环境间安全传递声明。JWT的声明一般被用来在身份提供者和服务提供者间传递被认证的用户身份信息，以便于从资源服务器获取资源，也可以增加一些额外的业务逻辑所须的声明信息。</p><h4 id="JWT特点："><a href="#JWT特点：" class="headerlink" title="JWT特点："></a>JWT特点：</h4><p>▷ 跨语言:支持Python、Node.js、Java、Go、c、JavaScript等主流语言</p><p>▷ 自包含：包含了必要的所有信息，如用户信息和签名等</p><p>▷ 易传递：很方便通过HTTP头部传递</p><p>官网位置：<a href="https://jwt.io/">https://jwt.io</a></p><h3 id="JWT原理"><a href="#JWT原理" class="headerlink" title="JWT原理"></a>JWT原理</h3><h4 id="JWT的token组成"><a href="#JWT的token组成" class="headerlink" title="JWT的token组成"></a>JWT的token组成</h4><p> JWT的token是三段由小数点分隔组成的字符串,如 aaaa.bbbb.ccccc，这三部分含义分别是header、payload、signature。</p><h5 id="header"><a href="#header" class="headerlink" title="header"></a>header</h5><p>头部包含了两部分：类型和使用的哈希算法（如HMAC SHA256）：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;typ&quot;</span>: <span class="string">&quot;JWT&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;alg&quot;</span>: <span class="string">&quot;HS256&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="payload"><a href="#payload" class="headerlink" title="payload"></a>payload</h5><p>也称为JWT claims，放置需要传输的信息，有三类：保留claims、公共claims、私有claims。</p><p>▷ 保留claims，主要包括iss发行者、exp过期时间、sub主题、aud用户等 </p><p>▷ 公共claims，定义新创的信息，比如用户信息和其他重要信息</p><p>▷ 私有claims，用于发布者和消费者都同意以私有的方式使用的信息</p><p>JWT示例：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">&quot;iss&quot;</span>: <span class="string">&quot;jwt.io&quot;</span>,</span><br><span class="line"><span class="attr">&quot;exp&quot;</span>: <span class="number">1496199995458</span>,</span><br><span class="line"><span class="attr">&quot;name&quot;</span>: <span class="string">&quot;sinwaj&quot;</span>,</span><br><span class="line"><span class="attr">&quot;role&quot;</span>: <span class="string">&quot;admin&quot;</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="signature"><a href="#signature" class="headerlink" title="signature"></a>signature</h5><p>  需要采用编码的header、编码的payload、secret，使用header中指定的算法进行签名。 </p><p>JWT提供下述功能：<br>▷ 某种程度的用户身份验证<br>▷ 使用密钥签名<br>▷ 客户端每个请求都带有JWT<br>▷ 服务器使用密钥分析和检查claims</p><p>以上摘自公众号: <code>中兴开发者社区</code></p><hr><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><h4 id="项目地址"><a href="#项目地址" class="headerlink" title="项目地址"></a>项目地址</h4><p><a href="https://github.com/cayzlh/springboot-jwt-demo">https://github.com/cayzlh/springboot-jwt-demo</a></p><h4 id="自定义Jwt登录拦截器"><a href="#自定义Jwt登录拦截器" class="headerlink" title="自定义Jwt登录拦截器"></a>自定义Jwt登录拦截器</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.cayzlh.jwt.security.filter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.cayzlh.jwt.exception.BaseException;</span><br><span class="line"><span class="keyword">import</span> com.cayzlh.jwt.security.dto.AuthenticationRequest;</span><br><span class="line"><span class="keyword">import</span> com.cayzlh.jwt.security.jwt.JwtTokenUtil;</span><br><span class="line"><span class="keyword">import</span> com.cayzlh.jwt.security.service.UserDetailsServiceImpl;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.ObjectMapper;</span><br><span class="line"><span class="keyword">import</span> com.google.common.base.Preconditions;</span><br><span class="line"><span class="keyword">import</span> com.google.common.collect.Lists;</span><br><span class="line"><span class="keyword">import</span> org.apache.log4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.authentication.AuthenticationManager;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.authentication.UsernamePasswordAuthenticationToken;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.Authentication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.AuthenticationException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.UserDetails;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.FilterChain;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Description:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 验证用户名密码是否正确, 生成一个token, 并将token返回给客户端</span></span><br><span class="line"><span class="comment"> * 该类继承自UsernamePasswordAuthenticationFilter，重写了其中的2个方法</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * attemptAuthentication ：接收并解析用户凭证。</span></span><br><span class="line"><span class="comment"> * successfulAuthentication ：用户成功登录后，这个方法会被调用，我们在这个方法里生成token。</span></span><br><span class="line"><span class="comment"> * &lt;/p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Ant丶</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018-05-11.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginFilter</span> <span class="keyword">extends</span> <span class="title">UsernamePasswordAuthenticationFilter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = Logger.getLogger(LoginFilter.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> AuthenticationManager authenticationManager;</span><br><span class="line">    <span class="keyword">private</span> JwtTokenUtil jwtTokenUtil;</span><br><span class="line">    <span class="keyword">private</span> UserDetailsServiceImpl jwtUserDetailsService;</span><br><span class="line">    <span class="keyword">private</span> String tokenHeader;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LoginFilter</span><span class="params">(AuthenticationManager authenticationManager, JwtTokenUtil jwtTokenUtil, UserDetailsServiceImpl jwtUserDetailsService, String tokenHeader)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.authenticationManager = authenticationManager;</span><br><span class="line">        <span class="keyword">this</span>.jwtTokenUtil = jwtTokenUtil;</span><br><span class="line">        <span class="keyword">this</span>.jwtUserDetailsService = jwtUserDetailsService;</span><br><span class="line">        <span class="keyword">this</span>.tokenHeader = tokenHeader;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 接收并解析用户凭证</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request request</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> response response</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> AuthenticationException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Authentication <span class="title">attemptAuthentication</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> AuthenticationException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            AuthenticationRequest user = <span class="keyword">new</span> ObjectMapper().readValue(request.getInputStream(), AuthenticationRequest.class);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> authenticationManager.authenticate(</span><br><span class="line">                    <span class="keyword">new</span> UsernamePasswordAuthenticationToken(user.getUsername(), user.getPassword(), Lists.newArrayList())</span><br><span class="line">            );</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;[LoginFilter][attemptAuthentication()]&quot;</span>, e);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BaseException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用户成功登录后</span></span><br><span class="line"><span class="comment">     *      这个方法会被调用,  在这里生成token</span></span><br><span class="line"><span class="comment"> *      设置到header里面返回</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request request</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> response response</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> chain chain</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> authResult authResult</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> ServletException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">successfulAuthentication</span><span class="params">(HttpServletRequest request, HttpServletResponse response, FilterChain chain, Authentication authResult)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        UserDetails userDetails = jwtUserDetailsService.loadUserByUsername(authResult.getName());</span><br><span class="line">        Preconditions.checkNotNull(userDetails);</span><br><span class="line">        String token = jwtTokenUtil.generateToken(userDetails);</span><br><span class="line">        response.addHeader(tokenHeader, <span class="string">&quot;Bearer &quot;</span> + token);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="自定义Jwt认证拦截器"><a href="#自定义Jwt认证拦截器" class="headerlink" title="自定义Jwt认证拦截器"></a>自定义Jwt认证拦截器</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.cayzlh.jwt.security.filter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.cayzlh.jwt.security.jwt.JwtTokenUtil;</span><br><span class="line"><span class="keyword">import</span> io.jsonwebtoken.ExpiredJwtException;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.lang3.StringUtils;</span><br><span class="line"><span class="keyword">import</span> org.apache.log4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.authentication.AuthenticationManager;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.authentication.UsernamePasswordAuthenticationToken;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.context.SecurityContextHolder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.UserDetails;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.UserDetailsService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.web.AuthenticationEntryPoint;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.web.authentication.WebAuthenticationDetailsSource;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.web.authentication.www.BasicAuthenticationFilter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.FilterChain;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Description:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> *     Jwt token认证拦截器</span></span><br><span class="line"><span class="comment"> *          如果校验通过, 就认为这是一个合法的请求</span></span><br><span class="line"><span class="comment"> * &lt;/p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Ant丶</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018-05-10.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AuthorizationTokenFilter</span> <span class="keyword">extends</span> <span class="title">BasicAuthenticationFilter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = Logger.getLogger(AuthorizationTokenFilter.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> UserDetailsService userDetailsService;</span><br><span class="line">    <span class="keyword">private</span> JwtTokenUtil jwtTokenUtil;</span><br><span class="line">    <span class="keyword">private</span> String tokenHeader;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AuthorizationTokenFilter</span><span class="params">(AuthenticationManager authenticationManager, AuthenticationEntryPoint authenticationEntryPoint, UserDetailsService userDetailsService, JwtTokenUtil jwtTokenUtil, String tokenHeader)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>(authenticationManager, authenticationEntryPoint);</span><br><span class="line"><span class="keyword">this</span>.userDetailsService = userDetailsService;</span><br><span class="line"><span class="keyword">this</span>.jwtTokenUtil = jwtTokenUtil;</span><br><span class="line"><span class="keyword">this</span>.tokenHeader = tokenHeader;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doFilterInternal</span><span class="params">(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, FilterChain filterChain)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        logger.debug(<span class="string">&quot;processing authentication for &#x27;&quot;</span>+httpServletRequest.getRequestURL()+<span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> String requestHeader = httpServletRequest.getHeader(<span class="keyword">this</span>.tokenHeader);</span><br><span class="line"></span><br><span class="line">        String username = <span class="keyword">null</span>;</span><br><span class="line">        String authToken = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isNotBlank(requestHeader) &amp;&amp; requestHeader.startsWith(<span class="string">&quot;Bearer &quot;</span>)) &#123;</span><br><span class="line">            authToken = requestHeader.substring(<span class="number">7</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                username = jwtTokenUtil.getUsernameFromToken(authToken);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IllegalArgumentException e) &#123;</span><br><span class="line">                logger.error(<span class="string">&quot;从令牌[&quot;</span>+authToken+<span class="string">&quot;]获取用户名期间发生错误&quot;</span>, e);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ExpiredJwtException e) &#123;</span><br><span class="line">                logger.error(<span class="string">&quot;令牌[&quot;</span>+authToken+<span class="string">&quot;]已过期并且不再有效&quot;</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            logger.debug(<span class="string">&quot;找不到Bearer字符串, 忽略Header继续.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        logger.debug(<span class="string">&quot;检查用户[&quot;</span>+username+<span class="string">&quot;]的身份验证&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isNotBlank(username) &amp;&amp; <span class="keyword">null</span> == SecurityContextHolder.getContext().getAuthentication()) &#123;</span><br><span class="line">            logger.debug(<span class="string">&quot;security context为空, 授权用户&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从数据库加载使用使用细节并不是必需的, 也可以存储信息在令牌中读取它并从中读取它.</span></span><br><span class="line">            UserDetails userDetails = <span class="keyword">this</span>.userDetailsService.loadUserByUsername(username);</span><br><span class="line"></span><br><span class="line"><span class="comment">//对于简单的验证，仅检查令牌完整性就足够了, 不需要引人注目地调用数据库.</span></span><br><span class="line">            <span class="keyword">if</span> (jwtTokenUtil.validateToken(authToken, userDetails)) &#123;</span><br><span class="line">                UsernamePasswordAuthenticationToken authentication = <span class="keyword">new</span> UsernamePasswordAuthenticationToken(userDetails, <span class="keyword">null</span>, userDetails.getAuthorities());</span><br><span class="line">                authentication.setDetails(<span class="keyword">new</span> WebAuthenticationDetailsSource().buildDetails(httpServletRequest));</span><br><span class="line">                logger.info(<span class="string">&quot;认证用户 [&quot;</span>+username+<span class="string">&quot;], 设置 security到context上下文&quot;</span>);</span><br><span class="line">                SecurityContextHolder.getContext().setAuthentication(authentication);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        filterChain.doFilter(httpServletRequest, httpServletResponse);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="自定义身份验证组件"><a href="#自定义身份验证组件" class="headerlink" title="自定义身份验证组件"></a>自定义身份验证组件</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.cayzlh.jwt.security.provider;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.cayzlh.jwt.security.dto.GrantedAuthorityImpl;</span><br><span class="line"><span class="keyword">import</span> com.google.common.base.Preconditions;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.authentication.AuthenticationProvider;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.authentication.BadCredentialsException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.authentication.UsernamePasswordAuthenticationToken;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.Authentication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.AuthenticationException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.GrantedAuthority;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.UserDetails;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.UserDetailsService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.UsernameNotFoundException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.util.DigestUtils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Description:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> *     自定义身份验证组件</span></span><br><span class="line"><span class="comment"> * &lt;/p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Ant丶</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018-05-11.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomAuthenticationProvider</span> <span class="keyword">implements</span> <span class="title">AuthenticationProvider</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> UserDetailsService userDetailsService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> BCryptPasswordEncoder bCryptPasswordEncoder;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CustomAuthenticationProvider</span><span class="params">(UserDetailsService userDetailsService, BCryptPasswordEncoder bCryptPasswordEncoder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userDetailsService = userDetailsService;</span><br><span class="line">        <span class="keyword">this</span>.bCryptPasswordEncoder = bCryptPasswordEncoder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Authentication <span class="title">authenticate</span><span class="params">(Authentication authentication)</span> <span class="keyword">throws</span> AuthenticationException </span>&#123;</span><br><span class="line">        String name = authentication.getName();</span><br><span class="line">        String password = authentication.getCredentials().toString();</span><br><span class="line"></span><br><span class="line">        Preconditions.checkNotNull(name);</span><br><span class="line">        Preconditions.checkNotNull(password);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// TODO　重新整理逻辑</span></span><br><span class="line">        UserDetails userDetails = userDetailsService.loadUserByUsername(name);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != userDetails) &#123;</span><br><span class="line">            String encodePassword = DigestUtils.md5DigestAsHex((password).getBytes());</span><br><span class="line">            <span class="keyword">if</span> (userDetails.getPassword().equalsIgnoreCase(encodePassword)) &#123;</span><br><span class="line">                <span class="comment">// TODO 设置权限</span></span><br><span class="line">                ArrayList&lt;GrantedAuthority&gt; authorities = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                authorities.add( <span class="keyword">new</span> GrantedAuthorityImpl(<span class="string">&quot;ROLE_ADMIN&quot;</span>) );</span><br><span class="line">                authorities.add( <span class="keyword">new</span> GrantedAuthorityImpl(<span class="string">&quot;AUTH_WRITE&quot;</span>) );</span><br><span class="line">                <span class="comment">// 生成令牌 这里令牌里面存入了:name,password,authorities, 当然你也可以放其他内容 todo 不要放密码</span></span><br><span class="line">                Authentication auth = <span class="keyword">new</span> UsernamePasswordAuthenticationToken(name, password, authorities);</span><br><span class="line">                <span class="keyword">return</span> auth;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BadCredentialsException(<span class="string">&quot;Password verification failed.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UsernameNotFoundException(<span class="string">&quot;Username does not exist.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否可以提供输入类型的认证服务</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> authentication auth</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 是否可以提供输入类型的认证服务</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(Class&lt;?&gt; authentication)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> authentication.equals(UsernamePasswordAuthenticationToken.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">String encodePassword = DigestUtils.md5DigestAsHex((<span class="string">&quot;Aa262535636@@&quot;</span>).getBytes());</span><br><span class="line">System.out.println(encodePassword);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="配置Security"><a href="#配置Security" class="headerlink" title="配置Security"></a>配置Security</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity httpSecurity)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// jwt登录拦截器</span></span><br><span class="line">    LoginFilter jwtLoginFilter = <span class="keyword">new</span> LoginFilter(authenticationManager(), jwtTokenUtil, jwtUserDetailsService, tokenHeader);</span><br><span class="line">    <span class="comment">// 自定义Jwt认证拦截器</span></span><br><span class="line">    AuthorizationTokenFilter authenticationTokenFilter = <span class="keyword">new</span> AuthorizationTokenFilter(authenticationManager(), unauthorizedHandler, userDetailsService(), jwtTokenUtil, tokenHeader);</span><br><span class="line"></span><br><span class="line">    httpSecurity</span><br><span class="line">            <span class="comment">// 不使用CSRF</span></span><br><span class="line">            .cors().and().csrf().disable()</span><br><span class="line">            <span class="comment">// 不创建session</span></span><br><span class="line">            .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS).and()</span><br><span class="line">            <span class="comment">// 异常处理</span></span><br><span class="line">            .exceptionHandling().authenticationEntryPoint(unauthorizedHandler).and()</span><br><span class="line"></span><br><span class="line">            .authorizeRequests()</span><br><span class="line"></span><br><span class="line">            .antMatchers(HttpMethod.POST, <span class="string">&quot;/auth/**&quot;</span>).permitAll()</span><br><span class="line"></span><br><span class="line">            .anyRequest().authenticated()</span><br><span class="line"></span><br><span class="line">            .and()</span><br><span class="line">            .addFilter(jwtLoginFilter)</span><br><span class="line">            .addFilter(authenticationTokenFilter)</span><br><span class="line"></span><br><span class="line">            .logout().logoutUrl(<span class="string">&quot;/auth/logout&quot;</span>)</span><br><span class="line">            .logoutSuccessUrl(<span class="string">&quot;/auth/login&quot;</span>)</span><br><span class="line">            .permitAll()</span><br><span class="line"></span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// disable page caching</span></span><br><span class="line">    httpSecurity</span><br><span class="line">            .headers()</span><br><span class="line">            .frameOptions().sameOrigin()  <span class="comment">// required to set for H2 else H2 Console will be blank.</span></span><br><span class="line">            .cacheControl();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要代码如上</p><hr><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><h4 id="编写一个测试的controller"><a href="#编写一个测试的controller" class="headerlink" title="编写一个测试的controller"></a>编写一个测试的controller</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(value = &quot;/jwt&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping(value = &quot;/test&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">restTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;hello .&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用Posman访问"><a href="#使用Posman访问" class="headerlink" title="使用Posman访问"></a>使用<code>Posman</code>访问</h4><p><img src="https://github.com/cayzlh/git-img-repository/raw/master/blog/%E6%97%A0%E6%9D%83%E9%99%90.png"></p><p>可以看到, 直接抛出<code>Unauthorized</code>错误</p><h4 id="登录获取token"><a href="#登录获取token" class="headerlink" title="登录获取token"></a>登录获取token</h4><p>访问 <code>http://localhost:8080/login</code>, 这是<code>security</code>自带的登录接口, 不需要自己定义:</p><p><img src="https://github.com/cayzlh/git-img-repository/raw/master/blog/%E7%99%BB%E5%BD%95.png"></p><p>可以看到, 在返回的<code>Header</code>中多了</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Authorization →Bearer eyJhbGciOiJIUzUxMiJ9.eyJzdWIiOiJjaGVuYW55dSIsImV4cCI6MTU0NjA1MzExNywiaWF0IjoxNTI3OTA5MTE3fQ.N37plSdzjBMkw5BoZQWXxVA8bobdI5vPfYs5N9CZq1Y_k-LVL3WhzySJBBwjwyVeySGB8CQR0l8yJr8fbxgiFw</span><br></pre></td></tr></table></figure><p>这样的内容, 这个就是<code>jwt</code>生成的token.</p><h4 id="带上token访问test接口"><a href="#带上token访问test接口" class="headerlink" title="带上token访问test接口"></a>带上token访问test接口</h4><p>将<code>token</code>放到<code>head</code>的<code>Authorization</code>节点里面, 重新访问test接口</p><p><img src="https://github.com/cayzlh/git-img-repository/blob/master/raw/%E6%9C%89%E6%9D%83%E9%99%90.png"></p><p>可以看到, 这个时候是可以正常返回结果的.</p><h3 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h3><ol><li>JWT中的token是明文, 但是明文被签名过，签名可以使用对称或者非对称秘钥，无论使用什么秘钥，都没人知道，所以别人无法伪造。也无法修改。</li><li>不需要退出的接口, <code>token</code>已经授权给客户端了，有过期时间，退出的话, 只需客户端把token删掉即可.</li></ol><p>end.</p>]]></content>
      
      
      <categories>
          
          <category> 编程技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot实现Redis分布式锁</title>
      <link href="post/1639182984/"/>
      <url>post/1639182984/</url>
      
        <content type="html"><![CDATA[<blockquote><p>最近项目中有用到redis实现的分布式锁, 但是胆码写起来比较繁琐, 就想着整一套注解的方式实现的分布式锁</p></blockquote><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>分布式锁一般有三种实现方式：1. 数据库乐观锁；2. 基于Redis的分布式锁；3. 基于ZooKeeper的分布式锁。本文介绍基于Redis实现分布式锁。</p><h3 id="为什么需要分布式锁"><a href="#为什么需要分布式锁" class="headerlink" title="为什么需要分布式锁"></a>为什么需要分布式锁</h3><p>在单机时代，虽然不需要分布式锁，但也面临过类似的问题，只不过在单机的情况下，如果有多个线程要同时访问某个共享资源的时候，我们可以采用线程间加锁的机制，即当某个线程获取到这个资源后，就立即对这个资源进行加锁，当使用完资源之后，再解锁，其它线程就可以接着使用了。例如，在JAVA中，甚至专门提供了一些处理锁机制的一些API（synchronize/Lock等）。</p><p>但是到了分布式系统的时代，这种线程之间的锁机制，就没作用了，系统可能会有多份并且部署在不同的机器上，这些资源已经不是在线程之间共享了，而是属于进程之间共享的资源。</p><p>因此，为了解决这个问题，我们就必须引入「分布式锁」。</p><p>分布式锁，是指在分布式的部署环境下，通过锁机制来让多客户端互斥的对共享资源进行访问。</p><p>分布式锁要满足哪些要求呢？</p><ul><li>排他性：在同一时间只会有一个客户端能获取到锁，其它客户端无法同时获取</li><li>避免死锁：这把锁在一段有限的时间之后，一定会被释放（正常释放或异常释放）</li><li>高可用：获取或释放锁的机制必须高可用且性能佳</li></ul><h3 id="可靠性-From"><a href="#可靠性-From" class="headerlink" title="可靠性(From)"></a>可靠性(<a href="http://www.importnew.com/27477.html">From</a>)</h3><p>首先，为了确保分布式锁可用，我们至少要确保锁的实现同时满足以下四个条件：</p><ol><li>互斥性。在任意时刻，只有一个客户端能持有锁。</li><li>不会发生死锁。即使有一个客户端在持有锁的期间崩溃而没有主动解锁，也能保证后续其他客户端能加锁。</li><li>具有容错性。只要大部分的Redis节点正常运行，客户端就可以加锁和解锁。</li><li>解铃还须系铃人。加锁和解锁必须是同一个客户端，客户端自己不能把别人加的锁给解了</li></ol><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>基于<code>Redis</code>实现的锁机制，主要是依赖<code>Redis</code>自身的原子操作，例如：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">SET user_key user_value NX PX 100</span><br></pre></td></tr></table></figure><p>redis从2.6.12版本开始，SET命令才支持这些参数：<br><strong>NX</strong>：只在在键不存在时，才对键进行设置操作，SET key value NX 效果等同于 SETNX key value<br><strong>PX millisecond</strong>：设置键的过期时间为millisecond毫秒，当超过这个时间后，设置的键会自动失效</p><p>上述代码示例是指，<br>当<code>redis</code>中不存在<code>user_key</code>这个键的时候，才会去设置一个<code>user_key</code>键，并且给这个键的值设置为 <code>user_value</code>，且这个键的存活时间为<code>100ms</code></p><p><strong>为什么这个命令可以帮我们实现锁机制呢？</strong><br>因为这个命令是只有在某个key不存在的时候，才会执行成功。那么当多个进程同时并发的去设置同一个key的时候，就永远只会有一个进程成功。<br>当某个进程设置成功之后，就可以去执行业务逻辑了，等业务逻辑执行完毕之后，再去进行解锁。</p><p>解锁很简单，只需要删除这个<code>key</code>就可以了，不过删除之前需要判断，这个<code>key</code>对应的<code>value</code>是当初自己设置的那个。</p><p>另外，针对redis集群模式的分布式锁，可以采用redis的<code>Redlock</code>机制。</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><h4 id="创建一个SpringBoot工程"><a href="#创建一个SpringBoot工程" class="headerlink" title="创建一个SpringBoot工程"></a>创建一个SpringBoot工程</h4><p>修改<code>pom.xml</code>文件, 添加如下依赖包:</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-logging<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-log4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.8.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-cache<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.4.7.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-aop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="定义一个注解类"><a href="#定义一个注解类" class="headerlink" title="定义一个注解类"></a>定义一个注解类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.METHOD&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> DistributeLock &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 锁的资源，key。</span></span><br><span class="line"><span class="comment">     *  支持spring El表达式</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@AliasFor(&quot;name&quot;)</span></span><br><span class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span> <span class="keyword">default</span> &quot;&#x27;<span class="keyword">default</span>&#x27;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 锁的资源，value。</span></span><br><span class="line"><span class="comment">     *  支持spring El表达式</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@AliasFor(&quot;value&quot;)</span></span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> &quot;&#x27;<span class="keyword">default</span>&#x27;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 持锁时间,单位毫秒</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">keepMills</span><span class="params">()</span> <span class="keyword">default</span> 5000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当获取失败时候动作</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">LockFailAction <span class="title">action</span><span class="params">()</span> <span class="keyword">default</span> LockFailAction.CONTINUE</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">LockFailAction</span></span>&#123;</span><br><span class="line">        <span class="comment">/** 放弃 */</span></span><br><span class="line">        GIVEUP,</span><br><span class="line">        <span class="comment">/** 继续 */</span></span><br><span class="line">        CONTINUE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 重试的间隔时间,设置GIVEUP忽略此项</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">sleepMills</span><span class="params">()</span> <span class="keyword">default</span> 200</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 重试次数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">retryTimes</span><span class="params">()</span> <span class="keyword">default</span> 5</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="定义接口"><a href="#定义接口" class="headerlink" title="定义接口"></a>定义接口</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IDistributedLock</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> TIMEOUT_MILLIS = <span class="number">5000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RETRY_TIMES = Integer.MAX_VALUE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> SLEEP_MILLIS = <span class="number">500</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">lock</span><span class="params">(String key)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">lock</span><span class="params">(String key, <span class="keyword">int</span> retryTimes)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">lock</span><span class="params">(String key, <span class="keyword">int</span> retryTimes, <span class="keyword">long</span> sleepMillis)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">lock</span><span class="params">(String key, <span class="keyword">long</span> expire)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">lock</span><span class="params">(String key, <span class="keyword">long</span> expire, <span class="keyword">int</span> retryTimes)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">lock</span><span class="params">(String key, <span class="keyword">long</span> expire, <span class="keyword">int</span> retryTimes, <span class="keyword">long</span> sleepMillis)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">releaseLock</span><span class="params">(String key)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="定义抽象类"><a href="#定义抽象类" class="headerlink" title="定义抽象类"></a>定义抽象类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractDistributedLockImpl</span> <span class="keyword">implements</span> <span class="title">IDistributedLock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">lock</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> lock(key, TIMEOUT_MILLIS, RETRY_TIMES, SLEEP_MILLIS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">lock</span><span class="params">(String key, <span class="keyword">int</span> retryTimes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> lock(key, TIMEOUT_MILLIS, retryTimes, SLEEP_MILLIS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">lock</span><span class="params">(String key, <span class="keyword">int</span> retryTimes, <span class="keyword">long</span> sleepMillis)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> lock(key, TIMEOUT_MILLIS, retryTimes, sleepMillis);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">lock</span><span class="params">(String key, <span class="keyword">long</span> expire)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> lock(key, expire, RETRY_TIMES, SLEEP_MILLIS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">lock</span><span class="params">(String key, <span class="keyword">long</span> expire, <span class="keyword">int</span> retryTimes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> lock(key, expire, retryTimes, SLEEP_MILLIS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="定义Redis分布式锁实现类"><a href="#定义Redis分布式锁实现类" class="headerlink" title="定义Redis分布式锁实现类"></a>定义Redis分布式锁实现类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisDistributedLock</span> <span class="keyword">extends</span> <span class="title">AbstractDistributedLockImpl</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = getLogger(RedisDistributedLock.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate&lt;Object, Object&gt; redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ThreadLocal&lt;String&gt; lockFlag = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String UNLOCK_LUA;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SET_IF_NOT_EXIST = <span class="string">&quot;NX&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SET_WITH_EXPIRE_TIME = <span class="string">&quot;PX&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        UNLOCK_LUA = <span class="string">&quot;if redis.call(&#x27;get&#x27;, KEYS[1]) == ARGV[1] then return redis.call(&#x27;del&#x27;, KEYS[1]) else return 0 end&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RedisDistributedLock</span><span class="params">(RedisTemplate&lt;Object, Object&gt; redisTemplate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.redisTemplate = redisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">lock</span><span class="params">(String key, <span class="keyword">long</span> expire, <span class="keyword">int</span> retryTimes, <span class="keyword">long</span> sleepMillis)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> result = setRedis(key, expire);</span><br><span class="line">        <span class="comment">// 如果获取锁失败，按照传入的重试次数进行重试</span></span><br><span class="line">        <span class="keyword">while</span>((!result) &amp;&amp; retryTimes-- &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                logger.debug(<span class="string">&quot;lock failed, retrying...&quot;</span> + retryTimes);</span><br><span class="line">                Thread.sleep(sleepMillis);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            result = setRedis(key, expire);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">releaseLock</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 释放锁的时候，有可能因为持锁之后方法执行时间大于锁的有效期，此时有可能已经被另外一个线程持有锁，所以不能直接删除</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            List&lt;String&gt; keys = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            keys.add(key);</span><br><span class="line">            List&lt;String&gt; args = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            args.add(lockFlag.get());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 使用lua脚本删除redis中匹配value的key，可以避免由于方法执行时间过长而redis锁自动过期失效的时候误删其他线程的锁</span></span><br><span class="line">            <span class="comment">// spring自带的执行脚本方法中，集群模式直接抛出不支持执行脚本的异常，所以只能拿到原redis的connection来执行脚本</span></span><br><span class="line"></span><br><span class="line">            Long result = redisTemplate.execute((RedisCallback&lt;Long&gt;) redisConnection -&gt; &#123;</span><br><span class="line">                Object nativeConnection = redisConnection.getNativeConnection();</span><br><span class="line">                <span class="comment">// 集群模式和单机模式虽然执行脚本的方法一样，但是没有共同的接口，所以只能分开执行</span></span><br><span class="line">                <span class="comment">// 集群模式</span></span><br><span class="line">                <span class="keyword">if</span> (nativeConnection <span class="keyword">instanceof</span> JedisCluster) &#123;</span><br><span class="line">                    <span class="keyword">return</span> (Long) ((JedisCluster) nativeConnection).eval(UNLOCK_LUA, keys, args);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 单机模式</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (nativeConnection <span class="keyword">instanceof</span> Jedis) &#123;</span><br><span class="line">                    <span class="keyword">return</span> (Long) ((Jedis) nativeConnection).eval(UNLOCK_LUA, keys, args);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0L</span>;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> result != <span class="keyword">null</span> &amp;&amp; result &gt; <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;release lock occured an exception&quot;</span>, e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 清除掉ThreadLocal中的数据，避免内存溢出</span></span><br><span class="line">            lockFlag.remove();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">setRedis</span><span class="params">(String key, <span class="keyword">long</span> expire)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String result = redisTemplate.execute((RedisCallback&lt;String&gt;) redisConnection -&gt; &#123;</span><br><span class="line">                JedisCommands commands = (JedisCommands) redisConnection.getNativeConnection();</span><br><span class="line">                String uuid = UUID.randomUUID().toString();</span><br><span class="line">                lockFlag.set(uuid);</span><br><span class="line">                <span class="keyword">return</span> commands.set(key, uuid, SET_IF_NOT_EXIST, SET_WITH_EXPIRE_TIME, expire);</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">return</span> !StringUtils.isEmpty(result);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;set redis occured an exception&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="装配DistributeLock"><a href="#装配DistributeLock" class="headerlink" title="装配DistributeLock"></a>装配DistributeLock</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@AutoConfigureAfter(RedisAutoConfiguration.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DistributedLockAutoConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnBean(RedisTemplate.class)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IDistributedLock <span class="title">redisDistributedLock</span><span class="params">(RedisTemplate&lt;Object, Object&gt; redisTemplate)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RedisDistributedLock(redisTemplate);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="定义切面"><a href="#定义切面" class="headerlink" title="定义切面"></a>定义切面</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(IDistributedLock.class)</span></span><br><span class="line"><span class="meta">@AutoConfigureAfter(DistributedLockAutoConfiguration.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DistributedLockAspectConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = getLogger(DistributedLockAspectConfiguration.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> IDistributedLock distributedLock;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ExpressionParser parser = <span class="keyword">new</span> SpelExpressionParser();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> LocalVariableTableParameterNameDiscoverer discoverer = <span class="keyword">new</span> LocalVariableTableParameterNameDiscoverer();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定义切入点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Pointcut(&quot;@annotation(com.cayzlh.distributedlock.annotations.DistributeLock)&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">lockPoint</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 环绕通知</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pjp pjp</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>  方法返回结果</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Throwable throwable</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Around(&quot;lockPoint()&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">around</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        Method method = ((MethodSignature) pjp.getSignature()).getMethod();</span><br><span class="line">        DistributeLock lockAction = method.getAnnotation(DistributeLock.class);</span><br><span class="line">        String logKey = getLogKey(lockAction, pjp, method);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> retryTimes = lockAction.action().equals(DistributeLock.LockFailAction.CONTINUE) ? lockAction.retryTimes() : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">boolean</span> lock = distributedLock.lock(logKey, lockAction.keepMills(), retryTimes, lockAction.sleepMills());</span><br><span class="line">        <span class="keyword">if</span> (!lock) &#123;</span><br><span class="line">            logger.debug(<span class="string">&quot;get lock failed : &quot;</span> + logKey);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//得到锁,执行方法，释放锁</span></span><br><span class="line">        logger.debug(<span class="string">&quot;get lock success : &quot;</span> + logKey);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> pjp.proceed();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;execute locked method occured an exception&quot;</span>, e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">boolean</span> releaseResult = distributedLock.releaseLock(logKey);</span><br><span class="line">            logger.debug(<span class="string">&quot;release lock : &quot;</span> + logKey + (releaseResult ? <span class="string">&quot; success&quot;</span> : <span class="string">&quot; failed&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获得分布式缓存的key</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> lockAction 注解对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pjp        pjp</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> method     method</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> String</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">getLogKey</span><span class="params">(DistributeLock lockAction, ProceedingJoinPoint pjp, Method method)</span> </span>&#123;</span><br><span class="line">        String name = lockAction.name();</span><br><span class="line">        String value = lockAction.value();</span><br><span class="line">        Object[] args = pjp.getArgs();</span><br><span class="line">        <span class="keyword">return</span> parse(name, method, args) + <span class="string">&quot;_&quot;</span> + parse(value, method, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解析spring EL表达式</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key    key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> method method</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args   args</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> parse result</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">parse</span><span class="params">(String key, Method method, Object[] args)</span> </span>&#123;</span><br><span class="line">        String[] params = discoverer.getParameterNames(method);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == params || params.length == <span class="number">0</span> || !key.contains(<span class="string">&quot;#&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> key;</span><br><span class="line">        &#125;</span><br><span class="line">        EvaluationContext context = <span class="keyword">new</span> StandardEvaluationContext();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; params.length; i++) &#123;</span><br><span class="line">            context.setVariable(params[i], args[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> parser.parseExpression(key).getValue(context, String.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h4><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">server.port</span>=<span class="string">8080</span></span><br><span class="line"></span><br><span class="line"><span class="meta">spring.redis.host</span>=<span class="string">127.0.0.1</span></span><br><span class="line"><span class="meta">spring.redis.port</span>=<span class="string">6379</span></span><br><span class="line"><span class="meta">spring.redis.jedis.pool.max-idle</span>=<span class="string">8</span></span><br><span class="line"><span class="meta">spring.redis.jedis.pool.min-idle</span>=<span class="string">0</span></span><br><span class="line"><span class="meta">spring.redis.jedis.pool.max-active</span>=<span class="string">8</span></span><br><span class="line"><span class="meta">spring.redis.jedis.pool.max-wait</span>=<span class="string">-1ms</span></span><br><span class="line"><span class="meta">spring.redis.timeout</span>=<span class="string">20ms</span></span><br><span class="line"><span class="meta">spring.redis.password</span>=<span class="string"></span></span><br></pre></td></tr></table></figure><h4 id="配置log4j配置文件"><a href="#配置log4j配置文件" class="headerlink" title="配置log4j配置文件"></a>配置log4j配置文件</h4><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># server默认为空</span></span><br><span class="line"><span class="attr">server</span>=<span class="string"></span></span><br><span class="line"><span class="comment"># 日志输出目录</span></span><br><span class="line"><span class="attr">logFilePath</span>=<span class="string">logs</span></span><br><span class="line"><span class="meta">log4j.rootCategory</span>=<span class="string">DEBUG,stdout,debugLog,infoLog,errorLog</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 控制台日志输出</span></span><br><span class="line"><span class="meta">log4j.logger.consoleLogger</span>=<span class="string">stdout</span></span><br><span class="line"></span><br><span class="line"><span class="meta">log4j.appender.stdout</span>=<span class="string">org.apache.log4j.ConsoleAppender</span></span><br><span class="line"><span class="meta">log4j.appender.stdout.Threshold</span>=<span class="string">DEBUG</span></span><br><span class="line"><span class="meta">log4j.appender.stdout.layout</span>=<span class="string">org.apache.log4j.PatternLayout</span></span><br><span class="line"><span class="meta">log4j.appender.stdout.layout.ConversionPattern</span>=<span class="string">[%p] %d %c - %m%n</span></span><br><span class="line"><span class="meta">log4j.appender.stdout.ImmediateFlush</span>=<span class="string">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># debug日志输出</span></span><br><span class="line"><span class="meta">log4j.logger.debugLog</span>=<span class="string">DEBUG, debugLog</span></span><br><span class="line"></span><br><span class="line"><span class="meta">log4j.appender.debugLog</span>=<span class="string">org.apache.log4j.DailyRollingFileAppender</span></span><br><span class="line"><span class="meta">log4j.appender.debugLog.File</span>=<span class="string">$&#123;logFilePath&#125;/debug.log</span></span><br><span class="line"><span class="meta">log4j.appender.debugLog.layout</span>=<span class="string">org.apache.log4j.PatternLayout</span></span><br><span class="line"><span class="meta">log4j.appender.debugLog.layout.ConversionPattern</span>=<span class="string">%d&#123;yyyy-MM-dd HH:mm:ss,SSS&#125; %5p %c&#123;1&#125;:%L - %m%n</span></span><br><span class="line"><span class="meta">log4j.appender.debugLog.DatePattern</span>=<span class="string">&#x27;.&#x27;yyyy-MM-dd</span></span><br><span class="line"><span class="meta">log4j.appender.debugLog.ImmediateFlush</span>=<span class="string">true</span></span><br><span class="line"><span class="meta">log4j.appender.debugLog.Threshold</span>=<span class="string">DEBUG</span></span><br><span class="line"><span class="meta">log4j.appender.debugLog.encoding</span>=<span class="string">UTF-8</span></span><br><span class="line"><span class="meta">log4j.appender.debugLog.filter.debugFilter</span>=<span class="string">org.apache.log4j.varia.LevelRangeFilter</span></span><br><span class="line"><span class="meta">log4j.appender.debugLog.filter.debugFilter.LevelMin</span>=<span class="string">DEBUG</span></span><br><span class="line"><span class="meta">log4j.appender.debugLog.filter.debugFilter.LevelMax</span>=<span class="string">DEBUG</span></span><br></pre></td></tr></table></figure><h3 id="完"><a href="#完" class="headerlink" title="完"></a>完</h3><p>源码<a href="https://github.com/cayzlh/springboot-distributedlock-demo">在这</a>.</p>]]></content>
      
      
      <categories>
          
          <category> 编程技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Redis </tag>
            
            <tag> SpringBoot </tag>
            
            <tag> 分布式锁 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot封装JedisUtils工具类</title>
      <link href="post/3717925105/"/>
      <url>post/3717925105/</url>
      
        <content type="html"><![CDATA[<blockquote><p>SpringBoot已经实现了很多实用的缓存组件;但是由于工作中习惯了试用JedisUtils工具类来进行缓存操作, 这里记录一下SpringBoot中对于JedisUtils的封装</p></blockquote><h3 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h3><h4 id="新建一个SpringBoot项目"><a href="#新建一个SpringBoot项目" class="headerlink" title="新建一个SpringBoot项目"></a>新建一个SpringBoot项目</h4><p>修改<code>pom.xml</code>增加:</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-cache<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.4.7.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="新建JedisConfiguration-java用于配置JedisPool-Bean"><a href="#新建JedisConfiguration-java用于配置JedisPool-Bean" class="headerlink" title="新建JedisConfiguration.java用于配置JedisPool Bean"></a>新建JedisConfiguration.java用于配置JedisPool Bean</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Value;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cache.annotation.EnableCaching;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.JedisPool;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.JedisPoolConfig;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableCaching</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JedisConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;spring.redis.host&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String host;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;spring.redis.port&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> port;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;spring.redis.timeout&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String timeouts;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;spring.redis.jedis.pool.min-idle&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxIdle;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;spring.redis.jedis.pool.max-wait&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String maxWaitMilliss;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;spring.redis.password&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(name = &quot;jedisPool&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> JedisPool <span class="title">redisPoolFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        JedisPoolConfig jedisPoolConfig = <span class="keyword">new</span> JedisPoolConfig();</span><br><span class="line">        jedisPoolConfig.setMaxIdle(maxIdle);</span><br><span class="line">        <span class="keyword">long</span> maxWaitMillis = Long.parseLong(maxWaitMilliss.replace(<span class="string">&quot;ms&quot;</span>, <span class="string">&quot;&quot;</span>));</span><br><span class="line">        jedisPoolConfig.setMaxWaitMillis(maxWaitMillis);</span><br><span class="line">        <span class="keyword">int</span> timeout = Integer.parseInt(timeouts.replace(<span class="string">&quot;ms&quot;</span>, <span class="string">&quot;&quot;</span>));</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JedisPool(jedisPoolConfig, host, port, timeout);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="创建JedisUtils-java"><a href="#创建JedisUtils-java" class="headerlink" title="创建JedisUtils.java"></a>创建JedisUtils.java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.log4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.BeansException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContextAware;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.JedisPool;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JedisUtils</span> <span class="keyword">implements</span> <span class="title">ApplicationContextAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ApplicationContext applicationContext = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> JedisPool jedisPool = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Jedis jedis = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Logger logger = Logger.getLogger(<span class="string">&quot;JedisUtils&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">JedisUtils</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (JedisUtils.applicationContext == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//初始化 spring applicationContext</span></span><br><span class="line">            JedisUtils.applicationContext = applicationContext;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Jedis <span class="title">getJedis</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (jedis == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Jedis.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (jedis == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    jedis = getJedisPool().getResource();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> jedis;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> JedisPool <span class="title">getJedisPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (jedisPool == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (JedisPool.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (jedisPool == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    jedisPool = applicationContext.getBean(<span class="string">&quot;jedisPool&quot;</span>, JedisPool.class);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> jedisPool;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据key查看是否存在</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">hasKey</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getJedis().exists(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置key -value 形式数据</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">set</span><span class="params">(String key, String value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> result = <span class="keyword">false</span>;</span><br><span class="line">        Jedis jedis = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            jedis = getJedis();</span><br><span class="line">            result = <span class="string">&quot;OK&quot;</span>.equals(jedis.set(key, value));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            closeBrokenJedis(jedis);</span><br><span class="line">            logger.error(<span class="string">&quot;JedisCache.set falid&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置 一个过期时间</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> timeOut 单位秒</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">set</span><span class="params">(String key, String value, <span class="keyword">int</span> timeOut)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> result = <span class="keyword">false</span>;</span><br><span class="line">        Jedis jedis = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            jedis = getJedis();</span><br><span class="line">            result = <span class="string">&quot;OK&quot;</span>.equals(jedis.setex(key, timeOut, value));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            closeBrokenJedis(jedis);</span><br><span class="line">            logger.error(<span class="string">&quot;JedisCache.set falid&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据key获取value</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">get</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        String result = <span class="keyword">null</span>;</span><br><span class="line">        Jedis jedis = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            jedis = getJedis();</span><br><span class="line">            result = jedis.get(key);</span><br><span class="line">            closeJedis(jedis);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            closeBrokenJedis(jedis);</span><br><span class="line">            logger.error(<span class="string">&quot;JedisCache.get falid&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据key删除</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">del</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        getJedis().del(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中的<code>getJedisPool()</code>可以从bean获取<code>JedisPool</code>对象, 用于后续的操作, 上面给出了部分代码, <a href="https://gist.github.com/cayzlh/98eafbb5ed71966e2ac603b55c479f3a">完整版</a>在这.</p><h4 id="在springboot的主类上添加注解"><a href="#在springboot的主类上添加注解" class="headerlink" title="在springboot的主类上添加注解"></a>在springboot的主类上添加注解</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableCaching</span></span><br><span class="line"><span class="meta">@Import(&#123;JedisUtils.class, JedisPool.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(DemoApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h3><p>至此, 就可以愉快的使用JedisUtils直接操作Redis缓存了.</p>]]></content>
      
      
      <categories>
          
          <category> 编程技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Spring </tag>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tomcat单机多实例部署</title>
      <link href="post/1347652223/"/>
      <url>post/1347652223/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote><p>单机多实例部署tomcat, 可以充分利用系统资源, 周期性地更新Tomcat，使用最新版的Tomcat, 统一管理，让Tomcat版本统一, 实例的配置统一.</p></blockquote><p>本文介绍Linux下Tomcat单机多实例的部署步骤.</p><h3 id="实现四路"><a href="#实现四路" class="headerlink" title="实现四路"></a>实现四路</h3><p>1、Tomcat运行时，系统会从conf及webapps目录中读取配置文件，并且写入logs、temp和work目录中<br>2、一些jar文件和class文件需要从公共目录例如lib/中加载，只需要加载一次就可以。<br>3、为了多个实例能同时运行，每一个Tomcat实例必须有自己的目录集</p><h3 id="传统实现方式：简单的复制出一个新的Tomcat目录后改一下端口"><a href="#传统实现方式：简单的复制出一个新的Tomcat目录后改一下端口" class="headerlink" title="传统实现方式：简单的复制出一个新的Tomcat目录后改一下端口"></a>传统实现方式：简单的复制出一个新的Tomcat目录后改一下端口</h3><p>缺点：<br>1、资源浪费，公用资源被多次加载，造成在内存中不必要的重用<br>2、针对不同web服务做配置能做但是异常麻烦<br>3、对Tomcat进行版本升级时能做但是异常麻烦，每个目录都需要替换，不必要的大量工作</p><hr><h3 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h3><h4 id="下载并解压安装包到目录"><a href="#下载并解压安装包到目录" class="headerlink" title="下载并解压安装包到目录"></a>下载并解压安装包到目录</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /usr/local/path/tomcat</span><br></pre></td></tr></table></figure><h4 id="编辑-etc-profile-文件"><a href="#编辑-etc-profile-文件" class="headerlink" title="编辑 /etc/profile 文件"></a>编辑 <code>/etc/profile</code> 文件</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo vi /etc/profile</span><br></pre></td></tr></table></figure><h4 id="添加Tomcat"><a href="#添加Tomcat" class="headerlink" title="添加Tomcat"></a>添加Tomcat</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export CATALINA_HOME=/usr/local/path/tomcat/apache-tomcat-7.0.85</span><br></pre></td></tr></table></figure><p>以上代码添加到<code>profile</code>中</p><h4 id="将在-data-service-中创建两个实例文件夹"><a href="#将在-data-service-中创建两个实例文件夹" class="headerlink" title="将在 /data/service/中创建两个实例文件夹"></a>将在 <code>/data/service/</code>中创建两个实例文件夹</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /data/service</span><br><span class="line">mkdir tomcat1</span><br><span class="line">mkdir tomcat2</span><br></pre></td></tr></table></figure><h4 id="tomcat的配置文件复制到实例文件夹内"><a href="#tomcat的配置文件复制到实例文件夹内" class="headerlink" title="tomcat的配置文件复制到实例文件夹内"></a>tomcat的配置文件复制到实例文件夹内</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd tomcat1/</span><br><span class="line">cp -a /usr/local/path/tomcat/* ./</span><br><span class="line">rm -rf lib/ bin/</span><br><span class="line"></span><br><span class="line">cd ..</span><br><span class="line">cp -a tomcat1/* tomcat2/</span><br><span class="line"></span><br><span class="line">cd /usr/local/path/tomcat</span><br><span class="line">rm -rf work/ webapps/ logs/ conf/</span><br></pre></td></tr></table></figure><h4 id="此时"><a href="#此时" class="headerlink" title="此时"></a>此时</h4><p><code>/usr/local/path/tomcat</code> 内剩下文件为: <code>bin/</code>, <code>lib/</code>;<br>两个实例文件夹中剩下的文件为; <code>work/</code> <code>webapps/</code> <code>logs/</code> <code>conf/</code></p><h4 id="创建运行脚本"><a href="#创建运行脚本" class="headerlink" title="创建运行脚本"></a>创建运行脚本</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /data/service/tomcat1</span><br><span class="line">mkdir bin</span><br><span class="line">cd bin/</span><br><span class="line">touch startup.sh</span><br><span class="line">touch shutdown.sh</span><br></pre></td></tr></table></figure><h4 id="编辑startup-sh和shutdown-sh"><a href="#编辑startup-sh和shutdown-sh" class="headerlink" title="编辑startup.sh和shutdown.sh"></a>编辑<code>startup.sh</code>和<code>shutdown.sh</code></h4><p>startup.sh :</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">export CATALINA_BASE=/data/service/tomcat1</span><br><span class="line"></span><br><span class="line">echo $CATALINA_BASE</span><br><span class="line"></span><br><span class="line">TOMCAT_ID=`ps aux |grep &quot;java&quot;|grep &quot;Dcatalina.base=$CATALINA_BASE &quot;|grep -v &quot;grep&quot;|awk &#x27;&#123; print $2&#125;&#x27;`</span><br><span class="line"></span><br><span class="line">if [ -n &quot;$TOMCAT_ID&quot; ] ; then</span><br><span class="line">echo &quot;tomcat($&#123;TOMCAT_ITOMCAT_ID&#125;) still running now , please shutdown it firest&quot;;</span><br><span class="line">    exit 2;</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">TOMCAT_START_LOG=`$CATALINA_HOME/bin/startup.sh`</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if [ &quot;$?&quot; = &quot;0&quot; ]; then</span><br><span class="line">    echo &quot;$0 $&#123;1%/&#125; start succeed&quot;</span><br><span class="line">else</span><br><span class="line">    echo &quot;$0 $&#123;1%/&#125; start failed&quot;</span><br><span class="line">    echo $TOMCAT_START_LOG</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>shutdown.sh :</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rt CATALINA_BASE=/data/service/tomcat-1</span><br><span class="line"></span><br><span class="line">echo $CATALINA_BASE</span><br><span class="line"></span><br><span class="line">TOMCAT_ID=`ps aux |grep &quot;java&quot;|grep &quot;[D]catalina.base=$CATALINA_BASE &quot;|awk &#x27;&#123; print $2&#125;&#x27;`</span><br><span class="line"></span><br><span class="line">if [ -n &quot;$TOMCAT_ID&quot; ] ; then</span><br><span class="line">TOMCAT_STOP_LOG=`$CATALINA_HOME/bin/shutdown.sh`</span><br><span class="line">else</span><br><span class="line">    echo &quot;Tomcat instance not found : $&#123;1%/&#125;&quot;</span><br><span class="line">    exit</span><br><span class="line"></span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if [ &quot;$?&quot; = &quot;0&quot; ]; then</span><br><span class="line">    echo &quot;$0 $&#123;1%/&#125; stop succeed&quot;</span><br><span class="line">else</span><br><span class="line">    echo &quot;$0 $&#123;1%/&#125; stop failed&quot;</span><br><span class="line">    echo $TOMCAT_STOP_LOG</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>至此, 单机多实例的tomcat已经基本上配置好了. </p><p>运行: </p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/data/service/tomcat1/bin/startup.sh</span><br></pre></td></tr></table></figure><p>即可.</p><p>当然, 要运行两个以上实例的话, 还得配置 <code>server.xml</code>, 这里就不讨论了.</p><p>两个tomcat实例运行起来之后, 可以看到2个tomcat实例的PID是不同的，也就是说对某个实例进行操作是不会影响到另外一个实例的.</p><hr>]]></content>
      
      
      <categories>
          
          <category> 编程技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Tomcat </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux搭建Git服务器</title>
      <link href="post/71240450/"/>
      <url>post/71240450/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Ubuntu环境搭建<code>Git</code>服务器</p></blockquote><h4 id="第一步，安装git"><a href="#第一步，安装git" class="headerlink" title="第一步，安装git"></a>第一步，安装<code>git</code></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install git</span><br></pre></td></tr></table></figure><h4 id="第二步，创建一个git用户"><a href="#第二步，创建一个git用户" class="headerlink" title="第二步，创建一个git用户"></a>第二步，创建一个<code>git</code>用户</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo adduser git</span><br></pre></td></tr></table></figure><h4 id="第三步，创建证书登录"><a href="#第三步，创建证书登录" class="headerlink" title="第三步，创建证书登录"></a>第三步，创建证书登录</h4><p>客户端在命令行中输入以下指令生成<code>ssh key</code>：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;your_email@example.com&quot;</span><br></pre></td></tr></table></figure><p>收集所有需要登录的用户的公钥，就是他们自己的<code>id_rsa.pub</code>文件，把所有公钥导入到<code>/home/git/.ssh/authorized_keys</code>文件里，一行一个。</p><h4 id="第四步，初始化Git仓库"><a href="#第四步，初始化Git仓库" class="headerlink" title="第四步，初始化Git仓库"></a>第四步，初始化Git仓库</h4><p>先选定一个目录作为Git仓库，假定是<code>/srv/sample.git</code>，在<code>/srv</code>目录下输入命令：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sudo git init --bare sample.git</span><br></pre></td></tr></table></figure><h4 id="第五步，禁用shell登录"><a href="#第五步，禁用shell登录" class="headerlink" title="第五步，禁用shell登录"></a>第五步，禁用shell登录</h4><p>出于安全考虑，第二步创建的git用户不允许登录shell，这可以通过编辑<code>/etc/passwd</code>文件完成。找到类似下面的一行：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git:x:1001:1001:,,,:&#x2F;home&#x2F;git:&#x2F;bin&#x2F;bash</span><br></pre></td></tr></table></figure><p>改为：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git:x:1001:1001:,,,:&#x2F;home&#x2F;git:&#x2F;usr&#x2F;bin&#x2F;git-shell</span><br></pre></td></tr></table></figure><p>这样，<code>git</code>用户可以正常通过ssh使用git，但无法登录shell，因为我们为<code>git</code>用户指定的<code>git-shell</code>每次一登录就自动退出。</p><h4 id="第六步，克隆远程仓库："><a href="#第六步，克隆远程仓库：" class="headerlink" title="第六步，克隆远程仓库："></a>第六步，克隆远程仓库：</h4><p>现在，可以通过<code>git clone</code>命令克隆远程仓库了，在各自的电脑上运行：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git clone git@server:&#x2F;srv&#x2F;sample.git</span><br><span class="line">Cloning into &#39;sample&#39;...</span><br><span class="line">warning: You appear to have cloned an empty repository.</span><br></pre></td></tr></table></figure><p>剩下的推送就简单了。</p><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p>如果没有装ssh服务，则需要安装ssh服务，不然无法正常使用git glone 指令</p><p>安装<code>sshd</code>：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install openssh-server</span><br></pre></td></tr></table></figure><p>启动<code>sshd</code>：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo net start sshd</span><br></pre></td></tr></table></figure><p>检查防火墙设置，关闭防火墙</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo ufw disable</span><br></pre></td></tr></table></figure><p>运行以下代码查看是否有<code>sshd</code>进程</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ps -e|grep ssh</span><br></pre></td></tr></table></figure><hr><h4 id="管理公钥"><a href="#管理公钥" class="headerlink" title="管理公钥"></a>管理公钥</h4><p>如果团队很小，把每个人的公钥收集起来放到服务器的<code>/home/git/.ssh/authorized_keys</code>文件里就是可行的。如果团队有几百号人，就没法这么玩了，这时，可以用<a href="https://github.com/res0nat0r/gitosis">Gitosis</a>来管理公钥。</p><p>这里我们不介绍怎么玩<a href="https://github.com/res0nat0r/gitosis">Gitosis</a>了，几百号人的团队基本都在500强了，相信找个高水平的Linux管理员问题不大。</p><h4 id="管理权限"><a href="#管理权限" class="headerlink" title="管理权限"></a>管理权限</h4><p>有很多不但视源代码如生命，而且视员工为窃贼的公司，会在版本控制系统里设置一套完善的权限控制，每个人是否有读写权限会精确到每个分支甚至每个目录下。因为Git是为Linux源代码托管而开发的，所以Git也继承了开源社区的精神，不支持权限控制。不过，因为Git支持钩子（hook），所以，可以在服务器端编写一系列脚本来控制提交等操作，达到权限控制的目的。<a href="https://github.com/sitaramc/gitolite">Gitolite</a>就是这个工具。</p><p>这里我们也不介绍<a href="https://github.com/sitaramc/gitolite">Gitolite</a>了，不要把有限的生命浪费到权限斗争中。</p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><ul><li>搭建Git服务器非常简单，通常10分钟即可完成；</li><li>要方便管理公钥，用<a href="https://github.com/sitaramc/gitolite">Gitosis</a>；</li><li>要像SVN那样变态地控制权限，用<a href="https://github.com/sitaramc/gitolite">Gitolite</a>。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 笔记本 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
