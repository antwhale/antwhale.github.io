<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>SpringBoot单元测试</title>
      <link href="/blog/2021/03/12/1832342668.html"/>
      <url>/blog/2021/03/12/1832342668.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、-单元测试的概念"><a href="#一、-单元测试的概念" class="headerlink" title="一、 单元测试的概念"></a>一、 单元测试的概念</h2><h3 id="概念："><a href="#概念：" class="headerlink" title="概念："></a><strong>概念：</strong></h3><ol><li>单元测试（unit testing），是指对软件中的最小可测试单元进行检查和验证。在Java中单元测试的最小单元是类。</li><li>单元测试是开发者编写的一小段代码，用于检验被测代码的一个很小的、很明确的功能是否正确。执行单元测试，就是为了证明这 段代码的行为和我们期望是否一致。</li></ol><h3 id="单元测试引用："><a href="#单元测试引用：" class="headerlink" title="单元测试引用："></a><strong>单元测试引用：</strong></h3><ol><li>众所周知，通过spring initialize创建的Spring Boot项目会在Maven中自动携带很多starter依赖：</li></ol><p><img src="https://cdn.jsdelivr.net/gh/cayzlh/git-img-repository@master/2021/03/14044716155290871615529087504.jpg" alt="图片"></p><p>其中包含了一个名为<code>spring-boot-starter-test</code>的依赖，本文是围绕这个依赖展开。</p><ol><li>Spring Boot中引入单元测试很简单，添加如下依赖（即<code>spring-boot-starter-test</code>依赖）：</li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;spring-boot-starter-test&lt;&#x2F;artifactId&gt;</span><br><span class="line">  &lt;scope&gt;test&lt;&#x2F;scope&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><ol><li>spring-boot-starter-test有如下几个库：</li></ol><p><code>spring-boot-starter-test</code>UML图：</p><p><img src="https://7.dusays.com/2021/03/12/208e02005c0b7.png" alt="image-20210312142854430"></p><p><img src="https://7.dusays.com/2021/03/12/23696982579aa.png" alt="image-20210312142907488"></p><h2 id="二、单元测试的作用"><a href="#二、单元测试的作用" class="headerlink" title="二、单元测试的作用"></a>二、单元测试的作用</h2><p>在没有接触单元测试之前我们是怎么做测试的？一般有两个方法：</p><p><img src="https://cdn.jsdelivr.net/gh/cayzlh/git-img-repository@master/2021/03/14044716155290871615529087678.jpg" alt="图片"></p><p>在时间允许的情况下，编写单元测试是程序员对代码的自测，这是对自己代码的负责。</p><h3 id="写单元测试的两个动机："><a href="#写单元测试的两个动机：" class="headerlink" title="写单元测试的两个动机："></a><strong>写单元测试的两个动机：</strong></h3><ol><li>保证或验证实现功能。</li><li>保护已经实现的功能不被破坏。</li></ol><h2 id="三、Spring-Boot引入的MockMvc的概念"><a href="#三、Spring-Boot引入的MockMvc的概念" class="headerlink" title="三、Spring Boot引入的MockMvc的概念"></a>三、Spring Boot引入的MockMvc的概念</h2><ol><li>什么是Mock?</li></ol><p>在面向对象的程序设计中，模拟对象（英语：mock object）是以可控的方式模拟真实对象行为的假对象。在编程过程中，通常通过模拟一些输入数据，来验证程序是否达到预期结果。</p><ol><li>为什么使用Mock对象？</li></ol><p>使用模拟对象，可以模拟复杂的、真实的对象行为。如果在单元测试中无法使用真实对象，可采用模拟对象进行替代。</p><ol><li>MockMvc的概念</li></ol><p>MockMvc是由spring-test包提供，实现了对Http请求的模拟，能够直接使用网络的形式，转换到Controller的调用，使得测试速度快、不依赖网络环境。同时提供了一套验证的工具，结果的验证十分方便。</p><p>接口MockMvcBuilder，提供一个唯一的build方法，用来构造MockMvc。主要有两个实现：StandaloneMockMvcBuilder和DefaultMockMvcBuilder。</p><p><img src="https://7.dusays.com/2021/03/12/8ca41b998aaab.png" alt="image-20210312142923082"></p><ol><li>MockMVC的基本步骤</li></ol><p>(1) mockMvc.perform执行一个请求。(2) MockMvcRequestBuilders.get(“XXX”)构造一个请求。(3) ResultActions.param添加请求传值 (4) ResultActions.accept()设置返回类型 (5) ResultActions.andExpect添加执行完成后的断言。(6) ResultActions.andDo添加一个结果处理器，表示要对结果做点什么事情，比如处使用print()输出整个响应结果信息。(7) ResultActions.andReturn表示执行完成后返回相应的结果。</p><h2 id="四、Service层的单元测试"><a href="#四、Service层的单元测试" class="headerlink" title="四、Service层的单元测试"></a>四、Service层的单元测试</h2><p><strong>第一步：</strong> Spring Boot中单元测试类写在src/test/java目录下，你可以手动创建具体测试类，也可以通过IDEA自动创建测试类，如下图：（注：点选并打开相应代码界面，再点击菜单栏的Navigate）</p><p><img src="https://7.dusays.com/2021/03/12/b9128a7d66811.png" alt="image-20210312140744322"></p><p><strong>第二步：</strong> 按照第一步的方法，点击测试后，出现<strong>图一</strong> 的对话框（如果想要测试的类已经存在测试类了会被列出来，也可以重新创建一个新的测试类），点击”Create New Test…”会弹出<strong>图二</strong> 的对话框，可以选择是否生成setUp以及要测试的成员方法等：</p><p>图一</p><p><img src="https://cdn.jsdelivr.net/gh/cayzlh/git-img-repository@master/2021/03/14044716155290871615529087979.jpg" alt="图片"></p><p>图二</p><p><img src="https://cdn.jsdelivr.net/gh/cayzlh/git-img-repository@master/2021/03/14044816155290881615529088115.jpg" alt="图片"></p><p><strong>第三步：</strong> 至此Service层的测试类就创建好了，测试类自动生成到了src/test/java目录下<strong>项目的同级目录中</strong> ，如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/cayzlh/git-img-repository@master/2021/03/14044816155290881615529088185.jpg" alt="图片"></p><p>Service层测试代码如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@SpringBootTest</span><br><span class="line">@RunWith(SpringRunner.class)</span><br><span class="line">public class XXXServiceTest &#123;</span><br><span class="line">@Resource</span><br><span class="line">private XXXService XXXService;</span><br><span class="line">@Test</span><br><span class="line">public void conflictTime() &#123;</span><br><span class="line">        DateTimeFormatter dtf &#x3D; DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd&quot;);</span><br><span class="line">        LocalDate start &#x3D; LocalDate.parse(&quot;2020-10-26&quot;, dtf);</span><br><span class="line">        LocalDate end &#x3D; LocalDate.parse(&quot;2020-10-31&quot;, dtf);</span><br><span class="line">        Integer integer &#x3D; XXXService.ConflictTime(&quot;10000001&quot;, start, end);</span><br><span class="line">        Assert.assertThat(integer, Matchers.notNullValue());&#x2F;&#x2F;assertThat断言后面介绍</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注解解释：</strong></p><p><code>@SpringBootTest</code>：获取启动类，加载配置，寻找主配置启动类（被 @SpringBootApplication 注解的） <code>@RunWith(SpringRunner.class)</code>：让JUnit运行Spring的测试环境,获得Spring环境的上下文的支持</p><h2 id="五、Controller层的单元测试"><a href="#五、Controller层的单元测试" class="headerlink" title="五、Controller层的单元测试"></a>五、Controller层的单元测试</h2><p>创建测试类步骤见第四部分，此处略。</p><p>第四部分只是针对Service层做了测试，但是咱么也需要对Controller层（API）做测试，这时候就用到MockMvc了，它使得你无需启动项目工程就能测试这些接口</p><p>MockMvc实现了对Http请求的模拟，能够直接使用网络的形式，转换到Controller的调用，这样可以使得测试速度快、不依赖网络环境，而且提供了一套验证的工具，这样可以使得请求的验证统一而且很方便。</p><p>Controller层部分的代码将分为三个代码块讲解，里面有看不懂的代码先不要着急哦😄，会在第五部分结尾处给大家汇总解答的，大家要坚持看到最后哟！😁</p><p><strong>代码块一：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@SpringBootTest</span><br><span class="line">@RunWith(SpringRunner.class)</span><br><span class="line">@AutoConfigureMockMvc</span><br><span class="line">public class DfTaskRecordControllerTest &#123;</span><br><span class="line">@Autowired</span><br><span class="line">private MockMvc mockMvc;</span><br><span class="line">@Before</span><br><span class="line">public void setUp() throws Exception &#123;</span><br><span class="line">       System.out.println(&quot;---------------start---------------&quot;);</span><br><span class="line">       save();</span><br><span class="line">get();</span><br><span class="line">       System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;end&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>注解解释：</strong></p><p><code>@SpringBootTest</code>&gt;：获取启动类，加载配置，寻找主配置启动类（被 @SpringBootApplication 注解的）</p><p><code>@RunWith(SpringRunner.class)</code>&gt;：让JUnit运行Spring的测试环境,获得Spring环境的上下文的支持 <code>@AutoConfigureMockMvc</code>：用于自动配置MockMvc,配置后MockMvc类可以直接注入,相当于new MockMvc <code>@Before</code>:初始化方法 ,对于每一个测试方法都要执行一次</p><p><strong>代码块二：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">@Transactional</span><br><span class="line">@Rollback()</span><br><span class="line">public void save() throws Exception &#123;</span><br><span class="line">        String json&quot;&#123;……&#125;&quot;;</span><br><span class="line">&#x2F;&#x2F;执行一个RequestBuilder请求，会自动执行SpringMVC的流程并映射到相应的控制器执行处理；</span><br><span class="line">        mockMvc.perform(MockMvcRequestBuilders</span><br><span class="line">                .post(&quot;&#x2F;XXX&#x2F;save&quot;)</span><br><span class="line">                .content(json.getBytes()) &#x2F;&#x2F;传json参数</span><br><span class="line">                .accept(MediaType.APPLICATION_JSON)</span><br><span class="line">                .contentType(MediaType.APPLICATION_JSON_VALUE)</span><br><span class="line">                .header(&quot;Authorization&quot;,&quot;Bearer ********-****-****-****-************&quot;)</span><br><span class="line">        )</span><br><span class="line">                .andExpect(MockMvcResultMatchers.status().isOk())</span><br><span class="line">                .andDo(print());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>注解解释：</strong></p><p><code>@Transactional</code>:开启事务功能</p><p><code>@Rollback()</code>: 事务回滚,默认是true</p><p><strong>代码块三：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void get() throws Exception&#123;</span><br><span class="line">        ResultActions resultActions &#x3D; mockMvc.perform(MockMvcRequestBuilders</span><br><span class="line">                .get(&quot;&#x2F;XXX&#x2F;get&quot;)</span><br><span class="line">                .param(&quot;id&quot;, &quot;**********&quot;)</span><br><span class="line">                .header(&quot;Authorization&quot;, &quot;Bearer ********-****-****-****-************&quot;)</span><br><span class="line">        );</span><br><span class="line">        resultActions.andReturn().getResponse().setCharacterEncoding(&quot;UTF-8&quot;);</span><br><span class="line">        resultActions.andExpect(MockMvcResultMatchers.status().isOk()).andDo(print());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>/get</code>运行结果如下：</p><p><img src="https://cdn.jsdelivr.net/gh/cayzlh/git-img-repository@master/2021/03/14044816155290881615529088275.jpg" alt="图片"></p><p><strong>现在将上面的一些琐碎的知识点汇总一下：</strong></p><p><code>1. mockMvc.perform</code>：执行一个请求</p><p><code>2. MockMvcRequestBuilders.get(“/XXX/get”)</code>：构造一个请求，Post请求使用.post方法</p><p><code>3. contentType(MediaType.APPLICATION_JSON_VALUE)</code>：代表发送端发送的数据格式是application/json;charset=UTF-8</p><p><code>4. accept(MediaType.APPLICATION_JSON)</code>：代表客户端希望接受的数据类型为application/json;charset=UTF-8</p><p><code>5. header(“Authorization”,“Bearer XXXX”)</code>：代表在报文头添加一些必须的信息，这里添加的是token</p><p><code>6. ResultActions.andExpect</code>：添加执行完成后的断言</p><p><code>7. ResultActions.andExpect(MockMvcResultMatchers.status().isOk())</code>：方法看请求的状态响应码是否为200如果不是则抛异常，测试不通过</p><p><code>8. ResultActions.andDo</code>：添加一个结果处理器，表示要对结果做点什么事情，比如此处使用print()：输出整个响应结果信息</p><h2 id="六、断言的概念"><a href="#六、断言的概念" class="headerlink" title="六、断言的概念"></a>六、断言的概念</h2><ol><li>断言（assert），是编程术语，表示为一些布尔表达式，程序员相信在程序中的某个特定点该表达式值为真。可以在任何时候启用和禁用断言验证，因此可以在测试时启用断言而在部署时禁用断言。</li><li>使用断言是判断一个函数或对象的一个方法所产生的结果是否符合你期望那个结果。</li></ol><h2 id="七、新断言assertThat使用"><a href="#七、新断言assertThat使用" class="headerlink" title="七、新断言assertThat使用"></a>七、新断言assertThat使用</h2><p>JUnit 4.4 结合 Hamcrest 提供了一个全新的断言语法——assertThat。程序员可以只使用 assertThat 一个断言语句，结合 Hamcrest 提供的匹配符，就可以表达全部的测试思想。</p><p><strong>assertThat 的优点：</strong></p><p><strong>优点 1：</strong> 以前 JUnit 提供了很多的 assertion 语句，如：assertEquals，assertNotSame，assertFalse，assertTrue，assertNotNull，assertNull 等，现在有了 JUnit 4.4，一条 assertThat 即可以替代所有的 assertion 语句，这样可以在所有的单元测试中只使用一个断言方法，使得编写测试用例变得简单，代码风格变得统一，测试代码也更容易维护。</p><p><strong>优点 2：</strong> assertThat 使用了 Hamcrest 的 Matcher 匹配符，用户可以使用匹配符规定的匹配准则精确的指定一些想设定满足的条件，具有很强的易读性，而且使用起来更加灵活。</p><p><strong>优点 3：</strong> assertThat 不再像 assertEquals 那样，使用比较难懂的“谓宾主”语法模式（如：assertEquals(3, x);），相反，assertThat 使用了类似于“主谓宾”的易读语法模式（如：assertThat(x,is(3));），使得代码更加直观、易读。</p><p><strong>assertThat 的基本语法如下：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">assertThat( [value], [matcher statement] );</span><br></pre></td></tr></table></figure><p><strong>value</strong> ：接下来想要测试的变量值；<strong>matcher statement</strong> ：使用 Hamcrest 匹配符来表达的对前面变量所期望的值的声明，如果 value 值与 matcher statement 所表达的期望值相符，则测试成功，否则测试失败。</p><h2 id="八、Postman与Spring-Boot-单元测试的区别"><a href="#八、Postman与Spring-Boot-单元测试的区别" class="headerlink" title="八、Postman与Spring Boot 单元测试的区别"></a>八、Postman与Spring Boot 单元测试的区别</h2><ol><li>Spring Boot的单元测试主要针对方法层面，可以测试Service层这类非对外暴露的接口的类中方法，并且可一次性批量测试多个方法、支持事务回滚。</li><li>Postman针对接口进行http测试，我平时这个比较多，创建的测试接口可保存、分类。</li></ol><h2 id="九、Postman基本用法"><a href="#九、Postman基本用法" class="headerlink" title="九、Postman基本用法"></a>九、Postman基本用法</h2><p>Postman是一款功能强大的网页调试与发送网页HTTP请求的工具。Postman能够发送任何类型的HTTP请求(GET, HEAD, POST,PUT..)，附带任何数量的参数和HTTP headers。支持不同的认证机制（basic, digest,OAuth），接收到的响应语法高亮（HTML，JSON或XML）。</p><p><strong>安装Postman</strong></p><p>官方网站：</p><p><a href="https://www.getpostman.com/apps">https://www.getpostman.com/apps</a></p><p><img src="https://7.dusays.com/2021/03/12/fb189913d88c3.png" alt="image-20210312140706367"></p><p>安装后，Postman是介样婶儿滴~~😊</p><p><img src="https://cdn.jsdelivr.net/gh/cayzlh/git-img-repository@master/2021/03/14044816155290881615529088535.jpg" alt="图片"></p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 转载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Elasticsearch权威指南》-基础入门</title>
      <link href="/blog/2021/01/05/d2d07489.html"/>
      <url>/blog/2021/01/05/d2d07489.html</url>
      
        <content type="html"><![CDATA[<p><em>Elasticsearch</em> 是一个实时的分布式搜索分析引擎，它能让你以前所未有的速度和规模，去探索你的数据。 它被用作全文检索、结构化搜索、分析以及这三个功能的组合。</p><p>Elasticsearch 中没有一个单独的组件是全新的或者是革命性的。全文搜索很久之前就已经可以做到了， 就像很早之前出现的分析系统和分布式数据库。 <strong>革命性的成果在于将这些单独的，有用的组件融合到一个单一的、一致的、实时的应用中。</strong></p><h2 id="Elasticsearch是什么"><a href="#Elasticsearch是什么" class="headerlink" title="Elasticsearch是什么"></a>Elasticsearch是什么</h2><p>Elasticsearch 是一个开源的搜索引擎，建立在一个全文搜索引擎库 <a href="https://lucene.apache.org/core/">Apache Lucene™</a> 基础之上。 Lucene 可以说是当下最先进、高性能、全功能的搜索引擎库—无论是开源还是私有。</p><p>但是 Lucene 仅仅只是一个库。为了充分发挥其功能，你需要使用 Java 并将 Lucene 直接集成到应用程序中。 更糟糕的是，您可能需要获得信息检索学位才能了解其工作原理。Lucene <em>非常</em> 复杂。</p><p>Elasticsearch 也是使用 Java 编写的，它的内部使用 Lucene 做索引与搜索，但是它的目的是使全文检索变得简单， 通过隐藏 Lucene 的复杂性，取而代之的提供一套简单一致的 RESTful API。</p><p>然而，Elasticsearch 不仅仅是 Lucene，并且也不仅仅只是一个全文搜索引擎。 它可以被下面这样准确的形容：</p><ul><li>一个分布式的实时文档存储，<em>每个字段</em> 可以被索引与搜索</li><li>一个分布式实时分析搜索引擎</li><li>能胜任上百个服务节点的扩展，并支持 PB 级别的结构化或者非结构化数据</li></ul><blockquote><p>Elasticsearch 将所有的功能打包成一个单独的服务，这样你可以通过程序与它提供的简单的 RESTful API 进行通信， 可以使用自己喜欢的编程语言充当 web 客户端，甚至可以使用命令行（去充当这个客户端）。</p></blockquote><h3 id="安装并运行Elasticsearch"><a href="#安装并运行Elasticsearch" class="headerlink" title="安装并运行Elasticsearch"></a>安装并运行Elasticsearch</h3><p>1、安装步骤参考<a href="/2021/01/05/93edb835.html">Docker部署elasticsearch</a>。</p><p>2、验证是否运行成功，在终端执行以下命令：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl <span class="string">&#x27;http://localhost:9200/?pretty&#x27;</span></span><br></pre></td></tr></table></figure><p>得到下面类似的响应则成功：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;name&quot;</span> : <span class="string">&quot;72Hw8Z7&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;cluster_name&quot;</span> : <span class="string">&quot;elasticsearch&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;cluster_uuid&quot;</span> : <span class="string">&quot;qjNWdKc2TtePsX9apDnatw&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;version&quot;</span> : &#123;</span><br><span class="line">    <span class="attr">&quot;number&quot;</span> : <span class="string">&quot;5.6.12&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;build_hash&quot;</span> : <span class="string">&quot;cfe3d9f&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;build_date&quot;</span> : <span class="string">&quot;2018-09-10T20:12:43.732Z&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;build_snapshot&quot;</span> : <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">&quot;lucene_version&quot;</span> : <span class="string">&quot;6.6.1&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;tagline&quot;</span> : <span class="string">&quot;You Know, for Search&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这就意味着你现在已经启动并运行一个 Elasticsearch 节点了，你可以用它做实验了。 单个 <em>节点</em> 可以作为一个运行中的 Elasticsearch 的实例。 而一个 集群 是一组拥有相同 <code>cluster.name</code> 的节点， 他们能一起工作并共享数据，还提供容错与可伸缩性。(当然，一个单独的节点也可以组成一个集群) 你可以在 <code>elasticsearch.yml</code> 配置文件中 修改 <code>cluster.name</code> ，该文件会在节点启动时加载 (译者注：这个重启服务后才会生效)。 </p></blockquote><h3 id="与Elasticsearch交互"><a href="#与Elasticsearch交互" class="headerlink" title="与Elasticsearch交互"></a>与Elasticsearch交互</h3><h2 id="集群内的原理"><a href="#集群内的原理" class="headerlink" title="集群内的原理"></a>集群内的原理</h2><h2 id="数据输入和输出"><a href="#数据输入和输出" class="headerlink" title="数据输入和输出"></a>数据输入和输出</h2><h2 id="分布式文档存储"><a href="#分布式文档存储" class="headerlink" title="分布式文档存储"></a>分布式文档存储</h2><h2 id="搜索——最基本的工具"><a href="#搜索——最基本的工具" class="headerlink" title="搜索——最基本的工具"></a>搜索——最基本的工具</h2><h2 id="映射与分析"><a href="#映射与分析" class="headerlink" title="映射与分析"></a>映射与分析</h2><h2 id="请求体查询"><a href="#请求体查询" class="headerlink" title="请求体查询"></a>请求体查询</h2><h2 id="排序与相关性"><a href="#排序与相关性" class="headerlink" title="排序与相关性"></a>排序与相关性</h2><h2 id="执行分布式检索"><a href="#执行分布式检索" class="headerlink" title="执行分布式检索"></a>执行分布式检索</h2><h2 id="索引管理"><a href="#索引管理" class="headerlink" title="索引管理"></a>索引管理</h2><h2 id="分片内部管理"><a href="#分片内部管理" class="headerlink" title="分片内部管理"></a>分片内部管理</h2>]]></content>
      
      
      <categories>
          
          <category> 书籍 </category>
          
          <category> 《Elasticsearch权威指南》 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>核心处理层-SqlNode&amp;SqlSource</title>
      <link href="/blog/2020/08/21/bebe404d.html"/>
      <url>/blog/2020/08/21/bebe404d.html</url>
      
        <content type="html"><![CDATA[<p>核心处理层以基础支持层为基础，实现了<code>MyBatis</code>的核心功能。这个部分将从<code>MyBatis</code>的初始化、动态<code>SQL</code>语句的解析、结果集的映射、参数解析以及<code>SQL</code>语句的执行等几个方面分析<code>MyBatis</code>的核心处理层，了解<code>MyBatis</code>的核心原理。</p><p><img src="https://gitee.com/cayzlh/img-repo/raw/master/2020/06/22/image-20200622175512211_aegXOG.png" alt="image-20200622175512211"></p><blockquote><p>本篇介绍SqINode&amp;SqISource</p></blockquote><p>映射配置文件中定义的<code>SQL</code>节点会被解析成<code>MappedStatement</code>对象，其中的<code>SQL</code>语句会被解析成<code>SqlSource</code>对象，<code>SQL</code>语句中定义的动态<code>SQL</code>节点、文本节点等，则由<code>SqlNode</code>接口的相应实现表示。</p><p><code>SqlSource</code>接口的定义：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SqlSource</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function">BoundSql <span class="title">getBoundSql</span><span class="params">(Object parameterObject)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>SqlSource</code>接口的实现类图：</p><p><img src="https://gitee.com/cayzlh/img-repo/raw/master/2020/08/17323715982615571598261557744.png" alt="image-20200824173236987"></p><ul><li><code>DynamicSqlSource</code>负责处理动态<code>SQL</code>语句，<code>RawSqlSource</code>负责处理静态语句，两者最终都会将处理后的<code>SQL</code>语句封装成<code>StaticSqlSource</code>返回。</li><li><code>DynamicSqlSource</code>与<code>StaticSqlSource</code>的主要区别：<ul><li><code>StaticSqlSource</code>中记录的<code>SQL</code>语句中可能含有<code>?</code>占位符，但是可以直接提交给数据库执行</li><li><code>DynamicSqlSource</code>中封装的<code>SQL</code>语句还需要进行一系列解析，才会最终形成数据库可执行的<code>SQL</code>语句</li></ul></li></ul><h2 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h2><p>组合模式是将对象组合成树形结构，以表示<code>部分-整体</code>的层次结构(一般是树形结构)，用户可以像处理一个简单对象一样来处理一个复杂对象，从而使得调用者无须了解复杂元素的内部结构。</p><p><img src="https://gitee.com/cayzlh/img-repo/raw/master/2020/08/17400415982620041598262004554.png" alt="image-20200824174003381"></p><p>组合模式中的各模式如下：</p><ul><li><p><strong>抽象组件(<code>Component</code>)</strong></p><p><code>Component</code>接口定义了树形结构中所有类的公共行为，例如这里的<code>operation()</code>方法。</p><p>一般情况下，其中还会定义一些用于管理子组件的方法，例如这里的<code>add()</code>、<code>remove()</code>、<code>getChild()</code>方法。</p></li><li><p><strong>树叶(<code>Leaf</code>)</strong></p><p><code>Leaf</code>在树形结构中表示叶节点对象，叶节点没有子节点。</p></li><li><p><strong>树枝(<code>Composite</code>)</strong></p><p>定义有子组件的那些组件的行为。该角色用于管理子组件，并通过<code>operation()</code>方法调用其管理的子组件的相关操作。</p></li><li><p><strong>调用者(<code>Client</code>)</strong></p><p>通过<code>Component</code>接口操纵整个树形结构。</p></li></ul><p><u>组合模式主要有两点好处</u>，<strong>首先组合模式可以帮助调用者屏蔽对象的复杂性</strong>。</p><p>对于调用者来说，使用整个树形结构与使用单个<code>Component</code>对象没有任何区别，也就是说，调用者并不必关心自己处理的是单个<code>Component</code>对象还是整个树形结构，这样就可以将调用者与复杂对象进行解耦。</p><p>另外，<strong>使用了组合模式之后，我们可以通过增加树中节点的方式，添加新的Component对象，从而实现功能上的扩展，这符合<code>开放-封闭</code>原则，也可以简化日后的维护工作。</strong></p><p><u>组合模式在带来上述好处的同时，也会引入一些问题</u>。</p><p>例如，有些场景下程序希望一个组合结构中只能有某些特定的组件，此时就很难直接通过组件类型进行限制(因为都是<code>Component</code>接口的实现类)，这就必须在运行时进行类型检测。而且，在递归程序中定位问题也是一件比较复杂的事情。</p><p><code>MyBatis</code>在处理动态<code>SQL</code>节点时，应用到了组合设计模式。<code>MyBatis</code>会将动态<code>SQL</code>节点解析成对应的<code>SqlNode</code>实现，并形成树形结构。</p><h2 id="OGNL表达式"><a href="#OGNL表达式" class="headerlink" title="OGNL表达式"></a>OGNL表达式</h2><p><code>OGNL</code>(<strong>Object Graphic Navigation Language，对象图导航语言</strong>)表达式在<code>Struts</code>、<code>MyBatis</code>等开源项目中有广泛的应用，其中<code>Struts</code>框架更是将<code>OGNL</code>作为默认的表达式语言。</p><p>在<code>MyBatis</code>中涉及的<code>OGNL</code>表达式的功能主要是：<strong>存取<code>Java</code>对象树中的属性</strong>、<strong>调用<code>Java</code>对象树中的方法等</strong>。</p><p><strong>OGNL中的几个概念：</strong></p><ul><li><p><strong>表达式</strong></p><p><code>OGNL</code>表达式执行的所有操作都是根据表达式解析得到的。</p><p>例如：</p><p><code>对象名.方法名</code>表示调用指定对象的指定方法</p><p><code>@[类的完全限定名]@[静态方法或静态字段]</code>表示调用指定类的静态方法或访问静态字段</p><p><code>OGNL</code>表达式还可以完成<u>变量赋值</u>、<u>操作集合</u>等操作。</p></li><li><p><strong>root对象</strong></p><p><code>OGNL</code>表达式指定了具体的操作，而<code>root</code>对象指定了需要操作的对象。</p></li><li><p><strong>OgnlContext（上下文对象）</strong></p><p><code>OgnlContext</code>类继承了<code>Map</code>接口，<code>OgnlContext</code>对象说白了也就是一个<code>Map</code>对象。</p><p>既然如此，<code>OgnIContext</code>对象中就可以存放除<code>root</code>对象之外的其他对象。</p><p>在使用<code>OGNL</code>表达式操作非<code>root</code>对象时，需要使用<code>#</code>前缀，而操作<code>root</code>对象则不需要使用<code>#</code>前缀。</p></li></ul><p>在<code>MyBatis</code>中，使用<code>OgnlCache</code>对原生的<code>OGNL</code>进行了封装。<code>OGNL</code>表达式的解析过程是比较耗时的，为了提高效率，<code>OgnlCache</code>中使用<code>expressionCache</code>字段(静态成员，<code>ConcurrentHashMap&lt;String,Object&gt;</code>类型)对解析后的<code>OGNL</code>表达式进行缓存。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String, Object&gt; expressionCache = <span class="keyword">new</span> ConcurrentHashMap&lt;String, Object&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getValue</span><span class="params">(String expression, Object root)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    Map&lt;Object, OgnlClassResolver&gt; context = Ognl.createDefaultContext(root, <span class="keyword">new</span> OgnlClassResolver());</span><br><span class="line">    <span class="keyword">return</span> Ognl.getValue(parseExpression(expression), context, root);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (OgnlException e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">&quot;Error evaluating expression &#x27;&quot;</span> + expression + <span class="string">&quot;&#x27;. Cause: &quot;</span> + e, e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Object <span class="title">parseExpression</span><span class="params">(String expression)</span> <span class="keyword">throws</span> OgnlException </span>&#123;</span><br><span class="line">  Object node = expressionCache.get(expression);</span><br><span class="line">  <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">    node = Ognl.parseExpression(expression);</span><br><span class="line">    expressionCache.put(expression, node);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="DynamicContext"><a href="#DynamicContext" class="headerlink" title="DynamicContext"></a>DynamicContext</h2><p><code>DynamicContext</code>主要用于记录解析动态<code>SQL</code>语句之后产生的<code>SQL</code>语句片段，可以认为它是一个用于记录动态<code>SQL</code>语句解析结果的容器。</p><p>其中有两个核心字段：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 参数上下文</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ContextMap bindings;</span><br><span class="line"><span class="comment">// 在SqlNode解析动态sql的时候，会将解析后的sql语句片段添加到该属性中保存，最终拼凑出一条完整的sql语句</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> StringBuilder sqlBuilder = <span class="keyword">new</span> StringBuilder();</span><br></pre></td></tr></table></figure><p><code>ContextMap</code>是<code>DynamicContext</code>中定义的内部类，它实现了<code>HashMap</code>并重写了<code>get()</code>方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ContextMap</span> <span class="keyword">extends</span> <span class="title">HashMap</span>&lt;<span class="title">String</span>, <span class="title">Object</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">2977601501966151582L</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将用户传的参数封装成MetaObject对象</span></span><br><span class="line">  <span class="keyword">private</span> MetaObject parameterMetaObject;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ContextMap</span><span class="params">(MetaObject parameterMetaObject)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.parameterMetaObject = parameterMetaObject;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    String strKey = (String) key;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">super</span>.containsKey(strKey)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">super</span>.get(strKey);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (parameterMetaObject != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// issue #61 do not modify the context when reading</span></span><br><span class="line">      <span class="keyword">return</span> parameterMetaObject.getValue(strKey);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>DynamicContext</code>的构造方法会初始化<code>bindings</code>集合，注意构造方法的第二个参数<code>pammeterObject</code>，它是运行时用户传入的参数，其中包含了后续用于替换<code>#&#123;&#125;</code>占位符的实参。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DynamicContext</span><span class="params">(Configuration configuration, Object parameterObject)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (parameterObject != <span class="keyword">null</span> &amp;&amp; !(parameterObject <span class="keyword">instanceof</span> Map)) &#123;</span><br><span class="line">    <span class="comment">// 对于不是Map类型的参数，会创装MetaObject对象，并封装成ContextMap对象</span></span><br><span class="line">    MetaObject metaObject = configuration.newMetaObject(parameterObject);</span><br><span class="line">    bindings = <span class="keyword">new</span> ContextMap(metaObject);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    bindings = <span class="keyword">new</span> ContextMap(<span class="keyword">null</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  bindings.put(PARAMETER_OBJECT_KEY, parameterObject);</span><br><span class="line">  bindings.put(DATABASE_ID_KEY, configuration.getDatabaseId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="SqlNode"><a href="#SqlNode" class="headerlink" title="SqlNode"></a>SqlNode</h2><p>接下来看看SqlNode的实现类是如何解析其对应的SQL节点。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SqlNode</span> </span>&#123;</span><br><span class="line">  <span class="comment">// apply()是SqlNode接口中定义的唯一方法，该方法会根据用户传入的实参，参数解析该SqlNode所</span></span><br><span class="line">  <span class="comment">// 记录的动态SQL节点，并调用DynamicContext.appendSql()方法将解析后的SQL片段追加到</span></span><br><span class="line">  <span class="comment">// DynamicContext.sqlBuilder中保存</span></span><br><span class="line">  <span class="comment">// 当SQL节点下的所有SqlNode完成解析后，我们就可以从DynamicContext中获取一条动态生成的、</span></span><br><span class="line">  <span class="comment">// 完整的SQL语句</span></span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">apply</span><span class="params">(DynamicContext context)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>SqlNode</code>接口有多个实现类，每个实现类对应一个动态<code>SQL</code>节点。按照组合模式的角色来划分，<code>SqlNode</code>扮演了抽象组件的角色，<code>MixedSqlNode</code>扮演了树枝节点的角色，<code>TextSqlNode</code>节点扮演了树叶节点的角色等等。</p><p><img src="https://gitee.com/cayzlh/img-repo/raw/master/2020/08/16395615983447961598344796478.png" alt="image-20200825163955175"></p><p><strong>1、StaticTextSqINode&amp;MixedSqINode</strong></p><p><code>StaticTextSqINode</code>中使用<code>text</code>字段(<code>String</code>类型)记录了对应的非动态<code>SQL</code>语句节点，其<code>apply()</code>方法直接将<code>text</code>字段追加到<code>DynamicContext.sqlBuilder</code>字段中。</p><p><code>MixedSqINode</code>中使用<code>contents</code>字段(<code>List&lt;SqlNode&gt;</code>类型)记录其子节点对应的<code>SqlNode</code>对象集合，其<code>apply()</code>方法会循环调用<code>contents</code>集合中所有<code>SqlNode</code>对象的<code>apply()</code>方法。</p><p><strong>2、TextSqlNode</strong></p><p><u><code>TextSqlNode</code>表示的是包含占位符的动态<code>SQL</code>节点。</u><code>TextSqlNode.apply()</code>方法会使用<code>GenericTokenParser</code>解析<code>$&#123;&#125;</code>占位符，并直接替换成用户给定的实际参数值。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">apply</span><span class="params">(DynamicContext context)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 创建GenericTokenParser解析器，</span></span><br><span class="line">  GenericTokenParser parser = createParser(<span class="keyword">new</span> BindingTokenParser(context, injectionFilter));</span><br><span class="line">  <span class="comment">// 将解析后的SQL片段添加到DynamicContext中</span></span><br><span class="line">  context.appendSql(parser.parse(text));</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> GenericTokenParser <span class="title">createParser</span><span class="params">(TokenHandler handler)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> GenericTokenParser(<span class="string">&quot;$&#123;&quot;</span>, <span class="string">&quot;&#125;&quot;</span>, handler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>**<code>BindingTokenParser</code>**是<code>TextSqlNode</code>中定义的内部类，继承了<code>TokenHandler</code>接口，<u>它的主要功能是根据<code>DynamicContext.bindings</code>集合中的信息解析<code>SQL</code>语句节点中的<code>$&#123;&#125;</code>占位符</u>。<code>BindingTokenParser.context</code>字段指向了对应的<code>DynamicContext</code>对象。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">BindingTokenParser</span> <span class="keyword">implements</span> <span class="title">TokenHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> DynamicContext context;</span><br><span class="line">  <span class="keyword">private</span> Pattern injectionFilter;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">BindingTokenParser</span><span class="params">(DynamicContext context, Pattern injectionFilter)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.context = context;</span><br><span class="line">    <span class="keyword">this</span>.injectionFilter = injectionFilter;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">handleToken</span><span class="params">(String content)</span> </span>&#123;</span><br><span class="line">    Object parameter = context.getBindings().get(<span class="string">&quot;_parameter&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (parameter == <span class="keyword">null</span>) &#123;</span><br><span class="line">      context.getBindings().put(<span class="string">&quot;value&quot;</span>, <span class="keyword">null</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (SimpleTypeRegistry.isSimpleType(parameter.getClass())) &#123;</span><br><span class="line">      context.getBindings().put(<span class="string">&quot;value&quot;</span>, parameter);</span><br><span class="line">    &#125;</span><br><span class="line">    Object value = OgnlCache.getValue(content, context.getBindings());</span><br><span class="line">    String srtValue = (value == <span class="keyword">null</span> ? <span class="string">&quot;&quot;</span> : String.valueOf(value)); <span class="comment">// issue #274 return &quot;&quot; instead of &quot;null&quot;</span></span><br><span class="line">    checkInjection(srtValue);</span><br><span class="line">    <span class="keyword">return</span> srtValue;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkInjection</span><span class="params">(String value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (injectionFilter != <span class="keyword">null</span> &amp;&amp; !injectionFilter.matcher(value).matches()) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> ScriptingException(<span class="string">&quot;Invalid input. Please conform to regex&quot;</span> + injectionFilter.pattern());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3、IfSqlNode</strong></p><p><code>IfSqlNode</code>对应的动态<code>SQL</code>节点是<code>&lt;if&gt;</code>节点，以下是几个核心字段。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 用于解析if节点的test表达式的值</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ExpressionEvaluator evaluator;</span><br><span class="line"><span class="comment">// 记录了test表达式</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String test;</span><br><span class="line"><span class="comment">// 记录子节点</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> SqlNode contents;</span><br></pre></td></tr></table></figure><p><code>IfSqlNode.apply()</code>方法首先会通过<code>ExpressionEvaluator.evaluateBoolean()</code>方法检测其<code>test</code>表达<br>式是否为<code>true</code>，然后根据<code>test</code>表达式的结果，决定是否执行其子节点的<code>apply()</code>方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">apply</span><span class="params">(DynamicContext context)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (evaluator.evaluateBoolean(test, context.getBindings())) &#123;</span><br><span class="line">    contents.apply(context);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">evaluateBoolean</span><span class="params">(String expression, Object parameterObject)</span> </span>&#123;</span><br><span class="line">  Object value = OgnlCache.getValue(expression, parameterObject);</span><br><span class="line">  <span class="keyword">if</span> (value <span class="keyword">instanceof</span> Boolean) &#123;</span><br><span class="line">    <span class="keyword">return</span> (Boolean) value;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (value <span class="keyword">instanceof</span> Number) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> BigDecimal(String.valueOf(value)).compareTo(BigDecimal.ZERO) != <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> value != <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>4、TrimSqINode&amp;WhereSqINode&amp;SetSqINode</strong></p><p><code>TrimSqlNode</code>会根据子节点的解析结果，添加或删除相应的前缀或后缀。其中几个字段如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 记录子节点</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> SqlNode contents;</span><br><span class="line"><span class="comment">// SQL语句添加的前缀</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String prefix;</span><br><span class="line"><span class="comment">// SQL语句添加的后缀</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String suffix;</span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> List&lt;String&gt; prefixesToOverride;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> List&lt;String&gt; suffixesToOverride;</span><br></pre></td></tr></table></figure><p>在<code>TrimSqlNode</code>的构造函数中，会调用<code>parseOverrides()</code>方法对参数<code>prefixesToOverride</code>(对应<code>&lt;trim&gt;</code>节点的<code>prefixOverrides</code>属性)和参数<code>suffixesToOverride</code>(对应<code>&lt;trim&gt;</code>节点的<code>suffixOverrides</code>属性)进行解析，并初始化<code>prefixesToOverride</code>和<code>sufflxesToOverride</code>。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">parseOverrides</span><span class="params">(String overrides)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (overrides != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">final</span> StringTokenizer parser = <span class="keyword">new</span> StringTokenizer(overrides, <span class="string">&quot;|&quot;</span>, <span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">final</span> List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;(parser.countTokens());</span><br><span class="line">    <span class="keyword">while</span> (parser.hasMoreTokens()) &#123;</span><br><span class="line">      list.add(parser.nextToken().toUpperCase(Locale.ENGLISH));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> Collections.emptyList();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>TrimSqlNode.apply()</code>方法首先解析子节点，然后根据子节点的解析结果处理前缀和后缀。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">apply</span><span class="params">(DynamicContext context)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 创建FilteredDynamicContext对象，其中封装了DynamicContext</span></span><br><span class="line">  FilteredDynamicContext filteredDynamicContext = <span class="keyword">new</span> FilteredDynamicContext(context);</span><br><span class="line">  <span class="comment">// 调用子节点的apply方法进行解析</span></span><br><span class="line">  <span class="keyword">boolean</span> result = contents.apply(filteredDynamicContext);</span><br><span class="line">  <span class="comment">// 处理前缀和后缀</span></span><br><span class="line">  filteredDynamicContext.applyAll();</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>处理前缀和后缀的主要逻辑是在<code>FilteredDynamicContext</code>中实现的，它继承了<code>DynamicContext</code>，同时也是<code>DynamicContext</code>的代理类。</p><p><code>FilteredDynamicContext</code>除了将对应方法调用委托给其中封装的<code>DynamicContext</code>对象，还提供了处理前缀和后缀的<code>applyAll()</code>方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">FilteredDynamicContext</span> <span class="keyword">extends</span> <span class="title">DynamicContext</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 底层封装的DynamicContext对象</span></span><br><span class="line">  <span class="keyword">private</span> DynamicContext delegate;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 是否已经处理过前缀和后缀</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">boolean</span> prefixApplied;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">boolean</span> suffixApplied;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 记录子节点解析过后的结果</span></span><br><span class="line">  <span class="keyword">private</span> StringBuilder sqlBuffer;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">applyAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取子节点解析过后的结果，并全部转换为大写</span></span><br><span class="line">    sqlBuffer = <span class="keyword">new</span> StringBuilder(sqlBuffer.toString().trim());</span><br><span class="line">    String trimmedUppercaseSql = sqlBuffer.toString().toUpperCase(Locale.ENGLISH);</span><br><span class="line">    <span class="keyword">if</span> (trimmedUppercaseSql.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      applyPrefix(sqlBuffer, trimmedUppercaseSql);<span class="comment">// 处理前缀</span></span><br><span class="line">      applySuffix(sqlBuffer, trimmedUppercaseSql);<span class="comment">// 处理后缀</span></span><br><span class="line">    &#125;</span><br><span class="line">    delegate.appendSql(sqlBuffer.toString());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 处理前缀</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">applyPrefix</span><span class="params">(StringBuilder sql, String trimmedUppercaseSql)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!prefixApplied) &#123;</span><br><span class="line">      prefixApplied = <span class="keyword">true</span>;</span><br><span class="line">      <span class="keyword">if</span> (prefixesToOverride != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (String toRemove : prefixesToOverride) &#123;</span><br><span class="line">          <span class="keyword">if</span> (trimmedUppercaseSql.startsWith(toRemove)) &#123;</span><br><span class="line">            sql.delete(<span class="number">0</span>, toRemove.trim().length());</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (prefix != <span class="keyword">null</span>) &#123;</span><br><span class="line">        sql.insert(<span class="number">0</span>, <span class="string">&quot; &quot;</span>);</span><br><span class="line">        sql.insert(<span class="number">0</span>, prefix);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 处理后缀</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">applySuffix</span><span class="params">(StringBuilder sql, String trimmedUppercaseSql)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!suffixApplied) &#123;</span><br><span class="line">      suffixApplied = <span class="keyword">true</span>;</span><br><span class="line">      <span class="keyword">if</span> (suffixesToOverride != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (String toRemove : suffixesToOverride) &#123;</span><br><span class="line">          <span class="keyword">if</span> (trimmedUppercaseSql.endsWith(toRemove) || </span><br><span class="line">              trimmedUppercaseSql.endsWith(toRemove.trim())) &#123;</span><br><span class="line">            <span class="keyword">int</span> start = sql.length() - toRemove.trim().length();</span><br><span class="line">            <span class="keyword">int</span> end = sql.length();</span><br><span class="line">            sql.delete(start, end);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (suffix != <span class="keyword">null</span>) &#123;</span><br><span class="line">        sql.append(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        sql.append(suffix);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><u><code>WhereSqlNode</code>和<code>SetSqlNode</code>都继承了<code>TrimSqlNode</code></u>。</p><p>其中<code>WhereSqlNode</code>指定了<code>prefix</code>字段为<code>WHERE</code>，<code>prefixesToOverride</code>集合中的项为<code>AND</code>和<code>OR</code>，<code>suffix</code>字段和<code>suffixesToOverride</code>集合为<code>null</code>。也就是说，<code>&lt;where&gt;</code>节点解析后的<code>SQL</code>语句片段如果以<code>AND</code>或<code>OR</code>开头，则将开头处的<code>AND</code>或<code>OR</code>删除，之后再将<code>WHERE</code>关键字添加到<code>SQL</code>片段开始位置，从而得到该<code>&lt;where&gt;</code>节点最终生成的<code>SQL</code>片段。</p><p><code>SetSqlNode</code>指定了<code>prefix</code>字段为<code>SET</code>，<code>suffixesToOverride</code>集合中的项只有<code>suffix</code>字段和<code>prefixesToOverride</code>集合为<code>null</code>。也就是说，<code>&lt;set&gt;</code>节点解析后的<code>SQL</code>语句片段如果以<code>,</code>结尾，则将结尾处的删除掉，之后再将<code>SET</code>关键字添加到<code>SQL</code>片段的开始位置，从而得到该<code>&lt;set&gt;</code>节点最终生成的<code>SQL</code>片段。</p><p><strong>5、ForeachSqINode</strong></p><p>在动态<code>SQL</code>语句中构建<code>IN</code>条件语句的时候，通常需要对一个集合进行迭代，<code>MyBatis</code>提供了<code>&lt;foreach&gt;</code>标签实现该功能。在使用<code>&lt;foreach&gt;</code>标签迭代集合时，不仅可以使用集合的元素和索引值，还可以在循环开始之前或结束之后添加指定的字符串，也允许在迭代过程中添加指定的分隔符。</p><p>解析<code>&lt;foreach&gt;</code>节点对应的<code>sqlnode</code>实现类是<code>ForeachSqlNode</code>，以下是其中定义的字段：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 用于判断循环的终止条件，ForeachSqlNode构造方法中会创建该对象</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ExpressionEvaluator evaluator;</span><br><span class="line"><span class="comment">// 迭代的集合表达式</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String collectionExpression;</span><br><span class="line"><span class="comment">// 子节点</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> SqlNode contents;</span><br><span class="line"><span class="comment">// 循环开始前要添加的字符串</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String open;</span><br><span class="line"><span class="comment">// 循环结束时要添加的字符串</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String close;</span><br><span class="line"><span class="comment">// 分隔符</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String separator;</span><br><span class="line"><span class="comment">// 本次迭代的元素</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String item;</span><br><span class="line"><span class="comment">// 当前迭代的次数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String index;</span><br><span class="line"><span class="comment">// 配置</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Configuration configuration;</span><br></pre></td></tr></table></figure><p><code>ForeachSqINode</code>中有两个内部类，分别是<code>PrefixedContext</code>和<code>FilteredDynamicContext</code>，它们都继承了<code>DynamicContext</code>，同时也都是<code>DynamicContext</code>的代理类。</p><p><strong><code>PreFixedContext</code></strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">PrefixedContext</span> <span class="keyword">extends</span> <span class="title">DynamicContext</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> DynamicContext delegate;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> String prefix;</span><br><span class="line">  <span class="comment">// 是否已经处理过前缀</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">boolean</span> prefixApplied;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">appendSql</span><span class="params">(String sql)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!prefixApplied &amp;&amp; sql != <span class="keyword">null</span> &amp;&amp; sql.trim().length() &gt; <span class="number">0</span>) &#123; <span class="comment">// 是否需要追加前缀</span></span><br><span class="line">      delegate.appendSql(prefix); <span class="comment">// 追加前缀</span></span><br><span class="line">      prefixApplied = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    delegate.appendSql(sql); <span class="comment">// 追加sql</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><code>FilteredDynamicContext</code></strong></p><p><code>FilteredDynamicContext</code>负责处理<code>#&#123;&#125;</code>占位符，但它并未完全解析<code>#&#123;&#125;</code>占位符。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">FilteredDynamicContext</span> <span class="keyword">extends</span> <span class="title">DynamicContext</span> </span>&#123;</span><br><span class="line">  <span class="comment">// DynamicContext对象</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> DynamicContext delegate;</span><br><span class="line">  <span class="comment">// 索引位置</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> index;</span><br><span class="line">  <span class="comment">// 对应集合项的index</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> String itemIndex;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> String item;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">appendSql</span><span class="params">(String sql)</span> </span>&#123;</span><br><span class="line">    GenericTokenParser parser = <span class="keyword">new</span> GenericTokenParser(<span class="string">&quot;#&#123;&quot;</span>, <span class="string">&quot;&#125;&quot;</span>, <span class="keyword">new</span> TokenHandler() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> String <span class="title">handleToken</span><span class="params">(String content)</span> </span>&#123;</span><br><span class="line">        String newContent = </span><br><span class="line">          content.replaceFirst(<span class="string">&quot;^\\s*&quot;</span> + item + <span class="string">&quot;(?![^.,:\\s])&quot;</span>, itemizeItem(item, index));</span><br><span class="line">        <span class="keyword">if</span> (itemIndex != <span class="keyword">null</span> &amp;&amp; newContent.equals(content)) &#123;</span><br><span class="line">          newContent = </span><br><span class="line">            content.replaceFirst(<span class="string">&quot;^\\s*&quot;</span> + itemIndex + <span class="string">&quot;(?![^.,:\\s])&quot;</span>, </span><br><span class="line">                                 itemizeItem(itemIndex, index));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> StringBuilder(<span class="string">&quot;#&#123;&quot;</span>).append(newContent).append(<span class="string">&quot;&#125;&quot;</span>).toString();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    delegate.appendSql(parser.parse(sql));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getUniqueNumber</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> delegate.getUniqueNumber();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>6、ChooseSqlNode</strong></p><p>如果在编写动态<code>SQL</code>语句时需要类似<code>Java</code>中的<code>switch</code>语句的功能，可以考虑使用<code>&lt;choose&gt;</code>、<code>&lt;when&gt;</code>和<code>&lt;otherwise&gt;</code>三个标签的组合。<code>MyBatis</code>会将<code>&lt;choose&gt;</code>标签解析成<code>ChooseSqlNode</code>，将<code>&lt;when&gt;</code>标签解析成<code>IfSqlNode</code>，将<code>&lt;otherwise&gt;</code>标签解析成<code>MixedSqlNode</code>。</p><p><code>ChooseSqlNode.apply()</code>方法的逻辑比较简单，首先遍历<code>ifSqlNodes</code>集合并调用其中<code>SqlNode</code><br>对象的<code>apply()</code>方法，然后根据前面的处理结果决定是否调用<code>defaultSqlNode</code>的<code>apply()</code>方法。</p><p><strong>7、VarDecISqINode</strong></p><p><code>VarDeclSqlNode</code>表示的是动态<code>SQL</code>语句中的<code>&lt;bind&gt;</code>节点,该节点可以从<code>OGNL</code>表达式中创建一个变量并将其记录到上下文中。</p><p>在<code>VarDecISqINode</code>中通过<code>name</code>字段记录<code>&lt;bind&gt;</code>节点的<code>name</code>属性值，<code>expression</code>字段记录<code>&lt;bind&gt;</code>节点的<code>value</code>属性值。</p><h2 id="SqlSourceBuilder"><a href="#SqlSourceBuilder" class="headerlink" title="SqlSourceBuilder"></a>SqlSourceBuilder</h2><p>在经过<code>SqlNode.apply()</code>方法的解析之后，<code>SQL</code>语句会被传递到<code>SqlSourceBuilder</code>中进行进一步的解析。</p><p><code>SqISourceBuilder</code>主要完成了两方面的操作，一方面是解析<code>SQL</code>语句中的<code>#&#123;&#125;</code><br>占位符中定义的属性，格式类似于<code>#&#123;__frc_item_0,javaType=int,jdbcType=NUMERIC,typeHandler=MyTypeHandler&#125;</code>，另一方面是将<code>SQL</code>语句中的<code>#&#123;&#125;</code>占位符替换成<code>?</code>占位符。</p><p><code>SqlSourceBuilder</code>也是<code>BaseBuilder</code>的子类之一，其核心逻辑位于<code>parse()</code>方法中。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> SqlSource <span class="title">parse</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  String originalSql, Class&lt;?&gt; parameterType, Map&lt;String, Object&gt; additionalParameters)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 第一个参数是经过SqlNode.apply()方法处理之后的sql语句</span></span><br><span class="line">  <span class="comment">// 第二个参数是用户传入的实参类型</span></span><br><span class="line">  <span class="comment">// 第三个参数记录了形参与实参的对应关系，其实就是经过SqlNode.apply()方法处理后的DynamicContext.bindings集合</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 创建ParameterMappingTokenHandler对象， 它是解析#&#123;&#125;占位符中的参数属性以及替换占位符的核心</span></span><br><span class="line">  ParameterMappingTokenHandler handler = </span><br><span class="line">    <span class="keyword">new</span> ParameterMappingTokenHandler(configuration, parameterType, additionalParameters);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 配合ParameterMappingTokenHandler解析占位符</span></span><br><span class="line">  GenericTokenParser parser = <span class="keyword">new</span> GenericTokenParser(<span class="string">&quot;#&#123;&quot;</span>, <span class="string">&quot;&#125;&quot;</span>, handler);</span><br><span class="line">  String sql = parser.parse(originalSql);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> StaticSqlSource(configuration, sql, handler.getParameterMappings());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="DynamicSqlSource"><a href="#DynamicSqlSource" class="headerlink" title="DynamicSqlSource"></a>DynamicSqlSource</h2><p><code>DynamicSqlSource</code>负责解析动态<code>SQL</code>语句，也是最常用的<code>Sqlource</code>实现之一。<code>SqlNode</code>中使用了组合模式，形成了一个树状结构，<code>DynamicSqlSource</code>中使用<code>rootSqlNode</code>字段(<code>SqlNode</code>类型)记录了待解析的<code>SqlNode</code>树的根节点。</p><p><code>DynamicSqlSource.getBoundSql()</code>方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> BoundSql <span class="title">getBoundSql</span><span class="params">(Object parameterObject)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 创建DynamicContext对象</span></span><br><span class="line">  DynamicContext context = <span class="keyword">new</span> DynamicContext(configuration, parameterObject);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 通过调用rootSqlNode.apply()方法调用整个树形结构中全部SqlNode.apply()方法。</span></span><br><span class="line">  <span class="comment">// 每个SqlNode的apply()方法都将解析得到的SQL语句片段追加到context中，</span></span><br><span class="line">  <span class="comment">// 最终通过context.getSql()得到完整的SQL语句</span></span><br><span class="line">  rootSqlNode.apply(context);</span><br><span class="line">  SqlSourceBuilder sqlSourceParser = <span class="keyword">new</span> SqlSourceBuilder(configuration);</span><br><span class="line">  Class&lt;?&gt; parameterType = parameterObject == <span class="keyword">null</span> ? </span><br><span class="line">    Object.class : parameterObject.getClass();</span><br><span class="line">  SqlSource sqlSource = sqlSourceParser.parse(context.getSql(), </span><br><span class="line">                                              parameterType, context.getBindings());</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 创建BoundSql对象，并将DynamicContext.bindings中的参数信息复制到其</span></span><br><span class="line">  BoundSql boundSql = sqlSource.getBoundSql(parameterObject);</span><br><span class="line">  <span class="keyword">for</span> (Map.Entry&lt;String, Object&gt; entry : context.getBindings().entrySet()) &#123;</span><br><span class="line">    boundSql.setAdditionalParameter(entry.getKey(), entry.getValue());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> boundSql;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/cayzlh/img-repo/raw/master/2020/08/10441615985826561598582656771.png" alt="image-20200828104415997"></p><h2 id="RawSqISource"><a href="#RawSqISource" class="headerlink" title="RawSqISource"></a>RawSqISource</h2><p><code>RawSqISource</code>是<code>SqlSource</code>的另一个实现，其逻辑与<code>DynamicSqlSource</code>类似，但是执行时机不一样，处理的<code>SQL</code>语句类型也不一样。</p><p>前面介绍<code>XMLScriptBuilder.parseDynamicTags()</code>方法时提到过，如果节点只包含<code>#&#123;&#125;</code>占位符，而不包含动态<code>SQL</code>节点或未解析的<code>$&#123;&#125;</code>占位符的话，则不是动态<code>SQL</code>语句，会创建相应的<code>StaticTextSqlNode</code>对象。</p><p>在<code>XMLScriptBuilder.parseScriptNode()</code>方法中会判断整个<code>SQL</code>节点是否为动态的，如果不是动态的<code>SQL</code>节点，则创建相应的<code>RawSqlSource</code>对象。</p><p><strong><code>RawSqlSource</code>在构造方法中首先会调用<code>getSql()</code>方法，其中通过调用<code>SqlNode.apply()</code>方法完成<code>SQL</code>语句的拼装和初步处理；</strong>之后会使用<code>SqlSourceBuilder</code>完成占位符的替换和<code>ParameterMapping</code>集合的创建，并返回<code>StaticSqlSource</code>对象。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RawSqlSource</span> <span class="keyword">implements</span> <span class="title">SqlSource</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> SqlSource sqlSource;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">RawSqlSource</span><span class="params">(Configuration configuration, SqlNode rootSqlNode, Class&lt;?&gt; parameterType)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 调用getsql()方法，完成SQL语句的拼装和初步解析</span></span><br><span class="line">    <span class="keyword">this</span>(configuration, getSql(configuration, rootSqlNode), parameterType);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">RawSqlSource</span><span class="params">(Configuration configuration, String sql, Class&lt;?&gt; parameterType)</span> </span>&#123;</span><br><span class="line">    SqlSourceBuilder sqlSourceParser = <span class="keyword">new</span> SqlSourceBuilder(configuration);</span><br><span class="line">    Class&lt;?&gt; clazz = parameterType == <span class="keyword">null</span> ? Object.class : parameterType;</span><br><span class="line">    sqlSource = sqlSourceParser.parse(sql, clazz, <span class="keyword">new</span> HashMap&lt;String, Object&gt;());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">getSql</span><span class="params">(Configuration configuration, SqlNode rootSqlNode)</span> </span>&#123;</span><br><span class="line">    DynamicContext context = <span class="keyword">new</span> DynamicContext(configuration, <span class="keyword">null</span>);</span><br><span class="line">    rootSqlNode.apply(context);</span><br><span class="line">    <span class="keyword">return</span> context.getSql();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> BoundSql <span class="title">getBoundSql</span><span class="params">(Object parameterObject)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sqlSource.getBoundSql(parameterObject);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>无论是<code>StaticSqlSource</code>、<code>DynamicSqlSource</code>还是<code>RawSqlSource</code>，最终都会统一生成<code>BoundSql</code>对象，其中封装了<u>完整的<code>SQL</code>语句(可能包含<code>?</code>占位符)</u>、<u>参数映射关系(<code>parameterMappings</code>集合)</u>以及<u>用户传入的参数(<code>additionalParameters</code>集合)</u>。</p><p>另外，<code>DynamicSqlSource</code>负责处理动态<code>SQL</code>语句，<code>RawSqlSource</code>负责处理静态<code>SQL</code>语句，除此之外，<u>两者解析<code>SQL</code>语句的时机也不一样，前者的解析时机是在实际执行<code>SQL</code>语句之前，而后者则是在<code>MyBatis</code>初始化时完成<code>SQL</code>语句的解析。</u></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><p><strong>《MyBatis技术内幕》</strong></p></li><li><p>部分图片来源——<strong>《MyBatis技术内幕》</strong></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 书籍 </category>
          
          <category> 《MyBatis技术内幕》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MyBatis </tag>
            
            <tag> 《MyBatis技术内幕》 </tag>
            
            <tag> 核心处理层 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>核心处理层-MyBatis初始化</title>
      <link href="/blog/2020/06/22/c499e157.html"/>
      <url>/blog/2020/06/22/c499e157.html</url>
      
        <content type="html"><![CDATA[<p>核心处理层以基础支持层为基础，实现了<code>MyBatis</code>的核心功能。这个部分将从<code>MyBatis</code>的初始化、动态<code>SQL</code>语句的解析、结果集的映射、参数解析以及<code>SQL</code>语句的执行等几个方面分析<code>MyBatis</code>的核心处理层，了解<code>MyBatis</code>的核心原理。</p><p><img src="https://gitee.com/cayzlh/img-repo/raw/master/2020/06/22/image-20200622175512211_aegXOG.png" alt="image-20200622175512211"></p><blockquote><p>本篇介绍MyBatis的初始化</p></blockquote><p>在<code>MyBatis</code>初始化的过程中，除了会读取<code>mybatis-config.xml</code>配置文件以及映射配置文件，还会加载配置文件指定的类，处理类中的注解，创建一些配置对象，最终完成框架中各个模块的初始化。</p><p>另外，也可以使用<code>JavaAPI</code>的方式对<code>MyBatis</code>进行配置，这种硬编码的配置方式主要用在配置量比较少且配置信息不常变化的场景下。</p><h2 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h2><p>在<code>MyBatis</code>处理<code>mybatis-config.xml</code>以及映射配置文件时，会在内存中创建相应的配置对象，该过程的设计使用到<strong>建造者模式</strong>的相关知识。</p><p><img src="https://gitee.com/cayzlh/img-repo/raw/master/2020/06/22/image-20200622215026613_lPP12T.png" alt="image-20200622215026613"></p><p>建造者模式中的主要角色如下：</p><ul><li><p><strong>建造者(Builder)接口</strong></p><p>Builder接口用于定义建造者构建产品对象的各部分的行为。</p></li><li><p><strong>具体建造者(ConcreteBuilder)角色</strong></p><p><strong>在建造者模式中，直接创建产品对象的是具体建造者。</strong>具体建造者类必须实现建造者接口所要求的两类方法：</p><p>一类是建造方法，如上图中的<code>buildPart1()</code>、<code>buildPart2()</code>等方法。</p><p>另一类是获取构建好的产品对象的方法，如上图中的<code>getProduct()</code>方法。</p></li><li><p><strong>导演(Director)角色</strong></p><p>该角色会通过调用具体建造者， 创建需要的产品对象</p></li><li><p><strong>产品(Product)角色</strong></p><p>产品对象就是用户需要使用的复杂对象</p></li></ul><p>建造者模式的优点：</p><ul><li>建造者模式中的导演角色并不需要知晓产品类的内部细节，它只提供需要的信息给建造者，由具体建造者处理这些信息(这个处理过程可能会比较复杂)并完成产品构造。这就使<strong>产品对象的上层代码与产品对象的创建过程解耦。</strong></li><li>建造者模式将复杂产品的创建过程分散到了不同的构造步骤中，这样可以对产品创建过程实现更加精细的控制，也会使<strong>创建过程更加清晰。</strong></li><li>每个具体建造者都可以创建出完整的产品对象，而且具体建造者之间是相互独立的，因此系统就可以通过不同的具体建造者，得到不同的产品对象。<strong>当有新产品出现时，无须修改原有的代码，只需要添加新的具体建造者即可完成扩展</strong>，这符合<strong>开放-封闭</strong>原则。</li></ul><p>建造者模式也有一些缺点，它所创建的产品一般具有较多的共同点，其组成部分相似，<strong>如果产品之间的差异性很大，则不适合使用建造者模式。</strong></p><p>如果产品种类较多，且内部变化复杂，就需要定义多个具体建造者类来实现这种变化，导致整个系统变得很复杂，不易于理解。</p><h2 id="BaseBuilder"><a href="#BaseBuilder" class="headerlink" title="BaseBuilder"></a>BaseBuilder</h2><p><code>MyBatis</code>初始化的主要工作是加载并解析<code>mybatis-config.xml</code>配置文件、映射配置文件以及相关的注解信息。<code>MyBatis</code>的初始化入口是<code>SqlSessionFactoryBuilder.build()</code>方法，其具体实现如下:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> SqlSessionFactory <span class="title">build</span><span class="params">(Reader reader, String environment, Properties properties)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 读取配置文件</span></span><br><span class="line">    XMLConfigBuilder parser = <span class="keyword">new</span> XMLConfigBuilder(reader, environment, properties);</span><br><span class="line">    <span class="comment">// 解析配置文件得到Configuration对象，创建DefaultSqlSessionFactory对象</span></span><br><span class="line">    <span class="keyword">return</span> build(parser.parse());</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> ExceptionFactory.wrapException(<span class="string">&quot;Error building SqlSession.&quot;</span>, e);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    ErrorContext.instance().reset();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      reader.close();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">      <span class="comment">// Intentionally ignore. Prefer previous error.</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>SqlSessionFactoryBuilder.build()</code>方法会创建<code>XMLConfigBuilder</code>对象来解析<code>mybatis-config.xml</code>配置文件，而<code>XMLConfigBuilder</code>继承自<code>BaseBuilder</code>抽象类。</p><p><img src="https://gitee.com/cayzlh/img-repo/raw/master/2020/06/23/image-20200623160844166_VAke1q.png" alt="image-20200623160844166"></p><p><code>MyBatis</code>的初始化过程使用了建造者模式，这里的<code>BaseBuilder</code>抽象类就扮演着建造者接口的角色。<code>BaseBuilder</code>中核心字段的含义如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Configuration是MyBatis初始化过程的核心对象，MyBatis中几乎全部的配置信息都会保存到Configuration中</span></span><br><span class="line"><span class="comment">// Configuration对象是在MyBatis初始化过程中创建且是全局唯一的（all-in-one配置对象）。</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> Configuration configuration;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在mybatis-config.xml配置文件中可以使用&lt;typeAliases&gt;标签定义别名，这些定义的别名都会记录在</span></span><br><span class="line"><span class="comment">// TypeAliasRegistry对象中</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> TypeAliasRegistry typeAliasRegistry;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在mybatis-config.xml配置文件中可以使用&lt;typeHandlers&gt;标签添加自定义TypeHandler器，</span></span><br><span class="line"><span class="comment">// 完成指定数据库类型与Java类型的转换，这些TypeHandler都会记录在TypeHandlerRegistry中</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> TypeHandlerRegistry typeHandlerRegistry;</span><br></pre></td></tr></table></figure><p><code>BaseBuilder</code>中记录的<code>TypeAliasRegistry</code>对象和<code>TypeHandlerRegistry</code>对象，其实是全局唯一的，它们都是在<code>Configuration</code>对象初始化时创建的。</p><p><code>Configuration</code>类中定义了这两个字段：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> TypeHandlerRegistry typeHandlerRegistry = <span class="keyword">new</span> TypeHandlerRegistry();</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> TypeAliasRegistry typeAliasRegistry = <span class="keyword">new</span> TypeAliasRegistry();</span><br></pre></td></tr></table></figure><p>在<code>BaseBuilder</code>构造函数中，通过相应的<code>Configuration.get*()</code>方法得到<code>TypeAliasRegistry</code>对象和<code>TypeHandlerRegistry</code>对象，并赋值给<code>BaseBuilder</code>相应字段。</p><p><code>BaseBuilder.resolveAlias()</code>方法依赖<code>TypeAliasRegistry</code>解析别名，<code>BaseBuilder.resolveTypeHandler()</code>方法依赖<code>TypeHandlerRegistry</code>查找指定的<code>TypeHandler</code>对象。</p><p><code>MyBatis</code>使用<code>JdbcType</code>枚举类型表示<code>JDBC</code>类型。<code>MyBatis</code>中常用的枚举类型还有<code>ResultSetType</code>和<code>ParameterMode:ResultSetType</code>枚举类型表示结果集类型，使用<code>ParameterMode</code>枚举类型表示存储过程中的参数类型。</p><p>在<code>BaseBuilder</code>中提供了相应的<code>resolveJdbcType()</code>、<code>resolveResultSetType()</code>、<code>resolveParameterMode()</code>方法，将<code>String</code>转换成对应的枚举对象。</p><h2 id="XMLConfigBuilder"><a href="#XMLConfigBuilder" class="headerlink" title="XMLConfigBuilder"></a>XMLConfigBuilder</h2><p><code>XMLConfigBuilder</code>是<code>BaseBuilder</code>的众多子类之一，它扮演的是具体建造者的角色。**<code>XMLConfigBuilder</code>主要负责解析<code>mybatis-config.xml</code>配置。**</p><p>核心字段：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 标识是否已经解析过mybatis-config.xml文件</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> parsed;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于解析mybatis-config.xml配置文件的XpathParser对象</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> XPathParser parser;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 标识 &lt;environment&gt; 配置的名称， 默认读取&lt;environment&gt;标签的默认值</span></span><br><span class="line"><span class="keyword">private</span> String environment;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 负责创建和缓存Reflector对象</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReflectorFactory localReflectorFactory = <span class="keyword">new</span> DefaultReflectorFactory();</span><br></pre></td></tr></table></figure><p><code>XMLConfigBuilder.parse()</code>方法是解析<code>mybatis-config.xml</code>配置文件的入口，它通过调用<code>XMLConfigBuilder.parseConfiguration()</code>方法实现整个解析过程。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Configuration <span class="title">parse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (parsed) &#123;</span><br><span class="line">    <span class="comment">// 根据parsed变量的值判断是否已经完成了对mybatis-config.xml配置文件的解析</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">&quot;Each XMLConfigBuilder can only be used once.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  parsed = <span class="keyword">true</span>;</span><br><span class="line">  <span class="comment">// 找到 configuration 节点，开始解析</span></span><br><span class="line">  parseConfiguration(parser.evalNode(<span class="string">&quot;/configuration&quot;</span>));</span><br><span class="line">  <span class="keyword">return</span> configuration;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parseConfiguration</span><span class="params">(XNode root)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 解析properties节点</span></span><br><span class="line">    propertiesElement(root.evalNode(<span class="string">&quot;properties&quot;</span>));</span><br><span class="line">    <span class="comment">// 解析settings节点</span></span><br><span class="line">    Properties settings = settingsAsProperties(root.evalNode(<span class="string">&quot;settings&quot;</span>));</span><br><span class="line">    loadCustomVfs(settings);</span><br><span class="line">    typeAliasesElement(root.evalNode(<span class="string">&quot;typeAliases&quot;</span>));</span><br><span class="line">    pluginElement(root.evalNode(<span class="string">&quot;plugins&quot;</span>));</span><br><span class="line">    objectFactoryElement(root.evalNode(<span class="string">&quot;objectFactory&quot;</span>));</span><br><span class="line">    objectWrapperFactoryElement(root.evalNode(<span class="string">&quot;objectWrapperFactory&quot;</span>));</span><br><span class="line">    reflectorFactoryElement(root.evalNode(<span class="string">&quot;reflectorFactory&quot;</span>));</span><br><span class="line">    settingsElement(settings);</span><br><span class="line">    <span class="comment">// read it after objectFactory and objectWrapperFactory issue #631</span></span><br><span class="line">    environmentsElement(root.evalNode(<span class="string">&quot;environments&quot;</span>));</span><br><span class="line">    databaseIdProviderElement(root.evalNode(<span class="string">&quot;databaseIdProvider&quot;</span>));</span><br><span class="line">    typeHandlerElement(root.evalNode(<span class="string">&quot;typeHandlers&quot;</span>));</span><br><span class="line">    mapperElement(root.evalNode(<span class="string">&quot;mappers&quot;</span>));</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">&quot;Error parsing SQL Mapper Configuration. Cause: &quot;</span> + e, e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解析<code>&lt;properties&gt;</code>节点</strong></p><p><code>XMLConfigBuilder.propertiesElement()</code>方法会解析<code>mybatis-config.xml</code>配置文件中的<code>properties</code>节点并形成<code>java.util.Properties</code>对象，之后将该<code>Properties</code>对象设置到<code>XPathParser</code>和<code>Configuration</code>的<code>variables</code>字段中。在后面的解析过程中，会使用该<code>Properties</code>对象中的信息替换占位符。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">propertiesElement</span><span class="params">(XNode context)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (context != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 解析&lt;properties&gt;的子节点（&lt;property&gt;标签）的name和value属性， 并记录到Properties中</span></span><br><span class="line">    Properties defaults = context.getChildrenAsProperties();</span><br><span class="line">    <span class="comment">// 解析&lt;properties&gt;的resource和url属性，这两个属性用于确定properties配置文件的位置</span></span><br><span class="line">    String resource = context.getStringAttribute(<span class="string">&quot;resource&quot;</span>);</span><br><span class="line">    String url = context.getStringAttribute(<span class="string">&quot;url&quot;</span>);</span><br><span class="line">    <span class="comment">// resource和url属性不能同时存在，否则抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (resource != <span class="keyword">null</span> &amp;&amp; url != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">&quot;...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (resource != <span class="keyword">null</span>) &#123;</span><br><span class="line">      defaults.putAll(Resources.getResourceAsProperties(resource));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (url != <span class="keyword">null</span>) &#123;</span><br><span class="line">      defaults.putAll(Resources.getUrlAsProperties(url));</span><br><span class="line">    &#125;</span><br><span class="line">    Properties vars = configuration.getVariables();</span><br><span class="line">    <span class="keyword">if</span> (vars != <span class="keyword">null</span>) &#123;</span><br><span class="line">      defaults.putAll(vars);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 更新XPathParser和Configuration的variables字段</span></span><br><span class="line">    parser.setVariables(defaults);</span><br><span class="line">    configuration.setVariables(defaults);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解析<code>&lt;settings&gt;</code>节点</strong></p><p><code>XMLConfigBuilder.settingsAsProperties()</code>方法负责解析<code>settings</code>节点，在<code>settings</code>点下的配置是<code>MyBatis</code>全局性的配置，它们会改变<code>MyBatis</code>的运行时行为，需要注意的是，在<code>MyBatis</code>初始化时，这些全局配置信息都会被记录到<code>Configuration</code>对象的对应属性中。</p><p>例如：开发人员可以通过配置<code>autoMappingBehavior</code>修改<code>MyBatis</code>是否开启自动映射的功能，具体配置如下</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">&lt;!- autoMappingBehavior配置项 是决 定MyBatis是否幵 启 自动 映射功能的条 件之一 --&gt; </span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;autoMappingBehavior&quot;</span> <span class="attr">value</span>=<span class="string">&quot;PARTIAL&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在<code>Configuration</code>中存在一个同名的相应字段：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> AutoMappingBehavior autoMappingBehavior = AutoMappingBehavior.PARTIAL;</span><br></pre></td></tr></table></figure><p><code>settingsAsProperties()</code>方法的解析方式与<code>propertiesElement()</code>方法类似，但是多了使用<code>MetaClass</code>检测<code>key</code>指定的属性在<code>Configuration</code>类中是否有对应<code>setter</code>方法的步骤。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Properties <span class="title">settingsAsProperties</span><span class="params">(XNode context)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (context == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Properties();</span><br><span class="line">  &#125;</span><br><span class="line">  Properties props = context.getChildrenAsProperties();</span><br><span class="line">  <span class="comment">// Check that all settings are known to the configuration class</span></span><br><span class="line">  <span class="comment">// 创建 Configuration 对应的MetaClass对象</span></span><br><span class="line">  MetaClass metaConfig = MetaClass.forClass(Configuration.class, localReflectorFactory);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 检测Configuration中是否定义了key指定属性相应的setter方法</span></span><br><span class="line">  <span class="keyword">for</span> (Object key : props.keySet()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!metaConfig.hasSetter(String.valueOf(key))) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">&quot;...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> props;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解析<code>&lt;typeAliases&gt;</code>、<code>&lt;typeHandlers&gt;</code>节点</strong></p><p><code>XMLConfigBuilder.typeAliasesElement()</code>方法负责解析<code>typeAliases</code>节点点及其子节点，并通过<code>TypeAliasRegistry</code>完成别名的注册。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">typeAliasesElement</span><span class="params">(XNode parent)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (XNode child : parent.getChildren()) &#123; <span class="comment">// 处理全部子节点</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="string">&quot;package&quot;</span>.equals(child.getName())) &#123; <span class="comment">// 处理package节点</span></span><br><span class="line"><span class="comment">// 获取指定包名</span></span><br><span class="line">        String typeAliasPackage = child.getStringAttribute(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        <span class="comment">// 通过TypeAliasRegistry扫描指定包中所有的类，并解析@Alias注解，完成别名注册</span></span><br><span class="line">        configuration.getTypeAliasRegistry().registerAliases(typeAliasPackage);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123; <span class="comment">// 处理typeAlias节点</span></span><br><span class="line">        String alias = child.getStringAttribute(<span class="string">&quot;alias&quot;</span>); <span class="comment">// 获取指定别名</span></span><br><span class="line">        String type = child.getStringAttribute(<span class="string">&quot;type&quot;</span>); <span class="comment">// 获取别名对应的类型</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          Class&lt;?&gt; clazz = Resources.classForName(type);</span><br><span class="line">          <span class="keyword">if</span> (alias == <span class="keyword">null</span>) &#123;</span><br><span class="line">            typeAliasRegistry.registerAlias(clazz); <span class="comment">// 扫描@Alias注解，完成注册</span></span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            typeAliasRegistry.registerAlias(alias, clazz); <span class="comment">// 注册别名</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">&quot;...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>XMLConfigBuilder.typeHandlerElement()</code>方法负责解析<code>typeHandlers</code>节点，并通过<code>TypeHandlerRegistry</code>对象完成<code>TypeHandler</code>的注册，该方法的实现与<code>typeAliasesElement()</code>方法类似。</p><p><strong>解析<code>&lt;plugins&gt;</code>节点</strong></p><p>插件是<code>MyBatis</code>提供的扩展机制之一，用户可以通过添加自定义插件在<code>SQL</code>语句执行过程中的某一点进行拦截。</p><p><code>MyBatis</code>中的自定义插件只需实现<code>Interceptor</code>接口，并通过注解指定想要拦截的方法签名即可。这里分析MyBatis中如何加载和管理插件。<br><code>XMLConfigBuilder.pluginElement()</code>方法负责解析<code>plugins</code>节点中定义的插件，并完成实例化和配置操作。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">pluginElement</span><span class="params">(XNode parent)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (XNode child : parent.getChildren()) &#123;</span><br><span class="line">      <span class="comment">// 获取plugin节点的interceptor属性</span></span><br><span class="line">      String interceptor = child.getStringAttribute(<span class="string">&quot;interceptor&quot;</span>);</span><br><span class="line">      <span class="comment">// 获取plugin节点下的properties配置的信息，并形成Properties对象</span></span><br><span class="line">      Properties properties = child.getChildrenAsProperties();</span><br><span class="line">      <span class="comment">// 通过TypeAliasRegistry解析别名之后，实例化Interceptor对象</span></span><br><span class="line">      Interceptor interceptorInstance </span><br><span class="line">        = (Interceptor) resolveClass(interceptor).newInstance();</span><br><span class="line">      <span class="comment">// 设置Interceptor的属性</span></span><br><span class="line">      interceptorInstance.setProperties(properties);</span><br><span class="line">      <span class="comment">// 记录Interceptor对象</span></span><br><span class="line">      configuration.addInterceptor(interceptorInstance);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所有配置的<code>Interceptor</code>对象都是通过<code>Configuration.interceptorChain</code>字段(<code>InterceptorChain</code>类型)管理的，<code>InterceptorChain</code>底层使用<code>ArrayList&lt;Interceptor&gt;</code>实现。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterceptorChain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Interceptor&gt; interceptors = <span class="keyword">new</span> ArrayList&lt;Interceptor&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">pluginAll</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Interceptor interceptor : interceptors) &#123;</span><br><span class="line">      target = interceptor.plugin(target);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptor</span><span class="params">(Interceptor interceptor)</span> </span>&#123;</span><br><span class="line">    interceptors.add(interceptor);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> List&lt;Interceptor&gt; <span class="title">getInterceptors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Collections.unmodifiableList(interceptors);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解析<code>&lt;objectFactory&gt;</code>节点</strong></p><p>我们可以通过添加自定义<code>Objectory</code>实现类、<code>ObjectWrapperFactory</code>实现类以及<code>ReflectorFactory</code>实现类对<code>MyBatis</code>进行扩展。<br><code>XMLConfigBuilder.objectFactoryElement()</code>方法负责解析并实例化<code>&lt;objectFactory&gt;</code>节点指定的<code>ObjectFactory</code>实现类，之后将自定义的<code>ObjectFactory</code>对象记录到<code>Configuration.objectFactory</code>字段中。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">objectFactoryElement</span><span class="params">(XNode context)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (context != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 获取&lt;objectFactory&gt;节点的type属性</span></span><br><span class="line">    String type = context.getStringAttribute(<span class="string">&quot;type&quot;</span>);</span><br><span class="line"><span class="comment">// 获取&lt;ObjectFactory&gt;节点下配置的信息，并形成Properties对象</span></span><br><span class="line">    Properties properties = context.getChildrenAsProperties();</span><br><span class="line">    <span class="comment">// 进行别名解析后，实例化自定义ObjectFactory实现</span></span><br><span class="line">    ObjectFactory factory = (ObjectFactory) resolveClass(type).newInstance();</span><br><span class="line">    <span class="comment">// 设置自定义ObjectFactory属性， 完成初始化相关操作</span></span><br><span class="line">    factory.setProperties(properties);</span><br><span class="line">    <span class="comment">// 将自定义ObjectFactory对象记录到Configuration对象的ObjectFactory字段中，待后续使用</span></span><br><span class="line">    configuration.setObjectFactory(factory);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>XMLConfigBuilder</code>对<code>&lt;objectWrapperFactory&gt;</code>节点、<code>&lt;reflectorFactory&gt;</code>节点的解析与上述过程类似，最终会将解析得到的自定义对象记录到<code>Configuration</code>的相应字段中。</p><p><strong>解析<code>&lt;environments&gt;</code>节点</strong></p><p>在实际生产中，同一项目可能分为开发、测试和生产多个不同的环境，每个环境的配置可能也不尽相同。</p><p><code>MyBatis</code>可以配置多个<code>&lt;environment&gt;</code>节点，每个<code>&lt;environment&gt;</code>节点对应一种环境的配置。但需要注意的是，尽管可以配置多个环境，每个<code>SqlSessionFactory</code>实例只能选择其一。</p><p><code>XMLConfigBuilder.environmentsElement()</code>方法负责解析<code>&lt;environments&gt;</code>的相关配置，它会根据<code>XMLConfigBuilder.environment</code>字段值确定要使用的<code>&lt;environment&gt;</code>配置，之后创建对应的<code>TransactionFactory</code>和<code>DataSource</code>对象，并封装进<code>Environment</code>对象中。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">environmentsElement</span><span class="params">(XNode context)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (context != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 未指定 XMLConfigBuilder.environment 字段，则使用default属性指定的&lt;environment&gt;</span></span><br><span class="line">    <span class="keyword">if</span> (environment == <span class="keyword">null</span>) &#123;</span><br><span class="line">      environment = context.getStringAttribute(<span class="string">&quot;default&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (XNode child : context.getChildren()) &#123;</span><br><span class="line">      String id = child.getStringAttribute(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">      <span class="keyword">if</span> (isSpecifiedEnvironment(id)) &#123;</span><br><span class="line">        TransactionFactory txFactory </span><br><span class="line">          = transactionManagerElement(child.evalNode(<span class="string">&quot;transactionManager&quot;</span>));</span><br><span class="line">        DataSourceFactory dsFactory = dataSourceElement(child.evalNode(<span class="string">&quot;dataSource&quot;</span>));</span><br><span class="line">        DataSource dataSource = dsFactory.getDataSource();</span><br><span class="line">        Environment.Builder environmentBuilder = <span class="keyword">new</span> Environment.Builder(id)</span><br><span class="line">          .transactionFactory(txFactory)</span><br><span class="line">          .dataSource(dataSource);</span><br><span class="line">        configuration.setEnvironment(environmentBuilder.build());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解析<code>&lt;databaseldProvider&gt;</code>节点</strong></p><p><code>MyBatis</code>不能像<code>Hibernate</code>那样，直接帮助开发人员屏蔽多种数据库产品在<code>SQL</code>语言支持方面的差异。</p><p>但是在<code>mybatis-config.xml</code>配置文件中，通过<code>&lt;databaseIdProvider&gt;</code>定义所有支持的数据库产品的<code>databaseld</code>,然后在映射配置文件中定义<code>SQL</code>语句节点时，通过<code>databaseld</code>指定该<code>SQL</code>语句应用的数据库产品，这样也可以实现类似的功能。</p><p>在<code>MyBatis</code>初始化时，会根据前面确定的<code>DataSource</code>确定当前使用的数据库产品，然后在解析映射配置文件时，加载不带<code>databaseld</code>属性和带有匹配当前数据库<code>databaseld</code>属性的所有SQL语句。如果同时找到带有<code>databaseld</code>和不带<code>databaseld</code>的相同语句，则后者会被舍弃，使用前者。</p><p><code>XMLConfigBuilder.databaseIdProviderElement()</code>方法负责解析<code>&lt;databaseIdProvider&gt;</code>节点，并创建指定的<code>DatabaseldProvider</code>对象。<code>DatabaseldProvider</code>会返回<code>databaseld</code>值，<code>MyBatis</code>会根据<code>databaseld</code>选择合适的<code>SQL</code>进行执行。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">databaseIdProviderElement</span><span class="params">(XNode context)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  DatabaseIdProvider databaseIdProvider = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">if</span> (context != <span class="keyword">null</span>) &#123;</span><br><span class="line">    String type = context.getStringAttribute(<span class="string">&quot;type&quot;</span>);</span><br><span class="line">    <span class="comment">// awful patch to keep backward compatibility</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&quot;VENDOR&quot;</span>.equals(type)) &#123;</span><br><span class="line">      type = <span class="string">&quot;DB_VENDOR&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Properties properties = context.getChildrenAsProperties();</span><br><span class="line">    <span class="comment">// 创建DatabaseIdProvider对象</span></span><br><span class="line">    databaseIdProvider = (DatabaseIdProvider) resolveClass(type).newInstance();</span><br><span class="line">    <span class="comment">// 配置DatabaseIdProvider，完成初始化</span></span><br><span class="line">    databaseIdProvider.setProperties(properties);</span><br><span class="line">  &#125;</span><br><span class="line">  Environment environment = configuration.getEnvironment();</span><br><span class="line">  <span class="keyword">if</span> (environment != <span class="keyword">null</span> &amp;&amp; databaseIdProvider != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 通过前面确定的DataSource获取databaseld，并记录到Configuration.databaseld字段中</span></span><br><span class="line">    String databaseId = databaseIdProvider.getDatabaseId(environment.getDataSource());</span><br><span class="line">    configuration.setDatabaseId(databaseId);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>MyBatis</code>提供的<code>DatabaseldProvider</code>接口及其实现比较简单。</p><p><code>DatabaseldProvider</code>接口的核心方法是<code>getDatabaseId()</code>方法，它主要负责通过给定的<code>DataSource</code>来查找对应的<code>databaseld</code>。</p><blockquote><p><code>MyBatis</code>提供了<code>VendorDatabaseldProvider</code>和<code>DefaukDatabaseldProvider</code>两个实现，其中<code>DefaultDatabaseldProvider</code>己过时。</p></blockquote><p><code>VendorDatabaseIdProvider.getDatabaseId()</code>方法在接收到<code>DataSource</code>对象时，会先解析<code>DataSource</code>所连接的数据库产品名称，之后根据<code>&lt;databaseIdProvider&gt;</code>节点配置的数据库产品名称与<code>databaseld</code>的对应关系确定最终的<code>databaseld</code>。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">getDatabaseName</span><span class="params">(DataSource dataSource)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  <span class="comment">// 解析DataSource连接的数据库产品的名称</span></span><br><span class="line">  String productName = getDatabaseProductName(dataSource);</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.properties != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;Object, Object&gt; property : properties.entrySet()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (productName.contains((String) property.getKey())) &#123;</span><br><span class="line">        <span class="keyword">return</span> (String) property.getValue();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// no match, return null</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> productName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">getDatabaseProductName</span><span class="params">(DataSource dataSource)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  Connection con = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    con = dataSource.getConnection();</span><br><span class="line">    DatabaseMetaData metaData = con.getMetaData();</span><br><span class="line">    <span class="keyword">return</span> metaData.getDatabaseProductName();</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (con != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        con.close();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">        <span class="comment">// ignored</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解析<code>&lt;mappers&gt;</code>节点</strong></p><p>在<code>MyBatis</code>初始化时，除了加载<code>mybatis-config.xml</code>配置文件，还会加载全部的映射配置文件，<code>mybatis-config.xml</code>配置文件中的<code>&lt;mappers&gt;</code>节点会告诉<code>MyBatis</code>去哪些位置查找映射配置文件以及使用了配置注解标识的接口。<br><code>XMLConfigBuilder.mapperElement()</code>方法负责解析<code>&lt;mappers&gt;</code>节点，它会创建<code>XMLMapperBuilder</code>对象加载映射文件，如果映射配置文件存在相应的<code>Mapper</code>接口，也会加载相应的<code>Mapper</code>接口，解析其中的注解并完成向<code>MapperRegistry</code>的注册。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">mapperElement</span><span class="params">(XNode parent)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (XNode child : parent.getChildren()) &#123; <span class="comment">// 处理&lt;mappers&gt;的子节点</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="string">&quot;package&quot;</span>.equals(child.getName())) &#123;<span class="comment">// &lt;package&gt;子节点</span></span><br><span class="line">        String mapperPackage = child.getStringAttribute(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        <span class="comment">// 扫描指定的包，并向MapperRegistry注册Mapper接口</span></span><br><span class="line">        configuration.addMappers(mapperPackage);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 获 取&lt;mapper&gt;节点的resource、url、class属性，这三个属性互斥</span></span><br><span class="line">        String resource = child.getStringAttribute(<span class="string">&quot;resource&quot;</span>);</span><br><span class="line">        String url = child.getStringAttribute(<span class="string">&quot;url&quot;</span>);</span><br><span class="line">        String mapperClass = child.getStringAttribute(<span class="string">&quot;class&quot;</span>);</span><br><span class="line">        <span class="comment">// 如果&lt;mapper&gt;节点指定了resource或是url属性，则创建XMLMapperBuilder对象，</span></span><br><span class="line">        <span class="comment">// 并通过该对象解析resource或是url属性指定的Mapper配置文件</span></span><br><span class="line">        <span class="keyword">if</span> (resource != <span class="keyword">null</span> &amp;&amp; url == <span class="keyword">null</span> &amp;&amp; mapperClass == <span class="keyword">null</span>) &#123;</span><br><span class="line">          ErrorContext.instance().resource(resource);</span><br><span class="line">          InputStream inputStream = Resources.getResourceAsStream(resource);</span><br><span class="line">          <span class="comment">// 创建XMLMapperBuilder对象，解析映射配置文件</span></span><br><span class="line">          XMLMapperBuilder mapperParser = </span><br><span class="line">            <span class="keyword">new</span> XMLMapperBuilder(inputStream, configuration, resource,</span><br><span class="line">                                 configuration.getSqlFragments());</span><br><span class="line">          mapperParser.parse();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (resource == <span class="keyword">null</span> &amp;&amp; url != <span class="keyword">null</span> &amp;&amp; mapperClass == <span class="keyword">null</span>) &#123;</span><br><span class="line">          ErrorContext.instance().resource(url);</span><br><span class="line">          InputStream inputStream = Resources.getUrlAsStream(url);</span><br><span class="line">          <span class="comment">// 创建XMLMapperBuilder对象，解析映射配置文件</span></span><br><span class="line">          XMLMapperBuilder mapperParser = </span><br><span class="line">            <span class="keyword">new</span> XMLMapperBuilder(inputStream, configuration, url, </span><br><span class="line">                                 configuration.getSqlFragments());</span><br><span class="line">          mapperParser.parse();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (resource == <span class="keyword">null</span> &amp;&amp; url == <span class="keyword">null</span> &amp;&amp; mapperClass != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="comment">// 如果&lt;mapper&gt;节点指定了class属性，则向MapperRegistry注册该Mapper接口</span></span><br><span class="line">          Class&lt;?&gt; mapperInterface = Resources.classForName(mapperClass);</span><br><span class="line">          configuration.addMapper(mapperInterface);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">&quot;...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="XMLMapperBuilder"><a href="#XMLMapperBuilder" class="headerlink" title="XMLMapperBuilder"></a>XMLMapperBuilder</h2><p>通过对<code>XMLConfigBuilder.mapperElement()</code>方法的介绍我们知道，<code>XMLMapperBuilder</code>负责解析映射配置文件，它继承了<code>BaseBuilder</code>抽象类，也是具体建造者的角色。<code>XMLMapperBuilder.parse()</code>方法是解析映射文件的入口。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 判断是否已加载过该映射文件</span></span><br><span class="line">  <span class="keyword">if</span> (!configuration.isResourceLoaded(resource)) &#123;</span><br><span class="line">    configurationElement(parser.evalNode(<span class="string">&quot;/mapper&quot;</span>));</span><br><span class="line">    <span class="comment">// 将resource添加到Configuration•loadedResources集合中保存，它是HashSet&lt;String&gt;</span></span><br><span class="line">    <span class="comment">// 类型的集合，其中记录了已经加栽过的映射文件。</span></span><br><span class="line">    configuration.addLoadedResource(resource);</span><br><span class="line">    bindMapperForNamespace();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 处理configurationElement()方法中解析失败的&lt;resultMap&gt;节点</span></span><br><span class="line">  parsePendingResultMaps();</span><br><span class="line">  <span class="comment">// 处理configurationElement()方法中解析失败的&lt;cache-ref&gt;节点</span></span><br><span class="line">  parsePendingCacheRefs();</span><br><span class="line">  <span class="comment">// 处理configurationElement()方法中解析失败的SQL语句节点</span></span><br><span class="line">  parsePendingStatements();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>XMLMapperBuilder</code>也是将每个节点的解析过程封装成了一个方法，而这些方法由<code>XMLMapperBuilder.configurationElement()</code>方法调用。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">configurationElement</span><span class="params">(XNode context)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    String namespace = context.getStringAttribute(<span class="string">&quot;namespace&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (namespace == <span class="keyword">null</span> || namespace.equals(<span class="string">&quot;&quot;</span>)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">&quot;Mapper&#x27;s namespace cannot be empty&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    builderAssistant.setCurrentNamespace(namespace);</span><br><span class="line">    cacheRefElement(context.evalNode(<span class="string">&quot;cache-ref&quot;</span>));</span><br><span class="line">    cacheElement(context.evalNode(<span class="string">&quot;cache&quot;</span>));</span><br><span class="line">    parameterMapElement(context.evalNodes(<span class="string">&quot;/mapper/parameterMap&quot;</span>));</span><br><span class="line">    resultMapElements(context.evalNodes(<span class="string">&quot;/mapper/resultMap&quot;</span>));</span><br><span class="line">    sqlElement(context.evalNodes(<span class="string">&quot;/mapper/sql&quot;</span>));</span><br><span class="line">    buildStatementFromContext(context.evalNodes(<span class="string">&quot;select|insert|update|delete&quot;</span>));</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">&quot;...&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>1. 解析<code>&lt;cache&gt;</code>节点</strong></p><p><code>MyBatis</code>拥有非常强大的二级缓存功能，该功能可以非常方便地进行配置，**<code>MyBatis</code>默认情**<br><strong>况下没有开启二级缓存，如果要为某命名空间开启二级缓存功能，则需要在相应映射配置文件中添加<code>&lt;cache&gt;</code>节点，还可以通过配置<code>&lt;cache&gt;</code>节点的相关属性，为二级缓存配置相应的特性(本质上就是添加相应的装饰器)。</strong></p><p><code>XMLMapperBuilder.cacheElement()</code>方法主要负责解析<code>&lt;cache&gt;</code>节点：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">cacheElement</span><span class="params">(XNode context)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (context != <span class="keyword">null</span>) &#123;</span><br><span class="line">    String type = context.getStringAttribute(<span class="string">&quot;type&quot;</span>, <span class="string">&quot;PERPETUAL&quot;</span>);</span><br><span class="line">    Class&lt;? extends Cache&gt; typeClass = typeAliasRegistry.resolveAlias(type);</span><br><span class="line">    String eviction = context.getStringAttribute(<span class="string">&quot;eviction&quot;</span>, <span class="string">&quot;LRU&quot;</span>);</span><br><span class="line">    Class&lt;? extends Cache&gt; evictionClass = typeAliasRegistry.resolveAlias(eviction);</span><br><span class="line">    Long flushInterval = context.getLongAttribute(<span class="string">&quot;flushInterval&quot;</span>);</span><br><span class="line">    Integer size = context.getIntAttribute(<span class="string">&quot;size&quot;</span>);</span><br><span class="line">    <span class="keyword">boolean</span> readWrite = !context.getBooleanAttribute(<span class="string">&quot;readOnly&quot;</span>, <span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">boolean</span> blocking = context.getBooleanAttribute(<span class="string">&quot;blocking&quot;</span>, <span class="keyword">false</span>);</span><br><span class="line">    Properties props = context.getChildrenAsProperties();</span><br><span class="line">    builderAssistant.useNewCache(</span><br><span class="line">      typeClass, evictionClass, flushInterval, size, readWrite, blocking, props);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>MapperBuilderAssistant</code>是一个辅助类，其<code>useNewCache()</code>方法负责创建<code>Cache</code>对象，并将其添加到<code>Configuration.caches</code>集合中保存。</p><p><code>Configuration</code>中的<code>caches</code>字段是<code>StrictMap&lt;Cache&gt;</code>类型的字段，它记录<code>Cache</code>的id(默认是映射文件的<code>namespace</code>)与<code>Cache</code>对象(二级缓存)之间的对应关系。</p><p><code>StrictMap</code>继承了<code>HashMap</code>,并在其基础上进行了少许修改，这里重点关注<code>StrictMap.put()</code>方法，如果检测到重复的<code>key</code>则抛出异常，如果没有重复的<code>key</code>则添加<code>key</code>以及<code>value</code>，同时会根据<code>key</code>产生<code>shortKey</code>。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(String key, V value)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (containsKey(key)) &#123; <span class="comment">// 如果已经包含了该key，则直接返回异常</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(name + <span class="string">&quot; already contains value for &quot;</span> + key);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (key.contains(<span class="string">&quot;.&quot;</span>)) &#123;</span><br><span class="line">    <span class="comment">// 按照将key切分成数组，并将数组的最后一项作为shortKey</span></span><br><span class="line">    <span class="keyword">final</span> String shortKey = getShortName(key);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">super</span>.get(shortKey) == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 如果不包含指定的sortKey，则添加键值对</span></span><br><span class="line">      <span class="keyword">super</span>.put(shortKey, value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 如果shortKey已存在，则将value修改成Ambiguity对象</span></span><br><span class="line">      <span class="keyword">super</span>.put(shortKey, (V) <span class="keyword">new</span> Ambiguity(shortKey));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">super</span>.put(key, value); <span class="comment">// 如果不包含该key，则添加键值对</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Ambiguity</code>是<code>StrictMap</code>中定义的静态内部类，它表示的是存在<strong>二义性的键值对</strong>。<code>Ambiguity</code>中使用<code>subject</code>字段记录了存在二义性的<code>key</code>，并提供了相应的<code>getter</code>方法。</p><p><code>StrictMap.get()</code>方法会检测<code>value</code>是否存在以及<code>value</code>是否为<code>Ambiguity</code>类型对象，如果满足这两个条件中的任意一个，则抛出异常。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">  V value = <span class="keyword">super</span>.get(key);</span><br><span class="line">  <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123; <span class="comment">// 如果key没有对应的value，就报错</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;...&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (value <span class="keyword">instanceof</span> Ambiguity) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;...&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>MapperBuilderAssistant. useNewCache()</code>方法的实现如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Cache <span class="title">useNewCache</span><span class="params">(Class&lt;? extends Cache&gt; typeClass,</span></span></span><br><span class="line"><span class="function"><span class="params">                         Class&lt;? extends Cache&gt; evictionClass,</span></span></span><br><span class="line"><span class="function"><span class="params">                         Long flushInterval,</span></span></span><br><span class="line"><span class="function"><span class="params">                         Integer size,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">boolean</span> readWrite,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">boolean</span> blocking,</span></span></span><br><span class="line"><span class="function"><span class="params">                         Properties props)</span> </span>&#123;</span><br><span class="line">  Cache cache = <span class="keyword">new</span> CacheBuilder(currentNamespace)</span><br><span class="line">    .implementation(valueOrDefault(typeClass, PerpetualCache.class))</span><br><span class="line">    .addDecorator(valueOrDefault(evictionClass, LruCache.class))</span><br><span class="line">    .clearInterval(flushInterval)</span><br><span class="line">    .size(size)</span><br><span class="line">    .readWrite(readWrite)</span><br><span class="line">    .blocking(blocking)</span><br><span class="line">    .properties(props)</span><br><span class="line">    .build();</span><br><span class="line">  configuration.addCache(cache);</span><br><span class="line">  currentCache = cache;</span><br><span class="line">  <span class="keyword">return</span> cache;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>CacheBuilder</code>是<code>Cache</code>的建造者，其字段如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 唯一标识，一般情况下对应的是映射文件中配置的namespace</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String id;</span><br><span class="line"><span class="comment">// Cache对象的真正实现类</span></span><br><span class="line"><span class="keyword">private</span> Class&lt;? extends Cache&gt; implementation;</span><br><span class="line"><span class="comment">// 装饰器集合</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> List&lt;Class&lt;? extends Cache&gt;&gt; decorators;</span><br><span class="line"><span class="comment">// 缓存大小</span></span><br><span class="line"><span class="keyword">private</span> Integer size;</span><br><span class="line"><span class="comment">// 清理时间周期</span></span><br><span class="line"><span class="keyword">private</span> Long clearInterval;</span><br><span class="line"><span class="comment">// 是否可读写</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> readWrite;</span><br><span class="line"><span class="comment">// 其他配置信息</span></span><br><span class="line"><span class="keyword">private</span> Properties properties;</span><br><span class="line"><span class="comment">// 是否阻塞</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> blocking;</span><br></pre></td></tr></table></figure><p><code>CacheBuilder.build()</code>方法，根据<code>CacheBuilder</code>中上述字段的值创建<code>Cache</code>对象并添加合适的装饰器。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Cache <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  setDefaultImplementations();</span><br><span class="line">  Cache cache = newBaseCacheInstance(implementation, id);</span><br><span class="line">  setCacheProperties(cache);</span><br><span class="line">  <span class="comment">// issue #352, do not apply decorators to custom caches</span></span><br><span class="line">  <span class="keyword">if</span> (PerpetualCache.class.equals(cache.getClass())) &#123;</span><br><span class="line">    <span class="keyword">for</span> (Class&lt;? extends Cache&gt; decorator : decorators) &#123;</span><br><span class="line">      cache = newCacheDecoratorInstance(decorator, cache);</span><br><span class="line">      setCacheProperties(cache);</span><br><span class="line">    &#125;</span><br><span class="line">    cache = setStandardDecorators(cache);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!LoggingCache.class.isAssignableFrom(cache.getClass())) &#123;</span><br><span class="line">    cache = <span class="keyword">new</span> LoggingCache(cache);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> cache;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>CacheBuilder.setCacheProperties()</code>方法会根据<code>&lt;cache&gt;</code>节点下配置的<code>&lt;property&gt;</code>信息，初始化<code>Cache</code>对象。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setCacheProperties</span><span class="params">(Cache cache)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (properties != <span class="keyword">null</span>) &#123;</span><br><span class="line">    MetaObject metaCache = SystemMetaObject.forObject(cache);</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;Object, Object&gt; entry : properties.entrySet()) &#123;</span><br><span class="line">      String name = (String) entry.getKey();</span><br><span class="line">      String value = (String) entry.getValue();</span><br><span class="line">      <span class="keyword">if</span> (metaCache.hasSetter(name)) &#123;</span><br><span class="line">        Class&lt;?&gt; type = metaCache.getSetterType(name);</span><br><span class="line">        <span class="keyword">if</span> (String.class == type) &#123;</span><br><span class="line">          metaCache.setValue(name, value);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">int</span>.class == type</span><br><span class="line">                   || Integer.class == type) &#123;</span><br><span class="line">          metaCache.setValue(name, Integer.valueOf(value));</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">long</span>.class == type</span><br><span class="line">                   || Long.class == type) &#123;</span><br><span class="line">          metaCache.setValue(name, Long.valueOf(value));</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">short</span>.class == type</span><br><span class="line">                   || Short.class == type) &#123;</span><br><span class="line">          metaCache.setValue(name, Short.valueOf(value));</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">byte</span>.class == type</span><br><span class="line">                   || Byte.class == type) &#123;</span><br><span class="line">          metaCache.setValue(name, Byte.valueOf(value));</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">float</span>.class == type</span><br><span class="line">                   || Float.class == type) &#123;</span><br><span class="line">          metaCache.setValue(name, Float.valueOf(value));</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">boolean</span>.class == type</span><br><span class="line">                   || Boolean.class == type) &#123;</span><br><span class="line">          metaCache.setValue(name, Boolean.valueOf(value));</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">double</span>.class == type</span><br><span class="line">                   || Double.class == type) &#123;</span><br><span class="line">          metaCache.setValue(name, Double.valueOf(value));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> CacheException(<span class="string">&quot;...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (InitializingObject.class.isAssignableFrom(cache.getClass()))&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      ((InitializingObject) cache).initialize();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> CacheException(<span class="string">&quot;...&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>CacheBuilder.setStandardDecorators()</code>方法会根据<code>CacheBuilder</code>中各个字段的值，为<code>cache</code>对象添加对应的装饰器。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Cache <span class="title">setStandardDecorators</span><span class="params">(Cache cache)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    MetaObject metaCache = SystemMetaObject.forObject(cache);</span><br><span class="line">    <span class="keyword">if</span> (size != <span class="keyword">null</span> &amp;&amp; metaCache.hasSetter(<span class="string">&quot;size&quot;</span>)) &#123;</span><br><span class="line">      metaCache.setValue(<span class="string">&quot;size&quot;</span>, size);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (clearInterval != <span class="keyword">null</span>) &#123;</span><br><span class="line">      cache = <span class="keyword">new</span> ScheduledCache(cache);</span><br><span class="line">      ((ScheduledCache) cache).setClearInterval(clearInterval);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (readWrite) &#123;</span><br><span class="line">      cache = <span class="keyword">new</span> SerializedCache(cache);</span><br><span class="line">    &#125;</span><br><span class="line">    cache = <span class="keyword">new</span> LoggingCache(cache);</span><br><span class="line">    cache = <span class="keyword">new</span> SynchronizedCache(cache);</span><br><span class="line">    <span class="keyword">if</span> (blocking) &#123;</span><br><span class="line">      cache = <span class="keyword">new</span> BlockingCache(cache);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cache;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> CacheException(<span class="string">&quot;...&quot;</span>, e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2. 解析<code>&lt;cache-ref&gt;</code>节点</strong></p><p><code>XMLMapperBuilder.cacheElement()</code>方法会为每个<code>namespace</code>创建一个对应的<code>Cache</code>对象，并在<code>Configuration.caches</code>集合中记录<code>namespace</code>与<code>Cache</code>对象之间的对应关系。</p><p>如果希望多个<code>namespace</code>共用同一个二级缓存，即同一个<code>Cache</code>对象，则可以使用<code>&lt;cache-ref&gt;</code>点进行配置。</p><blockquote><p><code>XMLMapperBuilder.cacheReffilement()</code>方法负责解析<code>&lt;cache-ref&gt;</code>节点。</p></blockquote><p>这里首先需要了解的是<code>Configuration.cacheRefMap</code>集合，该集合是<code>HashMap&lt;String，String&gt;</code>类型，其中<code>key</code>是<code>&lt;cache-ref&gt;</code>节点所在的<code>namespace</code>，<code>value</code>是<code>&lt;cache-ref&gt;</code>节点的<code>namespace</code>属性所指定的<code>namespace</code>。</p><p>也就是说，前者共用后者的<code>Cache</code>对象，如下图，<code>namespace2</code>共用了<code>namespace1</code>的<code>Cache</code>对象。</p><p><img src="https://gitee.com/cayzlh/img-repo/raw/master/2020/07/10/image-20200710104632511_3VqX9N.png" alt="image-20200710104632511"></p><p><code>XMLMapperBuilder.cacheReffilement()</code>：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">cacheRefElement</span><span class="params">(XNode context)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (context != <span class="keyword">null</span>) &#123;</span><br><span class="line">    configuration.addCacheRef(</span><br><span class="line">      builderAssistant.getCurrentNamespace(), context.getStringAttribute(<span class="string">&quot;namespace&quot;</span>));</span><br><span class="line">    CacheRefResolver cacheRefResolver = <span class="keyword">new</span> CacheRefResolver(</span><br><span class="line">      builderAssistant, context.getStringAttribute(<span class="string">&quot;namespace&quot;</span>));</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      cacheRefResolver.resolveCacheRef();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IncompleteElementException e) &#123;</span><br><span class="line">      <span class="comment">//如果解析过程出现异常，则添加到Configuration.incompleteCacheRefs集合，稍后再解析</span></span><br><span class="line">      configuration.addIncompleteCacheRef(cacheRefResolver);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>CacheRefResolver</code>是一个简单的<code>Cache</code>引用解析器，其中封装了被引用的<code>namespace</code>以及当前<code>XMLMapperBuilder</code>对应的<code>MapperBuilderAssistant</code>对象。</p><p><code>CacheRefResolver.resolveCacheRef()</code>方法会调用<code>MapperBuilderAssistant.useCacheRef()</code>方法。在<code>MapperBuilderAssistant.useCacheRef()</code>方法中会通过<code>namespace</code>查找被引用的<code>Cache</code>对象。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Cache <span class="title">useCacheRef</span><span class="params">(String namespace)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (namespace == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">&quot;...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      unresolvedCacheRef = <span class="keyword">true</span>;</span><br><span class="line">      Cache cache = configuration.getCache(namespace);</span><br><span class="line">      <span class="keyword">if</span> (cache == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IncompleteElementException(<span class="string">&quot;...&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      currentCache = cache;</span><br><span class="line">      unresolvedCacheRef = <span class="keyword">false</span>;</span><br><span class="line">      <span class="keyword">return</span> cache;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalArgumentException e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IncompleteElementException(<span class="string">&quot;...&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>另一个需要了解的<code>Configuration</code>字段是<code>incompleteCacheRefs</code>集合，它是<code>LinkedList&lt;CacheRefResolver&gt;</code>类型，其中记录了当前解析出现异常的<code>CacheRefResolver</code>对象。</p><p><strong>3. 解析<code>&lt;resultMap&gt;</code>节点</strong></p><p><code>select</code>语句查询得到的结果集是一张<strong>二维表</strong>，<u>水平方向上看是一个个字段，垂直方向上看是一条条记录</u>。</p><p>而<code>Java</code>是面向对象的程序设计语言，对象是根据类定义创建的，类之间的引用关系可以认为是嵌套的结构。</p><p>在<code>JDBC</code>编程中，为了将结果集中的数据映射成对象，我们需要自己写代码从结果集中获取数据，然后封装成对应的对象并设置对象之间的关系，而这些都是大量的重复性代码。</p><p>为了减少这些重复的代码，<code>MyBatis</code>使用<code>&lt;resultMap&gt;</code>节点定义了结果集与结果对象(<code>JavaBean</code>对象)之间的映射规则，<code>&lt;resultMap&gt;</code>节点可以满足绝大部分的映射需求，从而减少开发人员的重复性劳动，提高开发效率。</p><p>每个<code>ResultMapping</code>对象记录了结果集中的一列与<code>JavaBean</code>中一个属性之间的映射关系。<code>&lt;resultMap&gt;</code>节点下除了<code>&lt;discriminator&gt;</code>子节点的其他子节点，都会被解析成对应的<code>ResultMapping</code>对象。核心字段如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Configuration对象</span></span><br><span class="line"><span class="keyword">private</span> Configuration configuration;</span><br><span class="line"><span class="comment">//  应 节 点的property属 性，表示的是与 该 列进 行映射的属 性</span></span><br><span class="line"><span class="keyword">private</span> String property;</span><br><span class="line"><span class="comment">// 数据库获取的列名或别名</span></span><br><span class="line"><span class="keyword">private</span> String column;</span><br><span class="line"><span class="comment">// 对应的java类型，JavaBean的完全限定名</span></span><br><span class="line"><span class="keyword">private</span> Class&lt;?&gt; javaType;</span><br><span class="line"><span class="comment">// JDBC类型</span></span><br><span class="line"><span class="keyword">private</span> JdbcType jdbcType;</span><br><span class="line"><span class="comment">// 对应节点的typeHandler属性，表示的是类型处理器，它会覆盖默认的类型处理器，后面会介绍该字段的作用</span></span><br><span class="line"><span class="keyword">private</span> TypeHandler&lt;?&gt; typeHandler;</span><br><span class="line"><span class="comment">// 对应节点的resultMap属性，该属性通过id引用了另一个&lt;resultMap&gt;节点定义，它负责将结果集中的一部</span></span><br><span class="line"><span class="comment">// 分列映射成其他关联的结果对象。这样我们就可以通过join方式进行关联查询，然后直接映射成多个对象，</span></span><br><span class="line"><span class="comment">// 并同时设置这些对象之间的组合关系</span></span><br><span class="line"><span class="keyword">private</span> String nestedResultMapId;</span><br><span class="line"><span class="comment">// 对应节点的select属性，该属性通过id引用了另一个&lt;select&gt;节点定义，它会把指定的列的值传入</span></span><br><span class="line"><span class="comment">// select属性指定的select语句中作为参数进行查询。使用select属性可能会导致N+1问题</span></span><br><span class="line"><span class="keyword">private</span> String nestedQueryId;</span><br><span class="line"><span class="comment">// 非空字段集合</span></span><br><span class="line"><span class="keyword">private</span> Set&lt;String&gt; notNullColumns;</span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="keyword">private</span> String columnPrefix;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">private</span> List&lt;ResultFlag&gt; flags;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">private</span> List&lt;ResultMapping&gt; composites;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">private</span> String resultSet;</span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="keyword">private</span> String foreignColumn;</span><br><span class="line"><span class="comment">// 是否延迟加载</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> lazy;</span><br></pre></td></tr></table></figure><p><code>ResultMapping</code>中定义了一个内部<code>Builder</code>类，也应用了建造者模式，该<code>Builder</code>类主要用于数据整理和数据校验校验。</p><p>另一个比较重要的类是<code>ResultMap</code>，每个<code>&lt;resultMap&gt;</code>节点都会被解析成一个<code>ResultMap</code>对象，其中每个节点所定义的映射关系，则使用<code>ResultMapping</code>对象表示。</p><p><img src="https://gitee.com/cayzlh/img-repo/raw/master/2020/07/12/image-20200712084001741_Piqi53.png" alt="image-20200712084001741"></p><p><code>ResultMap</code>字段定义：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Configuration对象</span></span><br><span class="line"><span class="keyword">private</span> Configuration configuration;</span><br><span class="line"><span class="comment">// 对应节点的id属性</span></span><br><span class="line"><span class="keyword">private</span> String id;</span><br><span class="line"><span class="comment">// 对应节点的type属性</span></span><br><span class="line"><span class="keyword">private</span> Class&lt;?&gt; type;</span><br><span class="line"><span class="comment">// ResultMapping对象集合</span></span><br><span class="line"><span class="keyword">private</span> List&lt;ResultMapping&gt; resultMappings;</span><br><span class="line"><span class="comment">// 记录了映射关系中带有ID标志的映射关系，例如&lt;id&gt;节点和&lt;constructor&gt;节点的&lt;idArg&gt;子节点</span></span><br><span class="line"><span class="keyword">private</span> List&lt;ResultMapping&gt; idResultMappings;</span><br><span class="line"><span class="comment">// 记录了映射关系中带有Constructor标志的映射关系，例如&lt;constructor&gt;所有子元素</span></span><br><span class="line"><span class="keyword">private</span> List&lt;ResultMapping&gt; constructorResultMappings;</span><br><span class="line"><span class="comment">// 记录了映射关系中不带有Constructor标志的映射关系</span></span><br><span class="line"><span class="keyword">private</span> List&lt;ResultMapping&gt; propertyResultMappings;</span><br><span class="line"><span class="comment">// 记录所有映射关系中涉及的column属性的集合</span></span><br><span class="line"><span class="keyword">private</span> Set&lt;String&gt; mappedColumns;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">private</span> Set&lt;String&gt; mappedProperties;</span><br><span class="line"><span class="comment">// 鉴别器</span></span><br><span class="line"><span class="keyword">private</span> Discriminator discriminator;</span><br><span class="line"><span class="comment">// 是否含有嵌套的结果映射，如果某个映射关系中存在resultMap属性，且不存在resultSet属性，则为true</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> hasNestedResultMaps;</span><br><span class="line"><span class="comment">// 是否含有嵌套查询，如果某个属性映射存在select属性，则为true</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> hasNestedQueries;</span><br><span class="line"><span class="comment">// 是否开启自动映射</span></span><br><span class="line"><span class="keyword">private</span> Boolean autoMapping;</span><br></pre></td></tr></table></figure><p>在<code>XMLMapperBuilder</code>中通过<code>resultMapElements()</code>方法解析映射配置文件中的全部<code>&lt;resultMap&gt;</code>节点，该方法会循环调用<code>resultMapElement()</code>方法处理每个<code>&lt;resultMap&gt;</code>节点。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> ResultMap <span class="title">resultMapElement</span><span class="params">(XNode resultMapNode, List&lt;ResultMapping&gt; additionalResultMappings)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  ErrorContext.instance().activity(<span class="string">&quot;processing &quot;</span> + resultMapNode.getValueBasedIdentifier());</span><br><span class="line">  String id </span><br><span class="line">    = resultMapNode.getStringAttribute(</span><br><span class="line">    <span class="string">&quot;id&quot;</span>, resultMapNode.getValueBasedIdentifier());</span><br><span class="line">  String type </span><br><span class="line">    = resultMapNode.getStringAttribute(</span><br><span class="line">    <span class="string">&quot;type&quot;</span>,resultMapNode.getStringAttribute(</span><br><span class="line">      <span class="string">&quot;ofType&quot;</span>,resultMapNode.getStringAttribute(<span class="string">&quot;resultType&quot;</span>,</span><br><span class="line">                                     resultMapNode.getStringAttribute(<span class="string">&quot;javaType&quot;</span>))));</span><br><span class="line">  String extend = resultMapNode.getStringAttribute(<span class="string">&quot;extends&quot;</span>);</span><br><span class="line">  Boolean autoMapping = resultMapNode.getBooleanAttribute(<span class="string">&quot;autoMapping&quot;</span>);</span><br><span class="line">  Class&lt;?&gt; typeClass = resolveClass(type);</span><br><span class="line">  Discriminator discriminator = <span class="keyword">null</span>;</span><br><span class="line">  List&lt;ResultMapping&gt; resultMappings = <span class="keyword">new</span> ArrayList&lt;ResultMapping&gt;();</span><br><span class="line">  resultMappings.addAll(additionalResultMappings);</span><br><span class="line">  List&lt;XNode&gt; resultChildren = resultMapNode.getChildren();</span><br><span class="line">  <span class="keyword">for</span> (XNode resultChild : resultChildren) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&quot;constructor&quot;</span>.equals(resultChild.getName())) &#123;</span><br><span class="line">      processConstructorElement(resultChild, typeClass, resultMappings);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;discriminator&quot;</span>.equals(resultChild.getName())) &#123;</span><br><span class="line">      discriminator = processDiscriminatorElement(resultChild, typeClass, resultMappings);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      List&lt;ResultFlag&gt; flags = <span class="keyword">new</span> ArrayList&lt;ResultFlag&gt;();</span><br><span class="line">      <span class="keyword">if</span> (<span class="string">&quot;id&quot;</span>.equals(resultChild.getName())) &#123;</span><br><span class="line">        flags.add(ResultFlag.ID);</span><br><span class="line">      &#125;</span><br><span class="line">      resultMappings.add(buildResultMappingFromContext(resultChild, typeClass, flags));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ResultMapResolver resultMapResolver = <span class="keyword">new</span> ResultMapResolver(builderAssistant, id, typeClass, extend, discriminator, resultMappings, autoMapping);</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> resultMapResolver.resolve();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (IncompleteElementException  e) &#123;</span><br><span class="line">    configuration.addIncompleteResultMap(resultMapResolver);</span><br><span class="line">    <span class="keyword">throw</span> e;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在处理<code>&lt;resultMap&gt;</code>节点的过程中，该过程在执行获取到<code>id</code>属性和<code>type</code>属性之后，就会通过<code>XMLMapperBuilder.buildResultMappingFromContext()</code>方法为<code>&lt;result&gt;</code>节点创建对应的<code>ResultMapping</code>对象。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> ResultMapping <span class="title">buildResultMappingFromContext</span><span class="params">(XNode context, Class&lt;?&gt; resultType, List&lt;ResultFlag&gt; flags)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  String property;</span><br><span class="line">  <span class="comment">// 获取property的属性值</span></span><br><span class="line">  <span class="keyword">if</span> (flags.contains(ResultFlag.CONSTRUCTOR)) &#123;</span><br><span class="line">    property = context.getStringAttribute(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    property = context.getStringAttribute(<span class="string">&quot;property&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  String column = context.getStringAttribute(<span class="string">&quot;column&quot;</span>);</span><br><span class="line">  String javaType = context.getStringAttribute(<span class="string">&quot;javaType&quot;</span>);</span><br><span class="line">  String jdbcType = context.getStringAttribute(<span class="string">&quot;jdbcType&quot;</span>);</span><br><span class="line">  String nestedSelect = context.getStringAttribute(<span class="string">&quot;select&quot;</span>);</span><br><span class="line">  String nestedResultMap = context.getStringAttribute(</span><br><span class="line">    <span class="string">&quot;resultMap&quot;</span>,processNestedResultMappings(context, </span><br><span class="line">                                            Collections.&lt;ResultMapping&gt;emptyList()));</span><br><span class="line">  String notNullColumn = context.getStringAttribute(<span class="string">&quot;notNullColumn&quot;</span>);</span><br><span class="line">  String columnPrefix = context.getStringAttribute(<span class="string">&quot;columnPrefix&quot;</span>);</span><br><span class="line">  String typeHandler = context.getStringAttribute(<span class="string">&quot;typeHandler&quot;</span>);</span><br><span class="line">  String resultSet = context.getStringAttribute(<span class="string">&quot;resultSet&quot;</span>);</span><br><span class="line">  String foreignColumn = context.getStringAttribute(<span class="string">&quot;foreignColumn&quot;</span>);</span><br><span class="line">  <span class="keyword">boolean</span> lazy = <span class="string">&quot;lazy&quot;</span>.equals(</span><br><span class="line">    context.getStringAttribute(<span class="string">&quot;fetchType&quot;</span>, </span><br><span class="line">                               configuration.isLazyLoadingEnabled() ? <span class="string">&quot;lazy&quot;</span> : <span class="string">&quot;eager&quot;</span>));</span><br><span class="line">  Class&lt;?&gt; javaTypeClass = resolveClass(javaType);</span><br><span class="line">  <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">  Class&lt;? extends TypeHandler&lt;?&gt;&gt; typeHandlerClass </span><br><span class="line">    = (Class&lt;? extends TypeHandler&lt;?&gt;&gt;) resolveClass(typeHandler);</span><br><span class="line">  JdbcType jdbcTypeEnum = resolveJdbcType(jdbcType);</span><br><span class="line">  <span class="keyword">return</span> builderAssistant.buildResultMapping(</span><br><span class="line">    resultType, property, column, javaTypeClass, </span><br><span class="line">    jdbcTypeEnum, nestedSelect, nestedResultMap, </span><br><span class="line">    notNullColumn, columnPrefix, typeHandlerClass, flags, </span><br><span class="line">    resultSet, foreignColumn, lazy);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>MapperBuilderAssistant.buildResultMapping()</code>的具体实现：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ResultMapping <span class="title">buildResultMapping</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  Class&lt;?&gt; resultType,</span></span></span><br><span class="line"><span class="function"><span class="params">  String property,</span></span></span><br><span class="line"><span class="function"><span class="params">  String column,</span></span></span><br><span class="line"><span class="function"><span class="params">  Class&lt;?&gt; javaType,</span></span></span><br><span class="line"><span class="function"><span class="params">  JdbcType jdbcType,</span></span></span><br><span class="line"><span class="function"><span class="params">  String nestedSelect,</span></span></span><br><span class="line"><span class="function"><span class="params">  String nestedResultMap,</span></span></span><br><span class="line"><span class="function"><span class="params">  String notNullColumn,</span></span></span><br><span class="line"><span class="function"><span class="params">  String columnPrefix,</span></span></span><br><span class="line"><span class="function"><span class="params">  Class&lt;? extends TypeHandler&lt;?&gt;&gt; typeHandler,</span></span></span><br><span class="line"><span class="function"><span class="params">  List&lt;ResultFlag&gt; flags,</span></span></span><br><span class="line"><span class="function"><span class="params">  String resultSet,</span></span></span><br><span class="line"><span class="function"><span class="params">  String foreignColumn,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">boolean</span> lazy)</span> </span>&#123;</span><br><span class="line">  Class&lt;?&gt; javaTypeClass = resolveResultJavaType(resultType, property, javaType);</span><br><span class="line">  TypeHandler&lt;?&gt; typeHandlerInstance = resolveTypeHandler(javaTypeClass, typeHandler);</span><br><span class="line">  List&lt;ResultMapping&gt; composites = parseCompositeColumnName(column);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> ResultMapping.Builder(configuration, property, column, javaTypeClass)</span><br><span class="line">    .jdbcType(jdbcType)</span><br><span class="line">    .nestedQueryId(applyCurrentNamespace(nestedSelect, <span class="keyword">true</span>))</span><br><span class="line">    .nestedResultMapId(applyCurrentNamespace(nestedResultMap, <span class="keyword">true</span>))</span><br><span class="line">    .resultSet(resultSet)</span><br><span class="line">    .typeHandler(typeHandlerInstance)</span><br><span class="line">    .flags(flags == <span class="keyword">null</span> ? <span class="keyword">new</span> ArrayList&lt;ResultFlag&gt;() : flags)</span><br><span class="line">    .composites(composites)</span><br><span class="line">    .notNullColumns(parseMultipleColumnNames(notNullColumn))</span><br><span class="line">    .columnPrefix(columnPrefix)</span><br><span class="line">    .foreignColumn(foreignColumn)</span><br><span class="line">    .lazy(lazy)</span><br><span class="line">    .build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>得到<code>ResultMapping</code>对象集合之后，会调用<code>ResultMapResolver.resolve()</code>方法，该方法会调用<code>MapperBuilderAssistant.addResultMap()</code>方法创建<code>ResultMap</code>对象，并将<code>ResultMap</code>对象添加到<code>Configuration.resultMaps</code>集合中保存。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ResultMap <span class="title">addResultMap</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  String id,</span></span></span><br><span class="line"><span class="function"><span class="params">  Class&lt;?&gt; type,</span></span></span><br><span class="line"><span class="function"><span class="params">  String extend,</span></span></span><br><span class="line"><span class="function"><span class="params">  Discriminator discriminator,</span></span></span><br><span class="line"><span class="function"><span class="params">  List&lt;ResultMapping&gt; resultMappings,</span></span></span><br><span class="line"><span class="function"><span class="params">  Boolean autoMapping)</span> </span>&#123;</span><br><span class="line">  id = applyCurrentNamespace(id, <span class="keyword">false</span>);</span><br><span class="line">  extend = applyCurrentNamespace(extend, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (extend != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!configuration.hasResultMap(extend)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IncompleteElementException(<span class="string">&quot;...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ResultMap resultMap = configuration.getResultMap(extend);</span><br><span class="line">    List&lt;ResultMapping&gt; extendedResultMappings = <span class="keyword">new</span> ArrayList&lt;ResultMapping&gt;(resultMap.getResultMappings());</span><br><span class="line">    extendedResultMappings.removeAll(resultMappings);</span><br><span class="line">    <span class="comment">// Remove parent constructor if this resultMap declares a constructor.</span></span><br><span class="line">    <span class="keyword">boolean</span> declaresConstructor = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (ResultMapping resultMapping : resultMappings) &#123;</span><br><span class="line">      <span class="keyword">if</span> (resultMapping.getFlags().contains(ResultFlag.CONSTRUCTOR)) &#123;</span><br><span class="line">        declaresConstructor = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (declaresConstructor) &#123;</span><br><span class="line">      Iterator&lt;ResultMapping&gt; extendedResultMappingsIter = extendedResultMappings.iterator();</span><br><span class="line">      <span class="keyword">while</span> (extendedResultMappingsIter.hasNext()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (extendedResultMappingsIter.next().getFlags().contains(ResultFlag.CONSTRUCTOR)) &#123;</span><br><span class="line">          extendedResultMappingsIter.remove();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    resultMappings.addAll(extendedResultMappings);</span><br><span class="line">  &#125;</span><br><span class="line">  ResultMap resultMap = <span class="keyword">new</span> ResultMap.Builder(configuration, id, type, resultMappings, autoMapping)</span><br><span class="line">    .discriminator(discriminator)</span><br><span class="line">    .build();</span><br><span class="line">  configuration.addResultMap(resultMap);</span><br><span class="line">  <span class="keyword">return</span> resultMap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>&lt;constructor&gt;</code>节点的解析，由<code>XMLMapperBuilder.processConstructorElement()</code>方法完成。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processConstructorElement</span><span class="params">(XNode resultChild, Class&lt;?&gt; resultType, List&lt;ResultMapping&gt; resultMappings)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  List&lt;XNode&gt; argChildren = resultChild.getChildren();</span><br><span class="line">  <span class="keyword">for</span> (XNode argChild : argChildren) &#123;</span><br><span class="line">    List&lt;ResultFlag&gt; flags = <span class="keyword">new</span> ArrayList&lt;ResultFlag&gt;();</span><br><span class="line">    flags.add(ResultFlag.CONSTRUCTOR);</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&quot;idArg&quot;</span>.equals(argChild.getName())) &#123;</span><br><span class="line">      flags.add(ResultFlag.ID);</span><br><span class="line">    &#125;</span><br><span class="line">    resultMappings.add(buildResultMappingFromContext(argChild, resultType, flags));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后会解析<code>&lt;association&gt;</code>节点，正如前面对<code>XMLMapperBuilder.resultMapElement()</code>方法的介绍，<code>&lt;association&gt;</code>节点也是在<code>XMLMapperBuilder.buildResultMappingFromContext()</code>方法中完成解析的。</p><p><code>&lt;discriminator&gt;</code>节点的解析，该解析过程由<code>XMLMapperBuilder.processDiscriminatorElement()</code>方法完成。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Discriminator <span class="title">processDiscriminatorElement</span><span class="params">(XNode context, Class&lt;?&gt; resultType, List&lt;ResultMapping&gt; resultMappings)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  String column = context.getStringAttribute(<span class="string">&quot;column&quot;</span>);</span><br><span class="line">  String javaType = context.getStringAttribute(<span class="string">&quot;javaType&quot;</span>);</span><br><span class="line">  String jdbcType = context.getStringAttribute(<span class="string">&quot;jdbcType&quot;</span>);</span><br><span class="line">  String typeHandler = context.getStringAttribute(<span class="string">&quot;typeHandler&quot;</span>);</span><br><span class="line">  Class&lt;?&gt; javaTypeClass = resolveClass(javaType);</span><br><span class="line">  <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">  Class&lt;? extends TypeHandler&lt;?&gt;&gt; typeHandlerClass = (Class&lt;? extends TypeHandler&lt;?&gt;&gt;) resolveClass(typeHandler);</span><br><span class="line">  JdbcType jdbcTypeEnum = resolveJdbcType(jdbcType);</span><br><span class="line">  Map&lt;String, String&gt; discriminatorMap = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">  <span class="keyword">for</span> (XNode caseChild : context.getChildren()) &#123;</span><br><span class="line">    String value = caseChild.getStringAttribute(<span class="string">&quot;value&quot;</span>);</span><br><span class="line">    String resultMap = caseChild.getStringAttribute(<span class="string">&quot;resultMap&quot;</span>, processNestedResultMappings(caseChild, resultMappings));</span><br><span class="line">    discriminatorMap.put(value, resultMap);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> builderAssistant.buildDiscriminator(resultType, column, javaTypeClass, jdbcTypeEnum, typeHandlerClass, discriminatorMap);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>4. 解析<code>&lt;sql&gt;</code>节点</strong></p><p><code>XMLMapperBuilder.sqlElement()</code>方法负责解析映射配置文件中定义的全部<code>&lt;sql&gt;</code>节点。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sqlElement</span><span class="params">(List&lt;XNode&gt; list)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (configuration.getDatabaseId() != <span class="keyword">null</span>) &#123;</span><br><span class="line">    sqlElement(list, configuration.getDatabaseId());</span><br><span class="line">  &#125;</span><br><span class="line">  sqlElement(list, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sqlElement</span><span class="params">(List&lt;XNode&gt; list, String requiredDatabaseId)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (XNode context : list) &#123;</span><br><span class="line">    String databaseId = context.getStringAttribute(<span class="string">&quot;databaseId&quot;</span>);</span><br><span class="line">    String id = context.getStringAttribute(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">    id = builderAssistant.applyCurrentNamespace(id, <span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">if</span> (databaseIdMatchesCurrent(id, databaseId, requiredDatabaseId)) &#123;</span><br><span class="line">      sqlFragments.put(id, context);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="XMLStatementBuilder"><a href="#XMLStatementBuilder" class="headerlink" title="XMLStatementBuilder"></a>XMLStatementBuilder</h2><p>除了节点解析，映射文件中还有一类比较重要的节点需要解析，也就是<code>SQL</code>节点。<code>SQL</code>节点主要用于定义<code>SQL</code>语句，<code>SQL</code>节点由<code>XMLStatementBuilder</code>负责解析。</p><p><code>MyBatis</code>使用<code>SqlSource</code>接口表示映射文件或注解中定义的<code>SQL</code>语句，但它表示的<code>SQL</code>语句是不能直接被数据库执行的，因为其中可能含有动态<code>SQL</code>语句相关的节点或是占位符等需要解析的元素。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SqlSource</span> </span>&#123;</span><br><span class="line"><span class="comment">// getBoundSql()方法会根据映射文件或注解描述的SQL语句，以及传入的参数，返回可执行的SQL</span></span><br><span class="line">  <span class="function">BoundSql <span class="title">getBoundSql</span><span class="params">(Object parameterObject)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>MyBatis</code>使用<code>MappedStatement</code>表示映射配置文件中定义的<code>SQL</code>节点，<code>MappedStatement</code>包含了这些节点的很多属性。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// id属性</span></span><br><span class="line"><span class="keyword">private</span> String resource;</span><br><span class="line"><span class="keyword">private</span> Configuration configuration;</span><br><span class="line"><span class="keyword">private</span> String id;</span><br><span class="line"><span class="keyword">private</span> Integer fetchSize;</span><br><span class="line"><span class="keyword">private</span> Integer timeout;</span><br><span class="line"><span class="keyword">private</span> StatementType statementType;</span><br><span class="line"><span class="keyword">private</span> ResultSetType resultSetType;</span><br><span class="line"><span class="comment">// 对应一条sql语句</span></span><br><span class="line"><span class="keyword">private</span> SqlSource sqlSource;</span><br><span class="line"><span class="keyword">private</span> Cache cache;</span><br><span class="line"><span class="keyword">private</span> ParameterMap parameterMap;</span><br><span class="line"><span class="keyword">private</span> List&lt;ResultMap&gt; resultMaps;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> flushCacheRequired;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> useCache;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> resultOrdered;</span><br><span class="line"><span class="comment">// sql类型</span></span><br><span class="line"><span class="keyword">private</span> SqlCommandType sqlCommandType;</span><br><span class="line"><span class="keyword">private</span> KeyGenerator keyGenerator;</span><br><span class="line"><span class="keyword">private</span> String[] keyProperties;</span><br><span class="line"><span class="keyword">private</span> String[] keyColumns;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> hasNestedResultMaps;</span><br><span class="line"><span class="keyword">private</span> String databaseId;</span><br><span class="line"><span class="keyword">private</span> Log statementLog;</span><br><span class="line"><span class="keyword">private</span> LanguageDriver lang;</span><br><span class="line"><span class="keyword">private</span> String[] resultSets;</span><br></pre></td></tr></table></figure><p><code>XMLStatementBuilder.parseStatementNode()</code>方法是解析<code>SQL</code>节点的入口函数。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parseStatementNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  String id = context.getStringAttribute(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">  String databaseId = context.getStringAttribute(<span class="string">&quot;databaseId&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!databaseIdMatchesCurrent(id, databaseId, <span class="keyword">this</span>.requiredDatabaseId)) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Integer fetchSize = context.getIntAttribute(<span class="string">&quot;fetchSize&quot;</span>);</span><br><span class="line">  Integer timeout = context.getIntAttribute(<span class="string">&quot;timeout&quot;</span>);</span><br><span class="line">  String parameterMap = context.getStringAttribute(<span class="string">&quot;parameterMap&quot;</span>);</span><br><span class="line">  String parameterType = context.getStringAttribute(<span class="string">&quot;parameterType&quot;</span>);</span><br><span class="line">  Class&lt;?&gt; parameterTypeClass = resolveClass(parameterType);</span><br><span class="line">  String resultMap = context.getStringAttribute(<span class="string">&quot;resultMap&quot;</span>);</span><br><span class="line">  String resultType = context.getStringAttribute(<span class="string">&quot;resultType&quot;</span>);</span><br><span class="line">  String lang = context.getStringAttribute(<span class="string">&quot;lang&quot;</span>);</span><br><span class="line">  LanguageDriver langDriver = getLanguageDriver(lang);</span><br><span class="line"></span><br><span class="line">  Class&lt;?&gt; resultTypeClass = resolveClass(resultType);</span><br><span class="line">  String resultSetType = context.getStringAttribute(<span class="string">&quot;resultSetType&quot;</span>);</span><br><span class="line">  StatementType statementType = </span><br><span class="line">    StatementType.valueOf(</span><br><span class="line">    context.getStringAttribute(<span class="string">&quot;statementType&quot;</span>, StatementType.PREPARED.toString()));</span><br><span class="line">  ResultSetType resultSetTypeEnum = resolveResultSetType(resultSetType);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 根据节点名称决定SqlCommandType</span></span><br><span class="line">  String nodeName = context.getNode().getNodeName();</span><br><span class="line">  SqlCommandType sqlCommandType = </span><br><span class="line">    SqlCommandType.valueOf(nodeName.toUpperCase(Locale.ENGLISH));</span><br><span class="line">  <span class="keyword">boolean</span> isSelect = sqlCommandType == SqlCommandType.SELECT;</span><br><span class="line">  <span class="keyword">boolean</span> flushCache = context.getBooleanAttribute(<span class="string">&quot;flushCache&quot;</span>, !isSelect);</span><br><span class="line">  <span class="keyword">boolean</span> useCache = context.getBooleanAttribute(<span class="string">&quot;useCache&quot;</span>, isSelect);</span><br><span class="line">  <span class="keyword">boolean</span> resultOrdered = context.getBooleanAttribute(<span class="string">&quot;resultOrdered&quot;</span>, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Include Fragments before parsing</span></span><br><span class="line">  XMLIncludeTransformer includeParser = </span><br><span class="line">    <span class="keyword">new</span> XMLIncludeTransformer(configuration, builderAssistant);</span><br><span class="line">  includeParser.applyIncludes(context.getNode());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Parse selectKey after includes and remove them.</span></span><br><span class="line">  processSelectKeyNodes(id, parameterTypeClass, langDriver);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Parse the SQL (pre: &lt;selectKey&gt; and &lt;include&gt; were parsed and removed)</span></span><br><span class="line">  SqlSource sqlSource = </span><br><span class="line">    langDriver.createSqlSource(configuration, context, parameterTypeClass);</span><br><span class="line">  String resultSets = context.getStringAttribute(<span class="string">&quot;resultSets&quot;</span>);</span><br><span class="line">  String keyProperty = context.getStringAttribute(<span class="string">&quot;keyProperty&quot;</span>);</span><br><span class="line">  String keyColumn = context.getStringAttribute(<span class="string">&quot;keyColumn&quot;</span>);</span><br><span class="line">  KeyGenerator keyGenerator;</span><br><span class="line">  String keyStatementId = id + SelectKeyGenerator.SELECT_KEY_SUFFIX;</span><br><span class="line">  keyStatementId = builderAssistant.applyCurrentNamespace(keyStatementId, <span class="keyword">true</span>);</span><br><span class="line">  <span class="keyword">if</span> (configuration.hasKeyGenerator(keyStatementId)) &#123;</span><br><span class="line">    keyGenerator = configuration.getKeyGenerator(keyStatementId);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    keyGenerator = </span><br><span class="line">      context.getBooleanAttribute(<span class="string">&quot;useGeneratedKeys&quot;</span>,</span><br><span class="line">                                  configuration.isUseGeneratedKeys() </span><br><span class="line">                                  &amp;&amp; SqlCommandType.INSERT.equals(sqlCommandType))</span><br><span class="line">      ? Jdbc3KeyGenerator.INSTANCE : NoKeyGenerator.INSTANCE;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  builderAssistant.addMappedStatement(</span><br><span class="line">    id, sqlSource, statementType, sqlCommandType,</span><br><span class="line">    fetchSize, timeout, parameterMap, parameterTypeClass, resultMap, </span><br><span class="line">    resultTypeClass,resultSetTypeEnum, flushCache, useCache, resultOrdered,</span><br><span class="line">    keyGenerator, keyProperty, keyColumn, databaseId, langDriver, resultSets);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>1. 解析<code>&lt;include&gt;</code>节点</strong></p><p>在解析<code>SQL</code>节点之前，首先通过<code>XMLIncludeTransformer</code>解析<code>SQL</code>语句中的<code>&lt;include&gt;</code>节点，该过程会将<code>&lt;include&gt;</code>节点替换成<code>&lt;sql&gt;</code>节点中定义的<code>SQL</code>片段，并将其中的<code>$&#123;xxx&#125;</code>占位符替换成真实的参数，该解析过程在<code>XMLIncludeTransformer.applyIncludes()</code>方法中实现。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">applyIncludes</span><span class="params">(Node source)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 获取mybatis-config.xml中&lt;properties&gt;节点下定义的变量集合</span></span><br><span class="line">  Properties variablesContext = <span class="keyword">new</span> Properties();</span><br><span class="line">  Properties configurationVariables = configuration.getVariables();</span><br><span class="line">  <span class="keyword">if</span> (configurationVariables != <span class="keyword">null</span>) &#123;</span><br><span class="line">    variablesContext.putAll(configurationVariables);</span><br><span class="line">  &#125;</span><br><span class="line">  applyIncludes(source, variablesContext, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理&lt;include&gt;节点的重载方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">applyIncludes</span><span class="params">(Node source, <span class="keyword">final</span> Properties variablesContext, <span class="keyword">boolean</span> included)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (source.getNodeName().equals(<span class="string">&quot;include&quot;</span>)) &#123;</span><br><span class="line">    Node toInclude = findSqlFragment(getStringAttribute(source, <span class="string">&quot;refid&quot;</span>), variablesContext);</span><br><span class="line">    Properties toIncludeContext = getVariablesContext(source, variablesContext);</span><br><span class="line">    applyIncludes(toInclude, toIncludeContext, <span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">if</span> (toInclude.getOwnerDocument() != source.getOwnerDocument()) &#123;</span><br><span class="line">      toInclude = source.getOwnerDocument().importNode(toInclude, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    source.getParentNode().replaceChild(toInclude, source);</span><br><span class="line">    <span class="keyword">while</span> (toInclude.hasChildNodes()) &#123;</span><br><span class="line">      toInclude.getParentNode().insertBefore(toInclude.getFirstChild(), toInclude);</span><br><span class="line">    &#125;</span><br><span class="line">    toInclude.getParentNode().removeChild(toInclude);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (source.getNodeType() == Node.ELEMENT_NODE) &#123;</span><br><span class="line">    <span class="keyword">if</span> (included &amp;&amp; !variablesContext.isEmpty()) &#123;</span><br><span class="line">      <span class="comment">// replace variables in attribute values</span></span><br><span class="line">      NamedNodeMap attributes = source.getAttributes();</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; attributes.getLength(); i++) &#123;</span><br><span class="line">        Node attr = attributes.item(i);</span><br><span class="line">        attr.setNodeValue(PropertyParser.parse(attr.getNodeValue(), variablesContext));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    NodeList children = source.getChildNodes();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; children.getLength(); i++) &#123;</span><br><span class="line">      applyIncludes(children.item(i), variablesContext, included);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (included &amp;&amp; source.getNodeType() == Node.TEXT_NODE</span><br><span class="line">             &amp;&amp; !variablesContext.isEmpty()) &#123;</span><br><span class="line">    <span class="comment">// replace variables in text node</span></span><br><span class="line">    source.setNodeValue(PropertyParser.parse(source.getNodeValue(), variablesContext));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>&lt;inClude&gt;</code>节点和<code>&lt;sql&gt;</code>节点可以配合使用、多层嵌套，实现更加复杂的<code>sql</code>片段的重用，这样的话，解析过程就会递归更多层，流程变得更加复杂。</p><p><strong>2. 解析<code>&lt;selectKey&gt;</code>节点</strong></p><p>在<code>&lt;insert&gt;</code>、<code>&lt;update&gt;</code>节点中可以定义<code>&lt;selectKey&gt;</code>节点来解决主键自增问题，<code>&lt;selectKey&gt;</code>节点对应的<code>KeyGenerator</code>接口在后面会详细介绍，现在重点关节点的解析。</p><p><code>XMLStatementBuilder.processSelectKeyNodes()</code>方法负责解析<code>SQL</code>节点中子节点。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processSelectKeyNodes</span><span class="params">(String id, Class&lt;?&gt; parameterTypeClass, LanguageDriver langDriver)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 获取全部selectKey节点</span></span><br><span class="line">  List&lt;XNode&gt; selectKeyNodes = context.evalNodes(<span class="string">&quot;selectKey&quot;</span>);</span><br><span class="line">  <span class="comment">// 解析selectKey节点</span></span><br><span class="line">  <span class="keyword">if</span> (configuration.getDatabaseId() != <span class="keyword">null</span>) &#123;</span><br><span class="line">    parseSelectKeyNodes(id, selectKeyNodes, parameterTypeClass, langDriver, configuration.getDatabaseId());</span><br><span class="line">  &#125;</span><br><span class="line">  parseSelectKeyNodes(id, selectKeyNodes, parameterTypeClass, langDriver, <span class="keyword">null</span>);</span><br><span class="line">  removeSelectKeyNodes(selectKeyNodes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>parseSelectKeyNodes()</code>方法中会为<code>&lt;selectKey&gt;</code>节点生成<code>id</code>，检测<code>databaseld</code>是否匹配以及是否己经加载过相同<code>id</code>且<code>databaseld</code>不为空的<code>&lt;selectKey&gt;</code>节点，并调用<code>parseSelectKeyNode()</code>方法处理每个<code>&lt;selectKey&gt;</code>节点。<br>在<code>parseSelectKeyNode()</code>方法中，首先读取<code>&lt;selectKey&gt;</code>节点的一系列属性，然后调用<code>LanguageDriver.createSqlSource()</code>方法创建对应的<code>SqlSource</code>对象，最后创建<code>MappedStatement</code>对象，并添加到<code>Configuration.mappedStatements</code>集合中保存。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parseSelectKeyNode</span><span class="params">(String id, XNode nodeToHandle, </span></span></span><br><span class="line"><span class="function"><span class="params">                                Class&lt;?&gt; parameterTypeClass, </span></span></span><br><span class="line"><span class="function"><span class="params">                                LanguageDriver langDriver, String databaseId)</span> </span>&#123;</span><br><span class="line">  String resultType = nodeToHandle.getStringAttribute(<span class="string">&quot;resultType&quot;</span>);</span><br><span class="line">  Class&lt;?&gt; resultTypeClass = resolveClass(resultType);</span><br><span class="line">  StatementType statementType </span><br><span class="line">    = StatementType.valueOf(</span><br><span class="line">    nodeToHandle.getStringAttribute(<span class="string">&quot;statementType&quot;</span>, </span><br><span class="line">                                    StatementType.PREPARED.toString()));</span><br><span class="line">  String keyProperty = nodeToHandle.getStringAttribute(<span class="string">&quot;keyProperty&quot;</span>);</span><br><span class="line">  String keyColumn = nodeToHandle.getStringAttribute(<span class="string">&quot;keyColumn&quot;</span>);</span><br><span class="line">  <span class="keyword">boolean</span> executeBefore = <span class="string">&quot;BEFORE&quot;</span>.equals(nodeToHandle.getStringAttribute(<span class="string">&quot;order&quot;</span>, <span class="string">&quot;AFTER&quot;</span>));</span><br><span class="line"></span><br><span class="line">  <span class="comment">//defaults</span></span><br><span class="line">  <span class="keyword">boolean</span> useCache = <span class="keyword">false</span>;</span><br><span class="line">  <span class="keyword">boolean</span> resultOrdered = <span class="keyword">false</span>;</span><br><span class="line">  KeyGenerator keyGenerator = NoKeyGenerator.INSTANCE;</span><br><span class="line">  Integer fetchSize = <span class="keyword">null</span>;</span><br><span class="line">  Integer timeout = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">boolean</span> flushCache = <span class="keyword">false</span>;</span><br><span class="line">  String parameterMap = <span class="keyword">null</span>;</span><br><span class="line">  String resultMap = <span class="keyword">null</span>;</span><br><span class="line">  ResultSetType resultSetTypeEnum = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">  SqlSource sqlSource </span><br><span class="line">    = langDriver.createSqlSource(configuration, nodeToHandle, parameterTypeClass);</span><br><span class="line">  SqlCommandType sqlCommandType </span><br><span class="line">    = SqlCommandType.SELECT;</span><br><span class="line"></span><br><span class="line">  builderAssistant.addMappedStatement(</span><br><span class="line">    id, sqlSource, statementType, sqlCommandType,</span><br><span class="line">    fetchSize, timeout, parameterMap, parameterTypeClass, </span><br><span class="line">    resultMap, resultTypeClass,</span><br><span class="line">    resultSetTypeEnum, flushCache, useCache, resultOrdered,    </span><br><span class="line">    keyGenerator, keyProperty, keyColumn, databaseId, langDriver, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">  id = builderAssistant.applyCurrentNamespace(id, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">  MappedStatement keyStatement = configuration.getMappedStatement(id, <span class="keyword">false</span>);</span><br><span class="line">  configuration.addKeyGenerator(id, <span class="keyword">new</span> SelectKeyGenerator(keyStatement, executeBefore));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>LanguageDriver</code>接口有两个实现类。</p><p><img src="https://gitee.com/cayzlh/img-repo/raw/master/2020/07/17001915960996191596099619233.png" alt="image-20200730170018404"></p><p>在<code>Configuration</code>的构造方法中，可以看到如下代码片段，我们由此可以判断默认使用的<code>XMLLanguageDriver</code>实现类。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">languageRegistry.setDefaultDriverClass(XMLLanguageDriver.class);</span><br></pre></td></tr></table></figure><p>也可以提供自定义的<code>LanguageDriver</code>实现，并在<code>mybatis-config.xml</code>中通过<code>defaultScriptingLanguage</code>配置指定使用该自定义实现。<br>在<code>XMLLanguageDriver.createSqlSource()</code>方法中会创建<code>XMLScriptBuilder</code>对象并<code>XMLScriptBuilder.parseScriptNode()</code>方法创建<code>SqlSource</code>对象。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> SqlSource <span class="title">parseScriptNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  MixedSqlNode rootSqlNode = parseDynamicTags(context);</span><br><span class="line">  SqlSource sqlSource = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">if</span> (isDynamic) &#123;</span><br><span class="line">    sqlSource = <span class="keyword">new</span> DynamicSqlSource(configuration, rootSqlNode);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    sqlSource = <span class="keyword">new</span> RawSqlSource(configuration, rootSqlNode, parameterType);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> sqlSource;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>XMLScriptBuilder.parseDynamicTags()</code>方法中，会遍历<code>&lt;selectKey&gt;</code>下的每个节点，如果包含任何标签节点，则认为是动态<code>SQL</code>语句；如果文本节点中含有<code>$&#123;&#125;</code>占位符，也认为其为动态SQL语句。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> MixedSqlNode <span class="title">parseDynamicTags</span><span class="params">(XNode node)</span> </span>&#123;</span><br><span class="line">  List&lt;SqlNode&gt; contents = <span class="keyword">new</span> ArrayList&lt;SqlNode&gt;();</span><br><span class="line">  NodeList children = node.getNode().getChildNodes();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; children.getLength(); i++) &#123;</span><br><span class="line">    XNode child = node.newXNode(children.item(i));</span><br><span class="line">    <span class="keyword">if</span> (child.getNode().getNodeType() </span><br><span class="line">        == Node.CDATA_SECTION_NODE || </span><br><span class="line">        child.getNode().getNodeType() == Node.TEXT_NODE) &#123;</span><br><span class="line">      String data = child.getStringBody(<span class="string">&quot;&quot;</span>);</span><br><span class="line">      TextSqlNode textSqlNode = <span class="keyword">new</span> TextSqlNode(data);</span><br><span class="line">      <span class="keyword">if</span> (textSqlNode.isDynamic()) &#123;</span><br><span class="line">        contents.add(textSqlNode);</span><br><span class="line">        isDynamic = <span class="keyword">true</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        contents.add(<span class="keyword">new</span> StaticTextSqlNode(data));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (child.getNode().getNodeType() == Node.ELEMENT_NODE) &#123; <span class="comment">// issue #628</span></span><br><span class="line">      String nodeName = child.getNode().getNodeName();</span><br><span class="line">      NodeHandler handler = nodeHandlerMap.get(nodeName);</span><br><span class="line">      <span class="keyword">if</span> (handler == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">&quot;Unknown element &lt;&quot;</span> + nodeName + <span class="string">&quot;&gt; in SQL statement.&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      handler.handleNode(child, contents);</span><br><span class="line">      isDynamic = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> MixedSqlNode(contents);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面遇到的<code>TextSqlNode</code>、<code>StaticTextSqlNode</code>等都是<code>SqlNode</code>接口的实现，<code>SqlNode</code>接口的<br>每个实现都对应于不同的动态<code>SQL</code>节点类型，每个实现的具体代码后面遇到了再详细分析。</p><p><code>TextSqlNode.isDynamic()</code>方法中会通过<code>GenericTokenParser</code>和<code>DynamicCheckerTokenParser</code>配合解析文本节点，并判断它是否为动态<code>SQL</code>。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isDynamic</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  DynamicCheckerTokenParser checker = <span class="keyword">new</span> DynamicCheckerTokenParser();</span><br><span class="line">  GenericTokenParser parser = createParser(checker);</span><br><span class="line">  parser.parse(text);</span><br><span class="line">  <span class="keyword">return</span> checker.isDynamic();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">handleToken</span><span class="params">(String content)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.isDynamic = <span class="keyword">true</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3. 解析SQL节点</strong></p><p>经过上述两个解析过程之后，<code>&lt;include&gt;</code>节点和<code>&lt;selectKey&gt;</code>节点己经被解析并删除掉了。<code>XMLStatementBuilder.parseStatementNode()</code>方法剩余的操作就是解析<code>SQL</code>节点。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parseStatementNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  String id = context.getStringAttribute(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">  String databaseId = context.getStringAttribute(<span class="string">&quot;databaseId&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!databaseIdMatchesCurrent(id, databaseId, <span class="keyword">this</span>.requiredDatabaseId)) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Integer fetchSize = context.getIntAttribute(<span class="string">&quot;fetchSize&quot;</span>);</span><br><span class="line">  Integer timeout = context.getIntAttribute(<span class="string">&quot;timeout&quot;</span>);</span><br><span class="line">  String parameterMap = context.getStringAttribute(<span class="string">&quot;parameterMap&quot;</span>);</span><br><span class="line">  String parameterType = context.getStringAttribute(<span class="string">&quot;parameterType&quot;</span>);</span><br><span class="line">  Class&lt;?&gt; parameterTypeClass = resolveClass(parameterType);</span><br><span class="line">  String resultMap = context.getStringAttribute(<span class="string">&quot;resultMap&quot;</span>);</span><br><span class="line">  String resultType = context.getStringAttribute(<span class="string">&quot;resultType&quot;</span>);</span><br><span class="line">  String lang = context.getStringAttribute(<span class="string">&quot;lang&quot;</span>);</span><br><span class="line">  LanguageDriver langDriver = getLanguageDriver(lang);</span><br><span class="line"></span><br><span class="line">  Class&lt;?&gt; resultTypeClass = resolveClass(resultType);</span><br><span class="line">  String resultSetType = context.getStringAttribute(<span class="string">&quot;resultSetType&quot;</span>);</span><br><span class="line">  StatementType statementType = StatementType.valueOf(context.getStringAttribute(<span class="string">&quot;statementType&quot;</span>, StatementType.PREPARED.toString()));</span><br><span class="line">  ResultSetType resultSetTypeEnum = resolveResultSetType(resultSetType);</span><br><span class="line"></span><br><span class="line">  String nodeName = context.getNode().getNodeName();</span><br><span class="line">  SqlCommandType sqlCommandType = SqlCommandType.valueOf(nodeName.toUpperCase(Locale.ENGLISH));</span><br><span class="line">  <span class="keyword">boolean</span> isSelect = sqlCommandType == SqlCommandType.SELECT;</span><br><span class="line">  <span class="keyword">boolean</span> flushCache = context.getBooleanAttribute(<span class="string">&quot;flushCache&quot;</span>, !isSelect);</span><br><span class="line">  <span class="keyword">boolean</span> useCache = context.getBooleanAttribute(<span class="string">&quot;useCache&quot;</span>, isSelect);</span><br><span class="line">  <span class="keyword">boolean</span> resultOrdered = context.getBooleanAttribute(<span class="string">&quot;resultOrdered&quot;</span>, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Include Fragments before parsing</span></span><br><span class="line">  XMLIncludeTransformer includeParser = <span class="keyword">new</span> XMLIncludeTransformer(configuration, builderAssistant);</span><br><span class="line">  includeParser.applyIncludes(context.getNode());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Parse selectKey after includes and remove them.</span></span><br><span class="line">  processSelectKeyNodes(id, parameterTypeClass, langDriver);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Parse the SQL (pre: &lt;selectKey&gt; and &lt;include&gt; were parsed and removed)</span></span><br><span class="line">  SqlSource sqlSource = langDriver.createSqlSource(configuration, context, parameterTypeClass);</span><br><span class="line">  String resultSets = context.getStringAttribute(<span class="string">&quot;resultSets&quot;</span>);</span><br><span class="line">  String keyProperty = context.getStringAttribute(<span class="string">&quot;keyProperty&quot;</span>);</span><br><span class="line">  String keyColumn = context.getStringAttribute(<span class="string">&quot;keyColumn&quot;</span>);</span><br><span class="line">  KeyGenerator keyGenerator;</span><br><span class="line">  String keyStatementId = id + SelectKeyGenerator.SELECT_KEY_SUFFIX;</span><br><span class="line">  keyStatementId = builderAssistant.applyCurrentNamespace(keyStatementId, <span class="keyword">true</span>);</span><br><span class="line">  <span class="keyword">if</span> (configuration.hasKeyGenerator(keyStatementId)) &#123;</span><br><span class="line">    keyGenerator = configuration.getKeyGenerator(keyStatementId);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    keyGenerator = context.getBooleanAttribute(<span class="string">&quot;useGeneratedKeys&quot;</span>,</span><br><span class="line">                                               configuration.isUseGeneratedKeys() &amp;&amp; SqlCommandType.INSERT.equals(sqlCommandType))</span><br><span class="line">      ? Jdbc3KeyGenerator.INSTANCE : NoKeyGenerator.INSTANCE;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  builderAssistant.addMappedStatement(id, sqlSource, statementType, sqlCommandType,</span><br><span class="line">                                      fetchSize, timeout, parameterMap, parameterTypeClass, resultMap, resultTypeClass,</span><br><span class="line">                                      resultSetTypeEnum, flushCache, useCache, resultOrdered, </span><br><span class="line">                                      keyGenerator, keyProperty, keyColumn, databaseId, langDriver, resultSets);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="绑定Mapper接口"><a href="#绑定Mapper接口" class="headerlink" title="绑定Mapper接口"></a>绑定Mapper接口</h2><p>每个映射配置文件的命名空间可以绑定一个<code>Mapper</code>接口，并注册到<code>MapperRegistry</code>中。</p><p>在<code>XMLMapperBuilder.bindMapperForNamespace()</code>方法中，完成了映射配置文件与对应<code>Mapper</code>接口的绑定。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">bindMapperForNamespace</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  String namespace = builderAssistant.getCurrentNamespace();</span><br><span class="line">  <span class="keyword">if</span> (namespace != <span class="keyword">null</span>) &#123;</span><br><span class="line">    Class&lt;?&gt; boundType = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      boundType = Resources.classForName(namespace);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">      <span class="comment">//ignore, bound type is not required</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (boundType != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!configuration.hasMapper(boundType)) &#123;</span><br><span class="line">        <span class="comment">// Spring may not know the real resource name so we set a flag</span></span><br><span class="line">        <span class="comment">// to prevent loading again this resource from the mapper interface</span></span><br><span class="line">        <span class="comment">// look at MapperAnnotationBuilder#loadXmlResource</span></span><br><span class="line">        configuration.addLoadedResource(<span class="string">&quot;namespace:&quot;</span> + namespace);</span><br><span class="line">        configuration.addMapper(boundType);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在介绍<code>MapperRegistry.addMapper()</code>方法时，只提到了该方法会向<code>MapperRegistry.knownMappers</code>集合注册指定的<code>Mapper</code>接口，其实该方法还会创建<code>MapperAnnotationBuilder</code>，并调用<code>MapperAnnotationBuilder.parse()</code>方法解析<code>Mapper</code>接口中的注解信息。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  String resource = type.toString();</span><br><span class="line">  <span class="keyword">if</span> (!configuration.isResourceLoaded(resource)) &#123;</span><br><span class="line">    loadXmlResource();</span><br><span class="line">    configuration.addLoadedResource(resource);</span><br><span class="line">    assistant.setCurrentNamespace(type.getName());</span><br><span class="line">    parseCache();</span><br><span class="line">    parseCacheRef();</span><br><span class="line">    Method[] methods = type.getMethods();</span><br><span class="line">    <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// issue #237</span></span><br><span class="line">        <span class="keyword">if</span> (!method.isBridge()) &#123;</span><br><span class="line">          parseStatement(method);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (IncompleteElementException e) &#123;</span><br><span class="line">        configuration.addIncompleteMethod(<span class="keyword">new</span> MethodResolver(<span class="keyword">this</span>, method));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  parsePendingMethods();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="处理incomplete-集合"><a href="#处理incomplete-集合" class="headerlink" title="处理incomplete*集合"></a>处理incomplete*集合</h2><p><code>XMLMapperBuilder.configurationElement()</code>方法解析映射配置文件时，是按照从文件头到文件尾的顺序解析的，但是有时候在解析一个节点时，会引用定义在该节点之后的、还未解析的节点，这就会导致解析失败并抛出<code>IncompleteElementException</code>。</p><p>根据抛出异常的节点不同，<code>MyBatis</code>会创建不同的<code>*Resolver</code>对象，并添加到<code>Configuration</code>的不同<code>incomplete*</code>集合中。</p><p>例如，</p><ul><li><p>解析<code>Mapper</code>接口中的方法出现异常时，会创建<code>MethodResolver</code>对象，并将其追加到<code>Configuration.incompleteMethods</code>集合(<code>LinkedList&lt;MethodResolver&gt;</code>类型)中暂存;</p></li><li><p>解析<code>&lt;resultMap&gt;</code>节点时出现异常，则会将对应的<code>ResultMapResolver</code>对象追加到<code>incompleteResultMaps</code>(<code>LinkedList&lt;ResultMapResolver&gt;</code>类型)集合中暂存;</p></li><li><p>解析<code>&lt;cache-ref&gt;</code>节点时出现异常，则会将对应的<code>CacheRefResolver</code>对象追加到<code>incompleteCacheRefs</code>(<code>LinkedList&lt;CacheRefResolver&gt;</code>类型)集合中暂存;</p></li><li><p>解析<code>SQL</code>语句节点时出现异常，则会将对应的<code>XMLStatementBuilder</code>对象追加到<code>incompleteStatements</code>(<code>LinkedList&lt;XMLStatementBuilder&gt;</code>类型)集合中暂存。</p></li></ul><p>在<code>XMLMapperBuilder.parse()</code>方法中可以看到，通过<code>configurationElement()</code>方法完了一次映射配置文件的解析后，还会调用<code>parsePendingResultMaps()</code>方法、<code>parsePendingChacheRefs()</code>方法、<code>parsePendingStatements()</code>方法三个<code>parsePending*()</code>方法处理<code>Configuration</code>中对应的三个<code>incomplete*</code>集合。所有<code>parsePending*()</code>方法的逻辑都是基本类似的，这里以<code>parsePendingStatements()</code>方法为例进行分析</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parsePendingStatements</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Collection&lt;XMLStatementBuilder&gt; incompleteStatements = configuration.getIncompleteStatements();</span><br><span class="line">  <span class="keyword">synchronized</span> (incompleteStatements) &#123;</span><br><span class="line">    Iterator&lt;XMLStatementBuilder&gt; iter = incompleteStatements.iterator();</span><br><span class="line">    <span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        iter.next().parseStatementNode();</span><br><span class="line">        iter.remove();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (IncompleteElementException e) &#123;</span><br><span class="line">        <span class="comment">// Statement is still missing a resource...</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到此为止，<code>MyBatis</code>的初始化过程就全部介绍完了，其中分析了<code>mybatis-config.xml</code>配置文件的解析过程、映射配置文件的解析过程以及<code>Mapper</code>接口中相关注解的解析过程。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><p><strong>《MyBatis技术内幕》</strong></p></li><li><p>部分图片来源——<strong>《MyBatis技术内幕》</strong></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 书籍 </category>
          
          <category> 《MyBatis技术内幕》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MyBatis </tag>
            
            <tag> 《MyBatis技术内幕》 </tag>
            
            <tag> 核心处理层 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring面向切面编程（知识梳理）</title>
      <link href="/blog/2020/03/31/741621cd.html"/>
      <url>/blog/2020/03/31/741621cd.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>Aspect Oriented Programming with Spring</p><p>面向切面的编程（AOP）通过提供另一种思考程序结构的方式来补充面向对象的编程（OOP）。</p></blockquote><p> OOP中模块化的关键单元是类，而在AOP中模块化是方面。切面使关注点（例如事务管理）的模块化跨越了多个类型和对象。 （这种关注在AOP文献中通常被称为“跨领域”关注。）</p><p>Spring的关键组件之一是AOP框架。尽管Spring IoC容器不依赖于AOP，但<strong>AOP是对Spring IoC的补充，可以提供功能强大的中间件解决方案。</strong></p><blockquote><p>Spring AOP with AspectJ pointcuts</p><p>Spring provides simple and powerful ways of writing custom aspects by using either a <a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#aop-schema">schema-based approach</a> or the <a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#aop-ataspectj">@AspectJ annotation style</a>. Both of these styles offer fully typed advice and use of the AspectJ pointcut language while still using Spring AOP for weaving.</p><p>具有AspectJ切入点的Spring AOP<br>通过使用<strong>基于模式的方法</strong>或**@AspectJ注解样式**，Spring提供了编写自定义切面的简单而强大的方法。这两种样式都提供了完全类型化的建议，并使用了AspectJ切入点语言，同时仍然使用Spring AOP进行编程。</p></blockquote><h2 id="Spring-AOP概念"><a href="#Spring-AOP概念" class="headerlink" title="Spring AOP概念"></a>Spring AOP概念</h2><p>一些重要的AOP概念和术语。<em>这些术语不是特定于Spring的。</em></p><ul><li><p><strong>切面（Aspect）</strong></p><p>类是对物体特征的抽象，<em>切面就是对横切关注点的抽象</em>。</p><blockquote><p>在Spring AOP中，切面是通过使用常规类（基于架构的方法）或使用@Aspect注释（@AspectJ样式）注释的常规类来实现的。</p></blockquote><p><code>aspect</code> 由 <code>pointcount</code> 和 <code>advice</code> 组成, 它既包含了横切逻辑的定义, 也包括了连接点的定义. Spring AOP就是负责实施切面的框架, 它将切面所定义的横切逻辑织入到切面所指定的连接点中.<br>AOP的工作重心在于如何将增强织入目标对象的连接点上, 这里包含两个工作:</p><ol><li>如何通过 pointcut 和 advice 定位到特定的 joinpoint 上</li><li>如何在 advice 中编写切面代码.</li></ol></li><li><p><strong>连接点（Join point）</strong></p><blockquote><p>A point during the execution of a program, such as the execution of a method or the handling of an exception. In Spring AOP, a join point always represents a method execution.</p></blockquote><p>程序运行中的一些时间点，例如一个方法的执行，或者是一个异常的处理。<br><code>在 Spring AOP 中, join point 总是方法的执行点, 即只有方法连接点.</code></p></li><li><p><strong>增强（Advice）</strong></p><blockquote><p>Action taken by an aspect at a particular join point. Different types of advice include “around”, “before” and “after” advice. (Advice types are discussed later.) Many AOP frameworks, including Spring, model an advice as an interceptor and maintain a chain of interceptors around the join point.</p></blockquote><p>切面在特定的连接点处采取的操作。不同类型的建议包括<code>around</code>，<code>before</code>和<code>after</code>通知。 包括Spring在内的许多AOP框架都将通知建模为拦截器，并在连接点周围维护一系列拦截器。</p><p>由 <code>aspect</code> 添加到特定的 join point(即满足 <code>point cut</code> 规则的 join point) 的一段代码.<br>许多 <code>AOP</code>框架, 包括 <code>Spring AOP</code>, 会将 <code>advice</code> 模拟为一个拦截器(<code>interceptor</code>), 并且在 join point 上维护多个 <code>advice</code>, 进行层层拦截.<br><em>例如 <code>HTTP</code> 鉴权的实现, 我们可以为每个使用 <code>RequestMapping</code> 标注的方法织入 <code>advice</code>, 当 <code>HTTP</code> 请求到来时, 首先进入到 <code>advice</code> 代码中, 在这里我们可以分析这个 <code>HTTP</code> 请求是否有相应的权限, 如果有, 则执行 <code>Controller</code>, 如果没有, 则抛出异常. 这里的 <code>advice</code> 就扮演着鉴权拦截器的角色了.</em></p></li><li><p><strong>切入点（Pointcut）</strong></p><blockquote><p>A predicate that matches join points. Advice is associated with a pointcut expression and runs at any join point matched by the pointcut (for example, the execution of a method with a certain name). The concept of join points as matched by pointcut expressions is central to AOP, and Spring uses the AspectJ pointcut expression language by default.</p></blockquote><p>匹配连接点的谓词。通知与切入点表达式关联，并在与该切入点匹配的任何连接点处运行（例如，执行具有特定名称的方法）。使用切入点表达式来匹配连接点是AOP的核心，并且Spring默认使用AspectJ切入点表达语言。</p><p>在 <code>Spring</code> 中, 所有的方法都可以认为是 <code>joinpoint</code>, 但是我们并不希望在所有的方法上都添加 <code>Advice</code>, 而 pointcut 的作用就是提供一组规则(使用 <em>AspectJ pointcut expression language</em> 来描述) 来匹配<code>joinpoint</code>, 给满足规则的 <code>joinpoint</code> 添加 <code>Advice</code>.</p></li><li><p><strong>引入（Introduction）</strong></p><blockquote><p>Declaring additional methods or fields on behalf of a type. Spring AOP lets you introduce new interfaces (and a corresponding implementation) to any advised object. For example, you could use an introduction to make a bean implement an <code>IsModified</code> interface, to simplify caching. (An introduction is known as an inter-type declaration in the AspectJ community.)</p></blockquote><p>代表类型声明其他方法或字段。 Spring AOP允许您向任何建议的对象引入新的接口（和相应的实现）。例如，您可以使用<em>引入</em>使<code>Bean</code>实现<code>IsModified</code>接口，以简化缓存。 （在AspectJ社区中，<strong>引入</strong>被称为类型间声明。）</p></li></ul><blockquote><p>为一个类型添加额外的方法或字段. <code>Spring AOP</code> 允许我们为 <code>目标对象</code> 引入新的接口(和对应的实现). 例如我们可以使用 <code>introduction</code> 来为一个 <code>bean</code> 实现 <code>IsModified</code> 接口, 并以此来简化 <code>caching</code> 的实现.</p></blockquote><ul><li><p><strong>目标对象（Target object）</strong></p><blockquote><p>An object being advised by one or more aspects. Also referred to as the “advised object”. Since Spring AOP is implemented by using runtime proxies, this object is always a proxied object.</p></blockquote><p>一个或多个切面通知的对象。也称为“目标对象”。由于<code>Spring AOP</code>是使用运行时<strong>代理</strong>实现的，因此<strong>该对象始终是代理对象</strong>。</p><p>因为 Spring AOP 使用运行时代理的方式来实现 aspect, 因此 adviced object 总是一个代理对象(proxied object)。</p><p><em>注意, adviced object 指的不是原来的类, 而是织入 advice 后所产生的代理类</em></p></li><li><p><strong>代理（AOP proxy）</strong></p><blockquote><p> An object created by the AOP framework in order to implement the aspect contracts (advise method executions and so on). In the Spring Framework, an AOP proxy is a JDK dynamic proxy or a CGLIB proxy.</p></blockquote><p>一个类被 AOP 织入 <code>advice</code>， 就会产生一个结果类, 它是融合了原类和增强逻辑的代理类。在 Spring AOP 中, 一个 AOP 代理是一个 JDK 动态代理对象或 CGLIB 代理对象。</p></li><li><p><strong>织入（Weaving）</strong></p><blockquote><p> linking aspects with other application types or objects to create an advised object. This can be done at compile time (using the AspectJ compiler, for example), load time, or at runtime. Spring AOP, like other pure Java AOP frameworks, performs weaving at runtime.</p></blockquote><p>将切面与其他应用程序类型或对象链接以创建建议的对象（将 aspect 和其他对象连接起来, 并创建 adviced object 的过程）。这可以在编译时（例如，使用<code>AspectJ</code>编译器），加载时或在运行时完成。像其他纯Java AOP框架一样，<code>Spring AOP</code>在运行时执行编织。根据不同的实现技术, AOP织入有三种方式:</p><ul><li>编译器织入, 这要求有特殊的Java编译器.</li><li>类装载期织入, 这需要有特殊的类装载器.</li><li>动态代理织入, 在运行期为目标类添加增强(Advice)生成子类的方式.<br>Spring 采用动态代理织入, 而AspectJ采用编译器织入和类装载期织入.</li></ul></li></ul><h3 id="advice的几种类型"><a href="#advice的几种类型" class="headerlink" title="advice的几种类型"></a>advice的几种类型</h3><ul><li><p><strong>前置通知（Before advice）</strong></p><p>在连接点之前运行但无法阻止执行流前进到连接点的通知（除非它引发异常）。</p></li><li><p><strong>后置通知（After returning advice）</strong></p><p>连接点正常完成后要运行的通知（例如，如果方法返回而没有引发异常）。</p></li><li><p><strong>抛出异常后通知（After throwing advice）</strong></p><p>如果存在方法则通过抛出异常来执行的通知。</p></li><li><p><strong>在finally执行后通知（After (finally) advice）</strong></p><p>无论连接点退出的方式如何（正常或异常返回），都将执行通知。</p></li><li><p><strong>环绕通知（Around advice</strong>）</p><p>围绕联接点的通知，例如方法调用。这是最有力的通知。<strong>环绕通知可以在方法调用之前和之后执行自定义行为</strong>。它还负责选择是返回连接点还是通过返回其自身的返回值或引发异常来进行通知的方法执行。</p></li></ul><h2 id="AOP代理"><a href="#AOP代理" class="headerlink" title="AOP代理"></a>AOP代理</h2><p><code>Spring AOP</code>默认将标准<code>JDK</code>动态代理用于<code>AOP</code>代理。这使得可以代理任何接口（或一组接口）。</p><p><code>Spring AOP</code>也可以使用<code>CGLIB</code>代理。这对于代理类而不是接口是必需的。<strong>默认情况下，如果业务对象未实现接口，则使用CGLIB。</strong>由于对接口而不是对类进行编程是一种好习惯，因此业务类通常实现一个或多个业务接口。在那些需要建议在接口上未声明的方法或需要将代理对象作为具体类型传递给方法的情况下（在极少数情况下），可以强制使用<code>CGLIB</code>。</p><h3 id="Spring-Bean的生命周期"><a href="#Spring-Bean的生命周期" class="headerlink" title="Spring Bean的生命周期"></a>Spring Bean的生命周期</h3><blockquote><p>插播一下Spring Bean的生命周期</p></blockquote><p>两个概念：<code>Spring Bean</code> 和 <code>对象</code>：</p><ol><li><strong>spring bean</strong>——受spring容器管理的对象，可能经过了完整的spring bean生命周期（为什么是可能？难道还有bean是没有经过bean生命周期的？答案是有的，具体我们后面文章分析），最终存在spring容器当中；一个bean一定是个对象</li><li><strong>对象</strong>——任何符合java语法规则实例化出来的对象，但是一个对象并不一定是spring bean；</li></ol><p>所谓的bean的生命周期就是磁盘上的类通过Spring扫描，然后实例化，跟着初始化，继而放到容器当中的过程。下图展示Spring Bean的生命周期大概有哪些步骤：</p><p><img src="https://cdn.jsdelivr.net/gh/cayzlh/git-img-repository@master/uPic/20191118210559319.png" alt="Spring Bean的生命周期"></p><p><strong>其中AOP的代理也是在这个过程中完成的。</strong></p><h2 id="AOP的使用"><a href="#AOP的使用" class="headerlink" title="AOP的使用"></a>AOP的使用</h2><h3 id="AspectJ与-AspectJ"><a href="#AspectJ与-AspectJ" class="headerlink" title="AspectJ与@AspectJ"></a>AspectJ与@AspectJ</h3><p><code>@AspectJ</code>是一种将切面声明为带有注解的常规<code>Java</code>类的样式。 <code>@AspectJ</code>样式是<code>AspectJ</code>项目在<code>AspectJ 5</code>版本中引入的。 <code>Spring</code>使用<code>AspectJ</code>提供的用于切入点解析和匹配的库来解释与<code>AspectJ 5</code>相同的注解。但是，<code>AOP</code>运行时仍然是纯<code>Spring AOP</code>，并且不依赖于<code>AspectJ</code>编译器或编织器。</p><blockquote><p>为了方便使用，<code>Spring</code>借鉴了<code>AspectJ</code>的语法。</p><p>使用<code>AspectJ</code>编译器和<code>weaver</code>可以使用完整的<code>AspectJ</code>语法。</p></blockquote><blockquote><p>AspectJ 是最早、功能比较强大的 AOP 实现之一，对整套 AOP 机制都有较好的实现，很多其他语言的 AOP 实现，也借鉴或采纳了 AspectJ 中很多设计。</p></blockquote><h3 id="启用-AspectJ支持"><a href="#启用-AspectJ支持" class="headerlink" title="启用@AspectJ支持"></a>启用@AspectJ支持</h3><ol><li><p>通过<code>Java</code>配置启用<code>@AspectJ</code>支持</p><p>在配置类加上<code>@EnableAspectJAutoProxy</code>注解以启用<code>@AspectJ</code>支持</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>通过<code>XML</code>配置启用<code>@Aspect</code>J支持</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span>/&gt;</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="声明一个切面"><a href="#声明一个切面" class="headerlink" title="声明一个切面"></a>声明一个切面</h3><p>启用<code>@AspectJ</code>支持后，<code>Spring</code>会自动检测在应用程序上下文中使用<code>@AspectJ</code>切面（具有<code>@Aspect</code>批注）的类定义的bean，并用于配置<code>Spring AOP</code>。</p><ol><li><p>使用xml配置声明切面</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;myAspect&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.xyz.NotVeryUsefulAspect&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- configure properties of the aspect here --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>使用注解声明切面</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.xyz;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotVeryUsefulAspect</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="声明切入点"><a href="#声明切入点" class="headerlink" title="声明切入点"></a>声明切入点</h3><p>切入点确定了关注的的连接点，从而使我们能够控制执行通知的时机。 <code>Spring AOP</code>仅支持<code>Spring Bean</code>的方法执行连接点，可以将切入点视为与<code>Spring Bean</code>上的方法执行匹配。</p><p>切入点声明由两部分组成：一个包含名称和任何参数的签名，以及一个切入点表达式，该切入点表达式精确地确定我们关注的方法执行。在<code>AOP</code>的<code>@AspectJ</code>批注样式中，常规方法定义提供了切入点签名。 并通过使用<code>@Pointcut</code>注解声明切入点表达式（<strong>用作切入点签名的方法必须具有void返回类型</strong>）。</p><p>一个例子：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Pointcut(&quot;execution(* transfer(..))&quot;)</span> <span class="comment">// 切入点表达式</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">anyOldTransfer</span><span class="params">()</span> </span>&#123;&#125; <span class="comment">// 切入点方法签名</span></span><br></pre></td></tr></table></figure><h4 id="支持的切入点指示符"><a href="#支持的切入点指示符" class="headerlink" title="支持的切入点指示符"></a>支持的切入点指示符</h4><p><code>Spring AOP</code>支持以下在切入点表达式中使用的<code>AspectJ</code>切入点指示符（PCD）：</p><ul><li><p><code>execution</code>：匹配方法执行的连接点，这是你将会用到的Spring的最主要的切入点指定者。</p><blockquote><p>描述的最小粒度精确到方法（甚至方法的参数）</p></blockquote></li><li><p><code>within</code>：限定匹配特定类型的连接点（在使用SpringAOP的时候，在匹配的类型中定义的方法的执行）。</p><blockquote><p>描述的最小粒度仅仅到一个类</p></blockquote></li><li><p><code>this</code>：限定匹配特定的连接点（使用Spring AOP的时候方法的执行），其中bean reference（Spring AOP 代理）是<strong>指定类型的实例。</strong>（代理的对象本身）</p></li><li><p><code>target</code>：限定匹配特定的连接点（使用SpringAOP的时候方法的执行），其中目标对象（被代理的appolication object）是<strong>指定类型的实例。</strong>（被代理的对象）</p></li><li><p><code>args</code>：限定匹配特定的连接点（使用Spring AOP的时候方法的执行），其中参数是指定类型的实例。</p></li><li><p><code>@target</code>：限定匹配特定的连接点（使用SpringAOP的时候方法的执行），其中执行的对象的类已经有指定类型的注解。</p></li><li><p>@args：限定匹配特定的连接点（使用SpringAOP的时候方法的执行），其中实际传入参数的运行时类型有指定类型的注解。</p></li><li><p><code>@within</code>：限定匹配特定的连接点，其中连接点所在类型已指定注解（在使用Spring AOP的时候，所执行的方法所在类型已指定注解）。</p></li><li><p> <code>@annotation</code>：限定匹配特定的连接点（使用SpringAOP的时候方法的执行），其中连接点的主题有某种给定的注解合并切入点表达式</p></li></ul><h4 id="组合切入点"><a href="#组合切入点" class="headerlink" title="组合切入点"></a>组合切入点</h4><p>您可以使用<code>&amp;&amp;</code>，<code>||</code>组合切入点表达式和<code>！</code>您也可以按名称引用切入点表达式。以下示例显示了三个切入点表达式：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Pointcut(&quot;execution(public * *(..))&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">anyPublicOperation</span><span class="params">()</span> </span>&#123;&#125;  <span class="comment">// 1⃣️ 匹配所有公共方法</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Pointcut(&quot;within(com.xyz.someapp.trading..*)&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inTrading</span><span class="params">()</span> </span>&#123;&#125;  <span class="comment">// 2⃣️ 匹配指定包里面的所有方法</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Pointcut(&quot;anyPublicOperation() &amp;&amp; inTrading()&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">tradingOperation</span><span class="params">()</span> </span>&#123;&#125;  <span class="comment">// 3⃣️ 匹配指定包里面的所有公共方法</span></span><br></pre></td></tr></table></figure><h4 id="共享通用切入点定义"><a href="#共享通用切入点定义" class="headerlink" title="共享通用切入点定义"></a>共享通用切入点定义</h4><p>在开发应用程序时，开发人员通常希望从多个方面引用应用程序的模块和特定的操作集。我们建议为此定义一个 <code>SystemArchitecture</code>切面，以捕获常见的切入点表达式。这样的方面通常类似于以下示例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xyz.someapp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Pointcut;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SystemArchitecture</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * A join point is in the web layer if the method is defined</span></span><br><span class="line"><span class="comment">     * in a type in the com.xyz.someapp.web package or any sub-package</span></span><br><span class="line"><span class="comment">     * under that.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Pointcut(&quot;within(com.xyz.someapp.web..*)&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inWebLayer</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * A join point is in the service layer if the method is defined</span></span><br><span class="line"><span class="comment">     * in a type in the com.xyz.someapp.service package or any sub-package</span></span><br><span class="line"><span class="comment">     * under that.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Pointcut(&quot;within(com.xyz.someapp.service..*)&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inServiceLayer</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * A join point is in the data access layer if the method is defined</span></span><br><span class="line"><span class="comment">     * in a type in the com.xyz.someapp.dao package or any sub-package</span></span><br><span class="line"><span class="comment">     * under that.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Pointcut(&quot;within(com.xyz.someapp.dao..*)&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inDataAccessLayer</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * A business service is the execution of any method defined on a service</span></span><br><span class="line"><span class="comment">     * interface. This definition assumes that interfaces are placed in the</span></span><br><span class="line"><span class="comment">     * &quot;service&quot; package, and that implementation types are in sub-packages.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * If you group service interfaces by functional area (for example,</span></span><br><span class="line"><span class="comment">     * in packages com.xyz.someapp.abc.service and com.xyz.someapp.def.service) then</span></span><br><span class="line"><span class="comment">     * the pointcut expression &quot;execution(* com.xyz.someapp..service.*.*(..))&quot;</span></span><br><span class="line"><span class="comment">     * could be used instead.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Alternatively, you can write the expression using the &#x27;bean&#x27;</span></span><br><span class="line"><span class="comment">     * PCD, like so &quot;bean(*Service)&quot;. (This assumes that you have</span></span><br><span class="line"><span class="comment">     * named your Spring service beans in a consistent fashion.)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(* com.xyz.someapp..service.*.*(..))&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">businessService</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * A data access operation is the execution of any method defined on a</span></span><br><span class="line"><span class="comment">     * dao interface. This definition assumes that interfaces are placed in the</span></span><br><span class="line"><span class="comment">     * &quot;dao&quot; package, and that implementation types are in sub-packages.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(* com.xyz.someapp.dao.*.*(..))&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dataAccessOperation</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以在需要切入点表达式的任何地方引用切面中定义的切入点。例如，要使服务层具有事务性：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    &lt;aop:advisor</span><br><span class="line">        pointcut=&quot;com.xyz.someapp.SystemArchitecture.businessService()&quot;</span><br><span class="line">        advice-ref=&quot;tx-advice&quot;/&gt;</span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">&quot;tx-advice&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;*&quot;</span> <span class="attr">propagation</span>=<span class="string">&quot;REQUIRED&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h4><blockquote><p>语法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">execution(modifiers-pattern? ret-type-pattern declaring-type-pattern?name-pattern(param-pattern) <span class="keyword">throws</span>-pattern?)</span><br></pre></td></tr></table></figure><ul><li>问号表示当前项有也可以没有</li><li>其中各项语义如下：<ul><li><strong>modifiers- pattern</strong>：方法的可见性，如 public, protected</li><li><strong>ret-type- pattern</strong>：方法的返回值类型，如 int, void 等</li><li><strong>declaring-type- pattern</strong>：方法所在类的全路径名，如 com, spring, Aspect</li><li><strong>name- pattern</strong>：方法名，如 bui sinessservice () </li><li><strong>param- pattern</strong>：方法的参数类型，如 java. Lang String</li><li><strong>throws- pattern</strong>: 方法抛出的异常类型，如 java.Lang. Exception</li></ul></li></ul></blockquote><p>一些常见的表达式：</p><ul><li><p>匹配任意<code>public</code>方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">execution(<span class="keyword">public</span> * *(..))</span><br></pre></td></tr></table></figure></li><li><p>匹配所有以<code>set</code>开头的方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">execution(* set*(..))</span><br></pre></td></tr></table></figure></li><li><p>匹配<code>AccountService</code>接口定义的任何方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">execution(* com.xyz.service.AccountService.*(..))</span><br></pre></td></tr></table></figure></li><li><p>匹配指定包下的方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">execution(* com.xyz.service.*.*(..))</span><br></pre></td></tr></table></figure></li><li><p>匹配指定包下面的一个或多个子包下的类方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">execution(* com.xyz.service..*.*(..))</span><br></pre></td></tr></table></figure></li><li><p>匹配<code>service</code>包中的所有连接点</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">within(com.xyz.service.*)</span><br></pre></td></tr></table></figure></li><li><p>匹配<code>service</code>一个或多个子包中的所有连接点</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">within(com.xyz.service..*)</span><br></pre></td></tr></table></figure></li><li><p>代理实现<code>AccountService</code>接口的任何连接点</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>(com.xyz.service.AccountService)</span><br></pre></td></tr></table></figure></li><li><p>目标对象实现AccountService接口的任何连接点</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">target(com.xyz.service.AccountService)</span><br></pre></td></tr></table></figure></li><li><p>任何采用单个参数并且在运行时传递的参数为Serializable的连接点</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">args(java.io.Serializable)</span><br></pre></td></tr></table></figure></li><li><p>目标对象具有<code>@Transactional</code>注解的任何连接点</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@target(org.springframework.transaction.annotation.Transactional)</span></span><br></pre></td></tr></table></figure></li><li><p>目标对象的声明类型具有<code>@Transactional</code>注解的任何连接点</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@within(org.springframework.transaction.annotation.Transactional)</span></span><br></pre></td></tr></table></figure></li><li><p>任何执行方法带有@Transactional批注的连接点</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@annotation(org.springframework.transaction.annotation.Transactional)</span></span><br></pre></td></tr></table></figure></li><li><p>任何采用单个参数的联接点，并且传递的参数的运行时类型具有<code>Classified</code>注解</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@args(com.xyz.security.Classified)</span></span><br></pre></td></tr></table></figure></li><li><p>名为<code>tradeService</code>的<code>Spring bean</code>上的任何连接点</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">bean(tradeService)</span><br></pre></td></tr></table></figure></li><li><p><code>Spring Bean</code>上具有与通配符表达式<code>* Service</code>匹配的名称的任何连接点</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">bean(*Service)</span><br></pre></td></tr></table></figure></li></ul><h3 id="声明通知"><a href="#声明通知" class="headerlink" title="声明通知"></a>声明通知</h3><p>通知用来声明方法在切入点表达式匹配的方法执行之前，之后或周围运行。切入点表达式可以是对命名切入点的简单引用，也可以是就地声明的切入点表达式。</p><h4 id="Before-Advice"><a href="#Before-Advice" class="headerlink" title="Before Advice"></a>Before Advice</h4><p>使用<code>@Before</code>注解在切面中声明通知。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Before;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeforeExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before(&quot;com.xyz.myapp.SystemArchitecture.dataAccessOperation()&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAccessCheck</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>声明通知的同时声明切入点：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Before;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeforeExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before(&quot;execution(* com.xyz.myapp.dao.*.*(..))&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAccessCheck</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="After-Returning-Advice"><a href="#After-Returning-Advice" class="headerlink" title="After Returning Advice"></a>After Returning Advice</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.AfterReturning;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AfterReturningExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterReturning(&quot;com.xyz.myapp.SystemArchitecture.dataAccessOperation()&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAccessCheck</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有时，您需要在通知正文中访问返回的实际值。您可以使用<code>@AfterReturning</code>的形式绑定返回值以获取该访问权限，如以下示例所示：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.AfterReturning;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AfterReturningExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterReturning(</span></span><br><span class="line"><span class="meta">        pointcut=&quot;com.xyz.myapp.SystemArchitecture.dataAccessOperation()&quot;,</span></span><br><span class="line"><span class="meta">        returning=&quot;retVal&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAccessCheck</span><span class="params">(Object retVal)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="After-Throwing-Advice"><a href="#After-Throwing-Advice" class="headerlink" title="After Throwing Advice"></a>After Throwing Advice</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.AfterThrowing;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AfterThrowingExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterThrowing(&quot;com.xyz.myapp.SystemArchitecture.dataAccessOperation()&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doRecoveryActions</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>指定异常类型：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.AfterThrowing;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AfterThrowingExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterThrowing(</span></span><br><span class="line"><span class="meta">        pointcut=&quot;com.xyz.myapp.SystemArchitecture.dataAccessOperation()&quot;,</span></span><br><span class="line"><span class="meta">        throwing=&quot;ex&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doRecoveryActions</span><span class="params">(DataAccessException ex)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="After-Finally-Advice"><a href="#After-Finally-Advice" class="headerlink" title="After (Finally) Advice"></a>After (Finally) Advice</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.After;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AfterFinallyExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@After(&quot;com.xyz.myapp.SystemArchitecture.dataAccessOperation()&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doReleaseLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Around-Advice"><a href="#Around-Advice" class="headerlink" title="Around Advice"></a>Around Advice</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Around;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.ProceedingJoinPoint;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AroundExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around(&quot;com.xyz.myapp.SystemArchitecture.businessService()&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">doBasicProfiling</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">// start stopwatch</span></span><br><span class="line">        Object retVal = pjp.proceed();</span><br><span class="line">        <span class="comment">// stop stopwatch</span></span><br><span class="line">        <span class="keyword">return</span> retVal;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h3><p>引入（<strong>Introductions</strong>）（在AspectJ中称为类型间声明）使切面可以声明通知对象实现给定的接口，并代表那些对象提供该接口的实现。</p><p>您可以使用<code>@DeclareParents</code>批注进行介绍。此批注用于声明匹配类型具有新的父代（因此而得名）。例如，给定一个名为<code>UsageTracked</code>的接口和该接口名为<code>DefaultUsageTracked</code>的实现，以下方面声明服务接口的所有实现者也都实现了<code>UsageTracked</code>接口（例如，通过JMX公开统计信息）：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UsageTracking</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@DeclareParents(value=&quot;com.xzy.myapp.service.*+&quot;, defaultImpl=DefaultUsageTracked.class)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> UsageTracked mixin;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before(&quot;com.xyz.myapp.SystemArchitecture.businessService() &amp;&amp; this(usageTracked)&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recordUsage</span><span class="params">(UsageTracked usageTracked)</span> </span>&#123;</span><br><span class="line">        usageTracked.incrementUseCount();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Spring-AOP实例"><a href="#Spring-AOP实例" class="headerlink" title="Spring AOP实例"></a>Spring AOP实例</h2><p><strong>代码地址：</strong><a href="https://github.com/cayzlh/cayzlh-demos">https://github.com/cayzlh/cayzlh-demos</a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><code>Spring</code>借鉴了<code>AspectJ</code>的语法</li><li><code>Spring</code>通过动态代理来实现<code>aop</code></li><li>对接口创建代理优于对类创建代理，因为会产生更加松耦合的系统，所以spring默认是使用JDK代理。对类代理是让遗留系统或无法实现接口的第三方类库同样可以得到通知，这种方式应该是备用方案</li><li>标记为<code>final</code>的方法不能够被通知。spring是为目标类产生子类。任何需要被通知的方法都被复写，将通知织入。<code>final</code>方法是不允许重写的</li><li>spring只支持方法连接点：不提供属性接入点，spring的观点是属性拦截破坏了封装。面向对象的概念是对象自己处理工作，其他对象只能通过方法调用的得到的结果</li></ul><blockquote><p>spring在运行期，生成动态代理对象，不需要特殊的编译器</p><p>Spring AOP 优先对接口进行代理 （使用Jdk动态代理）如果目标对象没有实现任何接口，才会对类进行代理 （使用cglib动态代理）</p></blockquote><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#aop">Spring官网(aop)</a></li><li><a href="https://zhuanlan.zhihu.com/p/97223347">Spring AOP简介与底层实现机制——动态代理</a></li><li><a href="https://blog.csdn.net/java_lyvee/article/details/101793774">spring源码系列（一）——spring循环引用</a></li><li><a href="https://segmentfault.com/a/1190000007469968">彻底征服 Spring AOP 之 理论篇</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis中用到的几种设计模式</title>
      <link href="/blog/2020/03/23/26b455b4.html"/>
      <url>/blog/2020/03/23/26b455b4.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文转载自：<a href="http://www.crazyant.net/2022.html">http://www.crazyant.net/2022.html</a></p></blockquote><p>Mybatis至少遇到了以下的设计模式的使用：</p><ol><li><strong>Builder模式</strong>，例如<code>SqlSessionFactoryBuilder</code>、<code>XMLConfigBuilder</code>、<code>XMLMapperBuilder</code>、<code>XMLStatementBuilder</code>、<code>CacheBuilder</code>；</li><li><strong>工厂模式</strong>，例如<code>SqlSessionFactory</code>、<code>ObjectFactory</code>、<code>MapperProxyFactory</code>；</li><li><strong>单例模式</strong>，例如ErrorContext和<code>LogFactory</code>；</li><li><strong>代理模式</strong>，Mybatis实现的核心，比如<code>MapperProxy</code>、<code>ConnectionLogger</code>，用的jdk的动态代理；还有executor.loader包使用了cglib或者javassist达到延迟加载的效果；</li><li>组合模式，例如<code>SqlNode</code>和各个子类<code>ChooseSqlNode</code>等；</li><li><strong>模板方法模式</strong>，例如<code>BaseExecutor</code>和<code>SimpleExecutor</code>，还有<code>BaseTypeHandler</code>和所有的子类例如<code>IntegerTypeHandler</code>；</li><li><strong>适配器模式</strong>，例如Log的Mybatis接口和它对jdbc、log4j等各种日志框架的适配实现；</li><li><strong>装饰者模式</strong>，例如Cache包中的cache.decorators子包中等各个装饰者的实现；</li><li><strong>迭代器模式</strong>，例如迭代器模式<code>PropertyTokenizer</code>；</li></ol><p>接下来挨个模式进行解读，先介绍模式自身的知识，然后解读在Mybatis中怎样应用了该模式。</p><h2 id="Builder模式"><a href="#Builder模式" class="headerlink" title="Builder模式"></a>Builder模式</h2><p>Builder模式的定义是“将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示”，它属于创建类模式，一般来说，如果一个对象的构建比较复杂，超出了构造函数所能包含的范围，就可以使用工厂模式和Builder模式，相对于工厂模式会产出一个完整的产品，Builder应用于更加复杂的对象的构建，甚至只会构建产品的一个部分。</p><p><img src="https://cdn.jsdelivr.net/gh/cayzlh/git-img-repository@master/uPic/c32qrf.jpg" alt="Builder模式"></p><p>在Mybatis环境的初始化过程中，<code>SqlSessionFactoryBuilder</code>会调用<code>XMLConfigBuilder</code>读取所有的<code>MybatisMapConfig.xml</code>和所有的*Mapper.xml文件，构建Mybatis运行的核心对象Configuration对象，然后将该Configuration对象作为参数构建一个SqlSessionFactory对象。</p><p>其中<code>XMLConfigBuilder</code>在构建<code>Configuration</code>对象时，也会调用<code>XMLMapperBuilder</code>用于读取*Mapper文件，而<code>XMLMapperBuilder</code>会使用<code>XMLStatementBuilder</code>来读取和build所有的SQL语句。</p><p>在这个过程中，有一个相似的特点，就是这些Builder会读取文件或者配置，然后做大量的XpathParser解析、配置或语法的解析、反射生成对象、存入结果缓存等步骤，这么多的工作都不是一个构造函数所能包括的，因此大量采用了Builder模式来解决。</p><p>对于builder的具体类，方法都大都用build*开头，比如<code>SqlSessionFactoryBuilder</code>为例，它包含以下方法：</p><p><img src="https://cdn.jsdelivr.net/gh/cayzlh/git-img-repository@master/uPic/KAGdgM.jpg" alt="SqlSessionFactoryBuilder"></p><p>即根据不同的输入参数来构建<code>SqlSessionFactory</code>这个工厂对象。</p><h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><p>在Mybatis中比如<code>SqlSessionFactory</code>使用的是工厂模式，该工厂没有那么复杂的逻辑，是一个简单工厂模式。</p><p>简单工厂模式(Simple Factory Pattern)：又称为静态工厂方法(Static Factory Method)模式，它属于类创建型模式。在简单工厂模式中，可以根据参数的不同返回不同类的实例。简单工厂模式专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。</p><p><img src="https://cdn.jsdelivr.net/gh/cayzlh/git-img-repository@master/uPic/Z3PDMk.jpg" alt="简单工厂模式"></p><p>SqlSession可以认为是一个Mybatis工作的核心的接口，通过这个接口可以执行执行SQL语句、获取Mappers、管理事务。类似于连接MySQL的Connection对象。</p><p><img src="https://cdn.jsdelivr.net/gh/cayzlh/git-img-repository@master/uPic/70L93B.jpg" alt="70L93B"></p><p>可以看到，该Factory的openSession方法重载了很多个，分别支持autoCommit、Executor、Transaction等参数的输入，来构建核心的SqlSession对象。</p><p>在DefaultSqlSessionFactory的默认工厂实现里，有一个方法可以看出工厂怎么产出一个产品：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> SqlSession <span class="title">openSessionFromDataSource</span><span class="params">(ExecutorType execType,</span></span></span><br><span class="line"><span class="function"><span class="params">                                             TransactionIsolationLevel level,</span></span></span><br><span class="line"><span class="function"><span class="params">                                             <span class="keyword">boolean</span> autoCommit)</span> </span>&#123;</span><br><span class="line">Transaction tx = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">final</span> Environment environment = configuration.getEnvironment();</span><br><span class="line"><span class="keyword">final</span> TransactionFactory transactionFactory = </span><br><span class="line">        getTransactionFactoryFromEnvironment(environment);</span><br><span class="line">tx = </span><br><span class="line">        transactionFactory.newTransaction(environment.getDataSource(), </span><br><span class="line">                                          level, autoCommit);</span><br><span class="line"><span class="keyword">final</span> Executor executor = configuration.newExecutor(tx, execType);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> DefaultSqlSession(configuration, executor, autoCommit);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">closeTransaction(tx); <span class="comment">// may have fetched a connection so lets call</span></span><br><span class="line"><span class="comment">// close()</span></span><br><span class="line"><span class="keyword">throw</span> ExceptionFactory.wrapException(<span class="string">&quot;Error opening session.  Cause: &quot;</span> + e, e);</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">ErrorContext.instance().reset();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一个openSession调用的底层方法，该方法先从configuration读取对应的环境配置，然后初始化<code>TransactionFactory</code>获得一个<code>Transaction</code>对象，然后通过<code>Transaction</code>获取一个<code>Executor</code>对象，最后通过configuration、Executor、是否autoCommit三个参数构建了<code>SqlSession</code>。</p><p>在这里其实也可以看到端倪，<code>SqlSession</code>的执行，其实是委托给对应的<code>Executor</code>来进行的。</p><p>而对于<code>LogFactory</code>，它的实现代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">LogFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Constructor&lt;? extends Log&gt; logConstructor;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LogFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// disable construction</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Log <span class="title">getLog</span><span class="params">(Class&lt;?&gt; aClass)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getLog(aClass.getName());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这里有个特别的地方，是Log变量的的类型是<code>Constructor</code>，也就是说该工厂生产的不只是一个产品，而是具有Log公共接口的一系列产品，比如<code>Log4jImpl</code>、<code>Slf4jImpl</code>等很多具体的Log。</p><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>单例模式(Singleton Pattern)：单例模式确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例，这个类称为单例类，它提供全局访问的方法。</p><p>单例模式的要点有三个：一是某个类只能有一个实例；二是它必须自行创建这个实例；三是它必须自行向整个系统提供这个实例。单例模式是一种对象创建型模式。单例模式又名单件模式或单态模式。</p><p><img src="https://cdn.jsdelivr.net/gh/cayzlh/git-img-repository@master/uPic/tHOgLF.jpg" alt="tHOgLF"></p><p>在Mybatis中有两个地方用到单例模式，<code>ErrorContext</code>和<code>LogFactory</code>，其中<code>ErrorContext</code>是用在每个线程范围内的单例，用于记录该线程的执行环境错误信息，而<code>LogFactory</code>则是提供给整个Mybatis使用的日志工厂，用于获得针对项目配置好的日志对象。</p><p><code>ErrorContext</code>的单例实现代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ErrorContext</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;ErrorContext&gt; LOCAL = <span class="keyword">new</span> ThreadLocal&lt;ErrorContext&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ErrorContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ErrorContext <span class="title">instance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ErrorContext context = LOCAL.get();</span><br><span class="line">        <span class="keyword">if</span> (context == <span class="keyword">null</span>) &#123;</span><br><span class="line">            context = <span class="keyword">new</span> ErrorContext();</span><br><span class="line">            LOCAL.set(context);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> context;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>构造函数是private修饰，具有一个static的局部instance变量和一个获取instance变量的方法，在获取实例的方法中，先判断是否为空如果是的话就先创建，然后返回构造好的对象。</p><p>只是这里有个有趣的地方是，LOCAL的静态实例变量使用了<code>ThreadLocal</code>修饰，也就是说它属于每个线程各自的数据，而在<code>instance()</code>方法中，先获取本线程的该实例，如果没有就创建该线程独有的<code>ErrorContext</code>。</p><h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><p>代理模式可以认为是Mybatis的核心使用的模式，正是由于这个模式，我们只需要编写<code>Mapper.java</code>接口，不需要实现，由Mybatis后台帮我们完成具体SQL的执行。</p><p>代理模式(Proxy Pattern) ：给某一个对象提供一个代 理，并由代理对象控制对原对象的引用。代理模式的英 文叫做Proxy或Surrogate，它是一种对象结构型模式。</p><p>代理模式包含如下角色：</p><ul><li>Subject: 抽象主题角色</li><li>Proxy: 代理主题角色</li><li>RealSubject: 真实主题角色</li></ul><p><img src="https://cdn.jsdelivr.net/gh/cayzlh/git-img-repository@master/uPic/57qXzr.jpg" alt="57qXzr"></p><p>这里有两个步骤，第一个是提前创建一个Proxy，第二个是使用的时候会自动请求Proxy，然后由Proxy来执行具体事务；</p><p>当我们使用<code>Configuration</code>的<code>getMapper</code>方法时，会调用<code>mapperRegistry.getMapper</code>方法，而该方法又会调用<code>mapperProxyFactory.newInstance(sqlSession)</code>来生成一个具体的代理：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> mapperInterface;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;Method, MapperMethod&gt; <span class="title">getMethodCache</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> methodCache;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> T <span class="title">newInstance</span><span class="params">(MapperProxy&lt;T&gt; mapperProxy)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (T) Proxy.newProxyInstance(mapperInterface.getClassLoader(), </span><br><span class="line">                                          <span class="keyword">new</span> Class[] &#123; mapperInterface &#125;,</span><br><span class="line">                mapperProxy);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">newInstance</span><span class="params">(SqlSession sqlSession)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> MapperProxy&lt;T&gt; mapperProxy = <span class="keyword">new</span> MapperProxy&lt;T&gt;(sqlSession, </span><br><span class="line">                                                              mapperInterface, methodCache);</span><br><span class="line">        <span class="keyword">return</span> newInstance(mapperProxy);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里，先通过<code>T newInstance(SqlSession sqlSession)</code>方法会得到一个<code>MapperProxy</code>对象，然后调用<code>T newInstance(MapperProxy mapperProxy)</code>生成代理对象然后返回。</p><p>而查看<code>MapperProxy</code>的代码，可以看到如下内容：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapperProxy</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">InvocationHandler</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (Object.class.equals(method.getDeclaringClass())) &#123;</span><br><span class="line">                <span class="keyword">return</span> method.invoke(<span class="keyword">this</span>, args);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isDefaultMethod(method)) &#123;</span><br><span class="line">                <span class="keyword">return</span> invokeDefaultMethod(proxy, method, args);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            <span class="keyword">throw</span> ExceptionUtil.unwrapThrowable(t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> MapperMethod mapperMethod = cachedMapperMethod(method);</span><br><span class="line">        <span class="keyword">return</span> mapperMethod.execute(sqlSession, args);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>非常典型的，该<code>MapperProxy</code>类实现了<code>InvocationHandler</code>接口，并且实现了该接口的<code>invoke</code>方法。</p><p>通过这种方式，我们只需要编写<code>Mapper.java</code>接口类，当真正执行一个<code>Mapper</code>接口的时候，就会转发给<code>MapperProxy.invoke</code>方法，而该方法则会调用后续的<code>sqlSession.cud&gt;executor.execute&gt;prepareStatement</code>等一系列方法，完成SQL的执行和返回。</p><h2 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h2><p>组合模式组合多个对象形成树形结构以表示“整体-部分”的结构层次。</p><p>组合模式对单个对象(叶子对象)和组合对象(组合对象)具有一致性，它将对象组织到树结构中，可以用来描述整体与部分的关系。同时它也模糊了简单元素(叶子对象)和复杂元素(容器对象)的概念，使得客户能够像处理简单元素一样来处理复杂元素，从而使客户程序能够与复杂元素的内部结构解耦。</p><p>在使用组合模式中需要注意一点也是组合模式最关键的地方：叶子对象和组合对象实现相同的接口。这就是组合模式能够将叶子节点和对象节点进行一致处理的原因。</p><p><img src="https://cdn.jsdelivr.net/gh/cayzlh/git-img-repository@master/uPic/kEL5d7.jpg" alt="kEL5d7"></p><p>Mybatis支持动态SQL的强大功能，比如下面的这个SQL：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;update&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;org.format.dynamicproxy.mybatis.bean.User&quot;</span>&gt;</span></span><br><span class="line">    UPDATE users</span><br><span class="line">    <span class="tag">&lt;<span class="name">trim</span> <span class="attr">prefix</span>=<span class="string">&quot;SET&quot;</span> <span class="attr">prefixOverrides</span>=<span class="string">&quot;,&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;name != null and name != &#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">            name = #&#123;name&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;age != null and age != &#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">            , age = #&#123;age&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;birthday != null and birthday != &#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">            , birthday = #&#123;birthday&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">trim</span>&gt;</span></span><br><span class="line">    where id = $&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在这里面使用到了trim、if等动态元素，可以根据条件来生成不同情况下的SQL；</p><p>在<code>DynamicSqlSource.getBoundSql</code>方法里，调用了<code>rootSqlNode.apply(context)</code>方法，<code>apply</code>方法是所有的动态节点都实现的接口：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SqlNode</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">apply</span><span class="params">(DynamicContext context)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于实现该<code>SqlSource</code>接口的所有节点，就是整个组合模式树的各个节点：</p><p><img src="https://cdn.jsdelivr.net/gh/cayzlh/git-img-repository@master/uPic/4eSz9o.jpg" alt="4eSz9o"></p><p>组合模式的简单之处在于，所有的子节点都是同一类节点，可以递归的向下执行，比如对于TextSqlNode，因为它是最底层的叶子节点，所以直接将对应的内容append到SQL语句中：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">apply</span><span class="params">(DynamicContext context)</span> </span>&#123;</span><br><span class="line">  GenericTokenParser parser = createParser(<span class="keyword">new</span> BindingTokenParser(context,</span><br><span class="line">                                                                  injectionFilter));</span><br><span class="line">  context.appendSql(parser.parse(text));</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是对于IfSqlNode，就需要先做判断，如果判断通过，仍然会调用子元素的SqlNode，即<code>contents.apply</code>方法，实现递归的解析。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">apply</span><span class="params">(DynamicContext context)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (evaluator.evaluateBoolean(test, context.getBindings())) &#123;</span><br><span class="line">        contents.apply(context);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h2><p>模板方法模式是所有模式中最为常见的几个模式之一，是基于继承的代码复用的基本技术。</p><p>模板方法模式需要开发抽象类和具体子类的设计师之间的协作。一个设计师负责给出一个算法的轮廓和骨架，另一些设计师则负责给出这个算法的各个逻辑步骤。代表这些具体逻辑步骤的方法称做基本方法(primitive method)；而将这些基本方法汇总起来的方法叫做模板方法(template method)，这个设计模式的名字就是从此而来。</p><p>模板类定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。</p><p><img src="https://cdn.jsdelivr.net/gh/cayzlh/git-img-repository@master/uPic/mPNlOa.jpg" alt="mPNlOa"></p><p>在Mybatis中，sqlSession的SQL执行，都是委托给Executor实现的，Executor包含以下结构：</p><p><img src="https://cdn.jsdelivr.net/gh/cayzlh/git-img-repository@master/uPic/dq9xXH.jpg" alt="dq9xXH"></p><p>其中的BaseExecutor就采用了模板方法模式，它实现了大部分的SQL执行逻辑，然后把以下几个方法交给子类定制化完成：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">apply</span><span class="params">(DynamicContext context)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (evaluator.evaluateBoolean(test, context.getBindings())) &#123;</span><br><span class="line">     contents.apply(context);</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>该模板方法类有几个子类的具体实现，使用了不同的策略：</p><ul><li>简单<code>SimpleExecutor</code>：每执行一次<code>update</code>或<code>select</code>，就开启一个<code>Statement</code>对象，用完立刻关闭<code>Statement</code>对象。（可以是<code>Statement</code>或<code>PrepareStatement</code>对象）</li><li>重用<code>ReuseExecutor</code>：执行<code>update</code>或<code>select</code>，以sql作为key查找<code>Statement</code>对象，存在就使用，不存在就创建，用完后，不关闭<code>Statement</code>对象，而是放置于<code>Map</code>内，供下一次使用。（可以是<code>Statement</code>或<code>PrepareStatement</code>对象）</li><li>批量<code>BatchExecutor</code>：执行update（没有select，JDBC批处理不支持select），将所有sql都添加到批处理中（<code>addBatch()</code>），等待统一执行（<code>executeBatch()</code>），它缓存了多个Statement对象，每个Statement对象都是<code>addBatch()</code>完毕后，等待逐一执行<code>executeBatch()</code>批处理的；<code>BatchExecutor</code>相当于维护了多个桶，每个桶里都装了很多属于自己的SQL，就像苹果蓝里装了很多苹果，番茄蓝里装了很多番茄，最后，再统一倒进仓库。（可以是Statement或PrepareStatement对象）</li></ul><p>比如在SimpleExecutor中这样实现update方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">doUpdate</span><span class="params">(MappedStatement ms, Object parameter)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    Statement stmt = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Configuration configuration = ms.getConfiguration();</span><br><span class="line">        StatementHandler handler = configuration.newStatementHandler(<span class="keyword">this</span>, ms, parameter, RowBounds.DEFAULT, <span class="keyword">null</span>,</span><br><span class="line">                <span class="keyword">null</span>);</span><br><span class="line">        stmt = prepareStatement(handler, ms.getStatementLog());</span><br><span class="line">        <span class="keyword">return</span> handler.update(stmt);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        closeStatement(stmt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><p>适配器模式(Adapter Pattern) ：将一个接口转换成客户希望的另一个接口，适配器模式使接口不兼容的那些类可以一起工作，其别名为包装器(Wrapper)。适配器模式既可以作为类结构型模式，也可以作为对象结构型模式。</p><p><img src="https://cdn.jsdelivr.net/gh/cayzlh/git-img-repository@master/uPic/rkEM6Y.jpg" alt="rkEM6Y"></p><p>在Mybatsi的logging包中，有一个Log接口：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Log</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isDebugEnabled</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isTraceEnabled</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">error</span><span class="params">(String s, Throwable e)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">error</span><span class="params">(String s)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">debug</span><span class="params">(String s)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">trace</span><span class="params">(String s)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">warn</span><span class="params">(String s)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该接口定义了Mybatis直接使用的日志方法，而Log接口具体由谁来实现呢？Mybatis提供了多种日志框架的实现，这些实现都匹配这个Log接口所定义的接口方法，最终实现了所有外部日志框架到Mybatis日志包的适配：</p><p><img src="https://cdn.jsdelivr.net/gh/cayzlh/git-img-repository@master/uPic/uVGQZ0.jpg" alt="uVGQZ0"></p><p>比如对于<code>Log4jImpl</code>的实现来说，该实现持有了<code>org.apache.log4j.Logger</code>的实例，然后所有的日志方法，均委托该实例来实现。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Log4jImpl</span> <span class="keyword">implements</span> <span class="title">Log</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String FQCN = Log4jImpl.class.getName();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Logger log;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Log4jImpl</span><span class="params">(String clazz)</span> </span>&#123;</span><br><span class="line">        log = Logger.getLogger(clazz);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isDebugEnabled</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> log.isDebugEnabled();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isTraceEnabled</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> log.isTraceEnabled();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">error</span><span class="params">(String s, Throwable e)</span> </span>&#123;</span><br><span class="line">        log.log(FQCN, Level.ERROR, s, e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">error</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        log.log(FQCN, Level.ERROR, s, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">debug</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        log.log(FQCN, Level.DEBUG, s, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">trace</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        log.log(FQCN, Level.TRACE, s, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">warn</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        log.log(FQCN, Level.WARN, s, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h2><p>装饰模式(Decorator Pattern) ：动态地给一个对象增加一些额外的职责(Responsibility)，就增加对象功能来说，装饰模式比生成子类实现更为灵活。其别名也可以称为包装器(Wrapper)，与适配器模式的别名相同，但它们适用于不同的场合。根据翻译的不同，装饰模式也有人称之为“油漆工模式”，它是一种对象结构型模式。</p><p><img src="https://cdn.jsdelivr.net/gh/cayzlh/git-img-repository@master/uPic/BdaHcM.jpg" alt="BdaHcM"></p><p>在mybatis中，缓存的功能由根接口<code>Cache（org.apache.ibatis.cache.Cache）</code>定义。整个体系采用装饰器设计模式，数据存储和缓存的基本功能由<code>PerpetualCache（org.apache.ibatis.cache.impl.PerpetualCache）</code>永久缓存实现，然后通过一系列的装饰器来对<code>PerpetualCache</code>永久缓存进行缓存策略等方便的控制。如下图：</p><p>用于装饰PerpetualCache的标准装饰器共有8个（全部在org.apache.ibatis.cache.decorators包中）：</p><ol><li><code>FifoCache</code>：先进先出算法，缓存回收策略</li><li><code>LoggingCache</code>：输出缓存命中的日志信息</li><li><code>LruCache</code>：最近最少使用算法，缓存回收策略</li><li><code>ScheduledCache</code>：调度缓存，负责定时清空缓存</li><li><code>SerializedCache</code>：缓存序列化和反序列化存储</li><li><code>SoftCache</code>：基于软引用实现的缓存管理策略</li><li><code>SynchronizedCache</code>：同步的缓存装饰器，用于防止多线程并发访问</li><li><code>WeakCache</code>：基于弱引用实现的缓存管理策略</li></ol><p>另外，还有一个特殊的装饰器<code>TransactionalCache</code>：事务性的缓存正如大多数持久层框架一样，mybatis缓存同样分为一级缓存和二级缓存</p><ul><li>一级缓存，又叫本地缓存，是<code>PerpetualCache</code>类型的永久缓存，保存在执行器中（<code>BaseExecutor</code>），而执行器又在<code>SqlSession</code>（<code>DefaultSqlSession</code>）中，所以一级缓存的生命周期与<code>SqlSession</code>是相同的。</li><li>二级缓存，又叫自定义缓存，实现了<code>Cache</code>接口的类都可以作为二级缓存，所以可配置如encache等的第三方缓存。二级缓存以namespace名称空间为其唯一标识，被保存在<code>Configuration</code>核心配置对象中。</li></ul><p>二级缓存对象的默认类型为PerpetualCache，如果配置的缓存是默认类型，则mybatis会根据配置自动追加一系列装饰器。</p><p>Cache对象之间的引用顺序为：</p><p><code>SynchronizedCache</code>–&gt;<code>LoggingCache</code>–&gt;<code>SerializedCache</code>–&gt;<code>ScheduledCache</code>–&gt;<code>LruCache</code>–&gt;<code>PerpetualCache</code></p><h2 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h2><p>迭代器（Iterator）模式，又叫做游标（Cursor）模式。GOF给出的定义为：提供一种方法访问一个容器（container）对象中各个元素，而又不需暴露该对象的内部细节。</p><p><img src="https://cdn.jsdelivr.net/gh/cayzlh/git-img-repository@master/uPic/49UcwT.jpg" alt="49UcwT"></p><p>Java的<code>Iterator</code>就是迭代器模式的接口，只要实现了该接口，就相当于应用了迭代器模式：</p><p><img src="https://cdn.jsdelivr.net/gh/cayzlh/git-img-repository@master/uPic/dsNpxb.jpg" alt="dsNpxb"></p><p>比如Mybatis的<code>PropertyTokenizer</code>是property包中的重量级类，该类会被reflection包中其他的类频繁的引用到。这个类实现了<code>Iterator</code>接口，在使用时经常被用到的是<code>Iterator</code>接口中的<code>hasNext</code>这个函数。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PropertyTokenizer</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">PropertyTokenizer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String indexedName;</span><br><span class="line">    <span class="keyword">private</span> String index;</span><br><span class="line">    <span class="keyword">private</span> String children;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PropertyTokenizer</span><span class="params">(String fullname)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> delim = fullname.indexOf(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span> (delim &gt; -<span class="number">1</span>) &#123;</span><br><span class="line">            name = fullname.substring(<span class="number">0</span>, delim);</span><br><span class="line">            children = fullname.substring(delim + <span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            name = fullname;</span><br><span class="line">            children = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        indexedName = name;</span><br><span class="line">        delim = name.indexOf(<span class="string">&#x27;[&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span> (delim &gt; -<span class="number">1</span>) &#123;</span><br><span class="line">            index = name.substring(delim + <span class="number">1</span>, name.length() - <span class="number">1</span>);</span><br><span class="line">            name = name.substring(<span class="number">0</span>, delim);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getIndexedName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> indexedName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getChildren</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> children;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> children != <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PropertyTokenizer <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PropertyTokenizer(children);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(</span><br><span class="line">                <span class="string">&quot;Remove is not supported, as it has no meaning in the context of properties.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，这个类传入一个字符串到构造函数，然后提供了iterator方法对解析后的子串进行遍历，是一个很常用的方法类。</p><p><strong>参考资料</strong></p><ul><li><a href="http://design-patterns.readthedocs.io/zh_CN/latest/index.html">图说设计模式</a></li><li><a href="http://www.cnblogs.com/dongying/p/4142476.html">深入浅出Mybatis系列（十）—SQL执行流程分析（源码篇）</a></li><li><a href="http://www.cnblogs.com/chenssy/p/3299719.html">设计模式读书笔记—–组合模式</a></li><li><a href="http://blog.csdn.net/wagcy/article/details/32963235">Mybatis3.3.x技术内幕（四）：五鼠闹东京之执行器Executor设计原本</a></li><li><a href="https://my.oschina.net/lixin91/blog/620068">mybatis缓存机制详解（一）——Cache</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
          <category> MyBatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 转载 </tag>
            
            <tag> 设计模式 </tag>
            
            <tag> MyBatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring AOP和Spring Transaction源码资料整理</title>
      <link href="/blog/2020/01/27/9cf21717.html"/>
      <url>/blog/2020/01/27/9cf21717.html</url>
      
        <content type="html"><![CDATA[<h2 id="前置"><a href="#前置" class="headerlink" title="前置"></a>前置</h2><p>前面学习了Spring AOP的源码，接下来准备看AOP相关源码。Spring AOP基于Spring IOC机制。</p><p>在学习完Spring AOP之后可以继续看看Spring Transaction源码。</p><h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><h3 id="Spring-AOP"><a href="#Spring-AOP" class="headerlink" title="Spring AOP"></a>Spring AOP</h3><p>通过调试 <code>org.springframework.aop.aspectj.autoproxy.AspectJAutoProxyCreatorTests</code> 这个单元测试里的方法，来跟源码。</p><h3 id="Spring-Transaction"><a href="#Spring-Transaction" class="headerlink" title="Spring Transaction"></a>Spring Transaction</h3><ul><li><p>调试 <code>&lt;tx:advice /&gt;</code> 标签的解析的流程</p><p>可调试 <code>org.springframework.transaction.TxNamespaceHandlerTests</code> 这个单元测试里的方法。</p><ul><li><code>#invokeTransactional()</code> 方法，提交事务。</li><li><code>#rollbackRules()</code> 方法，回滚事务。</li></ul></li><li><p>调试 <code>@Transactional</code> 注解的解析的流程</p><p>使用的还是 <code>org.springframework.transaction.TxNamespaceHandlerTests</code> 这个单元测试里的方法</p></li></ul><h2 id="资料整理"><a href="#资料整理" class="headerlink" title="资料整理"></a>资料整理</h2><h3 id="Spring-AOP-1"><a href="#Spring-AOP-1" class="headerlink" title="Spring AOP"></a>Spring AOP</h3><ul><li><a href="https://book.douban.com/subject/30452948/">Spring 源码深度解析(第2版)</a> - AOP部分</li><li><a href="https://www.cnblogs.com/xrq730/p/6753160.html">《【Spring源码分析】AOP源码解析（上篇）》</a> ，对 Spring AOP XML 配置的方式进行源码解析。</li><li><a href="https://www.cnblogs.com/xrq730/p/6757608.html">《【Spring源码分析】AOP源码解析（下篇）》</a> ，和<a href="https://book.douban.com/subject/30452948/">Spring 源码深度解析(第2版)</a> 的内容相互补充</li></ul><h3 id="Spring-Transaction-1"><a href="#Spring-Transaction-1" class="headerlink" title="Spring Transaction"></a>Spring Transaction</h3><ul><li><a href="https://book.douban.com/subject/30452948/">Spring 源码深度解析(第2版)</a> - 事务相关部分</li><li><a href="http://www.linkedkeeper.com/1045.html">《原创 Spring 源码解析之事务篇》</a></li><li><a href="http://www.baowenwei.com/post/spring/spring-shi-wu-de-yuan-ma-fen-xi-qi">《Spring-事务的源码分析（七）》</a></li><li><a href="https://juejin.im/post/5b00c52ef265da0b95276091">《可能是最漂亮的 Spring 事务管理详解》</a></li></ul><h2 id="后置"><a href="#后置" class="headerlink" title="后置"></a>后置</h2><p><code>Spring MVC</code></p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
          <category> 《Spring源码分析》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> 源码学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>4张图带你读懂Spring IOC的世界</title>
      <link href="/blog/2020/01/26/101fc769.html"/>
      <url>/blog/2020/01/26/101fc769.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文作者：chenssy</p><p>出处：<a href="http://cmsblogs.com/?p=4045">http://cmsblogs.com/?p=4045</a></p><p>在学习<code>Spring源码</code>的过程中发现的好站+好贴，原创不易感谢作者。</p><p>Spring版本：<strong>Spring 5.0.6.RELEASE</strong></p></blockquote><h2 id="bean-的转换过程"><a href="#bean-的转换过程" class="headerlink" title="bean 的转换过程"></a>bean 的转换过程</h2><p>下面这张图演示了一个可用的<code>bean</code>是如何从<code>xml</code>配置文件中演变过来的.</p><p><img src="https://cdn.jsdelivr.net/gh/cayzlh/git-img-repository@master/2020/05/28/spring-201901311001_BJamFt.jpg" alt="img"></p><h2 id="ApplicationContext-的架构图"><a href="#ApplicationContext-的架构图" class="headerlink" title="ApplicationContext 的架构图"></a>ApplicationContext 的架构图</h2><p><img src="https://cdn.jsdelivr.net/gh/cayzlh/git-img-repository@master/2020/05/28/spring-201901311002-20200528151019732_6Qhaoy.jpg" alt="img"></p><h2 id="loadBean-的全流程"><a href="#loadBean-的全流程" class="headerlink" title="loadBean 的全流程"></a>loadBean 的全流程</h2><p><img src="https://cdn.jsdelivr.net/gh/cayzlh/git-img-repository@master/2020/05/28/spring-201901311003-20200528151032304_XtJJ2j.jpg" alt="img"></p><h2 id="getBean-的全流程"><a href="#getBean-的全流程" class="headerlink" title="getBean 的全流程"></a>getBean 的全流程</h2><p><img src="https://cdn.jsdelivr.net/gh/cayzlh/git-img-repository@master/2020/05/28/spring-201901311004_y7TnNL.jpg" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
          <category> 《Spring源码分析》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> 死磕Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入分析ApplicationContext的refresh()</title>
      <link href="/blog/2020/01/26/ea3a33da.html"/>
      <url>/blog/2020/01/26/ea3a33da.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文作者：chenssy</p><p>出处：<a href="http://cmsblogs.com/?p=4043">http://cmsblogs.com/?p=4043</a></p><p>在学习<code>Spring源码</code>的过程中发现的好站+好贴，原创不易感谢作者。</p><p>Spring版本：<strong>Spring 5.0.6.RELEASE</strong></p></blockquote><p>上篇博客对 ApplicationContext 相关的接口做了一个简单的介绍，作为一个高富帅级别的 Spring 容器，它涉及的方法实在是太多了，全部介绍是不可能的，而且大部分功能都已经在前面系列博客中做了详细的介绍，所以这篇博问介绍 ApplicationContext 最重要的方法（小编认为的） ：<code>refresh()</code>。</p><p><code>refresh()</code> 是定义在 ConfigurableApplicationContext 类中的，如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Load or refresh the persistent representation of the configuration,</span></span><br><span class="line"><span class="comment"> * which might an XML file, properties file, or relational database schema.</span></span><br><span class="line"><span class="comment"> * As this is a startup method, it should destroy already created singletons</span></span><br><span class="line"><span class="comment"> * if it fails, to avoid dangling resources. In other words, after invocation</span></span><br><span class="line"><span class="comment"> * of that method, either all or no singletons at all should be instantiated.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> BeansException if the bean factory could not be initialized</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalStateException if already initialized and multiple refresh</span></span><br><span class="line"><span class="comment"> * attempts are not supported</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException</span>;</span><br></pre></td></tr></table></figure><p>作用就是：<strong>刷新 Spring 的应用上下文</strong>。其实现是在 AbstractApplicationContext 中实现。如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException </span>&#123;</span><br><span class="line">  <span class="keyword">synchronized</span> (<span class="keyword">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line">    <span class="comment">// 准备刷新上下文环境</span></span><br><span class="line">    prepareRefresh();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建并初始化 BeanFactory</span></span><br><span class="line">    ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 填充BeanFactory功能</span></span><br><span class="line">    prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 提供子类覆盖的额外处理，即子类处理自定义的BeanFactoryPostProcess</span></span><br><span class="line">      postProcessBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 激活各种BeanFactory处理器</span></span><br><span class="line">      invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 注册拦截Bean创建的Bean处理器，即注册 BeanPostProcessor</span></span><br><span class="line">      registerBeanPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 初始化上下文中的资源文件，如国际化文件的处理等</span></span><br><span class="line">      initMessageSource();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 初始化上下文事件广播器</span></span><br><span class="line">      initApplicationEventMulticaster();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 给子类扩展初始化其他Bean</span></span><br><span class="line">      onRefresh();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 在所有bean中查找listener bean，然后注册到广播器中</span></span><br><span class="line">      registerListeners();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 初始化剩下的单例Bean(非延迟加载的)</span></span><br><span class="line">      finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 完成刷新过程,通知生命周期处理器lifecycleProcessor刷新过程,同时发出ContextRefreshEvent通知别人</span></span><br><span class="line">      finishRefresh();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">      <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">        logger.warn(<span class="string">&quot;Exception encountered during context initialization - &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;cancelling refresh attempt: &quot;</span> + ex);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//  销毁已经创建的Bean</span></span><br><span class="line">      destroyBeans();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 重置容器激活标签</span></span><br><span class="line">      cancelRefresh(ex);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 抛出异常</span></span><br><span class="line">      <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="comment">// Reset common introspection caches in Spring&#x27;s core, since we</span></span><br><span class="line">      <span class="comment">// might not ever need metadata for singleton beans anymore...</span></span><br><span class="line">      resetCommonCaches();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里每一个方法都非常重要，需要一个一个地解释说明。</p><h2 id="prepareRefresh"><a href="#prepareRefresh" class="headerlink" title="prepareRefresh()"></a>prepareRefresh()</h2><blockquote><p>初始化上下文环境，对系统的环境变量或者系统属性进行准备和校验,如环境变量中必须设置某个值才能运行，否则不能运行，这个时候可以在这里加这个校验，重写initPropertySources方法就好了</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">prepareRefresh</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 设置启动日期</span></span><br><span class="line">  <span class="keyword">this</span>.startupDate = System.currentTimeMillis();</span><br><span class="line">  <span class="comment">// 设置 context 当前状态</span></span><br><span class="line">  <span class="keyword">this</span>.closed.set(<span class="keyword">false</span>);</span><br><span class="line">  <span class="keyword">this</span>.active.set(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">    logger.info(<span class="string">&quot;Refreshing &quot;</span> + <span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 初始化context environment（上下文环境）中的占位符属性来源</span></span><br><span class="line">  initPropertySources();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 对属性进行必要的验证</span></span><br><span class="line">  getEnvironment().validateRequiredProperties();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.earlyApplicationEvents = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法主要是做一些准备工作，如：</p><ol><li>设置 context 启动时间</li><li>设置 context 的当前状态</li><li>初始化 context environment 中占位符</li><li>对属性进行必要的验证</li></ol><h2 id="obtainFreshBeanFactory"><a href="#obtainFreshBeanFactory" class="headerlink" title="obtainFreshBeanFactory()"></a>obtainFreshBeanFactory()</h2><blockquote><p>创建并初始化 BeanFactory</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> ConfigurableListableBeanFactory <span class="title">obtainFreshBeanFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 刷新 BeanFactory</span></span><br><span class="line">  refreshBeanFactory();</span><br><span class="line">  <span class="comment">// 获取 BeanFactory</span></span><br><span class="line">  ConfigurableListableBeanFactory beanFactory = getBeanFactory();</span><br><span class="line">  <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">    logger.debug(<span class="string">&quot;Bean factory for &quot;</span> + getDisplayName() + <span class="string">&quot;: &quot;</span> + beanFactory);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> beanFactory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>核心方法就在 <code>refreshBeanFactory()</code> ，该方法的核心任务就是创建 BeanFactory 并对其就行一番初始化。如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">refreshBeanFactory</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (hasBeanFactory()) &#123;</span><br><span class="line">    destroyBeans();</span><br><span class="line">    closeBeanFactory();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    DefaultListableBeanFactory beanFactory = createBeanFactory();</span><br><span class="line">    beanFactory.setSerializationId(getId());</span><br><span class="line">    customizeBeanFactory(beanFactory);</span><br><span class="line">    loadBeanDefinitions(beanFactory);</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>.beanFactoryMonitor) &#123;</span><br><span class="line">      <span class="keyword">this</span>.beanFactory = beanFactory;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ApplicationContextException(<span class="string">&quot;I/O error parsing bean definition source for &quot;</span> + getDisplayName(), ex);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>判断当前容器是否存在一个 BeanFactory，如果存在则对其进行销毁和关闭</li><li>调用 <code>createBeanFactory()</code> 创建一个 BeanFactory 实例，其实就是 DefaultListableBeanFactory</li><li>自定义 BeanFactory</li><li>加载 BeanDefinition</li><li>将创建好的 bean 工厂的引用交给的 context 来管理</li></ol><p>上面 5 个步骤，都是比较简单的，但是有必要讲解下第 4 步：加载 BeanDefinition。如果各位看过 【死磕 Spring】系列的话，在刚刚开始分析源码的时候，小编就是以 <code>loadBeanDefinitions()</code> 为入口来分析的，如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ClassPathResource resource = <span class="keyword">new</span> ClassPathResource(<span class="string">&quot;bean.xml&quot;</span>);</span><br><span class="line">DefaultListableBeanFactory factory = <span class="keyword">new</span> DefaultListableBeanFactory();</span><br><span class="line">XmlBeanDefinitionReader reader = <span class="keyword">new</span> XmlBeanDefinitionReader(factory);</span><br><span class="line">reader.loadBeanDefinitions(resource);</span><br></pre></td></tr></table></figure><p>只不过这段代码的 <code>loadBeanDefinitions()</code> 是定义在 BeanDefinitionReader 中，而此处的 <code>loadBeanDefinitions()</code> 则是定义在 AbstractRefreshableApplicationContext 中，如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">loadBeanDefinitions</span><span class="params">(DefaultListableBeanFactory beanFactory)</span></span></span><br><span class="line"><span class="function">  <span class="keyword">throws</span> BeansException, IOException</span></span><br></pre></td></tr></table></figure><p>由具体的子类实现，我们以 AbstractXmlApplicationContext 为例，实现如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">loadBeanDefinitions</span><span class="params">(DefaultListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException, IOException </span>&#123;</span><br><span class="line">  <span class="comment">// Create a new XmlBeanDefinitionReader for the given BeanFactory.</span></span><br><span class="line">  XmlBeanDefinitionReader beanDefinitionReader = <span class="keyword">new</span> XmlBeanDefinitionReader(beanFactory);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Configure the bean definition reader with this context&#x27;s</span></span><br><span class="line">  <span class="comment">// resource loading environment.</span></span><br><span class="line">  beanDefinitionReader.setEnvironment(<span class="keyword">this</span>.getEnvironment());</span><br><span class="line">  beanDefinitionReader.setResourceLoader(<span class="keyword">this</span>);</span><br><span class="line">  beanDefinitionReader.setEntityResolver(<span class="keyword">new</span> ResourceEntityResolver(<span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Allow a subclass to provide custom initialization of the reader,</span></span><br><span class="line">  <span class="comment">// then proceed with actually loading the bean definitions.</span></span><br><span class="line">  initBeanDefinitionReader(beanDefinitionReader);</span><br><span class="line">  loadBeanDefinitions(beanDefinitionReader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新建 XmlBeanDefinitionReader 实例对象 beanDefinitionReader，调用 <code>initBeanDefinitionReader()</code> 对其进行初始化，然后调用 <code>loadBeanDefinitions()</code> 加载 BeanDefinition。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">loadBeanDefinitions</span><span class="params">(XmlBeanDefinitionReader reader)</span> <span class="keyword">throws</span> BeansException, IOException </span>&#123;</span><br><span class="line">  Resource[] configResources = getConfigResources();</span><br><span class="line">  <span class="keyword">if</span> (configResources != <span class="keyword">null</span>) &#123;</span><br><span class="line">    reader.loadBeanDefinitions(configResources);</span><br><span class="line">  &#125;</span><br><span class="line">  String[] configLocations = getConfigLocations();</span><br><span class="line">  <span class="keyword">if</span> (configLocations != <span class="keyword">null</span>) &#123;</span><br><span class="line">    reader.loadBeanDefinitions(configLocations);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里我们发现，其实内部依然是调用 <code>BeanDefinitionReader#loadBeanDefinitionn()</code> 进行 BeanDefinition 的加载进程。</p><h2 id="prepareBeanFactory-beanFactory"><a href="#prepareBeanFactory-beanFactory" class="headerlink" title="prepareBeanFactory(beanFactory)"></a>prepareBeanFactory(beanFactory)</h2><blockquote><p>填充 BeanFactory 功能</p></blockquote><p>上面获取获取的 BeanFactory 除了加载了一些 BeanDefinition 就没有其他任何东西了，这个时候其实还不能投入生产，因为还少配置了一些东西，比如 context的 ClassLoader 和 后置处理器等等。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">prepareBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 设置beanFactory的classLoader</span></span><br><span class="line">  beanFactory.setBeanClassLoader(getClassLoader());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置beanFactory的表达式语言处理器,Spring3开始增加了对语言表达式的支持,默认可以使用#&#123;bean.xxx&#125;的形式来调用相关属性值</span></span><br><span class="line">  beanFactory.setBeanExpressionResolver(<span class="keyword">new</span> StandardBeanExpressionResolver(beanFactory.getBeanClassLoader()));</span><br><span class="line">  <span class="comment">// 为beanFactory增加一个默认的propertyEditor</span></span><br><span class="line">  beanFactory.addPropertyEditorRegistrar(<span class="keyword">new</span> ResourceEditorRegistrar(<span class="keyword">this</span>, getEnvironment()));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 添加ApplicationContextAwareProcessor</span></span><br><span class="line">  beanFactory.addBeanPostProcessor(<span class="keyword">new</span> ApplicationContextAwareProcessor(<span class="keyword">this</span>));</span><br><span class="line">  <span class="comment">// 设置忽略自动装配的接口</span></span><br><span class="line">  beanFactory.ignoreDependencyInterface(EnvironmentAware.class);</span><br><span class="line">  beanFactory.ignoreDependencyInterface(EmbeddedValueResolverAware.class);</span><br><span class="line">  beanFactory.ignoreDependencyInterface(ResourceLoaderAware.class);</span><br><span class="line">  beanFactory.ignoreDependencyInterface(ApplicationEventPublisherAware.class);</span><br><span class="line">  beanFactory.ignoreDependencyInterface(MessageSourceAware.class);</span><br><span class="line">  beanFactory.ignoreDependencyInterface(ApplicationContextAware.class);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置几个自动装配的特殊规则</span></span><br><span class="line">  beanFactory.registerResolvableDependency(BeanFactory.class, beanFactory);</span><br><span class="line">  beanFactory.registerResolvableDependency(ResourceLoader.class, <span class="keyword">this</span>);</span><br><span class="line">  beanFactory.registerResolvableDependency(ApplicationEventPublisher.class, <span class="keyword">this</span>);</span><br><span class="line">  beanFactory.registerResolvableDependency(ApplicationContext.class, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Register early post-processor for detecting inner beans as ApplicationListeners.</span></span><br><span class="line">  beanFactory.addBeanPostProcessor(<span class="keyword">new</span> ApplicationListenerDetector(<span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 增加对AspectJ的支持</span></span><br><span class="line">  <span class="keyword">if</span> (beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) &#123;</span><br><span class="line">    beanFactory.addBeanPostProcessor(<span class="keyword">new</span> LoadTimeWeaverAwareProcessor(beanFactory));</span><br><span class="line">    <span class="comment">// Set a temporary ClassLoader for type matching.</span></span><br><span class="line">    beanFactory.setTempClassLoader(<span class="keyword">new</span> ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 注册默认的系统环境bean</span></span><br><span class="line">  <span class="keyword">if</span> (!beanFactory.containsLocalBean(ENVIRONMENT_BEAN_NAME)) &#123;</span><br><span class="line">    beanFactory.registerSingleton(ENVIRONMENT_BEAN_NAME, getEnvironment());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!beanFactory.containsLocalBean(SYSTEM_PROPERTIES_BEAN_NAME)) &#123;</span><br><span class="line">    beanFactory.registerSingleton(SYSTEM_PROPERTIES_BEAN_NAME, getEnvironment().getSystemProperties());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!beanFactory.containsLocalBean(SYSTEM_ENVIRONMENT_BEAN_NAME)) &#123;</span><br><span class="line">    beanFactory.registerSingleton(SYSTEM_ENVIRONMENT_BEAN_NAME, getEnvironment().getSystemEnvironment());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看上面的源码知道这个就是对 BeanFactory 设置各种各种的功能。</p><h2 id="postProcessBeanFactory"><a href="#postProcessBeanFactory" class="headerlink" title="postProcessBeanFactory()"></a>postProcessBeanFactory()</h2><blockquote><p>提供子类覆盖的额外处理，即子类处理自定义的BeanFactoryPostProcess</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">  beanFactory.addBeanPostProcessor(<span class="keyword">new</span> ServletContextAwareProcessor(<span class="keyword">this</span>.servletContext, <span class="keyword">this</span>.servletConfig));</span><br><span class="line">  beanFactory.ignoreDependencyInterface(ServletContextAware.class);</span><br><span class="line">  beanFactory.ignoreDependencyInterface(ServletConfigAware.class);</span><br><span class="line"></span><br><span class="line">  WebApplicationContextUtils.registerWebApplicationScopes(beanFactory, <span class="keyword">this</span>.servletContext);</span><br><span class="line">  WebApplicationContextUtils.registerEnvironmentBeans(beanFactory, <span class="keyword">this</span>.servletContext, <span class="keyword">this</span>.servletConfig);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>添加 ServletContextAwareProcessor 到 BeanFactory 容器中，该 processor 实现 BeanPostProcessor 接口，主要用于将ServletContext 传递给实现了 ServletContextAware 接口的 bean</li><li>忽略 ServletContextAware、ServletConfigAware</li><li>注册 WEB 应用特定的域（scope）到 beanFactory 中，以便 WebApplicationContext 可以使用它们。比如 “request” , “session” , “globalSession” , “application”</li><li>注册 WEB 应用特定的 Environment bean 到 beanFactory 中，以便WebApplicationContext 可以使用它们。如：”contextParameters”, “contextAttributes”</li></ol><h2 id="invokeBeanFactoryPostProcessors"><a href="#invokeBeanFactoryPostProcessors" class="headerlink" title="invokeBeanFactoryPostProcessors()"></a>invokeBeanFactoryPostProcessors()</h2><blockquote><p>激活各种BeanFactory处理器</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">invokeBeanFactoryPostProcessors</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  ConfigurableListableBeanFactory beanFactory, List&lt;BeanFactoryPostProcessor&gt; beanFactoryPostProcessors)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 定义一个 set 保存所有的 BeanFactoryPostProcessors</span></span><br><span class="line">  Set&lt;String&gt; processedBeans = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果当前 BeanFactory 为 BeanDefinitionRegistry</span></span><br><span class="line">  <span class="keyword">if</span> (beanFactory <span class="keyword">instanceof</span> BeanDefinitionRegistry) &#123;</span><br><span class="line">    BeanDefinitionRegistry registry = (BeanDefinitionRegistry) beanFactory;</span><br><span class="line">    <span class="comment">// BeanFactoryPostProcessor 集合</span></span><br><span class="line">    List&lt;BeanFactoryPostProcessor&gt; regularPostProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">// BeanDefinitionRegistryPostProcessor 集合</span></span><br><span class="line">    List&lt;BeanDefinitionRegistryPostProcessor&gt; registryProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 迭代注册的 beanFactoryPostProcessors</span></span><br><span class="line">    <span class="keyword">for</span> (BeanFactoryPostProcessor postProcessor : beanFactoryPostProcessors) &#123;</span><br><span class="line">      <span class="comment">// 如果是 BeanDefinitionRegistryPostProcessor，则调用 postProcessBeanDefinitionRegistry 进行注册，</span></span><br><span class="line">      <span class="comment">// 同时加入到 registryProcessors 集合中</span></span><br><span class="line">      <span class="keyword">if</span> (postProcessor <span class="keyword">instanceof</span> BeanDefinitionRegistryPostProcessor) &#123;</span><br><span class="line">        BeanDefinitionRegistryPostProcessor registryProcessor =</span><br><span class="line">          (BeanDefinitionRegistryPostProcessor) postProcessor;</span><br><span class="line">        registryProcessor.postProcessBeanDefinitionRegistry(registry);</span><br><span class="line">        registryProcessors.add(registryProcessor);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 否则当做普通的 BeanFactoryPostProcessor 处理</span></span><br><span class="line">        <span class="comment">// 添加到 regularPostProcessors 集合中即可，便于后面做后续处理</span></span><br><span class="line">        regularPostProcessors.add(postProcessor);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用于保存当前处理的 BeanDefinitionRegistryPostProcessor</span></span><br><span class="line">    List&lt;BeanDefinitionRegistryPostProcessor&gt; currentRegistryProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 首先处理实现了 PriorityOrdered (有限排序接口)的 BeanDefinitionRegistryPostProcessor</span></span><br><span class="line">    String[] postProcessorNames =</span><br><span class="line">      beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class="line">      <span class="keyword">if</span> (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) &#123;</span><br><span class="line">        currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));</span><br><span class="line">        processedBeans.add(ppName);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 排序</span></span><br><span class="line">    sortPostProcessors(currentRegistryProcessors, beanFactory);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加入registryProcessors集合</span></span><br><span class="line">    registryProcessors.addAll(currentRegistryProcessors);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用所有实现了 PriorityOrdered 的 BeanDefinitionRegistryPostProcessors 的 postProcessBeanDefinitionRegistry()</span></span><br><span class="line">    invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清空，以备下次使用</span></span><br><span class="line">    currentRegistryProcessors.clear();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其次，调用是实现了 Ordered（普通排序接口）的 BeanDefinitionRegistryPostProcessors</span></span><br><span class="line">    <span class="comment">// 逻辑和 上面一样</span></span><br><span class="line">    postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!processedBeans.contains(ppName) &amp;&amp; beanFactory.isTypeMatch(ppName, Ordered.class)) &#123;</span><br><span class="line">        currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));</span><br><span class="line">        processedBeans.add(ppName);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sortPostProcessors(currentRegistryProcessors, beanFactory);</span><br><span class="line">    registryProcessors.addAll(currentRegistryProcessors);</span><br><span class="line">    invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);</span><br><span class="line">    currentRegistryProcessors.clear();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最后调用其他的 BeanDefinitionRegistryPostProcessors</span></span><br><span class="line">    <span class="keyword">boolean</span> reiterate = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">while</span> (reiterate) &#123;</span><br><span class="line">      reiterate = <span class="keyword">false</span>;</span><br><span class="line">      <span class="comment">// 获取 BeanDefinitionRegistryPostProcessor</span></span><br><span class="line">      postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line">      <span class="keyword">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 没有包含在 processedBeans 中的（因为包含了的都已经处理了）</span></span><br><span class="line">        <span class="keyword">if</span> (!processedBeans.contains(ppName)) &#123;</span><br><span class="line">          currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));</span><br><span class="line">          processedBeans.add(ppName);</span><br><span class="line">          reiterate = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 与上面处理逻辑一致</span></span><br><span class="line">      sortPostProcessors(currentRegistryProcessors, beanFactory);</span><br><span class="line">      registryProcessors.addAll(currentRegistryProcessors);</span><br><span class="line">      invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);</span><br><span class="line">      currentRegistryProcessors.clear();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用所有 BeanDefinitionRegistryPostProcessor (包括手动注册和通过配置文件注册)</span></span><br><span class="line">    <span class="comment">// 和 BeanFactoryPostProcessor(只有手动注册)的回调函数(postProcessBeanFactory())</span></span><br><span class="line">    invokeBeanFactoryPostProcessors(registryProcessors, beanFactory);</span><br><span class="line">    invokeBeanFactoryPostProcessors(regularPostProcessors, beanFactory);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 如果不是 BeanDefinitionRegistry 只需要调用其回调函数（postProcessBeanFactory()）即可</span></span><br><span class="line">    invokeBeanFactoryPostProcessors(beanFactoryPostProcessors, beanFactory);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  String[] postProcessorNames =</span><br><span class="line">    beanFactory.getBeanNamesForType(BeanFactoryPostProcessor.class, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这里同样需要区分 PriorityOrdered 、Ordered 和 no Ordered</span></span><br><span class="line">  List&lt;BeanFactoryPostProcessor&gt; priorityOrderedPostProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  List&lt;String&gt; orderedPostProcessorNames = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  List&lt;String&gt; nonOrderedPostProcessorNames = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  <span class="keyword">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class="line">    <span class="comment">// 已经处理过了的，跳过</span></span><br><span class="line">    <span class="keyword">if</span> (processedBeans.contains(ppName)) &#123;</span><br><span class="line">      <span class="comment">// skip - already processed in first phase above</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// PriorityOrdered</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) &#123;</span><br><span class="line">      priorityOrderedPostProcessors.add(beanFactory.getBean(ppName, BeanFactoryPostProcessor.class));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Ordered</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (beanFactory.isTypeMatch(ppName, Ordered.class)) &#123;</span><br><span class="line">      orderedPostProcessorNames.add(ppName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// no Ordered</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      nonOrderedPostProcessorNames.add(ppName);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// First, PriorityOrdered 接口</span></span><br><span class="line">  sortPostProcessors(priorityOrderedPostProcessors, beanFactory);</span><br><span class="line">  invokeBeanFactoryPostProcessors(priorityOrderedPostProcessors, beanFactory);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Next, Ordered 接口</span></span><br><span class="line">  List&lt;BeanFactoryPostProcessor&gt; orderedPostProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  <span class="keyword">for</span> (String postProcessorName : orderedPostProcessorNames) &#123;</span><br><span class="line">    orderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class));</span><br><span class="line">  &#125;</span><br><span class="line">  sortPostProcessors(orderedPostProcessors, beanFactory);</span><br><span class="line">  invokeBeanFactoryPostProcessors(orderedPostProcessors, beanFactory);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Finally, no ordered</span></span><br><span class="line">  List&lt;BeanFactoryPostProcessor&gt; nonOrderedPostProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  <span class="keyword">for</span> (String postProcessorName : nonOrderedPostProcessorNames) &#123;</span><br><span class="line">    nonOrderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class));</span><br><span class="line">  &#125;</span><br><span class="line">  invokeBeanFactoryPostProcessors(nonOrderedPostProcessors, beanFactory);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Clear cached merged bean definitions since the post-processors might have</span></span><br><span class="line">  <span class="comment">// modified the original metadata, e.g. replacing placeholders in values...</span></span><br><span class="line">  beanFactory.clearMetadataCache();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码较长，但是处理逻辑较为单一，就是对所有的 BeanDefinitionRegistryPostProcessors 、手动注册的 BeanFactoryPostProcessor 以及通过配置文件方式的 BeanFactoryPostProcessor 按照 PriorityOrdered 、 Ordered、no ordered 三种方式分开处理、调用。</p><h2 id="registerBeanPostProcessors"><a href="#registerBeanPostProcessors" class="headerlink" title="registerBeanPostProcessors"></a>registerBeanPostProcessors</h2><blockquote><p>注册拦截Bean创建的Bean处理器，即注册 BeanPostProcessor</p></blockquote><p>与 BeanFactoryPostProcessor 一样，也是委托给 PostProcessorRegistrationDelegate 来实现的。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerBeanPostProcessors</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  ConfigurableListableBeanFactory beanFactory, AbstractApplicationContext applicationContext)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 所有的 BeanPostProcessors</span></span><br><span class="line">  String[] postProcessorNames = beanFactory.getBeanNamesForType(BeanPostProcessor.class, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 注册 BeanPostProcessorChecker</span></span><br><span class="line">  <span class="comment">// 主要用于记录一些 bean 的信息，这些 bean 不符合所有 BeanPostProcessors 处理的资格时</span></span><br><span class="line">  <span class="keyword">int</span> beanProcessorTargetCount = beanFactory.getBeanPostProcessorCount() + <span class="number">1</span> + postProcessorNames.length;</span><br><span class="line">  beanFactory.addBeanPostProcessor(<span class="keyword">new</span> BeanPostProcessorChecker(beanFactory, beanProcessorTargetCount));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 区分 PriorityOrdered、Ordered 、 no ordered</span></span><br><span class="line">  List&lt;BeanPostProcessor&gt; priorityOrderedPostProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  List&lt;String&gt; orderedPostProcessorNames = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  List&lt;String&gt; nonOrderedPostProcessorNames = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  <span class="comment">// MergedBeanDefinition</span></span><br><span class="line">  List&lt;BeanPostProcessor&gt; internalPostProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  <span class="keyword">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class="line">    <span class="keyword">if</span> (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) &#123;</span><br><span class="line">      BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);</span><br><span class="line">      priorityOrderedPostProcessors.add(pp);</span><br><span class="line">      <span class="keyword">if</span> (pp <span class="keyword">instanceof</span> MergedBeanDefinitionPostProcessor) &#123;</span><br><span class="line">        internalPostProcessors.add(pp);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (beanFactory.isTypeMatch(ppName, Ordered.class)) &#123;</span><br><span class="line">      orderedPostProcessorNames.add(ppName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      nonOrderedPostProcessorNames.add(ppName);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// First, PriorityOrdered</span></span><br><span class="line">  sortPostProcessors(priorityOrderedPostProcessors, beanFactory);</span><br><span class="line">  registerBeanPostProcessors(beanFactory, priorityOrderedPostProcessors);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Next, Ordered</span></span><br><span class="line">  List&lt;BeanPostProcessor&gt; orderedPostProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  <span class="keyword">for</span> (String ppName : orderedPostProcessorNames) &#123;</span><br><span class="line">    BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);</span><br><span class="line">    orderedPostProcessors.add(pp);</span><br><span class="line">    <span class="keyword">if</span> (pp <span class="keyword">instanceof</span> MergedBeanDefinitionPostProcessor) &#123;</span><br><span class="line">      internalPostProcessors.add(pp);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  sortPostProcessors(orderedPostProcessors, beanFactory);</span><br><span class="line">  registerBeanPostProcessors(beanFactory, orderedPostProcessors);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// onOrdered</span></span><br><span class="line">  List&lt;BeanPostProcessor&gt; nonOrderedPostProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  <span class="keyword">for</span> (String ppName : nonOrderedPostProcessorNames) &#123;</span><br><span class="line">    BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);</span><br><span class="line">    nonOrderedPostProcessors.add(pp);</span><br><span class="line">    <span class="keyword">if</span> (pp <span class="keyword">instanceof</span> MergedBeanDefinitionPostProcessor) &#123;</span><br><span class="line">      internalPostProcessors.add(pp);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  registerBeanPostProcessors(beanFactory, nonOrderedPostProcessors);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Finally, all internal BeanPostProcessors.</span></span><br><span class="line">  sortPostProcessors(internalPostProcessors, beanFactory);</span><br><span class="line">  registerBeanPostProcessors(beanFactory, internalPostProcessors);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 重新注册用来自动探测内部ApplicationListener的post-processor，这样可以将他们移到处理器链条的末尾</span></span><br><span class="line">  beanFactory.addBeanPostProcessor(<span class="keyword">new</span> ApplicationListenerDetector(applicationContext));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="initMessageSource"><a href="#initMessageSource" class="headerlink" title="initMessageSource"></a>initMessageSource</h2><blockquote><p>初始化上下文中的资源文件，如国际化文件的处理等</p></blockquote><p>其实该方法就是初始化一个 MessageSource 接口的实现类，主要用于国际化/i18n。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initMessageSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ConfigurableListableBeanFactory beanFactory = getBeanFactory();</span><br><span class="line">  <span class="comment">// 包含 “messageSource” bean</span></span><br><span class="line">  <span class="keyword">if</span> (beanFactory.containsLocalBean(MESSAGE_SOURCE_BEAN_NAME)) &#123;</span><br><span class="line">    <span class="keyword">this</span>.messageSource = beanFactory.getBean(MESSAGE_SOURCE_BEAN_NAME, MessageSource.class);</span><br><span class="line">    <span class="comment">// 如果有父类</span></span><br><span class="line">    <span class="comment">// HierarchicalMessageSource 分级处理的 MessageSource</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.parent != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.messageSource <span class="keyword">instanceof</span> HierarchicalMessageSource) &#123;</span><br><span class="line">      HierarchicalMessageSource hms = (HierarchicalMessageSource) <span class="keyword">this</span>.messageSource;</span><br><span class="line">      <span class="keyword">if</span> (hms.getParentMessageSource() == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果没有注册父 MessageSource，则设置为父类上下文的的 MessageSource</span></span><br><span class="line">        hms.setParentMessageSource(getInternalParentMessageSource());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">      logger.debug(<span class="string">&quot;Using MessageSource [&quot;</span> + <span class="keyword">this</span>.messageSource + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 使用 空 MessageSource</span></span><br><span class="line">    DelegatingMessageSource dms = <span class="keyword">new</span> DelegatingMessageSource();</span><br><span class="line">    dms.setParentMessageSource(getInternalParentMessageSource());</span><br><span class="line">    <span class="keyword">this</span>.messageSource = dms;</span><br><span class="line">    beanFactory.registerSingleton(MESSAGE_SOURCE_BEAN_NAME, <span class="keyword">this</span>.messageSource);</span><br><span class="line">    <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">      logger.debug(<span class="string">&quot;Unable to locate MessageSource with name &#x27;&quot;</span> + MESSAGE_SOURCE_BEAN_NAME +</span><br><span class="line">                   <span class="string">&quot;&#x27;: using default [&quot;</span> + <span class="keyword">this</span>.messageSource + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="initApplicationEventMulticaster"><a href="#initApplicationEventMulticaster" class="headerlink" title="initApplicationEventMulticaster"></a>initApplicationEventMulticaster</h2><blockquote><p>初始化上下文事件广播器</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initApplicationEventMulticaster</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ConfigurableListableBeanFactory beanFactory = getBeanFactory();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果存在 applicationEventMulticaster bean，则获取赋值</span></span><br><span class="line">  <span class="keyword">if</span> (beanFactory.containsLocalBean(APPLICATION_EVENT_MULTICASTER_BEAN_NAME)) &#123;</span><br><span class="line">    <span class="keyword">this</span>.applicationEventMulticaster =</span><br><span class="line">      beanFactory.getBean(APPLICATION_EVENT_MULTICASTER_BEAN_NAME, ApplicationEventMulticaster.class);</span><br><span class="line">    <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">      logger.debug(<span class="string">&quot;Using ApplicationEventMulticaster [&quot;</span> + <span class="keyword">this</span>.applicationEventMulticaster + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 没有则新建 SimpleApplicationEventMulticaster，并完成 bean 的注册</span></span><br><span class="line">    <span class="keyword">this</span>.applicationEventMulticaster = <span class="keyword">new</span> SimpleApplicationEventMulticaster(beanFactory);</span><br><span class="line">    beanFactory.registerSingleton(APPLICATION_EVENT_MULTICASTER_BEAN_NAME, <span class="keyword">this</span>.applicationEventMulticaster);</span><br><span class="line">    <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">      logger.debug(<span class="string">&quot;Unable to locate ApplicationEventMulticaster with name &#x27;&quot;</span> +</span><br><span class="line">                   APPLICATION_EVENT_MULTICASTER_BEAN_NAME +</span><br><span class="line">                   <span class="string">&quot;&#x27;: using default [&quot;</span> + <span class="keyword">this</span>.applicationEventMulticaster + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果当前容器中存在 applicationEventMulticaster 的 bean，则对 applicationEventMulticaster 赋值，否则新建一个 SimpleApplicationEventMulticaster 的对象（默认的），并完成注册。</p><h2 id="onRefresh"><a href="#onRefresh" class="headerlink" title="onRefresh"></a>onRefresh</h2><blockquote><p>给子类扩展初始化其他Bean</p></blockquote><p>预留给 AbstractApplicationContext 的子类用于初始化其他特殊的 bean，该方法需要在所有单例 bean 初始化之前调用。</p><h2 id="registerListeners"><a href="#registerListeners" class="headerlink" title="registerListeners"></a>registerListeners</h2><blockquote><p>在所有 bean 中查找 listener bean，然后注册到广播器中</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">registerListeners</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 注册静态 监听器</span></span><br><span class="line">  <span class="keyword">for</span> (ApplicationListener&lt;?&gt; listener : getApplicationListeners()) &#123;</span><br><span class="line">    getApplicationEventMulticaster().addApplicationListener(listener);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  String[] listenerBeanNames = getBeanNamesForType(ApplicationListener.class, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line">  <span class="keyword">for</span> (String listenerBeanName : listenerBeanNames) &#123;</span><br><span class="line">    getApplicationEventMulticaster().addApplicationListenerBean(listenerBeanName);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 至此，已经完成将监听器注册到ApplicationEventMulticaster中，下面将发布前期的事件给监听器。</span></span><br><span class="line">  Set&lt;ApplicationEvent&gt; earlyEventsToProcess = <span class="keyword">this</span>.earlyApplicationEvents;</span><br><span class="line">  <span class="keyword">this</span>.earlyApplicationEvents = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">if</span> (earlyEventsToProcess != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (ApplicationEvent earlyEvent : earlyEventsToProcess) &#123;</span><br><span class="line">      getApplicationEventMulticaster().multicastEvent(earlyEvent);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="finishBeanFactoryInitialization"><a href="#finishBeanFactoryInitialization" class="headerlink" title="finishBeanFactoryInitialization"></a>finishBeanFactoryInitialization</h2><blockquote><p>初始化剩下的单例Bean(非延迟加载的)</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finishBeanFactoryInitialization</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 初始化转换器</span></span><br><span class="line">  <span class="keyword">if</span> (beanFactory.containsBean(CONVERSION_SERVICE_BEAN_NAME) &amp;&amp;</span><br><span class="line">      beanFactory.isTypeMatch(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class)) &#123;</span><br><span class="line">    beanFactory.setConversionService(</span><br><span class="line">      beanFactory.getBean(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果之前没有注册 bean 后置处理器（例如PropertyPlaceholderConfigurer），则注册默认的解析器</span></span><br><span class="line">  <span class="keyword">if</span> (!beanFactory.hasEmbeddedValueResolver()) &#123;</span><br><span class="line">    beanFactory.addEmbeddedValueResolver(strVal -&gt; getEnvironment().resolvePlaceholders(strVal));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 初始化 Initialize LoadTimeWeaverAware beans early to allow for registering their transformers early.</span></span><br><span class="line">  String[] weaverAwareNames = beanFactory.getBeanNamesForType(LoadTimeWeaverAware.class, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">  <span class="keyword">for</span> (String weaverAwareName : weaverAwareNames) &#123;</span><br><span class="line">    getBean(weaverAwareName);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 停止使用临时的 ClassLoader</span></span><br><span class="line">  beanFactory.setTempClassLoader(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  beanFactory.freezeConfiguration();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 初始化所有剩余的单例（非延迟初始化）</span></span><br><span class="line">  beanFactory.preInstantiateSingletons();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="finishRefresh"><a href="#finishRefresh" class="headerlink" title="finishRefresh"></a>finishRefresh</h2><blockquote><p>完成刷新过程,通知生命周期处理器 lifecycleProcessor 刷新过程,同时发出 ContextRefreshEvent 通知别人</p></blockquote><p>主要是调用 <code>LifecycleProcessor#onRefresh()</code> ，并且发布事件（ContextRefreshedEvent）。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finishRefresh</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Clear context-level resource caches (such as ASM metadata from scanning).</span></span><br><span class="line">  clearResourceCaches();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Initialize lifecycle processor for this context.</span></span><br><span class="line">  initLifecycleProcessor();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Propagate refresh to lifecycle processor first.</span></span><br><span class="line">  getLifecycleProcessor().onRefresh();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Publish the final event.</span></span><br><span class="line">  publishEvent(<span class="keyword">new</span> ContextRefreshedEvent(<span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Participate in LiveBeansView MBean, if active.</span></span><br><span class="line">  LiveBeansView.registerApplicationContext(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
          <category> 《Spring源码分析》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> 死磕Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ApplicationContext相关接口架构分析</title>
      <link href="/blog/2020/01/26/1a84ff95.html"/>
      <url>/blog/2020/01/26/1a84ff95.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文作者：chenssy</p><p>出处：<a href="http://cmsblogs.com/?p=4036">http://cmsblogs.com/?p=4036</a></p><p>在学习<code>Spring源码</code>的过程中发现的好站+好贴，原创不易感谢作者。</p><p>Spring版本：<strong>Spring 5.0.6.RELEASE</strong></p></blockquote><p>前面的文章都是基于 BeanFactory 这个容器来进行分析的，BeanFactory 容器有点儿简单，并不适用于我们生产环境，在生产环境我们通常会选择 ApplicationContext ，相对于大多数人而言，它才是正规军，相比于 BeanFactory 这个杂牌军而言，它由如下几个区别：</p><ol><li>继承 MessageSource，提供国际化的标准访问策略。</li><li>继承 ApplicationEventPublisher ，提供强大的事件机制。</li><li>扩展 ResourceLoader，可以用来加载多个 Resource，可以灵活访问不同的资源。</li><li>对 Web 应用的支持。</li></ol><h2 id="ApplicationContext"><a href="#ApplicationContext" class="headerlink" title="ApplicationContext"></a>ApplicationContext</h2><p>下图是 ApplicationContext 结构类图：</p><p><img src="https://cdn.jsdelivr.net/gh/cayzlh/git-img-repository@master/2020/05/28/15409479819725_t0jF0z_flFIsn.jpg" alt="img"></p><ul><li><p><strong>BeanFactory</strong>：Spring 管理 Bean 的顶层接口，我们可以认为他是一个简易版的 Spring 容器。</p><p>ApplicationContext 继承 BeanFactory 的两个子类：HierarchicalBeanFactory 和 ListableBeanFactory。HierarchicalBeanFactory 是一个具有层级关系的 BeanFactory，拥有属性 parentBeanFactory。ListableBeanFactory 实现了枚举方法可以列举出当前 BeanFactory 中所有的 bean 对象而不必根据 name 一个一个的获取。</p></li><li><p><strong>ApplicationEventPublisher</strong>：用于封装事件发布功能的接口，向事件监听器（Listener）发送事件消息。</p></li><li><p><strong>ResourceLoader</strong>：Spring 加载资源的顶层接口，用于从一个源加载资源文件。</p><p>ApplicationContext 继承 ResourceLoader 的子类 ResourcePatternResolver，该接口是将 location 解析为 Resource 对象的策略接口。</p></li><li><p><strong>MessageSource</strong>：解析 message 的策略接口，用不支撑国际化等功能。</p></li><li><p><strong>EnvironmentCapable</strong>：用于获取 Environment 的接口。</p></li></ul><h2 id="ApplicationContext-的子接口"><a href="#ApplicationContext-的子接口" class="headerlink" title="ApplicationContext 的子接口"></a>ApplicationContext 的子接口</h2><p>ApplicationContext 有两个直接子类：WebApplicationContext 和 ConfigurableApplicationContext。</p><h3 id="WebApplicationContext"><a href="#WebApplicationContext" class="headerlink" title="WebApplicationContext"></a><strong>WebApplicationContext</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">WebApplicationContext</span> <span class="keyword">extends</span> <span class="title">ApplicationContext</span> </span>&#123;</span><br><span class="line">    <span class="function">ServletContext <span class="title">getServletContext</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该接口只有一个 <code>getServletContext()</code> ，用于给 servlet 提供上下文信息。</p><h3 id="ConfigurableApplicationContext"><a href="#ConfigurableApplicationContext" class="headerlink" title="ConfigurableApplicationContext"></a><strong>ConfigurableApplicationContext</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ConfigurableApplicationContext</span> <span class="keyword">extends</span> <span class="title">ApplicationContext</span>, <span class="title">Lifecycle</span>, <span class="title">Closeable</span> </span>&#123;</span><br><span class="line"> <span class="comment">// 为 ApplicationContext 设置唯一 ID</span></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">setId</span><span class="params">(String id)</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 为 ApplicationContext 设置 parent</span></span><br><span class="line"> <span class="comment">// 父类不应该被修改：如果创建的对象不可用时，则应该在构造函数外部设置它</span></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">setParent</span><span class="params">(<span class="meta">@Nullable</span> ApplicationContext parent)</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 设置 Environment</span></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">setEnvironment</span><span class="params">(ConfigurableEnvironment environment)</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 获取 Environment</span></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="function">ConfigurableEnvironment <span class="title">getEnvironment</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 添加 BeanFactoryPostProcessor</span></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">addBeanFactoryPostProcessor</span><span class="params">(BeanFactoryPostProcessor postProcessor)</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 添加 ApplicationListener</span></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">addApplicationListener</span><span class="params">(ApplicationListener&lt;?&gt; listener)</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 添加 ProtocolResolver</span></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">addProtocolResolver</span><span class="params">(ProtocolResolver resolver)</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 加载或者刷新配置</span></span><br><span class="line"> <span class="comment">// 这是一个非常重要的方法</span></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException</span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 注册 shutdown hook</span></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">registerShutdownHook</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 关闭 ApplicationContext</span></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// ApplicationContext 是否处于激活状态</span></span><br><span class="line"> <span class="function"><span class="keyword">boolean</span> <span class="title">isActive</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 获取当前上下文的 BeanFactory</span></span><br><span class="line"> <span class="function">ConfigurableListableBeanFactory <span class="title">getBeanFactory</span><span class="params">()</span> <span class="keyword">throws</span> IllegalStateException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面代码可以看到 ConfigurableApplicationContext 接口提供的方法都是对 ApplicationContext 进行配置的，例如 <code>setEnvironment()</code>、<code>addBeanFactoryPostProcessor</code>，同时它还继承了如下两个接口：</p><ul><li>Lifecycle：对 context 生命周期的管理，它提供 <code>start()</code> 和 <code>stop()</code> 方法启动和暂停组件。</li><li>Closeable：标准 JDK 所提供的一个接口，用于最后关闭组件释放资源等。</li></ul><p><code>WebApplicationContext</code> 接口和 <code>ConfigurableApplicationContext</code> 接口有一个共同的子类接口 <code>ConfigurableWebApplicationContext</code>，该接口将这两个接口进行合并，提供了一个可配置、可管理、可关闭的WebApplicationContext，同时该接口还增加了 <code>setServletContext()</code>，<code>setServletConfig()</code>等方法，用于装配WebApplicationContext。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ConfigurableWebApplicationContext</span> <span class="keyword">extends</span> <span class="title">WebApplicationContext</span>, <span class="title">ConfigurableApplicationContext</span> </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">setServletContext</span><span class="params">(<span class="meta">@Nullable</span> ServletContext servletContext)</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">setServletConfig</span><span class="params">(<span class="meta">@Nullable</span> ServletConfig servletConfig)</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="function">ServletConfig <span class="title">getServletConfig</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">setNamespace</span><span class="params">(<span class="meta">@Nullable</span> String namespace)</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="function">String <span class="title">getNamespace</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">setConfigLocation</span><span class="params">(String configLocation)</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">setConfigLocations</span><span class="params">(String... configLocations)</span></span>;</span><br><span class="line"></span><br><span class="line"> String[] getConfigLocations();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面三个接口就可以构成一个比较完整的 Spring 容器，整个 Spring 容器体系涉及的接口较多，所以下面小编就一个具体的实现类来看看 ApplicationContext 的实现（其实在前面一系列的文章中，小编对涉及的大部分接口都已经分析了其原理），当然不可能每个方法都涉及到，但小编会把其中最为重要的实现方法贴出来分析。</p><blockquote><p>ApplicationContext 的实现类较多，就以 ClassPathXmlApplicationContext 来分析 ApplicationContext。</p></blockquote><h2 id="ClassPathXmlApplicationContext"><a href="#ClassPathXmlApplicationContext" class="headerlink" title="ClassPathXmlApplicationContext"></a>ClassPathXmlApplicationContext</h2><p><code>ClassPathXmlApplicationContext</code> 是我们在学习 Spring 过程中用的非常多的一个类，很多人第一个接触的 Spring 容器就是它，包括小编自己，下面代码我想很多人依然还记得吧。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ApplicationContext ac = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">StudentService studentService = (StudentService)ac.getBean(<span class="string">&quot;studentService&quot;</span>);</span><br></pre></td></tr></table></figure><p>下图是 ClassPathXmlApplicationContext 的结构类图：</p><p><img src="https://cdn.jsdelivr.net/gh/cayzlh/git-img-repository@master/2020/05/28/15410421887266-20200528144153812_tzVVcv.jpg" alt="img"></p><p>主要的的类层级关系如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">org.springframework.context.support.AbstractApplicationContext</span><br><span class="line">      org.springframework.context.support.AbstractRefreshableApplicationContext</span><br><span class="line">            org.springframework.context.support.AbstractRefreshableConfigApplicationContext</span><br><span class="line">                  org.springframework.context.support.AbstractXmlApplicationContext</span><br><span class="line">                        org.springframework.context.support.ClassPathXmlApplicationContext</span><br></pre></td></tr></table></figure><p>这种设计是模板方法模式典型的应用，AbstractApplicationContext 实现了 ConfigurableApplicationContext 这个全家桶接口，其子类 AbstractRefreshableConfigApplicationContext 又实现了 BeanNameAware 和 InitializingBean 接口。所以 ClassPathXmlApplicationContext 设计的顶级接口有：</p><ul><li><code>BeanFactory</code>：Spring 容器 Bean 的管理</li><li><code>MessageSource</code>：管理 message ，实现国际化等功能</li><li><code>ApplicationEventPublisher</code>：事件发布</li><li><code>ResourcePatternResolver</code>：资源加载</li><li><code>EnvironmentCapable</code>：系统 Environment（profile + Properties） 相关</li><li><code>Lifecycle</code>：管理生命周期</li><li><code>Closeable</code>：关闭，释放资源</li><li><code>InitializingBean</code>：自定义初始化</li><li><code>BeanNameAware</code>：设置 beanName 的 Aware 接口</li></ul><p>下面就这些接口来一一分析。</p><h3 id="MessageSource"><a href="#MessageSource" class="headerlink" title="MessageSource"></a>MessageSource</h3><p>MessageSource 定义了获取 message 的策略方法 <code>getMessage()</code>，在 ApplicationContext 体系中，该方法 AbstractApplicationContext 实现，在 AbstractApplicationContext 中，它持有一个 MessageSource 实例，将 <code>getMessage()</code> 的实现给该实例来实现，如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> MessageSource messageSource;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现 getMessage()</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getMessage</span><span class="params">(String code, <span class="meta">@Nullable</span> Object[] args, <span class="meta">@Nullable</span> String defaultMessage, Locale locale)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 委托给 messageSource 实现</span></span><br><span class="line"> <span class="keyword">return</span> getMessageSource().getMessage(code, args, defaultMessage, locale);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> MessageSource <span class="title">getMessageSource</span><span class="params">()</span> <span class="keyword">throws</span> IllegalStateException </span>&#123;</span><br><span class="line"> <span class="keyword">if</span> (<span class="keyword">this</span>.messageSource == <span class="keyword">null</span>) &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;MessageSource not initialized - &quot;</span> +</span><br><span class="line">    <span class="string">&quot;call &#x27;refresh&#x27; before accessing messages via the context: &quot;</span> + <span class="keyword">this</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">this</span>.messageSource;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>真正实现 是在 <code>AbstractMessageSource</code> 中，如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">getMessage</span><span class="params">(String code, <span class="meta">@Nullable</span> Object[] args, <span class="meta">@Nullable</span> String defaultMessage, Locale locale)</span> </span>&#123;</span><br><span class="line"> String msg = getMessageInternal(code, args, locale);</span><br><span class="line"> <span class="keyword">if</span> (msg != <span class="keyword">null</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> msg;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">if</span> (defaultMessage == <span class="keyword">null</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> getDefaultMessage(code);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> renderDefaultMessage(defaultMessage, args, locale);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体的实现这里就不分析了。</p><h3 id="ApplicationEventPublisher"><a href="#ApplicationEventPublisher" class="headerlink" title="ApplicationEventPublisher"></a>ApplicationEventPublisher</h3><p>用于封装事件发布功能的接口，向事件监听器（Listener）发送事件消息。</p><p>该接口提供了一个 <code>publishEvent()</code> 用于通知在此应用程序中注册的所有的监听器。</p><p>该方法在 AbstractApplicationContext 中实现。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">publishEvent</span><span class="params">(Object event)</span> </span>&#123;</span><br><span class="line">  publishEvent(event, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">publishEvent</span><span class="params">(Object event, <span class="meta">@Nullable</span> ResolvableType eventType)</span> </span>&#123;</span><br><span class="line">  Assert.notNull(event, <span class="string">&quot;Event must not be null&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">    logger.trace(<span class="string">&quot;Publishing event in &quot;</span> + getDisplayName() + <span class="string">&quot;: &quot;</span> + event);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ApplicationEvent applicationEvent;</span><br><span class="line">  <span class="keyword">if</span> (event <span class="keyword">instanceof</span> ApplicationEvent) &#123;</span><br><span class="line">    applicationEvent = (ApplicationEvent) event;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    applicationEvent = <span class="keyword">new</span> PayloadApplicationEvent&lt;&gt;(<span class="keyword">this</span>, event);</span><br><span class="line">    <span class="keyword">if</span> (eventType == <span class="keyword">null</span>) &#123;</span><br><span class="line">      eventType = ((PayloadApplicationEvent) applicationEvent).getResolvableType();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.earlyApplicationEvents != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.earlyApplicationEvents.add(applicationEvent);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    getApplicationEventMulticaster().multicastEvent(applicationEvent, eventType);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.parent <span class="keyword">instanceof</span> AbstractApplicationContext) &#123;</span><br><span class="line">      ((AbstractApplicationContext) <span class="keyword">this</span>.parent).publishEvent(event, eventType);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.parent.publishEvent(event);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果指定的事件不是ApplicationEvent，则它将包装在PayloadApplicationEvent中。如果存在父级 ApplicationContext ，则同样要将 event 发布给父级 ApplicationContext。</p><h3 id="ResourcePatternResolver"><a href="#ResourcePatternResolver" class="headerlink" title="ResourcePatternResolver"></a>ResourcePatternResolver</h3><p>ResourcePatternResolver 接口继承 ResourceLoader 接口，为将 location 解析为 Resource 对象的策略接口。他提供的 <code>getResources()</code> 在 AbstractApplicationContext 中实现，在 AbstractApplicationContext 中他持有一个 ResourcePatternResolver 的实例对象。</p><p>如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Resource[] getResources(String locationPattern) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">this</span>.resourcePatternResolver.getResources(locationPattern);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果小伙伴对 Spring 的 ResourceLoader 比较熟悉的话，你会发现最终是在 PathMatchingResourcePatternResolver 中实现，该类是 ResourcePatternResolver 接口的实现者。</p><h3 id="EnvironmentCapable"><a href="#EnvironmentCapable" class="headerlink" title="EnvironmentCapable"></a>EnvironmentCapable</h3><p>提供当前系统环境 Environment 组件。提供了一个 <code>getEnvironment()</code> 用于返回 Environment 实例对象，该方法在 AbstractApplicationContext 实现。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ConfigurableEnvironment <span class="title">getEnvironment</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="keyword">if</span> (<span class="keyword">this</span>.environment == <span class="keyword">null</span>) &#123;</span><br><span class="line">  <span class="keyword">this</span>.environment = createEnvironment();</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">this</span>.environment;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果持有的 environment 实例对象为空，则调用 <code>createEnvironment()</code> 创建一个。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> ConfigurableEnvironment <span class="title">createEnvironment</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">new</span> StandardEnvironment();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>StandardEnvironment 是一个适用于非 WEB 应用的 Environment。</p><h3 id="Lifecycle"><a href="#Lifecycle" class="headerlink" title="Lifecycle"></a>Lifecycle</h3><p>一个用于管理声明周期的接口。</p><p>在 AbstractApplicationContext 中存在一个 LifecycleProcessor 类型的实例对象 lifecycleProcessor，AbstractApplicationContext 中关于 Lifecycle 接口的实现都是委托给 lifecycleProcessor 实现的。如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  getLifecycleProcessor().start();</span><br><span class="line">  publishEvent(<span class="keyword">new</span> ContextStartedEvent(<span class="keyword">this</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  getLifecycleProcessor().stop();</span><br><span class="line">  publishEvent(<span class="keyword">new</span> ContextStoppedEvent(<span class="keyword">this</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isRunning</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">this</span>.lifecycleProcessor != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.lifecycleProcessor.isRunning());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在启动、停止的时候会分别发布 ContextStartedEvent 和 ContextStoppedEvent 事件。</p><h3 id="Closeable"><a href="#Closeable" class="headerlink" title="Closeable"></a>Closeable</h3><p>Closeable 接口用于关闭和释放资源，提供了 <code>close()</code> 以释放对象所持有的资源。在 ApplicationContext 体系中由AbstractApplicationContext 实现，用于关闭 ApplicationContext 销毁所有 bean ，此外如果注册有 JVM shutdown hook，同样要将其移除。如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">synchronized</span> (<span class="keyword">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line">    doClose();</span><br><span class="line">    <span class="comment">// If we registered a JVM shutdown hook, we don&#x27;t need it anymore now:</span></span><br><span class="line">    <span class="comment">// We&#x27;ve already explicitly closed the context.</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.shutdownHook != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        Runtime.getRuntime().removeShutdownHook(<span class="keyword">this</span>.shutdownHook);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (IllegalStateException ex) &#123;</span><br><span class="line">        <span class="comment">// ignore - VM is already shutting down</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用 <code>doClose()</code> 发布 ContextClosedEvent 事件，销毁所有 bean（单例），关闭 BeanFactory 。如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doClose</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 省略部分代码</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// Publish shutdown event.</span></span><br><span class="line">    publishEvent(<span class="keyword">new</span> ContextClosedEvent(<span class="keyword">this</span>));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">    logger.warn(<span class="string">&quot;Exception thrown from ApplicationListener handling ContextClosedEvent&quot;</span>, ex);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 省略部分代码</span></span><br><span class="line">  destroyBeans();</span><br><span class="line">  closeBeanFactory();</span><br><span class="line">  onClose();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.active.set(<span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="InitializingBean"><a href="#InitializingBean" class="headerlink" title="InitializingBean"></a>InitializingBean</h3><p>InitializingBean 为 bean 提供了初始化方法的方式，它提供的 <code>afterPropertiesSet()</code> 用于执行初始化动作。在 ApplicationContext 体系中，该方法由 AbstractRefreshableConfigApplicationContext 实现，如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!isActive()) &#123;</span><br><span class="line">    refresh();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行 <code>refresh()</code> ，该方法在 AbstractApplicationContext 中执行，执行整个 Spring 容器的初始化过程。该方法将在下篇文章进行详细分析说明。</p><h3 id="BeanNameAware"><a href="#BeanNameAware" class="headerlink" title="BeanNameAware"></a>BeanNameAware</h3><p>设置 bean name 的接口。接口在 AbstractRefreshableConfigApplicationContext 中实现。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBeanName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">this</span>.setIdCalled) &#123;</span><br><span class="line">    <span class="keyword">super</span>.setId(name);</span><br><span class="line">    setDisplayName(<span class="string">&quot;ApplicationContext &#x27;&quot;</span> + name + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>由于篇幅问题再加上大部分接口都已经在前面文章进行了详细的阐述，所以本文主要是以 Spring Framework 的 ApplicationContext 为中心，对其结构和功能的实现进行了简要的说明。</p><p><strong>这里不得不说 Spring 真的是一个非常优秀的框架，具有良好的结构设计和接口抽象，它的每一个接口职能单一，且都是具体功能到各个模块的高度抽象，且几乎每套接口都提供了一个默认的实现（defaultXXX）。</strong></p><p>对于 ApplicationContext 体系而言，他继承 Spring 中众多的核心接口，能够为客户端提供一个相对完整的 Spring 容器，接口 ConfigurableApplicationContext 对 ApplicationContext 接口再次进行扩展，提供了生命周期的管理功能。</p><p>抽象类 ApplicationContext 对整套接口提供了大部分的默认实现，将其中“不易变动”的部分进行了封装，通过“组合”的方式将“容易变动”的功能委托给其他类来实现，同时利用模板方法模式将一些方法的实现开放出去由子类实现，从而实现“**<u>对扩展开放，对修改封闭</u>**”的设计原则。</p><p>最后我们再来领略下图的风采：</p><p><img src="https://cdn.jsdelivr.net/gh/cayzlh/git-img-repository@master/2020/05/28/15410421887266-20200528145142270_hlq2Td.jpg" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
          <category> 《Spring源码分析》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> 死磕Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IOC之分析bean的生命周期</title>
      <link href="/blog/2020/01/26/90c034e1.html"/>
      <url>/blog/2020/01/26/90c034e1.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文作者：chenssy</p><p>出处：<a href="http://cmsblogs.com/?p=4034">http://cmsblogs.com/?p=4034</a></p><p>在学习<code>Spring源码</code>的过程中发现的好站+好贴，原创不易感谢作者。</p><p>Spring版本：<strong>Spring 5.0.6.RELEASE</strong></p></blockquote><p>在分析 Spring Bean 实例化过程中提到 Spring 并不是一启动容器就开启 bean 的实例化进程，只有当客户端通过显示或者隐式的方式调用 BeanFactory 的 <code>getBean()</code> 方法来请求某个实例对象的时候，它才会触发相应 bean 的实例化进程，当然也可以选择直接使用 ApplicationContext 容器，因为该容器启动的时候会立刻调用注册到该容器所有 bean 定义的实例化方法。当然对于 BeanFactory 容器而言并不是所有的 <code>getBean()</code> 方法都会触发实例化进程，比如 signleton 类型的 bean，该类型的 bean 只会在第一次调用 <code>getBean()</code> 的时候才会触发，而后续的调用则会直接返回容器缓存中的实例对象。</p><p><code>getBean()</code> 只是 bean 实例化进程的入口，真正的实现逻辑其实是在 AbstractAutowireCapableBeanFactory 的 <code>doCreateBean()</code> 实现，实例化过程如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/cayzlh/git-img-repository@master/2020/05/28/15359386381747_wNxvJ5_Lyaby1.jpg" alt="img"></p><p>原来我们采用 new 的方式创建一个对象，用完该对象在其脱离作用域后就会被回收，对于后续操作我们无权也没法干涉，但是采用 Spring 容器后，我们完全摆脱了这种命运，Spring 容器将会对其所有管理的 Bean 对象全部给予一个统一的生命周期管理，同时在这个阶段我们也可以对其进行干涉（比如对 bean 进行增强处理，对 bean 进行篡改），如上图。</p><h2 id="bean-实例化"><a href="#bean-实例化" class="headerlink" title="bean 实例化"></a>bean 实例化</h2><p>在 <code>doCreateBean()</code> 中首先进行 bean 实例化工作，主要由 <code>createBeanInstance()</code> 实现，该方法返回一个 BeanWrapper 对象。BeanWrapper 对象是 Spring 的一个低级 Bean 基础结构的核心接口，为什么说是低级呢？因为这个时候的 Bean 还不能够被我们使用，连最基本的属性都没有设置。而且在我们实际开发过程中一般都不会直接使用该类，而是通过 BeanFactory 隐式使用。</p><p>BeanWrapper 接口有一个默认实现类 BeanWrapperImpl，其主要作用是对 Bean 进行“包裹”，然后对这个包裹的 bean 进行操作，比如后续注入 bean 属性。</p><p>在实例化 bean 过程中，Spring 采用“策略模式”来决定采用哪种方式来实例化 bean，一般有反射和 CGLIB 动态字节码两种方式。</p><p>InstantiationStrategy 定义了 Bean 实例化策略的抽象接口，其子类 SimpleInstantiationStrategy 提供了基于反射来实例化对象的功能，但是不支持方法注入方式的对象实例化。</p><p>CglibSubclassingInstantiationStrategy 继承 SimpleInstantiationStrategy，他除了拥有父类以反射实例化对象的功能外，还提供了通过 CGLIB 的动态字节码的功能进而支持方法注入所需的对象实例化需求。默认情况下，Spring 采用 CglibSubclassingInstantiationStrategy。</p><h2 id="激活-Aware"><a href="#激活-Aware" class="headerlink" title="激活 Aware"></a>激活 Aware</h2><p>当 Spring 完成 bean 对象实例化并且设置完相关属性和依赖后，则会开始 bean 的初始化进程（<code>initializeBean()</code>），初始化第一个阶段是检查当前 bean 对象是否实现了一系列以 Aware 结尾的的接口。</p><p>Aware 接口为 Spring 容器的核心接口，是一个具有标识作用的超级接口，实现了该接口的 bean 是具有被 Spring 容器通知的能力，通知的方式是采用回调的方式。</p><p>在初始化阶段主要是感知 BeanNameAware、BeanClassLoaderAware、BeanFactoryAware ：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">invokeAwareMethods</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> Object bean)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> Aware) &#123;</span><br><span class="line">    <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> BeanNameAware) &#123;</span><br><span class="line">      ((BeanNameAware) bean).setBeanName(beanName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> BeanClassLoaderAware) &#123;</span><br><span class="line">      ClassLoader bcl = getBeanClassLoader();</span><br><span class="line">      <span class="keyword">if</span> (bcl != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ((BeanClassLoaderAware) bean).setBeanClassLoader(bcl);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> BeanFactoryAware) &#123;</span><br><span class="line">      ((BeanFactoryAware) bean).setBeanFactory(AbstractAutowireCapableBeanFactory.<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>BeanNameAware</code>：对该 bean 对象定义的 beanName 设置到当前对象实例中</li><li><code>BeanClassLoaderAware</code>：将当前 bean 对象相应的 ClassLoader 注入到当前对象实例中</li><li><code>BeanFactoryAware</code>：BeanFactory 容器会将自身注入到当前对象实例中，这样当前对象就会拥有一个 BeanFactory 容器的引用。</li></ul><p><strong>当然，Spring 不仅仅只是提供了上面三个 Aware 接口，而是一系列：</strong></p><ul><li><code>LoadTimeWeaverAware</code>：加载Spring Bean时织入第三方模块，如AspectJ</li><li><code>BootstrapContextAware</code>：资源适配器BootstrapContext，如JCA,CCI</li><li><code>ResourceLoaderAware</code>：底层访问资源的加载器</li><li><code>PortletConfigAware</code>：PortletConfig</li><li><code>PortletContextAware</code>：PortletContext</li><li><code>ServletConfigAware</code>：ServletConfig</li><li><code>ServletContextAware</code>：ServletContext</li><li><code>MessageSourceAware</code>：国际化</li><li><code>ApplicationEventPublisherAware</code>：应用事件</li><li><code>NotificationPublisherAware</code>：JMX通知</li></ul><h2 id="BeanPostProcessor"><a href="#BeanPostProcessor" class="headerlink" title="BeanPostProcessor"></a>BeanPostProcessor</h2><p>初始化第二个阶段则是 BeanPostProcessor 增强处理，在该阶段 BeanPostProcessor 会处理当前容器内所有符合条件的实例化后的 bean 对象。</p><p><u>它主要是对 Spring 容器提供的 bean 实例对象进行有效的扩展，允许 Spring 在初始化 bean 阶段对其进行定制化修改，如处理标记接口或者为其提供代理实现。</u></p><p>BeanPostProcessor 接口提供了两个方法，在不同的时机执行，分别对应上图的前置处理和后置处理。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanPostProcessor</span> </span>&#123;</span><br><span class="line"> <span class="meta">@Nullable</span></span><br><span class="line"> <span class="function"><span class="keyword">default</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> bean;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@Nullable</span></span><br><span class="line"> <span class="function"><span class="keyword">default</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> bean;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="InitializingBean-和-init-method"><a href="#InitializingBean-和-init-method" class="headerlink" title="InitializingBean 和 init-method"></a>InitializingBean 和 init-method</h2><p>InitializingBean 是一个接口，它为 Spring Bean 的初始化提供了一种方式，它有一个 <code>afterPropertiesSet()</code> 方法，在 bean 的初始化进程中会判断当前 bean 是否实现了 InitializingBean，如果实现了则调用 <code>afterPropertiesSet()</code> 进行初始化工作。然后再检查是否也指定了 init-method()，如果指定了则通过反射机制调用指定的 init-method()。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">invokeInitMethods</span><span class="params">(String beanName, <span class="keyword">final</span> Object bean, <span class="meta">@Nullable</span> RootBeanDefinition mbd)</span></span></span><br><span class="line"><span class="function">  <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">boolean</span> isInitializingBean = (bean <span class="keyword">instanceof</span> InitializingBean);</span><br><span class="line">  <span class="keyword">if</span> (isInitializingBean &amp;&amp; (mbd == <span class="keyword">null</span> || !mbd.isExternallyManagedInitMethod(<span class="string">&quot;afterPropertiesSet&quot;</span>))) &#123;</span><br><span class="line">    <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">      logger.debug(<span class="string">&quot;Invoking afterPropertiesSet() on bean with name &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        AccessController.doPrivileged((PrivilegedExceptionAction&lt;Object&gt;) () -&gt; &#123;</span><br><span class="line">          ((InitializingBean) bean).afterPropertiesSet();</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;, getAccessControlContext());</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (PrivilegedActionException pae) &#123;</span><br><span class="line">        <span class="keyword">throw</span> pae.getException();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      ((InitializingBean) bean).afterPropertiesSet();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (mbd != <span class="keyword">null</span> &amp;&amp; bean.getClass() != NullBean.class) &#123;</span><br><span class="line">    String initMethodName = mbd.getInitMethodName();</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.hasLength(initMethodName) &amp;&amp;</span><br><span class="line">        !(isInitializingBean &amp;&amp; <span class="string">&quot;afterPropertiesSet&quot;</span>.equals(initMethodName)) &amp;&amp;</span><br><span class="line">        !mbd.isExternallyManagedInitMethod(initMethodName)) &#123;</span><br><span class="line">      invokeCustomInitMethod(beanName, bean, mbd);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于 Spring 而言，虽然上面两种方式都可以实现初始化定制化，但是更加推崇 <code>init-method</code> 方式，因为对于 InitializingBean 接口而言，他需要 bean 去实现接口，这样就会污染我们的应用程序，显得 Spring 具有一定的侵入性。但是由于 <code>init-method</code> 是采用反射的方式，所以执行效率上相对于 InitializingBean 接口回调的方式可能会低一些。</p><h2 id="DisposableBean-和-destroy-method"><a href="#DisposableBean-和-destroy-method" class="headerlink" title="DisposableBean 和 destroy-method"></a>DisposableBean 和 destroy-method</h2><p>与 InitializingBean 和 init-method 用于对象的自定义初始化工作相似，DisposableBean和 destroy-method 则用于对象的自定义销毁工作。</p><p>当一个 bean 对象经历了实例化、设置属性、初始化阶段,那么该 bean 对象就可以供容器使用了（调用的过程）。当完成调用后，如果是 singleton 类型的 bean ，则会看当前 bean 是否应实现了 DisposableBean 接口或者配置了 destroy-method 属性，如果是的话，则会为该实例注册一个用于对象销毁的回调方法，便于在这些 singleton 类型的 bean 对象销毁之前执行销毁逻辑。</p><p>但是，并不是对象完成调用后就会立刻执行销毁方法，因为这个时候 Spring 容器还处于运行阶段，只有当 Spring 容器关闭的时候才会去调用。但是， Spring 容器不会这么聪明会自动去调用这些销毁方法，而是需要我们主动去告知 Spring 容器。</p><ul><li>对于 BeanFactory 容器而言，我们需要主动调用 <code>destroySingletons()</code> 通知 BeanFactory 容器去执行相应的销毁方法。</li><li>对于 ApplicationContext 容器而言调用 <code>registerShutdownHook()</code> 方法。</li></ul><h2 id="实践验证"><a href="#实践验证" class="headerlink" title="实践验证"></a>实践验证</h2><p>下面用一个实例来真实看看看上面执行的逻辑，毕竟理论是不能缺少实践的：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">lifeCycleBean</span> <span class="keyword">implements</span> <span class="title">BeanNameAware</span>,<span class="title">BeanFactoryAware</span>,<span class="title">BeanClassLoaderAware</span>,<span class="title">BeanPostProcessor</span>,</span></span><br><span class="line"><span class="class">        <span class="title">InitializingBean</span>,<span class="title">DisposableBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String test;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> test;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTest</span><span class="params">(String test)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;属性注入....&quot;</span>);</span><br><span class="line">        <span class="keyword">this</span>.test = test;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">lifeCycleBean</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;构造函数调用...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;方法调用...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBeanFactory</span><span class="params">(BeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;BeanFactoryAware 被调用...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBeanName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;BeanNameAware 被调用...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBeanClassLoader</span><span class="params">(ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;BeanClassLoaderAware 被调用...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;BeanPostProcessor postProcessBeforeInitialization 被调用...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;BeanPostProcessor postProcessAfterInitialization 被调用...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;DisposableBean destroy 被调动...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;InitializingBean afterPropertiesSet 被调动...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;init-method 被调用...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroyMethdo</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;destroy-method 被调用...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>lifeCycleBean 继承了 <code>BeanNameAware</code> , <code>BeanFactoryAware</code> , <code>BeanClassLoaderAware</code> , <code>BeanPostProcessor</code> , <code>InitializingBean</code> , <code>DisposableBean</code> 六个接口，同时定义了一个 test 属性用于验证属性注入和提供一个 <code>display()</code> 用于模拟调用。 配置如下：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;lifeCycle&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.core.test.lifeCycleBean&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">init-method</span>=<span class="string">&quot;initMethod&quot;</span> <span class="attr">destroy-method</span>=<span class="string">&quot;destroyMethdo&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;test&quot;</span> <span class="attr">value</span>=<span class="string">&quot;test&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>配置 init-method 和 destroy-method。测试方法如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// BeanFactory 容器一定要调用该方法进行 BeanPostProcessor 注册</span></span><br><span class="line">factory.addBeanPostProcessor(<span class="keyword">new</span> lifeCycleBean());</span><br><span class="line"></span><br><span class="line">lifeCycleBean lifeCycleBean = (lifeCycleBean) factory.getBean(<span class="string">&quot;lifeCycle&quot;</span>);</span><br><span class="line">lifeCycleBean.display();</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;方法调用完成，容器开始关闭....&quot;</span>);</span><br><span class="line"><span class="comment">// 关闭容器</span></span><br><span class="line">factory.destroySingletons();</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">构造函数调用...</span><br><span class="line">构造函数调用...</span><br><span class="line">属性注入....</span><br><span class="line">BeanNameAware 被调用...</span><br><span class="line">BeanClassLoaderAware 被调用...</span><br><span class="line">BeanFactoryAware 被调用...</span><br><span class="line">BeanPostProcessor postProcessBeforeInitialization 被调用...</span><br><span class="line">InitializingBean afterPropertiesSet 被调动...</span><br><span class="line">init-method 被调用...</span><br><span class="line">BeanPostProcessor postProcessAfterInitialization 被调用...</span><br><span class="line">方法调用...</span><br><span class="line">方法调用完成，容器开始关闭....</span><br><span class="line">DisposableBean destroy 被调动...</span><br><span class="line">destroy-method 被调用...</span><br></pre></td></tr></table></figure><p>有两个构造函数调用是因为要注入一个 BeanPostProcessor（你也可以另外提供一个 BeanPostProcessor 实例）。</p><p>根据执行的结果已经上面的分析，我们就可以对 Spring Bean 的声明周期过程如下（方法级别）：</p><ol><li>Spring 容器根据实例化策略对 Bean 进行实例化。</li><li>实例化完成后，如果该 bean 设置了一些属性的话，则利用 set 方法设置一些属性。</li><li>如果该 Bean 实现了 BeanNameAware 接口，则调用 <code>setBeanName()</code> 方法。</li><li>如果该 bean 实现了 BeanClassLoaderAware 接口，则调用 <code>setBeanClassLoader()</code> 方法。</li><li>如果该 bean 实现了 BeanFactoryAware接口，则调用 <code>setBeanFactory()</code> 方法。</li><li>如果该容器注册了 BeanPostProcessor，则会调用<code>postProcessBeforeInitialization()</code> 方法完成 bean 前置处理</li><li>如果该 bean 实现了 InitializingBean 接口，则调用 。<code>afterPropertiesSet()</code> 方法。</li><li>如果该 bean 配置了 init-method 方法，则调用 init-method 指定的方法。</li><li>初始化完成后，如果该容器注册了 BeanPostProcessor 则会调用 <code>postProcessAfterInitialization()</code> 方法完成 bean 的后置处理。</li><li>对象完成初始化，开始方法调用。</li><li>在容器进行关闭之前，如果该 bean 实现了 DisposableBean 接口，则调用 <code>destroy()</code> 方法。</li><li>在容器进行关闭之前，如果该 bean 配置了 destroy-mehod，则调用其指定的方法。</li><li>到这里一个 bean 也就完成了它的一生。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
          <category> 《Spring源码分析》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> 死磕Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring的环境&amp;属性：PropertySource、Environment、Profile</title>
      <link href="/blog/2020/01/25/8ce6797f.html"/>
      <url>/blog/2020/01/25/8ce6797f.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文作者：chenssy</p><p>出处：<a href="http://cmsblogs.com/?p=4032">http://cmsblogs.com/?p=4032</a></p><p>在学习<code>Spring源码</code>的过程中发现的好站+好贴，原创不易感谢作者。</p><p>Spring版本：<strong>Spring 5.0.6.RELEASE</strong></p></blockquote><p><code>spring.profiles.active</code> 和 <code>@Profile</code> 这两个我相信各位都熟悉吧，主要功能是可以实现不同环境下（开发、测试、生产）参数配置的切换。</p><p>其实关于环境的切换，在博客 <a href="/2020/01/23/cd2eaad8.html"> IOC 之 PropertyPlaceholderConfigurer 的应用</a> 已经介绍了利用 PropertyPlaceholderConfigurer 来实现动态切换配置环境，当然这种方法需要我们自己实现，有点儿麻烦。但是对于这种非常实际的需求，Spring 怎么可能没有提供呢？下面就这个问题来对 Spring 的<strong>环境 &amp; 属性</strong>来做一个分析说明。</p><h2 id="概括"><a href="#概括" class="headerlink" title="概括"></a>概括</h2><p>Spring 环境 &amp; 属性由四个部分组成：<code>PropertySource</code>、<code>PropertyResolver</code>、<code>Profile</code> 和 <code>Environment</code>。</p><ul><li><strong>PropertySource</strong>：属性源，key-value 属性对抽象，用于配置数据。</li><li><strong>PropertyResolver</strong>：属性解析器，用于解析属性配置</li><li><strong>Profile</strong>：剖面，只有激活的剖面的组件/配置才会注册到 Spring 容器，类似于 Spring Boot 中的 profile</li><li><strong>Environment</strong>：环境，Profile 和 PropertyResolver 的组合。</li></ul><p>下面是整个体系的结构图：</p><p><img src="https://gitee.com/cayzlh/img-repo/raw/master/2020/05/27/15398567835599_IpITEl_QAdnEu.jpg" alt="img"></p><p>下面就针对上面结构图对 Spring 的 Properties &amp; Environment 做一个详细的分析。</p><h2 id="Properties"><a href="#Properties" class="headerlink" title="Properties"></a>Properties</h2><h3 id="PropertyResolver"><a href="#PropertyResolver" class="headerlink" title="PropertyResolver"></a>PropertyResolver</h3><blockquote><p>属性解析器，用于解析任何基础源的属性的接口</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PropertyResolver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否包含某个属性</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">containsProperty</span><span class="params">(String key)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取属性值 如果找不到返回null</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function">String <span class="title">getProperty</span><span class="params">(String key)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取属性值，如果找不到返回默认值  </span></span><br><span class="line">    <span class="function">String <span class="title">getProperty</span><span class="params">(String key, String defaultValue)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取指定类型的属性值，找不到返回null</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    &lt;T&gt; <span class="function">T <span class="title">getProperty</span><span class="params">(String key, Class&lt;T&gt; targetType)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取指定类型的属性值，找不到返回默认值</span></span><br><span class="line">    &lt;T&gt; <span class="function">T <span class="title">getProperty</span><span class="params">(String key, Class&lt;T&gt; targetType, T defaultValue)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取属性值，找不到抛出异常IllegalStateException</span></span><br><span class="line">    <span class="function">String <span class="title">getRequiredProperty</span><span class="params">(String key)</span> <span class="keyword">throws</span> IllegalStateException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取指定类型的属性值，找不到抛出异常IllegalStateException</span></span><br><span class="line">    &lt;T&gt; <span class="function">T <span class="title">getRequiredProperty</span><span class="params">(String key, Class&lt;T&gt; targetType)</span> <span class="keyword">throws</span> IllegalStateException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 替换文本中的占位符（$&#123;key&#125;）到属性值，找不到不解析</span></span><br><span class="line">    <span class="function">String <span class="title">resolvePlaceholders</span><span class="params">(String text)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 替换文本中的占位符（$&#123;key&#125;）到属性值，找不到抛出异常IllegalArgumentException</span></span><br><span class="line">    <span class="function">String <span class="title">resolveRequiredPlaceholders</span><span class="params">(String text)</span> <span class="keyword">throws</span> IllegalArgumentException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从 API 上面我们就知道属性解析器 PropertyResolver 的作用了。下面是一个简单的运用。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">PropertyResolver propertyResolver = <span class="keyword">new</span> PropertySourcesPropertyResolver(propertySources);</span><br><span class="line"></span><br><span class="line">System.out.println(propertyResolver.getProperty(<span class="string">&quot;name&quot;</span>));</span><br><span class="line">System.out.println(propertyResolver.getProperty(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;chenssy&quot;</span>));</span><br><span class="line">System.out.println(propertyResolver.resolvePlaceholders(<span class="string">&quot;my name is  $&#123;name&#125;&quot;</span>));</span><br></pre></td></tr></table></figure><p>下图是 PropertyResolver 体系结构图：</p><p><img src="https://gitee.com/cayzlh/img-repo/raw/master/2020/05/27/201810241001_UC9RsT_5WoqUp.png" alt="201810241001"></p><ul><li><strong>ConfigurablePropertyResolver</strong>：供属性类型转换的功能</li><li><strong>AbstractPropertyResolver</strong>：解析属性文件的抽象基类</li><li><strong>PropertySourcesPropertyResolver</strong>：PropertyResolver 的实现者，他对一组 PropertySources 提供属性解析服务</li></ul><h3 id="ConfigurablePropertyResolver"><a href="#ConfigurablePropertyResolver" class="headerlink" title="ConfigurablePropertyResolver"></a>ConfigurablePropertyResolver</h3><blockquote><p>提供属性类型转换的功能</p></blockquote><p>通俗点说就是 ConfigurablePropertyResolver 提供属性值类型转换所需要的 ConversionService。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ConfigurablePropertyResolver</span> <span class="keyword">extends</span> <span class="title">PropertyResolver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回执行类型转换时使用的 ConfigurableConversionService</span></span><br><span class="line">    <span class="function">ConfigurableConversionService <span class="title">getConversionService</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置 ConfigurableConversionService</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setConversionService</span><span class="params">(ConfigurableConversionService conversionService)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置占位符前缀</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setPlaceholderPrefix</span><span class="params">(String placeholderPrefix)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置占位符后缀</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setPlaceholderSuffix</span><span class="params">(String placeholderSuffix)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置占位符与默认值之间的分隔符</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setValueSeparator</span><span class="params">(<span class="meta">@Nullable</span> String valueSeparator)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置当遇到嵌套在给定属性值内的不可解析的占位符时是否抛出异常</span></span><br><span class="line">    <span class="comment">// 当属性值包含不可解析的占位符时，getProperty(String)及其变体的实现必须检查此处设置的值以确定正确的行为。</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setIgnoreUnresolvableNestedPlaceholders</span><span class="params">(<span class="keyword">boolean</span> ignoreUnresolvableNestedPlaceholders)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指定必须存在哪些属性，以便由validateRequiredProperties（）验证</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setRequiredProperties</span><span class="params">(String... requiredProperties)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 验证setRequiredProperties指定的每个属性是否存在并解析为非null值</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">validateRequiredProperties</span><span class="params">()</span> <span class="keyword">throws</span> MissingRequiredPropertiesException</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从 ConfigurablePropertyResolver 所提供的方法来看，除了访问和设置 ConversionService 外，主要还提供了一些解析规则之类的方法。</p><p>就 Properties 体系而言，PropertyResolver 定义了访问 Properties 属性值的方法，而 ConfigurablePropertyResolver 则定义了解析 Properties 一些相关的规则和值进行类型转换所需要的 Service。</p><p>该体系有两个实现者：<code>AbstractPropertyResolver</code> 和 <code>PropertySourcesPropertyResolver</code>，其中 <code>AbstractPropertyResolver</code> 为实现的抽象基类，<code>PropertySourcesPropertyResolver</code> 为真正的实现者。</p><h3 id="AbstractPropertyResolver"><a href="#AbstractPropertyResolver" class="headerlink" title="AbstractPropertyResolver"></a>AbstractPropertyResolver</h3><blockquote><p>解析属性文件的抽象基类</p></blockquote><p>AbstractPropertyResolver 作为基类它仅仅只是设置了一些解析属性文件所需要配置或者转换器，如 <code>setConversionService()</code>、<code>setPlaceholderPrefix()</code>、<code>setValueSeparator()</code>，其实这些方法的实现都比较简单都是设置或者获取 AbstractPropertyResolver 所提供的属性，如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 类型转换去</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> ConfigurableConversionService conversionService;</span><br><span class="line"><span class="comment">// 占位符</span></span><br><span class="line"><span class="keyword">private</span> PropertyPlaceholderHelper nonStrictHelper;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">private</span> PropertyPlaceholderHelper strictHelper;</span><br><span class="line"><span class="comment">// 设置是否抛出异常</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> ignoreUnresolvableNestedPlaceholders = <span class="keyword">false</span>;</span><br><span class="line"><span class="comment">// 占位符前缀</span></span><br><span class="line"><span class="keyword">private</span> String placeholderPrefix = SystemPropertyUtils.PLACEHOLDER_PREFIX;</span><br><span class="line"><span class="comment">// 占位符后缀</span></span><br><span class="line"><span class="keyword">private</span> String placeholderSuffix = SystemPropertyUtils.PLACEHOLDER_SUFFIX;</span><br><span class="line"><span class="comment">// 与默认值的分割</span></span><br><span class="line"><span class="keyword">private</span> String valueSeparator = SystemPropertyUtils.VALUE_SEPARATOR;</span><br><span class="line"><span class="comment">// 必须要有的字段值</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Set&lt;String&gt; requiredProperties = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br></pre></td></tr></table></figure><p>这些属性都是 ConfigurablePropertyResolver 接口所提供方法需要的属性，他所提供的方法都是设置和读取这些值，如下几个方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ConfigurableConversionService <span class="title">getConversionService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 需要提供独立的DefaultConversionService，而不是PropertySourcesPropertyResolver 使用的共享DefaultConversionService。</span></span><br><span class="line">  ConfigurableConversionService cs = <span class="keyword">this</span>.conversionService;</span><br><span class="line">  <span class="keyword">if</span> (cs == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">      cs = <span class="keyword">this</span>.conversionService;</span><br><span class="line">      <span class="keyword">if</span> (cs == <span class="keyword">null</span>) &#123;</span><br><span class="line">        cs = <span class="keyword">new</span> DefaultConversionService();</span><br><span class="line">        <span class="keyword">this</span>.conversionService = cs;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> cs;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setConversionService</span><span class="params">(ConfigurableConversionService conversionService)</span> </span>&#123;</span><br><span class="line">  Assert.notNull(conversionService, <span class="string">&quot;ConversionService must not be null&quot;</span>);</span><br><span class="line">  <span class="keyword">this</span>.conversionService = conversionService;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPlaceholderPrefix</span><span class="params">(String placeholderPrefix)</span> </span>&#123;</span><br><span class="line">  Assert.notNull(placeholderPrefix, <span class="string">&quot;&#x27;placeholderPrefix&#x27; must not be null&quot;</span>);</span><br><span class="line">  <span class="keyword">this</span>.placeholderPrefix = placeholderPrefix;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPlaceholderSuffix</span><span class="params">(String placeholderSuffix)</span> </span>&#123;</span><br><span class="line">  Assert.notNull(placeholderSuffix, <span class="string">&quot;&#x27;placeholderSuffix&#x27; must not be null&quot;</span>);</span><br><span class="line">  <span class="keyword">this</span>.placeholderSuffix = placeholderSuffix;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而对属性的访问则委托给子类 PropertySourcesPropertyResolver 实现。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getProperty</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> getProperty(key, String.class);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getProperty</span><span class="params">(String key, String defaultValue)</span> </span>&#123;</span><br><span class="line">  String value = getProperty(key);</span><br><span class="line">  <span class="keyword">return</span> (value != <span class="keyword">null</span> ? value : defaultValue);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getProperty</span><span class="params">(String key, Class&lt;T&gt; targetType, T defaultValue)</span> </span>&#123;</span><br><span class="line">  T value = getProperty(key, targetType);</span><br><span class="line">  <span class="keyword">return</span> (value != <span class="keyword">null</span> ? value : defaultValue);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getRequiredProperty</span><span class="params">(String key)</span> <span class="keyword">throws</span> IllegalStateException </span>&#123;</span><br><span class="line">  String value = getProperty(key);</span><br><span class="line">  <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Required key &#x27;&quot;</span> + key + <span class="string">&quot;&#x27; not found&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getRequiredProperty</span><span class="params">(String key, Class&lt;T&gt; valueType)</span> <span class="keyword">throws</span> IllegalStateException </span>&#123;</span><br><span class="line">  T value = getProperty(key, valueType);</span><br><span class="line">  <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Required key &#x27;&quot;</span> + key + <span class="string">&quot;&#x27; not found&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> value;</span><br></pre></td></tr></table></figure><h3 id="PropertySourcesPropertyResolver"><a href="#PropertySourcesPropertyResolver" class="headerlink" title="PropertySourcesPropertyResolver"></a>PropertySourcesPropertyResolver</h3><blockquote><p>PropertyResolver 的实现者，他对一组 PropertySources 提供属性解析服务</p></blockquote><p>它仅有一个成员变量：PropertySources。该成员变量内部存储着一组 PropertySource，表示 key-value 键值对的源的抽象基类，即一个 PropertySource 对象则是一个 key-value 键值对。如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">PropertySource</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> Log logger = LogFactory.getLog(getClass());</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> String name;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> T source;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对外公开的 <code>getProperty()</code> 都是委托给 <code>getProperty(String key, Class&lt;T&gt; targetValueType, boolean resolveNestedPlaceholders)</code> 实现，他有三个参数，分别表示为：</p><ul><li>key：获取的 key</li><li>targetValueType： 目标 value 的类型</li><li>resolveNestedPlaceholders：是否解决嵌套占位符</li></ul><p>源码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function">T <span class="title">getProperty</span><span class="params">(String key, Class&lt;T&gt; targetValueType, <span class="keyword">boolean</span> resolveNestedPlaceholders)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.propertySources != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (PropertySource&lt;?&gt; propertySource : <span class="keyword">this</span>.propertySources) &#123;</span><br><span class="line">      <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">        logger.trace(<span class="string">&quot;Searching for key &#x27;&quot;</span> + key + <span class="string">&quot;&#x27; in PropertySource &#x27;&quot;</span> +</span><br><span class="line">                     propertySource.getName() + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      Object value = propertySource.getProperty(key);</span><br><span class="line">      <span class="keyword">if</span> (value != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (resolveNestedPlaceholders &amp;&amp; value <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">          value = resolveNestedPlaceholders((String) value);</span><br><span class="line">        &#125;</span><br><span class="line">        logKeyFound(key, propertySource, value);</span><br><span class="line">        <span class="keyword">return</span> convertValueIfNecessary(value, targetValueType);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">    logger.debug(<span class="string">&quot;Could not find key &#x27;&quot;</span> + key + <span class="string">&quot;&#x27; in any property source&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先从 propertySource 中获取指定 key 的 value 值，然后判断是否需要进行嵌套占位符解析，如果需要则调用 <code>resolveNestedPlaceholders()</code> 进行嵌套占位符解析，然后调用 <code>convertValueIfNecessary()</code> 进行类型转换。</p><p><strong>resolveNestedPlaceholders()</strong></p><p>该方法用于解析给定字符串中的占位符，同时根据 ignoreUnresolvableNestedPlaceholders 的值，来确定是否对不可解析的占位符的处理方法：是忽略还是抛出异常（该值由 <code>setIgnoreUnresolvableNestedPlaceholders()</code> 设置）。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> String <span class="title">resolveNestedPlaceholders</span><span class="params">(String value)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">this</span>.ignoreUnresolvableNestedPlaceholders ?</span><br><span class="line">          resolvePlaceholders(value) : resolveRequiredPlaceholders(value));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果 this.ignoreUnresolvableNestedPlaceholders 为 true，则调用 <code>resolvePlaceholders()</code> ，否则调用 <code>resolveRequiredPlaceholders()</code>但是无论是哪个方法，最终都会到 <code>doResolvePlaceholders()</code>，该方法接收两个参数：</p><ul><li>String 类型的 text：待解析的字符串</li><li>PropertyPlaceholderHelper 类型的 helper：用于解析占位符的工具类。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">doResolvePlaceholders</span><span class="params">(String text, PropertyPlaceholderHelper helper)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> helper.replacePlaceholders(text, <span class="keyword">this</span>::getPropertyAsRawString);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PropertyPlaceholderHelper 是用于处理包含占位符值的字符串，构造该实例需要四个参数：</p><ul><li>placeholderPrefix：占位符前缀</li><li>placeholderSuffix：占位符后缀</li><li>valueSeparator：占位符变量与关联的默认值之间的分隔符</li><li>ignoreUnresolvablePlaceholders：指示是否忽略不可解析的占位符（true）或抛出异常（false）</li></ul><p>构造函数如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PropertyPlaceholderHelper</span><span class="params">(String placeholderPrefix, String placeholderSuffix,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 <span class="meta">@Nullable</span> String valueSeparator, <span class="keyword">boolean</span> ignoreUnresolvablePlaceholders)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  Assert.notNull(placeholderPrefix, <span class="string">&quot;&#x27;placeholderPrefix&#x27; must not be null&quot;</span>);</span><br><span class="line">  Assert.notNull(placeholderSuffix, <span class="string">&quot;&#x27;placeholderSuffix&#x27; must not be null&quot;</span>);</span><br><span class="line">  <span class="keyword">this</span>.placeholderPrefix = placeholderPrefix;</span><br><span class="line">  <span class="keyword">this</span>.placeholderSuffix = placeholderSuffix;</span><br><span class="line">  String simplePrefixForSuffix = wellKnownSimplePrefixes.get(<span class="keyword">this</span>.placeholderSuffix);</span><br><span class="line">  <span class="keyword">if</span> (simplePrefixForSuffix != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.placeholderPrefix.endsWith(simplePrefixForSuffix)) &#123;</span><br><span class="line">    <span class="keyword">this</span>.simplePrefix = simplePrefixForSuffix;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.simplePrefix = <span class="keyword">this</span>.placeholderPrefix;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.valueSeparator = valueSeparator;</span><br><span class="line">  <span class="keyword">this</span>.ignoreUnresolvablePlaceholders = ignoreUnresolvablePlaceholders;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就 PropertySourcesPropertyResolver 而言，其父类 AbstractPropertyResolver 已经对上述四个值做了定义：placeholderPrefix 为 <code>$&#123;</code>，placeholderSuffix 为 <code>&#125;</code>，valueSeparator 为 <code>:</code>，ignoreUnresolvablePlaceholders 默认为 false，当然我们也可以使用相应的 setter 方法自定义。</p><p>调用 PropertyPlaceholderHelper 的 <code>replacePlaceholders()</code> 对占位符进行处理，该方法接收两个参数，一个是待解析的字符串 value ，一个是 PlaceholderResolver 类型的 placeholderResolver，他是定义占位符解析的策略类。如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">replacePlaceholders</span><span class="params">(String value, PlaceholderResolver placeholderResolver)</span> </span>&#123;</span><br><span class="line">  Assert.notNull(value, <span class="string">&quot;&#x27;value&#x27; must not be null&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> parseStringValue(value, placeholderResolver, <span class="keyword">new</span> HashSet&lt;&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内部委托给 <code>parseStringValue()</code> 实现：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> String <span class="title">parseStringValue</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  String value, PlaceholderResolver placeholderResolver, Set&lt;String&gt; visitedPlaceholders)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  StringBuilder result = <span class="keyword">new</span> StringBuilder(value);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 检索前缀，$&#123;</span></span><br><span class="line">  <span class="keyword">int</span> startIndex = value.indexOf(<span class="keyword">this</span>.placeholderPrefix);</span><br><span class="line">  <span class="keyword">while</span> (startIndex != -<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">// 检索后缀 ,&#125;</span></span><br><span class="line">    <span class="keyword">int</span> endIndex = findPlaceholderEndIndex(result, startIndex);</span><br><span class="line">    <span class="keyword">if</span> (endIndex != -<span class="number">1</span>) &#123;</span><br><span class="line">      <span class="comment">// 前缀和后缀之间的字符串</span></span><br><span class="line">      String placeholder = result.substring(startIndex + <span class="keyword">this</span>.placeholderPrefix.length(), endIndex);</span><br><span class="line">      String originalPlaceholder = placeholder;</span><br><span class="line">      <span class="comment">// 循环占位符</span></span><br><span class="line">      <span class="comment">// 判断该占位符是否已经处理了</span></span><br><span class="line">      <span class="keyword">if</span> (!visitedPlaceholders.add(originalPlaceholder)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">          <span class="string">&quot;Circular placeholder reference &#x27;&quot;</span> + originalPlaceholder + <span class="string">&quot;&#x27; in property definitions&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 递归调用，解析占位符</span></span><br><span class="line">      placeholder = parseStringValue(placeholder, placeholderResolver, visitedPlaceholders);</span><br><span class="line">      <span class="comment">// 获取值</span></span><br><span class="line">      String propVal = placeholderResolver.resolvePlaceholder(placeholder);</span><br><span class="line">      <span class="comment">// propval 为空，则提取默认值</span></span><br><span class="line">      <span class="keyword">if</span> (propVal == <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.valueSeparator != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> separatorIndex = placeholder.indexOf(<span class="keyword">this</span>.valueSeparator);</span><br><span class="line">        <span class="keyword">if</span> (separatorIndex != -<span class="number">1</span>) &#123;</span><br><span class="line">          String actualPlaceholder = placeholder.substring(<span class="number">0</span>, separatorIndex);</span><br><span class="line">          String defaultValue = placeholder.substring(separatorIndex + <span class="keyword">this</span>.valueSeparator.length());</span><br><span class="line">          propVal = placeholderResolver.resolvePlaceholder(actualPlaceholder);</span><br><span class="line">          <span class="keyword">if</span> (propVal == <span class="keyword">null</span>) &#123;</span><br><span class="line">            propVal = defaultValue;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (propVal != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 递归调用，解析先前解析的占位符值中包含的占位符</span></span><br><span class="line">        propVal = parseStringValue(propVal, placeholderResolver, visitedPlaceholders);</span><br><span class="line">        result.replace(startIndex, endIndex + <span class="keyword">this</span>.placeholderSuffix.length(), propVal);</span><br><span class="line">        <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">          logger.trace(<span class="string">&quot;Resolved placeholder &#x27;&quot;</span> + placeholder + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        startIndex = result.indexOf(<span class="keyword">this</span>.placeholderPrefix, startIndex + propVal.length());</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.ignoreUnresolvablePlaceholders) &#123;</span><br><span class="line">        <span class="comment">// Proceed with unprocessed value.</span></span><br><span class="line">        startIndex = result.indexOf(<span class="keyword">this</span>.placeholderPrefix, endIndex + <span class="keyword">this</span>.placeholderSuffix.length());</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Could not resolve placeholder &#x27;&quot;</span> +</span><br><span class="line">                                           placeholder + <span class="string">&quot;&#x27;&quot;</span> + <span class="string">&quot; in value \&quot;&quot;</span> + value + <span class="string">&quot;\&quot;&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">      visitedPlaceholders.remove(originalPlaceholder);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      startIndex = -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实就是获取占位符 <code>$&#123;&#125;</code> 中间的值，这里面会涉及到一个递归的过程，因为可能会存在这种情况 <code>$&#123;$&#123;name&#125;&#125;</code>。</p><p><strong>convertValueIfNecessary()</strong></p><p>该方法是不是感觉到非常的熟悉，该方法就是完成类型转换的。如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function">T <span class="title">convertValueIfNecessary</span><span class="params">(Object value, <span class="meta">@Nullable</span> Class&lt;T&gt; targetType)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (targetType == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (T) value;</span><br><span class="line">  &#125;</span><br><span class="line">  ConversionService conversionServiceToUse = <span class="keyword">this</span>.conversionService;</span><br><span class="line">  <span class="keyword">if</span> (conversionServiceToUse == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// Avoid initialization of shared DefaultConversionService if</span></span><br><span class="line">    <span class="comment">// no standard type conversion is needed in the first place...</span></span><br><span class="line">    <span class="keyword">if</span> (ClassUtils.isAssignableValue(targetType, value)) &#123;</span><br><span class="line">      <span class="keyword">return</span> (T) value;</span><br><span class="line">    &#125;</span><br><span class="line">    conversionServiceToUse = DefaultConversionService.getSharedInstance();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> conversionServiceToUse.convert(value, targetType);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先获取类型转换服务 conversionService ，若为空，则判断是否可以通过反射来设置，如果可以则直接强转返回，否则构造一个 DefaultConversionService 实例，最后调用其 <code>convert()</code> 完成类型转换，后续就是 Spring 类型转换体系的事情了，如果对其不了解，可以参考小编这篇博客：<a href="/2020/01/24/683bb448.html">IOC 之深入分析 Bean 的类型转换体系</a></p><h2 id="Environment"><a href="#Environment" class="headerlink" title="Environment"></a>Environment</h2><blockquote><p>表示当前应用程序正在运行的环境</p></blockquote><p>应用程序的环境有两个关键方面：profile 和 properties。</p><ul><li>properties 的方法由 PropertyResolver 定义。</li><li>profile 则表示当前的运行环境，对于应用程序中的 properties 而言，并不是所有的都会加载到系统中，只有其属性与 profile 一直才会被激活加载，</li></ul><p>所以 Environment 对象的作用是确定哪些配置文件（如果有）当前处于活动状态，以及默认情况下哪些配置文件（如果有）应处于活动状态。properties 在几乎所有应用程序中都发挥着重要作用，并且有多种来源：属性文件，JVM 系统属性，系统环境变量，JNDI，servlet 上下文参数，ad-hoc 属性对象，映射等。同时它继承 PropertyResolver 接口，所以与属性相关的 Environment 对象其主要是为用户提供方便的服务接口，用于配置属性源和从中属性源中解析属性。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Environment</span> <span class="keyword">extends</span> <span class="title">PropertyResolver</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 返回此环境下激活的配置文件集</span></span><br><span class="line">    String[] getActiveProfiles();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果未设置激活配置文件，则返回默认的激活的配置文件集</span></span><br><span class="line">    String[] getDefaultProfiles();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">acceptsProfiles</span><span class="params">(String... profiles)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Environment 体系结构图如下：</p><p><img src="https://gitee.com/cayzlh/img-repo/raw/master/2020/05/27/15403714670613_02ZL9z_ul8OAy.jpg" alt="img"></p><ul><li>PropertyResolver：提供属性访问功能</li><li>Environment：提供访问和判断 profiles 的功能</li><li>ConfigurableEnvironment：提供设置激活的 profile 和默认的 profile 的功能以及操作 Properties 的工具</li><li>ConfigurableWebEnvironment：提供配置 Servlet 上下文和 Servlet 参数的功能</li><li>AbstractEnvironment：实现了 ConfigurableEnvironment 接口，默认属性和存储容器的定义，并且实现了 ConfigurableEnvironment 的方法，并且为子类预留可覆盖了扩展方法</li><li>StandardEnvironment：继承自 AbstractEnvironment ，非 Servlet(Web) 环境下的标准 Environment 实现</li><li>StandardServletEnvironment：继承自 StandardEnvironment ，Servlet(Web) 环境下的标准 Environment 实现</li></ul><h3 id="ConfigurableEnvironment"><a href="#ConfigurableEnvironment" class="headerlink" title="ConfigurableEnvironment"></a>ConfigurableEnvironment</h3><blockquote><p>提供设置激活的 profile 和默认的 profile 的功能以及操作 Properties 的工具</p></blockquote><p>该类除了继承 Environment 接口外还继承了 ConfigurablePropertyResolver 接口，所以它即具备了设置 profile 的功能也具备了操作 Properties 的功能。同时还允许客户端通过它设置和验证所需要的属性，自定义转换服务等功能。如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ConfigurableEnvironment</span> <span class="keyword">extends</span> <span class="title">Environment</span>, <span class="title">ConfigurablePropertyResolver</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 指定该环境下的 profile 集</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setActiveProfiles</span><span class="params">(String... profiles)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 增加此环境的 profile</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addActiveProfile</span><span class="params">(String profile)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置默认的 profile</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setDefaultProfiles</span><span class="params">(String... profiles)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回此环境的 PropertySources</span></span><br><span class="line">    <span class="function">MutablePropertySources <span class="title">getPropertySources</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 尝试返回 System.getenv() 的值，若失败则返回通过 System.getenv(string) 的来访问各个键的映射</span></span><br><span class="line">    <span class="function">Map&lt;String, Object&gt; <span class="title">getSystemEnvironment</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试返回 System.getProperties() 的值，若失败则返回通过 System.getProperties(string) 的来访问各个键的映射</span></span><br><span class="line">    <span class="function">Map&lt;String, Object&gt; <span class="title">getSystemProperties</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(ConfigurableEnvironment parent)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="AbstractEnvironment"><a href="#AbstractEnvironment" class="headerlink" title="AbstractEnvironment"></a>AbstractEnvironment</h3><blockquote><p>Environment 的基础实现</p></blockquote><p>允许通过设置 ACTIVE_PROFILES_PROPERTY_NAME 和DEFAULT_PROFILES_PROPERTY_NAME 属性指定活动和默认配置文件。子类的主要区别在于它们默认添加的 PropertySource 对象。而 AbstractEnvironment 则没有添加任何内容。子类应该通过受保护的 <code>customizePropertySources(MutablePropertySources)</code> 钩子提供属性源，而客户端应该使用<code>ConfigurableEnvironment.getPropertySources()</code>进行自定义并对MutablePropertySources API进行操作。</p><p>在 AbstractEnvironment 有两对变量，这两对变量维护着激活和默认配置 profile。如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String ACTIVE_PROFILES_PROPERTY_NAME = <span class="string">&quot;spring.profiles.active&quot;</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Set&lt;String&gt; activeProfiles = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_PROFILES_PROPERTY_NAME = <span class="string">&quot;spring.profiles.default&quot;</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Set&lt;String&gt; defaultProfiles = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(getReservedDefaultProfiles());</span><br></pre></td></tr></table></figure><p>由于实现方法较多，这里只关注两个方法：<code>setActiveProfiles()</code> 和 <code>getActiveProfiles()</code>。</p><p><strong>setActiveProfiles()</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setActiveProfiles</span><span class="params">(String... profiles)</span> </span>&#123;</span><br><span class="line">  Assert.notNull(profiles, <span class="string">&quot;Profile array must not be null&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">    logger.debug(<span class="string">&quot;Activating profiles &quot;</span> + Arrays.asList(profiles));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">synchronized</span> (<span class="keyword">this</span>.activeProfiles) &#123;</span><br><span class="line">    <span class="keyword">this</span>.activeProfiles.clear();</span><br><span class="line">    <span class="keyword">for</span> (String profile : profiles) &#123;</span><br><span class="line">      validateProfile(profile);</span><br><span class="line">      <span class="keyword">this</span>.activeProfiles.add(profile);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法其实就是操作 activeProfiles 集合，在每次设置之前都会将该集合清空重新添加，添加之前调用 <code>validateProfile()</code> 对添加的 profile 进行校验，如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">validateProfile</span><span class="params">(String profile)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!StringUtils.hasText(profile)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Invalid profile [&quot;</span> + profile + <span class="string">&quot;]: must contain text&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (profile.charAt(<span class="number">0</span>) == <span class="string">&#x27;!&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Invalid profile [&quot;</span> + profile + <span class="string">&quot;]: must not begin with ! operator&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个校验过程比较弱，子类可以提供更加严格的校验规则。</p><p><strong>getActiveProfiles()</strong></p><p>从 <code>getActiveProfiles()</code> 中我们可以猜出这个方法实现的逻辑：获取 activeProfiles 集合即可。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String[] getActiveProfiles() &#123;</span><br><span class="line">  <span class="keyword">return</span> StringUtils.toStringArray(doGetActiveProfiles());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>委托给 <code>doGetActiveProfiles()</code> 实现：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Set&lt;String&gt; <span class="title">doGetActiveProfiles</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">synchronized</span> (<span class="keyword">this</span>.activeProfiles) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.activeProfiles.isEmpty()) &#123;</span><br><span class="line">      String profiles = getProperty(ACTIVE_PROFILES_PROPERTY_NAME);</span><br><span class="line">      <span class="keyword">if</span> (StringUtils.hasText(profiles)) &#123;</span><br><span class="line">        setActiveProfiles(StringUtils.commaDelimitedListToStringArray(</span><br><span class="line">          StringUtils.trimAllWhitespace(profiles)));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.activeProfiles;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果 activeProfiles 为空，则从 Properties 中获取 spring.profiles.active 配置，如果不为空，则调用 <code>setActiveProfiles()</code> 设置 profile，最后返回。</p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
          <category> 《Spring源码分析》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> 死磕Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IOC之BeanDefinition注册机：BeanDefinitionRegistry</title>
      <link href="/blog/2020/01/25/86c712d3.html"/>
      <url>/blog/2020/01/25/86c712d3.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文作者：chenssy</p><p>出处：<a href="http://cmsblogs.com/?p=4026">http://cmsblogs.com/?p=4026</a></p><p>在学习<code>Spring源码</code>的过程中发现的好站+好贴，原创不易感谢作者。</p><p>Spring版本：<strong>Spring 5.0.6.RELEASE</strong></p></blockquote><p>将定义 bean 的资源文件解析成 BeanDefinition 后需要将其注入容器中，这个过程由 BeanDefinitionRegistry 来完成。</p><p><strong>BeanDefinitionRegistry：向注册表中注册 BeanDefinition 实例，完成注册的过程。</strong></p><p>下图是 BeanDefinitionRegistry 类结构图：</p><p><img src="https://gitee.com/cayzlh/img-repo/raw/master/2020/05/27/15397559425630_7v1hdo_IqTnko.jpg" alt="img"></p><p>BeanDefinitionRegistry 继承了 AliasRegistry 接口，其核心子类有三个：<code>SimpleBeanDefinitionRegistry</code>、<code>DefaultListableBeanFactory</code>、<code>GenericApplicationContext</code>。</p><h2 id="AliasRegistry"><a href="#AliasRegistry" class="headerlink" title="AliasRegistry"></a>AliasRegistry</h2><p><strong>用于别名管理的通用型接口，作为 BeanDefinitionRegistry 的顶层接口。</strong> AliasRegistry 定义了一些别名管理的方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AliasRegistry</span> </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">registerAlias</span><span class="params">(String name, String alias)</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">removeAlias</span><span class="params">(String alias)</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">boolean</span> <span class="title">isAlias</span><span class="params">(String name)</span></span>;</span><br><span class="line"></span><br><span class="line"> String[] getAliases(String name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BeanDefinitionRegistry"><a href="#BeanDefinitionRegistry" class="headerlink" title="BeanDefinitionRegistry"></a>BeanDefinitionRegistry</h2><p><strong>BeanDefinition 的注册接口，如 RootBeanDefinition 和 ChildBeanDefinition。它通常由 BeanFactories 实现，在 Spring 中已知的实现者为：DefaultListableBeanFactory 和 GenericApplicationContext。BeanDefinitionRegistry 是 Spring 的 Bean 工厂包中唯一封装 BeanDefinition 注册的接口。</strong></p><p>BeanDefinitionRegistry 接口定义了关于 BeanDefinition 注册、注销、查询等一系列的操作。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanDefinitionRegistry</span> <span class="keyword">extends</span> <span class="title">AliasRegistry</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 往注册表中注册一个新的 BeanDefinition 实例</span></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">registerBeanDefinition</span><span class="params">(String beanName, BeanDefinition beanDefinition)</span></span></span><br><span class="line"><span class="function">   <span class="keyword">throws</span> BeanDefinitionStoreException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移除注册表中已注册的 BeanDefinition 实例</span></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">removeBeanDefinition</span><span class="params">(String beanName)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从注册中取得指定的 BeanDefinition 实例</span></span><br><span class="line"> <span class="function">BeanDefinition <span class="title">getBeanDefinition</span><span class="params">(String beanName)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断 BeanDefinition 实例是否在注册表中（是否注册）</span></span><br><span class="line"> <span class="function"><span class="keyword">boolean</span> <span class="title">containsBeanDefinition</span><span class="params">(String beanName)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取得注册表中所有 BeanDefinition 实例的 beanName（标识）</span></span><br><span class="line"> String[] getBeanDefinitionNames();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回注册表中 BeanDefinition 实例的数量</span></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">getBeanDefinitionCount</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// beanName（标识）是否被占用</span></span><br><span class="line"> <span class="function"><span class="keyword">boolean</span> <span class="title">isBeanNameInUse</span><span class="params">(String beanName)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="SimpleBeanDefinitionRegistry"><a href="#SimpleBeanDefinitionRegistry" class="headerlink" title="SimpleBeanDefinitionRegistry"></a>SimpleBeanDefinitionRegistry</h2><p><strong>SimpleBeanDefinitionRegistry 是 BeanDefinitionRegistry 一个简单的实现，它还继承 SimpleAliasRegistry（ AliasRegistry 的简单实现），它仅仅只提供注册表功能，无工厂功能</strong>。</p><p>SimpleBeanDefinitionRegistry 使用 ConcurrentHashMap 来存储注册的 BeanDefinition。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, BeanDefinition&gt; beanDefinitionMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="number">64</span>);</span><br></pre></td></tr></table></figure><p>他对注册其中的 BeanDefinition 都是基于 beanDefinitionMap 这个集合来实现的，如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinition</span><span class="params">(String beanName, BeanDefinition beanDefinition)</span></span></span><br><span class="line"><span class="function">  <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line"></span><br><span class="line"> Assert.hasText(beanName, <span class="string">&quot;&#x27;beanName&#x27; must not be empty&quot;</span>);</span><br><span class="line"> Assert.notNull(beanDefinition, <span class="string">&quot;BeanDefinition must not be null&quot;</span>);</span><br><span class="line"> <span class="keyword">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeBeanDefinition</span><span class="params">(String beanName)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException </span>&#123;</span><br><span class="line"> <span class="keyword">if</span> (<span class="keyword">this</span>.beanDefinitionMap.remove(beanName) == <span class="keyword">null</span>) &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchBeanDefinitionException(beanName);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BeanDefinition <span class="title">getBeanDefinition</span><span class="params">(String beanName)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException </span>&#123;</span><br><span class="line"> BeanDefinition bd = <span class="keyword">this</span>.beanDefinitionMap.get(beanName);</span><br><span class="line"> <span class="keyword">if</span> (bd == <span class="keyword">null</span>) &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchBeanDefinitionException(beanName);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> bd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现简单、粗暴。</p><h2 id="DefaultListableBeanFactory"><a href="#DefaultListableBeanFactory" class="headerlink" title="DefaultListableBeanFactory"></a>DefaultListableBeanFactory</h2><p><strong>DefaultListableBeanFactory，ConfigurableListableBeanFactory（其实就是 BeanFactory ） 和 BeanDefinitionRegistry 接口的默认实现：一个基于 BeanDefinition 元数据的完整 bean 工厂</strong>。</p><p>所以相对于 SimpleBeanDefinitionRegistry 而言，DefaultListableBeanFactory 则是一个具有注册功能的完整 bean 工厂。它同样是用 ConcurrentHashMap 数据结构来存储注册的 BeanDefinition。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注册表，由 BeanDefinition 的标识 （beanName） 与其实例组成</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, BeanDefinition&gt; beanDefinitionMap = <span class="keyword">new</span> ConcurrentHashMap&lt;String, bean&gt;(<span class="number">64</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 标识（beanName）集合</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> List&lt;String&gt; beanDefinitionNames = <span class="keyword">new</span> ArrayList&lt;String&gt;(<span class="number">64</span>);</span><br></pre></td></tr></table></figure><p>在看 <code>registerBeanDefinition()</code>：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinition</span><span class="params">(String beanName, BeanDefinition beanDefinition)</span></span></span><br><span class="line"><span class="function">  <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 省略其他代码</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (hasBeanCreationStarted()) &#123;</span><br><span class="line">      <span class="comment">// Cannot modify startup-time collection elements anymore (for stable iteration)</span></span><br><span class="line">      <span class="keyword">synchronized</span> (<span class="keyword">this</span>.beanDefinitionMap) &#123;</span><br><span class="line">        <span class="keyword">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">        List&lt;String&gt; updatedDefinitions = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="keyword">this</span>.beanDefinitionNames.size() + <span class="number">1</span>);</span><br><span class="line">        updatedDefinitions.addAll(<span class="keyword">this</span>.beanDefinitionNames);</span><br><span class="line">        updatedDefinitions.add(beanName);</span><br><span class="line">        <span class="keyword">this</span>.beanDefinitionNames = updatedDefinitions;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.manualSingletonNames.contains(beanName)) &#123;</span><br><span class="line">          Set&lt;String&gt; updatedSingletons = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(<span class="keyword">this</span>.manualSingletonNames);</span><br><span class="line">          updatedSingletons.remove(beanName);</span><br><span class="line">          <span class="keyword">this</span>.manualSingletonNames = updatedSingletons;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 注册 BeanDefinition</span></span><br><span class="line">      <span class="keyword">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">      <span class="keyword">this</span>.beanDefinitionNames.add(beanName);</span><br><span class="line">      <span class="keyword">this</span>.manualSingletonNames.remove(beanName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.frozenBeanDefinitionNames = <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (existingDefinition != <span class="keyword">null</span> || containsSingleton(beanName)) &#123;</span><br><span class="line">    resetBeanDefinition(beanName);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实上面一堆代码最重要就只有一句：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br></pre></td></tr></table></figure><p><code>removeBeanDefinition()</code> 其实也是调用 <code>beanDefinitionMap.remove(beanName)</code>。</p><p>对于类 GenericApplicationContext ，查看源码你会发现他实现注册、注销功能都是委托 DefaultListableBeanFactory 实现的。</p><blockquote><p>所以 BeanDefinition 注册并不是非常高大上的功能，内部就是用一个 Map 实现 ，并不是多么高大上的骚操作，所以有时候我们会潜意识地认为某些技术很高大上就觉得他很深奥，如果试着去一探究竟你会发现，原来这么简单。虽然 BeanDefinitionRegistry 实现简单，但是它作为 Spring IOC 容器的核心接口，其地位还是很重的。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
          <category> 《Spring源码分析》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> 死磕Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IOC之bean的实例化策略：InstantiationStrategy</title>
      <link href="/blog/2020/01/24/25302edf.html"/>
      <url>/blog/2020/01/24/25302edf.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文作者：chenssy</p><p>出处：<a href="http://cmsblogs.com/?p=4022">http://cmsblogs.com/?p=4022</a></p><p>在学习<code>Spring源码</code>的过程中发现的好站+好贴，原创不易感谢作者。</p><p>Spring版本：<strong>Spring 5.0.6.RELEASE</strong></p></blockquote><p>在开始分析 InstantiationStrategy 之前，我们先来简单回顾下 bean 的实例化过程：</p><ol><li>bean 的创建，主要是 <code>AbstractAutowireCapableBeanFactory.doCreateBean()</code> ，在这个方法中有 bean 的实例化、属性注入和初始化过程，对于 bean 的实例化过程这是根据 bean 的类型来判断的，如果是单例模式，则直接从 factoryBeanInstanceCache 缓存中获取，否则调用 <code>createBeanInstance()</code> 创建。</li><li>在 <code>createBeanInstance()</code> 中，如果 Supplier 不为空，则调用 <code>obtainFromSupplier()</code> 实例化 bean。如果 factory 不为空，则调用 <code>instantiateUsingFactoryMethod()</code> 实例化 bean ，如果都不是则调用 <code>instantiateBean()</code> 实例化bean 。但是无论是 <code>instantiateUsingFactoryMethod()</code> 还是 <code>instantiateBean()</code> 最后都一定会调用到 InstantiationStrategy 接口的 <code>instantiate()</code>。</li></ol><h2 id="InstantiationStrategy"><a href="#InstantiationStrategy" class="headerlink" title="InstantiationStrategy"></a>InstantiationStrategy</h2><p>InstantiationStrategy 接口定义了 Spring Bean 实例化的策略，根据创建对象情况的不同，提供了三种策略：<strong>无参构造方法</strong>、<strong>有参构造方法</strong>、<strong>工厂方法</strong>。如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">InstantiationStrategy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 默认构造方法</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function">Object <span class="title">instantiate</span><span class="params">(RootBeanDefinition bd, <span class="meta">@Nullable</span> String beanName, BeanFactory owner)</span></span></span><br><span class="line"><span class="function">   <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 指定构造方法</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function">Object <span class="title">instantiate</span><span class="params">(RootBeanDefinition bd, <span class="meta">@Nullable</span> String beanName, BeanFactory owner,</span></span></span><br><span class="line"><span class="function"><span class="params">   Constructor&lt;?&gt; ctor, <span class="meta">@Nullable</span> Object... args)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 工厂方法</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function">Object <span class="title">instantiate</span><span class="params">(RootBeanDefinition bd, <span class="meta">@Nullable</span> String beanName, BeanFactory owner,</span></span></span><br><span class="line"><span class="function"><span class="params">   <span class="meta">@Nullable</span> Object factoryBean, Method factoryMethod, <span class="meta">@Nullable</span> Object... args)</span></span></span><br><span class="line"><span class="function">   <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="SimpleInstantiationStrategy"><a href="#SimpleInstantiationStrategy" class="headerlink" title="SimpleInstantiationStrategy"></a>SimpleInstantiationStrategy</h3><p><code>InstantiationStrategy</code> 接口有两个实现类：<code>SimpleInstantiationStrategy</code> 和 <code>CglibSubclassingInstantiationStrategy</code>。</p><p><code>SimpleInstantiationStrategy</code> 对以上三个方法都做了简单的实现。</p><p>如果是工厂方法实例化，则直接使用反射创建对象，如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">instantiate</span><span class="params">(RootBeanDefinition bd, <span class="meta">@Nullable</span> String beanName, BeanFactory owner,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="meta">@Nullable</span> Object factoryBean, <span class="keyword">final</span> Method factoryMethod, <span class="meta">@Nullable</span> Object... args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">      AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; &#123;</span><br><span class="line">        ReflectionUtils.makeAccessible(factoryMethod);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      ReflectionUtils.makeAccessible(factoryMethod);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Method priorInvokedFactoryMethod = currentlyInvokedFactoryMethod.get();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      currentlyInvokedFactoryMethod.set(factoryMethod);</span><br><span class="line">      Object result = factoryMethod.invoke(factoryBean, args);</span><br><span class="line">      <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line">        result = <span class="keyword">new</span> NullBean();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (priorInvokedFactoryMethod != <span class="keyword">null</span>) &#123;</span><br><span class="line">        currentlyInvokedFactoryMethod.set(priorInvokedFactoryMethod);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        currentlyInvokedFactoryMethod.remove();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 省略 catch</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果是构造方法实例化，则是先判断是否有 MethodOverrides，如果没有则是直接使用反射，如果有则就需要 CGLIB 实例化对象。如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">instantiate</span><span class="params">(RootBeanDefinition bd, <span class="meta">@Nullable</span> String beanName, BeanFactory owner)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Don&#x27;t override the class with CGLIB if no overrides.</span></span><br><span class="line">  <span class="keyword">if</span> (!bd.hasMethodOverrides()) &#123;</span><br><span class="line">    Constructor&lt;?&gt; constructorToUse;</span><br><span class="line">    <span class="keyword">synchronized</span> (bd.constructorArgumentLock) &#123;</span><br><span class="line">      constructorToUse = (Constructor&lt;?&gt;) bd.resolvedConstructorOrFactoryMethod;</span><br><span class="line">      <span class="keyword">if</span> (constructorToUse == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">final</span> Class&lt;?&gt; clazz = bd.getBeanClass();</span><br><span class="line">        <span class="keyword">if</span> (clazz.isInterface()) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> BeanInstantiationException(clazz, <span class="string">&quot;Specified class is an interface&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            constructorToUse = AccessController.doPrivileged(</span><br><span class="line">              (PrivilegedExceptionAction&lt;Constructor&lt;?&gt;&gt;) clazz::getDeclaredConstructor);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span> &#123;</span><br><span class="line">            constructorToUse =   clazz.getDeclaredConstructor();</span><br><span class="line">          &#125;</span><br><span class="line">          bd.resolvedConstructorOrFactoryMethod = constructorToUse;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> BeanInstantiationException(clazz, <span class="string">&quot;No default constructor found&quot;</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> BeanUtils.instantiateClass(constructorToUse);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Must generate CGLIB subclass.</span></span><br><span class="line">    <span class="keyword">return</span> instantiateWithMethodInjection(bd, beanName, owner);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">instantiate</span><span class="params">(RootBeanDefinition bd, <span class="meta">@Nullable</span> String beanName, BeanFactory owner,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">final</span> Constructor&lt;?&gt; ctor, <span class="meta">@Nullable</span> Object... args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!bd.hasMethodOverrides()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// use own privileged to change accessibility (when security is on)</span></span><br><span class="line">      AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; &#123;</span><br><span class="line">        ReflectionUtils.makeAccessible(ctor);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (args != <span class="keyword">null</span> ? BeanUtils.instantiateClass(ctor, args) : BeanUtils.instantiateClass(ctor));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> instantiateWithMethodInjection(bd, beanName, owner, ctor, args);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SimpleInstantiationStrategy 对 <code>instantiateWithMethodInjection()</code> 的实现任务交给了子类 CglibSubclassingInstantiationStrategy。</p><h3 id="MethodOverrides"><a href="#MethodOverrides" class="headerlink" title="MethodOverrides"></a>MethodOverrides</h3><p>对于 MethodOverrides，在 BeanDefinitionParserDelegate 类解析 <code>&lt;bean/&gt;</code> 的时候是否还记得这两个方法：<code>parseLookupOverrideSubElements()</code> 和 <code>parseReplacedMethodSubElements()</code> 这两个方法分别用于解析 lookup-method 和 replaced-method。<code>parseLookupOverrideSubElements()</code> 源码如下：</p><p><img src="https://gitee.com/cayzlh/img-repo/raw/master/2020/05/27/15395929815414_38Okah_ZrNViV.jpg" alt="img"></p><p>更多关于 lookup-method 和 replaced-method 请看：<a href="/2020/01/24/fa973ffe.html">IOC 之解析 bean 标签：meta、lookup-method、replace-method</a></p><h3 id="CGLIB-实例化策略"><a href="#CGLIB-实例化策略" class="headerlink" title="CGLIB 实例化策略"></a>CGLIB 实例化策略</h3><p>类 CglibSubclassingInstantiationStrategy 为 Spring 实例化 bean 的默认实例化策略，其主要功能还是对父类功能进行补充：其父类将 CGLIB 的实例化策略委托其实现。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// SimpleInstantiationStrategy</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">instantiateWithMethodInjection</span><span class="params">(RootBeanDefinition bd, <span class="meta">@Nullable</span> String beanName, BeanFactory owner)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">&quot;Method Injection not supported in SimpleInstantiationStrategy&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CglibSubclassingInstantiationStrategy</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">instantiateWithMethodInjection</span><span class="params">(RootBeanDefinition bd, <span class="meta">@Nullable</span> String beanName, BeanFactory owner)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> instantiateWithMethodInjection(bd, beanName, owner, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CglibSubclassingInstantiationStrategy 实例化 bean 策略是通过其内部类 CglibSubclassCreator 来实现的。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">instantiateWithMethodInjection</span><span class="params">(RootBeanDefinition bd, <span class="meta">@Nullable</span> String beanName, BeanFactory owner,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                <span class="meta">@Nullable</span> Constructor&lt;?&gt; ctor, <span class="meta">@Nullable</span> Object... args)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> CglibSubclassCreator(bd, owner).instantiate(ctor, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建 CglibSubclassCreator 实例然后调用其 <code>instantiate()</code>，该方法用于动态创建子类实例，同时实现所需要的 lookups（lookup-method、replace-method）。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">instantiate</span><span class="params">(<span class="meta">@Nullable</span> Constructor&lt;?&gt; ctor, <span class="meta">@Nullable</span> Object... args)</span> </span>&#123;</span><br><span class="line">  Class&lt;?&gt; subclass = createEnhancedSubclass(<span class="keyword">this</span>.beanDefinition);</span><br><span class="line">  Object instance;</span><br><span class="line">  <span class="keyword">if</span> (ctor == <span class="keyword">null</span>) &#123;</span><br><span class="line">    instance = BeanUtils.instantiateClass(subclass);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      Constructor&lt;?&gt; enhancedSubclassConstructor = subclass.getConstructor(ctor.getParameterTypes());</span><br><span class="line">      instance = enhancedSubclassConstructor.newInstance(args);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BeanInstantiationException(<span class="keyword">this</span>.beanDefinition.getBeanClass(),</span><br><span class="line">                                           <span class="string">&quot;Failed to invoke constructor for CGLIB enhanced subclass [&quot;</span> + subclass.getName() + <span class="string">&quot;]&quot;</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//这个地方解决一个bug，bug提交报告https://jira.spring.io/browse/SPR-10785</span></span><br><span class="line">  <span class="comment">// SPR-10785: set callbacks directly on the instance instead of in the</span></span><br><span class="line">  <span class="comment">// enhanced class (via the Enhancer) in order to avoid memory leaks.</span></span><br><span class="line">  Factory factory = (Factory) instance;</span><br><span class="line">  factory.setCallbacks(<span class="keyword">new</span> Callback[] &#123;NoOp.INSTANCE,</span><br><span class="line">                                       <span class="keyword">new</span> LookupOverrideMethodInterceptor(<span class="keyword">this</span>.beanDefinition, <span class="keyword">this</span>.owner),</span><br><span class="line">                                       <span class="keyword">new</span> ReplaceOverrideMethodInterceptor(<span class="keyword">this</span>.beanDefinition, <span class="keyword">this</span>.owner)&#125;);</span><br><span class="line">  <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用 <code>createEnhancedSubclass()</code> 为提供的 BeanDefinition 创建 bean 类的增强子类。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Class&lt;?&gt; createEnhancedSubclass(RootBeanDefinition beanDefinition) &#123;</span><br><span class="line"> <span class="comment">// cglib里面的用法，对原始class进行增强，并设置callback</span></span><br><span class="line"> Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line"> enhancer.setSuperclass(beanDefinition.getBeanClass());</span><br><span class="line"> enhancer.setNamingPolicy(SpringNamingPolicy.INSTANCE);</span><br><span class="line"> <span class="keyword">if</span> (<span class="keyword">this</span>.owner <span class="keyword">instanceof</span> ConfigurableBeanFactory) &#123;</span><br><span class="line">  ClassLoader cl = ((ConfigurableBeanFactory) <span class="keyword">this</span>.owner).getBeanClassLoader();</span><br><span class="line">  enhancer.setStrategy(<span class="keyword">new</span> ClassLoaderAwareGeneratorStrategy(cl));</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// 过滤，自定义逻辑来指定调用的callback下标</span></span><br><span class="line"> enhancer.setCallbackFilter(<span class="keyword">new</span> MethodOverrideCallbackFilter(beanDefinition));</span><br><span class="line"> enhancer.setCallbackTypes(CALLBACK_TYPES);</span><br><span class="line"> <span class="keyword">return</span> enhancer.createClass();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取子类增强 class 后，如果 Constructor 实例 ctr 为空，则调用默认构造函数（<code>BeanUtils.instantiateClass()</code>）来实例化类，否则则根据构造函数类型获取具体的构造器，调用 <code>newInstance()</code> 实例化类。在 <code>createEnhancedSubclass()</code> 我们注意两行代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">enhancer.setCallbackFilter(<span class="keyword">new</span> MethodOverrideCallbackFilter(beanDefinition));</span><br><span class="line">enhancer.setCallbackTypes(CALLBACK_TYPES);</span><br></pre></td></tr></table></figure><p>通过 MethodOverrideCallbackFilter 来定义调用 callback 类型，MethodOverrideCallbackFilter 是用来定义 CGLIB 回调过滤方法的拦截器行为，它继承 CglibIdentitySupport 实现 CallbackFilter 接口， CallbackFilter 是 CGLIB 的一个回调过滤器，CglibIdentitySupport 则为 CGLIB 提供 <code>hashCode()</code> 和 <code>equals()</code> 方法，以确保 CGLIB 不会为每个 bean 生成不同的类。MethodOverrideCallbackFilter 实现 CallbackFilter <code>accept()</code>：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">accept</span><span class="params">(Method method)</span> </span>&#123;</span><br><span class="line">  MethodOverride methodOverride = getBeanDefinition().getMethodOverrides().getOverride(method);</span><br><span class="line">  <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">    logger.trace(<span class="string">&quot;Override for &#x27;&quot;</span> + method.getName() + <span class="string">&quot;&#x27; is [&quot;</span> + methodOverride + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (methodOverride == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> PASSTHROUGH;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (methodOverride <span class="keyword">instanceof</span> LookupOverride) &#123;</span><br><span class="line">    <span class="keyword">return</span> LOOKUP_OVERRIDE;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (methodOverride <span class="keyword">instanceof</span> ReplaceOverride) &#123;</span><br><span class="line">    <span class="keyword">return</span> METHOD_REPLACER;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">&quot;Unexpected MethodOverride subclass: &quot;</span> +</span><br><span class="line">                                          methodOverride.getClass().getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据 BeanDefinition 中定义的 MethodOverride 不同，返回不同的值， 这里返回的 PASSTHROUGH 、LOOKUP_OVERRIDE、METHOD_REPLACER 都是 Callbak 数组的下标，这里对应的数组为 CALLBACK_TYPES 数组，如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Class&lt;?&gt;[] CALLBACK_TYPES </span><br><span class="line">  = <span class="keyword">new</span> Class&lt;?&gt;[] &#123;NoOp.class, LookupOverrideMethodInterceptor.class, ReplaceOverrideMethodInterceptor.class&#125;;</span><br></pre></td></tr></table></figure><p>这里又定义了两个熟悉的拦截器 ：LookupOverrideMethodInterceptor 和 ReplaceOverrideMethodInterceptor，两个拦截器分别对应两个不同的 callback 业务：</p><p><strong>LookupOverrideMethodInterceptor</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">LookupOverrideMethodInterceptor</span> </span></span><br><span class="line"><span class="class">  <span class="keyword">extends</span> <span class="title">CglibIdentitySupport</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> BeanFactory owner;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">LookupOverrideMethodInterceptor</span><span class="params">(RootBeanDefinition beanDefinition, BeanFactory owner)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(beanDefinition);</span><br><span class="line">    <span class="keyword">this</span>.owner = owner;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object obj, Method method, Object[] args, MethodProxy mp)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    <span class="comment">// Cast is safe, as CallbackFilter filters are used selectively.</span></span><br><span class="line">    LookupOverride lo = (LookupOverride) getBeanDefinition().getMethodOverrides().getOverride(method);</span><br><span class="line">    Assert.state(lo != <span class="keyword">null</span>, <span class="string">&quot;LookupOverride not found&quot;</span>);</span><br><span class="line">    Object[] argsToUse = (args.length &gt; <span class="number">0</span> ? args : <span class="keyword">null</span>); <span class="comment">// if no-arg, don&#x27;t insist on args at all</span></span><br><span class="line">    <span class="keyword">if</span> (StringUtils.hasText(lo.getBeanName())) &#123;</span><br><span class="line">      <span class="keyword">return</span> (argsToUse != <span class="keyword">null</span> ? <span class="keyword">this</span>.owner.getBean(lo.getBeanName(), argsToUse) :</span><br><span class="line">              <span class="keyword">this</span>.owner.getBean(lo.getBeanName()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> (argsToUse != <span class="keyword">null</span> ? <span class="keyword">this</span>.owner.getBean(method.getReturnType(), argsToUse) :</span><br><span class="line">              <span class="keyword">this</span>.owner.getBean(method.getReturnType()));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>ReplaceOverrideMethodInterceptor</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ReplaceOverrideMethodInterceptor</span> </span></span><br><span class="line"><span class="class">  <span class="keyword">extends</span> <span class="title">CglibIdentitySupport</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> BeanFactory owner;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ReplaceOverrideMethodInterceptor</span><span class="params">(RootBeanDefinition beanDefinition, BeanFactory owner)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(beanDefinition);</span><br><span class="line">    <span class="keyword">this</span>.owner = owner;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object obj, Method method, Object[] args, MethodProxy mp)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    ReplaceOverride ro = (ReplaceOverride) getBeanDefinition().getMethodOverrides().getOverride(method);</span><br><span class="line">    Assert.state(ro != <span class="keyword">null</span>, <span class="string">&quot;ReplaceOverride not found&quot;</span>);</span><br><span class="line">    <span class="comment">// TODO could cache if a singleton for minor performance optimization</span></span><br><span class="line">    MethodReplacer mr = <span class="keyword">this</span>.owner.getBean(ro.getMethodReplacerBeanName(), MethodReplacer.class);</span><br><span class="line">    <span class="keyword">return</span> mr.reimplement(obj, method, args);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过这两个拦截器，再加上这篇博客：<a href="/2020/01/fa973ffe.html">IOC 之解析 bean 标签：meta、lookup-method、replace-method</a>，是不是一道绝佳的美食。</p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
          <category> 《Spring源码分析》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> 转载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IOC之分析BeanWrapper</title>
      <link href="/blog/2020/01/24/fcc18cc7.html"/>
      <url>/blog/2020/01/24/fcc18cc7.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文作者：chenssy</p><p>出处：<a href="http://cmsblogs.com/?p=4020">http://cmsblogs.com/?p=4020</a></p><p>在学习<code>Spring源码</code>的过程中发现的好站+好贴，原创不易感谢作者。</p><p>Spring版本：<strong>Spring 5.0.6.RELEASE</strong></p></blockquote><p>在实例化 bean 阶段，我们从 BeanDefinition 得到的并不是我们最终想要的 Bean 实例，而是 BeanWrapper 实例，如下：</p><p><img src="https://cdn.jsdelivr.net/gh/cayzlh/git-img-repository@master/2020/05/27/15393305208552_Zt9ZVl_ocP6l0.jpg" alt="img"></p><p>所以这里 BeanWrapper 是一个从 BeanDefinition 到 Bean 直接的中间产物，我们可以称它为”低级 bean“，在一般情况下，我们不会在实际项目中用到它。</p><p>BeanWrapper 是 Spring 框架中重要的组件类，它就相当于一个代理类，Spring 委托 BeanWrapper 完成 Bean 属性的填充工作。</p><p>在 bean 实例被 InstantiatioonStrategy 创建出来后，Spring 容器会将 Bean 实例通过 BeanWrapper 包裹起来，是通过 <code>BeanWrapper.setWrappedInstance()</code> 完成的，如下：</p><p><img src="https://cdn.jsdelivr.net/gh/cayzlh/git-img-repository@master/2020/05/27/15393328767959-20200527205704408_oBMSK2.jpg" alt="img"></p><p>beanInstance 就是我们实例出来的 bean 实例，通过构造一个 BeanWrapper 实例对象进行包裹，如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">BeanWrapperImpl</span><span class="params">(Object object)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">super</span>(object);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">AbstractNestablePropertyAccessor</span><span class="params">(Object object)</span> </span>&#123;</span><br><span class="line"> registerDefaultEditors();</span><br><span class="line"> setWrappedInstance(object);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面小编就 BeanWrapper 来进行分析说明，先看整体的结构：</p><p><img src="https://gitee.com/cayzlh/img-repo/raw/master/2020/05/27/2018101210001-20200527205754152_znKAqi.png" alt="2018101210001"></p><p>从上图可以看出 BeanWrapper 主要继承三个核心接口：PropertyAccessor、PropertyEditorRegistry、TypeConverter。</p><p><strong>PropertyAccessor</strong></p><blockquote><p>可以访问属性的通用型接口（例如对象的 bean 属性或者对象中的字段），作为 BeanWrapper 的基础接口。</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PropertyAccessor</span> </span>&#123;</span><br><span class="line"> String NESTED_PROPERTY_SEPARATOR = <span class="string">&quot;.&quot;</span>;</span><br><span class="line"> <span class="keyword">char</span> NESTED_PROPERTY_SEPARATOR_CHAR = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line"></span><br><span class="line"> String PROPERTY_KEY_PREFIX = <span class="string">&quot;[&quot;</span>;</span><br><span class="line"> <span class="keyword">char</span> PROPERTY_KEY_PREFIX_CHAR = <span class="string">&#x27;[&#x27;</span>;</span><br><span class="line"></span><br><span class="line"> String PROPERTY_KEY_SUFFIX = <span class="string">&quot;]&quot;</span>;</span><br><span class="line"> <span class="keyword">char</span> PROPERTY_KEY_SUFFIX_CHAR = <span class="string">&#x27;]&#x27;</span>;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">boolean</span> <span class="title">isReadableProperty</span><span class="params">(String propertyName)</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">boolean</span> <span class="title">isWritableProperty</span><span class="params">(String propertyName)</span></span>;</span><br><span class="line"></span><br><span class="line"> Class&lt;?&gt; getPropertyType(String propertyName) <span class="keyword">throws</span> BeansException;</span><br><span class="line"></span><br><span class="line"> <span class="function">TypeDescriptor <span class="title">getPropertyTypeDescriptor</span><span class="params">(String propertyName)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"></span><br><span class="line"> <span class="function">Object <span class="title">getPropertyValue</span><span class="params">(String propertyName)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">setPropertyValue</span><span class="params">(String propertyName, <span class="meta">@Nullable</span> Object value)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">setPropertyValue</span><span class="params">(PropertyValue pv)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">setPropertyValues</span><span class="params">(Map&lt;?, ?&gt; map)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">setPropertyValues</span><span class="params">(PropertyValues pvs)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">setPropertyValues</span><span class="params">(PropertyValues pvs, <span class="keyword">boolean</span> ignoreUnknown)</span></span></span><br><span class="line"><span class="function">   <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">setPropertyValues</span><span class="params">(PropertyValues pvs, <span class="keyword">boolean</span> ignoreUnknown, <span class="keyword">boolean</span> ignoreInvalid)</span></span></span><br><span class="line"><span class="function">   <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就上面的源码我们可以分解为四类方法：</p><ul><li><code>isReadableProperty()</code>：判断指定 property 是否可读，是否包含 getter 方法</li><li><code>isWritableProperty()</code>：判断指定 property 是否可写,是否包含 setter 方法</li><li><code>getPropertyType()</code>：获取指定 propertyName 的类型</li><li><code>setPropertyValue()</code>：设置指定 propertyValue</li></ul><p><strong>PropertyEditorRegistry</strong></p><blockquote><p>用于注册 JavaBean 的 PropertyEditors，对 PropertyEditorRegistrar 起核心作用的中心接口。由 BeanWrapper 扩展，BeanWrapperImpl 和 DataBinder 实现。</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PropertyEditorRegistry</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">registerCustomEditor</span><span class="params">(Class&lt;?&gt; requiredType, PropertyEditor propertyEditor)</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">registerCustomEditor</span><span class="params">(<span class="meta">@Nullable</span> Class&lt;?&gt; requiredType, <span class="meta">@Nullable</span> String propertyPath, PropertyEditor propertyEditor)</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@Nullable</span></span><br><span class="line"> <span class="function">PropertyEditor <span class="title">findCustomEditor</span><span class="params">(<span class="meta">@Nullable</span> Class&lt;?&gt; requiredType, <span class="meta">@Nullable</span> String propertyPath)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据接口提供的方法，PropertyEditorRegistry 就是用于 PropertyEditor 的注册和发现，而 PropertyEditor 是 Java 内省里面的接口，用于改变指定 property 属性的类型。</p><p><strong>TypeConverter</strong></p><blockquote><p>定义类型转换的接口，通常与 PropertyEditorRegistry 接口一起实现（但不是必须），但由于 TypeConverter 是基于线程不安全的 PropertyEditors ，因此 TypeConverters 本身也不被视为线程安全。 这里小编解释下，在 Spring 3 后，不在采用 PropertyEditors 类作为 Spring 默认的类型转换接口，而是采用 ConversionService 体系，但 ConversionService 是线程安全的，所以在 Spring 3 后，如果你所选择的类型转换器是 ConversionService 而不是 PropertyEditors 那么 TypeConverters 则是线程安全的。</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TypeConverter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &lt;T&gt; <span class="function">T <span class="title">convertIfNecessary</span><span class="params">(Object value, Class&lt;T&gt; requiredType)</span> <span class="keyword">throws</span> TypeMismatchException</span>;</span><br><span class="line"></span><br><span class="line">    &lt;T&gt; <span class="function">T <span class="title">convertIfNecessary</span><span class="params">(Object value, Class&lt;T&gt; requiredType, MethodParameter methodParam)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> TypeMismatchException</span>;</span><br><span class="line"></span><br><span class="line">    &lt;T&gt; <span class="function">T <span class="title">convertIfNecessary</span><span class="params">(Object value, Class&lt;T&gt; requiredType, Field field)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> TypeMismatchException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>BeanWrapper 继承上述三个接口，那么它就具有三重身份：</p><ul><li>属性编辑器</li><li>属性编辑器注册表</li><li>类型转换器</li></ul><p>BeanWrapper 继承 ConfigurablePropertyAccessor 接口，该接口除了继承上面介绍的三个接口外还集成了 Spring 的 ConversionService 类型转换体系。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ConfigurablePropertyAccessor</span> <span class="keyword">extends</span> <span class="title">PropertyAccessor</span>, <span class="title">PropertyEditorRegistry</span>, <span class="title">TypeConverter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">setConversionService</span><span class="params">(<span class="meta">@Nullable</span> ConversionService conversionService)</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@Nullable</span></span><br><span class="line"> <span class="function">ConversionService <span class="title">getConversionService</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">setExtractOldValueForEditor</span><span class="params">(<span class="keyword">boolean</span> extractOldValueForEditor)</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">boolean</span> <span class="title">isExtractOldValueForEditor</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">setAutoGrowNestedPaths</span><span class="params">(<span class="keyword">boolean</span> autoGrowNestedPaths)</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">boolean</span> <span class="title">isAutoGrowNestedPaths</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>setConversionService()</code> 和 <code>getConversionService()</code> 则是用于集成 Spring 的 ConversionService 类型转换体系。</p><p><strong>BeanWrapper</strong></p><blockquote><p>Spring 的 低级 JavaBean 基础结构的接口，一般不会直接使用，而是通过 BeanFactory 或者 DataBinder 隐式使用。它提供分析和操作标准 JavaBeans 的操作：获取和设置属性值、获取属性描述符以及查询属性的可读性/可写性的能力。</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanWrapper</span> <span class="keyword">extends</span> <span class="title">ConfigurablePropertyAccessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">setAutoGrowCollectionLimit</span><span class="params">(<span class="keyword">int</span> autoGrowCollectionLimit)</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">getAutoGrowCollectionLimit</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="function">Object <span class="title">getWrappedInstance</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"> Class&lt;?&gt; getWrappedClass();</span><br><span class="line"></span><br><span class="line"> PropertyDescriptor[] getPropertyDescriptors();</span><br><span class="line"></span><br><span class="line"> <span class="function">PropertyDescriptor <span class="title">getPropertyDescriptor</span><span class="params">(String propertyName)</span> <span class="keyword">throws</span> InvalidPropertyException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面几个方法比较重要：</p><p>个对象有4个方法比较重要:</p><ul><li><code>getWrappedInstance()</code>：获取包装对象的实例。</li><li><code>getWrappedClass()</code>：获取包装对象的类型。</li><li><code>getPropertyDescriptors()</code>：获取包装对象所有属性的 PropertyDescriptor 就是这个属性的上下文。</li><li><code>getPropertyDescriptor()</code>：获取包装对象指定属性的上下文。</li></ul><p><strong>BeanWrapperImpl</strong></p><blockquote><p>BeanWrapper 接口的默认实现，用于对Bean的包装，实现上面接口所定义的功能很简单包括设置获取被包装的对象，获取被包装bean的属性描述器</p></blockquote><p>BeanWrapper 体系相比于 Spring 中其他体系是比较简单的，它作为 BeanDefinition 向 Bean 转换过程中的中间产物，承载了 bean 实例的包装、类型转换、属性的设置以及访问等重要作用。</p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
          <category> 《Spring源码分析》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> 转载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IOC之自定义类型转换器</title>
      <link href="/blog/2020/01/24/10825e64.html"/>
      <url>/blog/2020/01/24/10825e64.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文作者：chenssy</p><p>出处：<a href="http://cmsblogs.com/?p=3985">http://cmsblogs.com/?p=3985</a></p><p>在学习<code>Spring源码</code>的过程中发现的好站+好贴，原创不易感谢作者。</p><p>Spring版本：<strong>Spring 5.0.6.RELEASE</strong></p></blockquote><p>在上篇文章中分析了 Spring ConversionService 类型转换体系，这篇博客将利用 <code>ConversionService</code> 体系来实现自己的类型转换器。</p><p><code>ConversionService</code> 是 Spring 类型转换器体系中的核心接口，它定义了是否可以完成转换（<code>canConvert()</code>） 与 类型转换（<code>convert()</code>）两类接口。</p><p>ConversionService 有三个子类，每个子类针对不同的类型转换：</p><ul><li><p><code>Converter&lt;S,T&gt;</code>: 将 S 类型对象转为 T 类型对象。</p></li><li><p><code>GenericConverter</code>: 会根据源类对象及目标类对象所在的宿主类中的上下文信息进行类型转换。</p></li><li><p><code>ConverterFactory</code>: 将相同系列多个 “同质” Converter 封装在一起。</p><p>如果希望将一种类型的对象转换为另一种类型及其子类的对象(例如将 String 转换为 Number 及 Number 子类(Integer、Long、Double 等)对象)可使用该转换器工厂类。</p></li></ul><p>如何自定义类型转换器？分两步走：</p><ol><li>实现 Converter / GenericConverter / ConverterFactory 接口</li><li>将该类注册到 ConversionServiceFactoryBean 中。</li></ol><p>ConversionServiceFactoryBean 实现了 InitializingBean 接口实现 <code>afterPropertiesSet()</code> ，我们知道在 Bean 实例化 bean 阶段，Spring 容器会检查当前 bean 是否实现了 InitializingBean 接口，如果是则执行相应的初始化方法。（关于 InitializingBean 详情请参考：<a href="/2020/01/23/3af7524a.html"> IOC 之 深入分析 InitializingBean 和 init-method</a>）。</p><p><code>afterPropertiesSet()</code> 源码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="keyword">this</span>.conversionService = createConversionService();</span><br><span class="line"> ConversionServiceFactory.registerConverters(<span class="keyword">this</span>.converters, <span class="keyword">this</span>.conversionService);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>首先调用 <code>createConversionService()</code> 初始化 conversionService</li><li>然后调用 <code>ConversionServiceFactory.registerConverters()</code> 将定义的 converters 注入到类型转换体系中。<code>createConversionService()</code> 其实就是创建一个 DefaultConversionService 实例对象，对于 DefaultConversionService 在上篇博客已经分析了，如有不了解的请移步上篇博文。这里直接分析 <code>ConversionServiceFactory.registerConverters()</code>，该方法是将定义的 converter 注册到目标 ConverterRegistry 中，我们知道 ConverterRegistry 是一个 Converter 注册器，他定义了一系列注册方法。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerConverters</span><span class="params">(<span class="meta">@Nullable</span> Set&lt;?&gt; converters, ConverterRegistry registry)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">if</span> (converters != <span class="keyword">null</span>) &#123;</span><br><span class="line">  <span class="keyword">for</span> (Object converter : converters) &#123;</span><br><span class="line">   <span class="keyword">if</span> (converter <span class="keyword">instanceof</span> GenericConverter) &#123;</span><br><span class="line">    registry.addConverter((GenericConverter) converter);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span> (converter <span class="keyword">instanceof</span> Converter&lt;?, ?&gt;) &#123;</span><br><span class="line">    registry.addConverter((Converter&lt;?, ?&gt;) converter);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span> (converter <span class="keyword">instanceof</span> ConverterFactory&lt;?, ?&gt;) &#123;</span><br><span class="line">    registry.addConverterFactory((ConverterFactory&lt;?, ?&gt;) converter);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Each converter object must implement one of the &quot;</span> +</span><br><span class="line">      <span class="string">&quot;Converter, ConverterFactory, or GenericConverter interfaces&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用 ConverterRegistry 的 <code>addConverter()</code> 方法将转换器注册到容器中。所以在我们使用 Spring 容器的时候，Spring 将会自动识别出 IOC 容器中注册的 ConversionService 并且在 bean 属性注入阶段使用自定义的转换器完成属性的转换了。</p><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>定义 StudentConversionService 转换器：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentConversionService</span> <span class="keyword">implements</span> <span class="title">Converter</span>&lt;<span class="title">String</span>,<span class="title">StudentService</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> StudentService <span class="title">convert</span><span class="params">(String source)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(StringUtils.hasLength(source))&#123;</span><br><span class="line">            String[] sources = source.split(<span class="string">&quot;#&quot;</span>);</span><br><span class="line"></span><br><span class="line">            StudentService studentService = <span class="keyword">new</span> StudentService();</span><br><span class="line">            studentService.setAge(Integer.parseInt(sources[<span class="number">0</span>]));</span><br><span class="line">            studentService.setName(sources[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> studentService;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;conversionService&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">class</span>=<span class="string">&quot;org.springframework.context.support.ConversionServiceFactoryBean&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;converters&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;studentConversionService&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;studentConversionService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.core.conversion.StudentConversionService&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;student&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.core.conversion.Student&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;studentService&quot;</span> <span class="attr">value</span>=<span class="string">&quot;18#chenssy&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
          <category> 《Spring源码分析》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> 转载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IOC之深入分析Bean的类型转换体系</title>
      <link href="/blog/2020/01/24/683bb448.html"/>
      <url>/blog/2020/01/24/683bb448.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文作者：chenssy</p><p>出处：<a href="http://cmsblogs.com/?p=3983">http://cmsblogs.com/?p=3983</a></p><p>在学习<code>Spring源码</code>的过程中发现的好站+好贴，原创不易感谢作者。</p><p>Spring版本：<strong>Spring 5.0.6.RELEASE</strong></p></blockquote><p>我们知道不管 bean 对象里面的属性时什么类型，他们都是通过 XML 、Properties 或者其他方式来配置这些属性对象类型的。在 Spring 容器加载过程中，这些属性都是以 String 类型加载进容器的，但是最终都需要将这些 String 类型的属性转换 Bean 对象属性所对应真正的类型，要想完成这种由字符串到具体对象的转换，就需要这种转换规则相关的信息，而这些信息以及转换过程由 Spring 类型转换体系来完成。</p><p>我们依然以 xml 为例，在 Spring 容器加载阶段，容器将 xml 文件中定义的 <code>&lt;bean&gt;</code> 解析为 BeanDefinition，BeanDefinition 中存储着我们定义一个 bean 需要的所有信息，包括属性，这些属性是以 String 类型的存储的。</p><p>当用户触发 Bean 实例化阶段时，Spring 容器会将这些属性转换为这些属性真正对应的类型。我们知道在 bean 实例化阶段，属性的注入是在实例化 bean 阶段的属性注入阶段，即 <code>populateBean()</code> 方法。在 <code>populateBean()</code> 中会将 BeanDefinition 中定义的属性值翻译为 PropertyValue 然后调用 <code>applyPropertyValues()</code> 进行属性应用。其中 PropertyValue 用于保存单个 bean 属性的信息和值的对象。在 <code>applyPropertyValues()</code> 中会调用 <code>convertForProperty()</code> 进行属性转换，如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">convertForProperty</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="meta">@Nullable</span> Object value, String propertyName, BeanWrapper bw, TypeConverter converter)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (converter <span class="keyword">instanceof</span> BeanWrapperImpl) &#123;</span><br><span class="line">    <span class="keyword">return</span> ((BeanWrapperImpl) converter).convertForProperty(value, propertyName);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    PropertyDescriptor pd = bw.getPropertyDescriptor(propertyName);</span><br><span class="line">    MethodParameter methodParam = BeanUtils.getWriteMethodParameter(pd);</span><br><span class="line">    <span class="keyword">return</span> converter.convertIfNecessary(value, pd.getPropertyType(), methodParam);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>若 TypeConverter 为 BeanWrapperImpl 类型，则使用 BeanWrapperImpl 来进行类型转换，这里主要是因为 BeanWrapperImpl 实现了 PropertyEditorRegistry 接口。否则则调用 TypeConverter 的 <code>convertIfNecessary()</code> 进行类型转换。TypeConverter 是定义类型转换方法的接口，通常情况下与 PropertyEditorRegistry 配合使用实现类型转换。</p><p><code>convertIfNecessary()</code> 的实现者有两个：<code>DataBinder</code> 和 <code>TypeConverterSupport</code> ，其中 <code>DataBinder</code> 主要用于参数绑定（熟悉 Spring MVC 的都应该知道这个类），<code>TypeConverterSupport</code> 则是 <code>TypeConverter</code> 的基本实现，使用的是 <code>package-private</code> 策略。</p><p> 所以这里我们只需要关注 TypeConverterSupport 的 <code>convertIfNecessary()</code>，如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">convertIfNecessary</span><span class="params">(<span class="meta">@Nullable</span> Object value, <span class="meta">@Nullable</span> Class&lt;T&gt; requiredType, <span class="meta">@Nullable</span> MethodParameter methodParam)</span></span></span><br><span class="line"><span class="function">  <span class="keyword">throws</span> TypeMismatchException </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> doConvert(value, requiredType, methodParam, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function">T <span class="title">doConvert</span><span class="params">(<span class="meta">@Nullable</span> Object value,<span class="meta">@Nullable</span> Class&lt;T&gt; requiredType,</span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="meta">@Nullable</span> MethodParameter methodParam, <span class="meta">@Nullable</span> Field field)</span> <span class="keyword">throws</span> TypeMismatchException </span>&#123;</span><br><span class="line"></span><br><span class="line">  Assert.state(<span class="keyword">this</span>.typeConverterDelegate != <span class="keyword">null</span>, <span class="string">&quot;No TypeConverterDelegate&quot;</span>);</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (field != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.typeConverterDelegate.convertIfNecessary(value, requiredType, field);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.typeConverterDelegate.convertIfNecessary(value, requiredType, methodParam);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (ConverterNotFoundException | IllegalStateException ex) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ConversionNotSupportedException(value, requiredType, ex);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (ConversionException | IllegalArgumentException ex) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> TypeMismatchException(value, requiredType, ex);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们一直往下跟会跟踪到 TypeConverterDelegate 的 <code>convertIfNecessary()</code> ，会发现如下代码段：</p><p><img src="https://cdn.jsdelivr.net/gh/cayzlh/git-img-repository@master/2020/05/27/15388823317115-20200527094430730_S7jNAq.jpg" alt="img"></p><p>如果没有自定义的编辑器则使用 ConversionService 。ConversionService 是 Spring 自 3 后推出来用来替代 PropertyEditor 转换模式的转换体系，接口定义如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ConversionService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">canConvert</span><span class="params">(<span class="meta">@Nullable</span> Class&lt;?&gt; sourceType, Class&lt;?&gt; targetType)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">canConvert</span><span class="params">(<span class="meta">@Nullable</span> TypeDescriptor sourceType, TypeDescriptor targetType)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    &lt;T&gt; <span class="function">T <span class="title">convert</span><span class="params">(<span class="meta">@Nullable</span> Object source, Class&lt;T&gt; targetType)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function">Object <span class="title">convert</span><span class="params">(<span class="meta">@Nullable</span> Object source, <span class="meta">@Nullable</span> TypeDescriptor sourceType, TypeDescriptor targetType)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其 UML 类图如下：</p><p><img src="https://cdn.jsdelivr.net/gh/cayzlh/git-img-repository@master/2020/05/27/15388832533588_Cmgmcb_smrQ4E.jpg" alt="img"></p><ul><li><strong>ConfigurableConversionService</strong>：ConversionService 的配置接口，继承 ConversionService 和 ConverterRegistry 两个接口，用于合并他们两者的操作，以便于通过 add 和 remove 的方式添加和删除转换器。</li><li><strong>GenericConversionService</strong>：ConversionService 接口的基础实现，适用于大部分条件下的转换工作，通过 ConfigurableConversionService 接口间接地将 ConverterRegistry 实现为注册 API 。</li><li><strong>DefaultConversionService</strong>：ConversionService 接口的默认实现，适用于大部分条件下的转换工作。</li></ul><p>回归到 <code>convertIfNecessary()</code>，在该方法中如果没有自定义的属性编辑器则调用 ConversionService 接口的 <code>convert()</code>，方法定义如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Object <span class="title">convert</span><span class="params">(<span class="meta">@Nullable</span> Object source, <span class="meta">@Nullable</span> TypeDescriptor sourceType, TypeDescriptor targetType)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>source：要转换的源对象，可以为 null</li><li>sourceType：source 的类型的上下文，如果 source 为 null，则可以为 null</li><li>targetType：source 要转换的类型的上下文。</li></ul><p><code>convert()</code> 将给定的源对象 source 转换为指定的 targetType。</p><p>TypeDescriptors 提供有关发生转换的源位置和目标位置的附加上下文，通常是对象字段或属性位置。方法由子类 GenericConversionService 实现：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">convert</span><span class="params">(<span class="meta">@Nullable</span> Object source, <span class="meta">@Nullable</span> TypeDescriptor sourceType, TypeDescriptor targetType)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 删掉 if ，其实就是上面的 null 判断</span></span><br><span class="line">  GenericConverter converter = getConverter(sourceType, targetType);</span><br><span class="line">  <span class="keyword">if</span> (converter != <span class="keyword">null</span>) &#123;</span><br><span class="line">    Object result = ConversionUtils.invokeConverter(converter, source, sourceType, targetType);</span><br><span class="line">    <span class="keyword">return</span> handleResult(sourceType, targetType, result);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> handleConverterNotFound(source, sourceType, targetType);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先根据 sourceType 和 targetType 调用 <code>getConverter()</code> 获取 GenericConverter 对象 converter ，如果 converter 为 null，则调用 <code>handleConverterNotFound()</code>，否则调用 <code>handleResult()</code> 方法。<code>getConverter()</code> 如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> GenericConverter <span class="title">getConverter</span><span class="params">(TypeDescriptor sourceType, TypeDescriptor targetType)</span> </span>&#123;</span><br><span class="line">  ConverterCacheKey key = <span class="keyword">new</span> ConverterCacheKey(sourceType, targetType);</span><br><span class="line">  GenericConverter converter = <span class="keyword">this</span>.converterCache.get(key);</span><br><span class="line">  <span class="keyword">if</span> (converter != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (converter != NO_MATCH ? converter : <span class="keyword">null</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  converter = <span class="keyword">this</span>.converters.find(sourceType, targetType);</span><br><span class="line">  <span class="keyword">if</span> (converter == <span class="keyword">null</span>) &#123;</span><br><span class="line">    converter = getDefaultConverter(sourceType, targetType);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (converter != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.converterCache.put(key, converter);</span><br><span class="line">    <span class="keyword">return</span> converter;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.converterCache.put(key, NO_MATCH);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码意图非常明确，从 converterCache 缓存中获取，如果存在返回，否则从 converters 中获取，然后加入到 converterCache 缓存中。converterCache 和 converters 是 GenericConversionService 维护的两个很重要的对象，其中 converterCache 用于存储 GenericConverter ，converters 对象为 GenericConversionService 的内部类。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Converters converters = <span class="keyword">new</span> Converters();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;ConverterCacheKey, GenericConverter&gt; converterCache = <span class="keyword">new</span> ConcurrentReferenceHashMap&lt;&gt;(<span class="number">64</span>);</span><br></pre></td></tr></table></figure><p>Converters 用于管理所有注册的转换器，其内部维护一个 Set 和 Map 的数据结构用于管理转换器，如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Set&lt;GenericConverter&gt; globalConverters = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;ConvertiblePair, ConvertersForPair&gt; converters = <span class="keyword">new</span> LinkedHashMap&lt;&gt;(<span class="number">36</span>);</span><br></pre></td></tr></table></figure><p>同时提供了相应的方法（如 add、remove）操作这两个集合。在 <code>getConverter()</code> 中如果缓存 converterCache 中 不存在，则调用 Converters 对象的 <code>find()</code> 方法获取相应的 GenericConverter，如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> GenericConverter <span class="title">find</span><span class="params">(TypeDescriptor sourceType, TypeDescriptor targetType)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Search the full type hierarchy</span></span><br><span class="line">    List&lt;Class&lt;?&gt;&gt; sourceCandidates = getClassHierarchy(sourceType.getType());</span><br><span class="line">    List&lt;Class&lt;?&gt;&gt; targetCandidates = getClassHierarchy(targetType.getType());</span><br><span class="line">    <span class="keyword">for</span> (Class&lt;?&gt; sourceCandidate : sourceCandidates) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Class&lt;?&gt; targetCandidate : targetCandidates) &#123;</span><br><span class="line">            ConvertiblePair convertiblePair = <span class="keyword">new</span> ConvertiblePair(sourceCandidate, targetCandidate);</span><br><span class="line">            GenericConverter converter = getRegisteredConverter(sourceType, targetType, convertiblePair);</span><br><span class="line">            <span class="keyword">if</span> (converter != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> converter;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> GenericConverter <span class="title">getRegisteredConverter</span><span class="params">(TypeDescriptor sourceType,</span></span></span><br><span class="line"><span class="function"><span class="params">                TypeDescriptor targetType, ConvertiblePair convertiblePair)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check specifically registered converters</span></span><br><span class="line">    ConvertersForPair convertersForPair = <span class="keyword">this</span>.converters.get(convertiblePair);</span><br><span class="line">    <span class="keyword">if</span> (convertersForPair != <span class="keyword">null</span>) &#123;</span><br><span class="line">        GenericConverter converter = convertersForPair.getConverter(sourceType, targetType);</span><br><span class="line">        <span class="keyword">if</span> (converter != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> converter;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Check ConditionalConverters for a dynamic match</span></span><br><span class="line">    <span class="keyword">for</span> (GenericConverter globalConverter : <span class="keyword">this</span>.globalConverters) &#123;</span><br><span class="line">        <span class="keyword">if</span> (((ConditionalConverter) globalConverter).matches(sourceType, targetType)) &#123;</span><br><span class="line">            <span class="keyword">return</span> globalConverter;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>find()</code> 中会根据 sourceType 和 targetType 去查询 Converters 中维护的 Map 中是否包括支持的注册类型，如果存在返回 GenericConverter ，如果没有存在返回 null。</p><p>当得到 GenericConverter 后，则调用其 <code>convert()</code> 进行类型转换。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Object <span class="title">convert</span><span class="params">(<span class="meta">@Nullable</span> Object source, TypeDescriptor sourceType, TypeDescriptor targetType)</span></span>;</span><br></pre></td></tr></table></figure><p>到这里我们就可以得到 bean 属性定义的真正类型了。</p><p><strong>GenericConverter 接口</strong></p><p>GenericConverter 是一个转换接口，一个用于在两种或更多种类型之间转换的通用型转换器接口。它是 Converter SPI 体系中最灵活的，也是最复杂的接口，灵活性在于 GenericConverter 可以支持在多个源/目标类型对之间进行转换，同时也可以在类型转换过程中访问源/目标字段上下文。由于该接口足够复杂，所有当更简单的 Converter 或 ConverterFactory 接口足够使用时，通常不应使用此接口。其定义如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">GenericConverter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function">Set&lt;ConvertiblePair&gt; <span class="title">getConvertibleTypes</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function">Object <span class="title">convert</span><span class="params">(<span class="meta">@Nullable</span> Object source, TypeDescriptor sourceType, TypeDescriptor targetType)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>GenericConverter 的子类有这么多（看类名就知道是干嘛的了）：</p><p><img src="https://cdn.jsdelivr.net/gh/cayzlh/git-img-repository@master/2020/05/27/15388984648307_DEQ9BT_olp6Km.jpg" alt="img"></p><p>我们看一个子类的实现 StringToArrayConverter，该子类将逗号分隔的 String 转换为 Array。如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">convert</span><span class="params">(<span class="meta">@Nullable</span> Object source, TypeDescriptor sourceType, TypeDescriptor targetType)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (source == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  String string = (String) source;</span><br><span class="line">  String[] fields = StringUtils.commaDelimitedListToStringArray(string);</span><br><span class="line">  TypeDescriptor targetElementType = targetType.getElementTypeDescriptor();</span><br><span class="line">  Assert.state(targetElementType != <span class="keyword">null</span>, <span class="string">&quot;No target element type&quot;</span>);</span><br><span class="line">  Object target = Array.newInstance(targetElementType.getType(), fields.length);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; fields.length; i++) &#123;</span><br><span class="line">    String sourceElement = fields[i];</span><br><span class="line">    Object targetElement = <span class="keyword">this</span>.conversionService.convert(sourceElement.trim(), sourceType, targetElementType);</span><br><span class="line">    Array.set(target, i, targetElement);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在类型转换体系中，Spring 提供了非常多的类型转换器，除了上面的 GenericConverter，还有 Converter、ConditionalConverter、ConverterFactory。</p><p><strong>Converter</strong></p><p>Converter 是一个将 S 类型的源对象转换为 T 类型的目标对象的转换器。该接口是线程安全的，所以可以共享。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Converter</span>&lt;<span class="title">S</span>, <span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function">T <span class="title">convert</span><span class="params">(S source)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>子类如下：</p><p><img src="https://cdn.jsdelivr.net/gh/cayzlh/git-img-repository@master/2020/05/27/15389004851676-20200527094627489_1lakfm.jpg" alt="img"></p><p><strong>ConditionalConverter</strong></p><p>ConditionalConverter 接口用于表示有条件的类型转换，通过转入的sourceType 与 targetType 判断转换能否匹配，只有可匹配的转换才会调用convert 方法进行转换，如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface ConditionalConverter &#123;</span><br><span class="line">    boolean matches(TypeDescriptor sourceType, TypeDescriptor targetType);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ConditionalConverter 的子类如下：</p><p><a href="https://gitee.com/chenssy/blog-home/raw/master/image/201811/15389064279138.jpg"><img src="https://gitee.com/chenssy/blog-home/raw/master/image/201811/15389064279138.jpg" alt="img"></a></p><p><strong>ConverterFactory</strong></p><p>一个用于“远程”转换的转换工厂，可以将对象从 S 转换为 R 的子类型。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ConverterFactory</span>&lt;<span class="title">S</span>, <span class="title">R</span>&gt; </span>&#123;</span><br><span class="line">    &lt;T extends R&gt; <span class="function">Converter&lt;S, T&gt; <span class="title">getConverter</span><span class="params">(Class&lt;T&gt; targetType)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>子类如下：</p><p><img src="https://cdn.jsdelivr.net/gh/cayzlh/git-img-repository@master/2020/05/27/15389071818355_KBtf0I_MmL1Mp.jpg" alt="img"></p><p>四种不同的转换器承载着不同的转换过程：</p><ul><li>Converter：用于 1:1 的 source -&gt; target 类型转换</li><li>ConverterFactory：用于 1:N 的 source -&gt; target 类型转换</li><li>GenericConverter用于 N:N 的 source -&gt; target 类型转换</li><li>ConditionalConverter：有条件的 source -&gt; target 类型转换</li></ul><p><strong>GenericConversionService</strong></p><p>转换器介绍完了，我们再次回归到 ConversionService 接口中去，该接口定义了两类方法 <code>canConvert()</code> 和 <code>convert()</code>，其中 <code>canConvert()</code> 用于判 sourceType 能否转成 targetType ,而 <code>convert()</code> 用于将 source 转成转入的 TargetType 类型实例。这两类方法都是在 GenericConversionService 中实现。类 GenericConversionService 实现 ConfigurableConversionService 接口，而 ConfigurableConversionService 接口继承 ConversionService 和 ConverterRegistry。ConverterRegistry 提供了类型转换器的管理功能，他提供了四个 add 和 一个 remove 方法，支持注册/删除相应的类型转换器。GenericConversionService 作为一个基础实现类，它即支持了不同类型之间的转换，也对各类型转换器进行管理，主要是通过一个 Map 类型的 converterCache 和一个内部类 Converters。在上面已经分析了 GenericConversionService 执行类型转换的过程 <code>cover()</code>，下面我们就一个 <code>addConverter()</code> 来看看它是如何完成转换器的注入工作的。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addConverter</span><span class="params">(Converter&lt;?, ?&gt; converter)</span> </span>&#123;</span><br><span class="line">  ResolvableType[] typeInfo = getRequiredTypeInfo(converter.getClass(), Converter.class);</span><br><span class="line">  <span class="keyword">if</span> (typeInfo == <span class="keyword">null</span> &amp;&amp; converter <span class="keyword">instanceof</span> DecoratingProxy) &#123;</span><br><span class="line">    typeInfo = getRequiredTypeInfo(((DecoratingProxy) converter).getDecoratedClass(), Converter.class);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (typeInfo == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Unable to determine source type &lt;S&gt; and target type &lt;T&gt; for your &quot;</span> +</span><br><span class="line">                                       <span class="string">&quot;Converter [&quot;</span> + converter.getClass().getName() + <span class="string">&quot;]; does the class parameterize those types?&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  addConverter(<span class="keyword">new</span> ConverterAdapter(converter, typeInfo[<span class="number">0</span>], typeInfo[<span class="number">1</span>]));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先根据 converter 获取 ResolvableType，然后将其与 converter 封装成一个 ConverterAdapter 实例，最后调用 <code>addConverter()</code>。ResolvableType 用于封装 Java 的类型。ConverterAdapter 则是 Converter 的一个适配器， 它实现了 GenericConverter 和 ConditionalConverter 两个类型转换器。</p><p><code>addConverter()</code> 如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addConverter</span><span class="params">(GenericConverter converter)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.converters.add(converter);</span><br><span class="line">    invalidateCache();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接调用内部类 Converters 的 <code>add()</code> 方法，如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(GenericConverter converter)</span> </span>&#123;</span><br><span class="line">  Set&lt;ConvertiblePair&gt; convertibleTypes = converter.getConvertibleTypes();</span><br><span class="line">  <span class="keyword">if</span> (convertibleTypes == <span class="keyword">null</span>) &#123;</span><br><span class="line">    Assert.state(converter <span class="keyword">instanceof</span> ConditionalConverter,</span><br><span class="line">                 <span class="string">&quot;Only conditional converters may return null convertible types&quot;</span>);</span><br><span class="line">    <span class="keyword">this</span>.globalConverters.add(converter);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (ConvertiblePair convertiblePair : convertibleTypes) &#123;</span><br><span class="line">      ConvertersForPair convertersForPair = getMatchableConverters(convertiblePair);</span><br><span class="line">      convertersForPair.add(converter);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先调用 <code>getConvertibleTypes()</code> 获取 ConvertiblePair 集合，如果为空，则加入到 globalConverters 集合中，否则通过迭代的方式依次添加。ConvertiblePair 为 source-to-targer 的持有者，它持有 source 和 target 的 class 类型，如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ConvertiblePair</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Class&lt;?&gt; sourceType;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Class&lt;?&gt; targetType;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其他代码   </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在迭代过程中会根据 ConvertiblePair 获取相应的 ConvertersForPair ，然后 converter 转换器加入其中，ConvertiblePair 用于管理使用特定GenericConverter.ConvertiblePair 注册的转换器。如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ConvertersForPair</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> LinkedList&lt;GenericConverter&gt; converters = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(GenericConverter converter)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.converters.addFirst(converter);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Nullable</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> GenericConverter <span class="title">getConverter</span><span class="params">(TypeDescriptor sourceType, TypeDescriptor targetType)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (GenericConverter converter : <span class="keyword">this</span>.converters) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!(converter <span class="keyword">instanceof</span> ConditionalGenericConverter) ||</span><br><span class="line">          ((ConditionalGenericConverter) converter).matches(sourceType, targetType)) &#123;</span><br><span class="line">        <span class="keyword">return</span> converter;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实内部就是维护一个 LinkedList 集合。他内部有两个方法：<code>add()</code> 和 <code>getConverter()</code>，实现较为简单，这里就不多介绍了。</p><p><strong>DefaultConversionService</strong></p><p>DefaultConversionService 是 ConversionService 的默认实现，它继承 GenericConversionService，GenericConversionService 主要用于转换器的注册和调用，DefaultConversionService 则是为 ConversionService 体系提供一些默认的转换器。在 DefaultConversionService 构造方法中就会添加默认的 Converter ，如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DefaultConversionService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  addDefaultConverters(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addDefaultConverters</span><span class="params">(ConverterRegistry converterRegistry)</span> </span>&#123;</span><br><span class="line">  addScalarConverters(converterRegistry);</span><br><span class="line">  addCollectionConverters(converterRegistry);</span><br><span class="line"></span><br><span class="line">  converterRegistry.addConverter(<span class="keyword">new</span> ByteBufferConverter((ConversionService) converterRegistry));</span><br><span class="line">  <span class="keyword">if</span> (jsr310Available) &#123;</span><br><span class="line">    Jsr310ConverterRegistrar.registerJsr310Converters(converterRegistry);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  converterRegistry.addConverter(<span class="keyword">new</span> ObjectToObjectConverter());</span><br><span class="line">  converterRegistry.addConverter(<span class="keyword">new</span> IdToEntityConverter((ConversionService) converterRegistry));</span><br><span class="line">  converterRegistry.addConverter(<span class="keyword">new</span> FallbackObjectToStringConverter());</span><br><span class="line">  <span class="keyword">if</span> (javaUtilOptionalClassAvailable) &#123;</span><br><span class="line">    converterRegistry.addConverter(<span class="keyword">new</span> ObjectToOptionalConverter((ConversionService) converterRegistry));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然它还提供了一些其他的方法如 <code>addCollectionConverters()</code>、<code>addScalarConverters()</code> 用于注册其他类型的转换器。</p><p>至此，从 bean 属性的转换，到 Spring ConversionService 体系的转换器 Converter 以及转换器的管理都介绍完毕了。</p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
          <category> 《Spring源码分析》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> 转载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IOC之深入分析PropertyOverrideConfigurer</title>
      <link href="/blog/2020/01/24/e5d90f02.html"/>
      <url>/blog/2020/01/24/e5d90f02.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文作者：chenssy</p><p>出处：<a href="http://cmsblogs.com/?p=3924">http://cmsblogs.com/?p=3924</a></p><p>在学习<code>Spring源码</code>的过程中发现的好站+好贴，原创不易感谢作者。</p><p>Spring版本：<strong>Spring 5.0.6.RELEASE</strong></p></blockquote><p>在文章 <a href="/2020/01/23/81b83a69.html">IOC 之 深入分析 BeanFactoryPostProcessor</a> 中提到，BeanFactoryPostProcessor 作用与 bean 完成加载之后与 bean 实例化之前，是 Spring 提供的一种强大的扩展机制，他有两个重要的子类，一个是 PropertyPlaceholderConfigurer，另一个是 PropertyOverrideConfigurer ，其中 PropertyPlaceholderConfigurer 允许我们通过配置 Properties 的方式来取代 bean 中定义的占位符，而 PropertyOverrideConfigurer 呢？正是我们这篇博客介绍的。</p><blockquote><p>PropertyOverrideConfigurer 允许我们对 Spring 容器中配置的任何我们想处理的 bean 定义的 property 信息进行覆盖替换。</p></blockquote><p>这个定义听起来有点儿玄乎，通俗点说就是我们可以通过 PropertyOverrideConfigurer 来覆盖任何 bean 中的任何属性，只要我们想。</p><p><u>PropertyOverrideConfigurer 的使用规则是 <code>beanName.propertyName=value</code>，这里需要注意的是 beanName，propertyName 则是该 bean 中存在的属性。</u></p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>依然使用以前的例子，Student.class，我们只需要修改下配置文件，声明下 PropertyOverrideConfigurer 以及其加载的配置文件。如下：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.beans.factory.config.PropertyOverrideConfigurer&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;locations&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">value</span>&gt;</span>classpath:application.properties<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;student&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.core.service.StudentService&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;chenssy&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>指定 student 的 name 属性值为 chenssy，声明 PropertyOverrideConfigurer 加载的文件为 application.properties，内容如下：</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">student.name</span> = <span class="string">chenssy-PropertyOverrideConfigurer</span></span><br></pre></td></tr></table></figure><p>指定 beanName 为 student 的 bean 的 name 属性值为 chenssy-PropertyOverrideConfigurer。</p><p>测试打印 student 中的 name 属性值，如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;spring.xml&quot;</span>);</span><br><span class="line"></span><br><span class="line">StudentService studentService = (StudentService) context.getBean(<span class="string">&quot;student&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;student name:&quot;</span> + studentService.getName());</span><br></pre></td></tr></table></figure><p>运行结果为：</p><p><img src="https://cdn.jsdelivr.net/gh/cayzlh/git-img-repository@master/2020/05/27/15377119278769_ti0Upp_WR3LqN.jpg" alt="img"></p><p>从中可以看出 PropertyOverrideConfigurer 定义的文件取代了 bean 中默认的值。</p><p>下面我们看一个有趣的例子，如果我们一个 bean 中 PropertyPlaceholderConfigurer 和 PropertyOverrideConfigurer 都使用呢？那是显示谁定义的值呢？</p><p>这里先简单分析下：如果<code>PropertyOverrideConfigurer</code> 先作用，那么 <code>PropertyPlaceholderConfigurer</code> 在匹配占位符的时候就找不到了，如果 <code>PropertyOverrideConfigurer</code> 后作用，也会直接取代 <code>PropertyPlaceholderConfigurer</code> 定义的值，所以无论如何都会显示 <code>PropertyOverrideConfigurer</code> 定义的值。</p><p>是不是这样呢？看如下例子：</p><p>xml 配置文件调整如下：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.beans.factory.config.PropertyOverrideConfigurer&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;locations&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">value</span>&gt;</span>classpath:application1.properties<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.beans.factory.config.PropertyPlaceholderConfigurer&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;locations&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">value</span>&gt;</span>classpath:application2.properties<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;student&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.core.service.StudentService&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;studentService.name&#125;&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>指定 PropertyPlaceholderConfigurer 加载文件为 application1.properties，PropertyPlaceholderConfigurer 加载文件为 application2.properties，student 的 name 属性使用占位符 <code>$&#123;studentService.name&#125;</code>。配置文件内容为：</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># application1.properties：</span></span><br><span class="line"><span class="meta">student.name</span> = <span class="string">chenssy-PropertyOverrideConfigurer</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># application2.properties：</span></span><br><span class="line"><span class="meta">studentService.name</span> = <span class="string">chenssy-PropertyPlaceholderConfigurer</span></span><br></pre></td></tr></table></figure><p>测试程序依然是打印 name 属性值，运行结果如下：</p><p><img src="https://cdn.jsdelivr.net/gh/cayzlh/git-img-repository@master/2020/05/27/15377127284347_fDOIPu_94XAir.jpg" alt="img"></p><p>所以，上面的分析没有错。</p><p>下面我们来分析 PropertyOverrideConfigurer 实现原理。其实如果了解 PropertyPlaceholderConfigurer 的实现机制的话，那么 PropertyOverrideConfigurer 也不难猜测：加载指定 Properties，迭代其中的属性值，依据 “.” 来得到 beanName（split(“.”)[0]），从容器中获取指定的 BeanDefinition，然后得到 name 属性，进行替换即可。</p><h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>UML 结构图如下：</p><p><img src="https://cdn.jsdelivr.net/gh/cayzlh/git-img-repository@master/2020/05/27/spring-201809231001-20200527093418095_v2NThs.png" alt="spring-201809231001"></p><p>与 PropertyPlaceholderConfigurer 一样，也是继承 PropertyResourceConfigurer，我们知道 PropertyResourceConfigurer 对 BeanFactoryPostProcessor 的 <code>postProcessBeanFactory()</code> 提供了实现，在该实现中它会去读取指定配置文件中的内容，然后 <code>processProperties()</code> ，该方法是一个抽象方法，具体的实现由子类来实现，所以这里我们只需要看 PropertyOverrideConfigurer 中 <code>processProperties()</code> 中的具体实现，如下:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">processProperties</span><span class="params">(ConfigurableListableBeanFactory beanFactory, Properties props)</span></span></span><br><span class="line"><span class="function">  <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">  <span class="comment">// 迭代配置文件中的内容</span></span><br><span class="line">  <span class="keyword">for</span> (Enumeration&lt;?&gt; names = props.propertyNames(); names.hasMoreElements();) &#123;</span><br><span class="line">    String key = (String) names.nextElement();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      processKey(beanFactory, key, props.getProperty(key));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">      String msg = <span class="string">&quot;Could not process key &#x27;&quot;</span> + key + <span class="string">&quot;&#x27; in PropertyOverrideConfigurer&quot;</span>;</span><br><span class="line">      <span class="keyword">if</span> (!<span class="keyword">this</span>.ignoreInvalidKeys) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanInitializationException(msg, ex);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">        logger.debug(msg, ex);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>迭代 props 内容，依次调用 <code>processKey()</code>，如下:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">processKey</span><span class="params">(ConfigurableListableBeanFactory factory, String key, String value)</span></span></span><br><span class="line"><span class="function">  <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断是否存在 &quot;.&quot;</span></span><br><span class="line">  <span class="comment">// 获取其索引位置</span></span><br><span class="line">  <span class="keyword">int</span> separatorIndex = key.indexOf(<span class="keyword">this</span>.beanNameSeparator);</span><br><span class="line">  <span class="comment">// 如果不存在，. 则抛出异常</span></span><br><span class="line">  <span class="keyword">if</span> (separatorIndex == -<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BeanInitializationException(<span class="string">&quot;Invalid key &#x27;&quot;</span> + key +</span><br><span class="line">                                          <span class="string">&quot;&#x27;: expected &#x27;beanName&quot;</span> + <span class="keyword">this</span>.beanNameSeparator + <span class="string">&quot;property&#x27;&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 得到 beanName</span></span><br><span class="line">  String beanName = key.substring(<span class="number">0</span>, separatorIndex);</span><br><span class="line">  <span class="comment">// 得到属性值</span></span><br><span class="line">  String beanProperty = key.substring(separatorIndex+<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">this</span>.beanNames.add(beanName);</span><br><span class="line">  <span class="comment">// 替换</span></span><br><span class="line">  applyPropertyValue(factory, beanName, beanProperty, value);</span><br><span class="line">  <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">    logger.debug(<span class="string">&quot;Property &#x27;&quot;</span> + key + <span class="string">&quot;&#x27; set to value [&quot;</span> + value + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取分割符 “.” 的索引位置，得到 beanName 以及相应的属性，然后调用 <code>applyPropertyValue()</code>，如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">applyPropertyValue</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  ConfigurableListableBeanFactory factory, String beanName, String property, String value)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  BeanDefinition bd = factory.getBeanDefinition(beanName);</span><br><span class="line">  BeanDefinition bdToUse = bd;</span><br><span class="line">  <span class="keyword">while</span> (bd != <span class="keyword">null</span>) &#123;</span><br><span class="line">    bdToUse = bd;</span><br><span class="line">    bd = bd.getOriginatingBeanDefinition();</span><br><span class="line">  &#125;</span><br><span class="line">  PropertyValue pv = <span class="keyword">new</span> PropertyValue(property, value);</span><br><span class="line">  pv.setOptional(<span class="keyword">this</span>.ignoreInvalidKeys);</span><br><span class="line">  bdToUse.getPropertyValues().addPropertyValue(pv);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从容器中获取 BeanDefinition ，然后根据属性 property 和 其值 value 构造成一个 PropertyValue 对象，最后调用 <code>addPropertyValue()</code> 方法。<strong>PropertyValue 是用于保存一组bean属性的信息和值的对像。</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> MutablePropertyValues <span class="title">addPropertyValue</span><span class="params">(PropertyValue pv)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.propertyValueList.size(); i++) &#123;</span><br><span class="line">  PropertyValue currentPv = <span class="keyword">this</span>.propertyValueList.get(i);</span><br><span class="line">  <span class="keyword">if</span> (currentPv.getName().equals(pv.getName())) &#123;</span><br><span class="line">   pv = mergeIfRequired(pv, currentPv);</span><br><span class="line">   setPropertyValueAt(pv, i);</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">this</span>.propertyValueList.add(pv);</span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>添加 PropertyValue 对象，替换或者合并相同的属性值。整个过程其实与上面猜测相差不是很大。</p><p>至此，PropertyOverrideConfigurer 到这里也就分析完毕了。最后看下 PropertyPlaceholderConfigurer 和 PropertyOverrideConfigurer 整体的结构图：</p><p><img src="https://cdn.jsdelivr.net/gh/cayzlh/git-img-repository@master/2020/05/27/spring-201809231002_8yTF1l_7kG2Gt.png" alt="spring-201809231002"></p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
          <category> 《Spring源码分析》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> 转载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IOC之PropertyPlaceholderConfigurer的应用</title>
      <link href="/blog/2020/01/23/cd2eaad8.html"/>
      <url>/blog/2020/01/23/cd2eaad8.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文作者：chenssy</p><p>出处：<a href="http://cmsblogs.com/?p=3839">http://cmsblogs.com/?p=3839</a></p><p>在学习<code>Spring源码</code>的过程中发现的好站+好贴，原创不易感谢作者。</p><p>Spring版本：<strong>Spring 5.0.6.RELEASE</strong></p></blockquote><p>在博客 <a href="/2020/01/23/99d35216.html">IOC 之 深入分析 PropertyPlaceholderConfigurer</a> 中了解了 PropertyPlaceholderConfigurer 内部实现原理，她<strong>允许我们在 XML 配置文件中使用占位符并将这些占位符所代表的资源单独配置到简单的 properties 文件中来加载</strong>。</p><p>这个特性非常重要，因为它我们对 Bean 实例属性的配置变得非常容易控制了，主要使用场景有：</p><ol><li>动态加载配置文件，多环境切换</li><li>属性加解密</li></ol><p>下面我们就第一个应用场景来做说明。</p><p><strong>利用 PropertyPlaceholderConfigurer 实现多环境切换</strong></p><p>在我们项目开发过程中，都会存在多个环境，如 dev 、test 、prod 等等，各个环境的配置都会不一样，在传统的开发过程中我们都是在进行打包的时候进行人工干预，或者将配置文件放在系统外部，加载的时候指定加载目录，这种方式容易出错，那么有没有一种比较好的方式来解决这种情况呢？</p><p>有，<strong>利用 PropertyPlaceholderConfigurer 的特性来动态加载配置文件，实现多环境切换</strong>。</p><p>首先我们定义四个 Properties 文件，如下：</p><p><a href="https://gitee.com/chenssy/blog-home/raw/master/image/201811/15374242055683.jpg"><img src="https://cdn.jsdelivr.net/gh/cayzlh/git-img-repository@master/2020/05/26/15374242055683_YcHOyX.jpg" alt="img"></a></p><p>内容如下：</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># application-dev.properties</span></span><br><span class="line"><span class="meta">student.name</span>=<span class="string">chenssy-dev</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># application-test.properties</span></span><br><span class="line"><span class="meta">student.name</span>=<span class="string">chenssy-test</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># application-prod.properties</span></span><br><span class="line"><span class="meta">student.name</span>=<span class="string">chenssy-prod</span></span><br></pre></td></tr></table></figure><p>然后实现一个类，该类继承 PropertyPlaceholderConfigurer，实现 <code>loadProperties()</code>，根据环境的不同加载不同的配置文件，如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomPropertyConfig</span> <span class="keyword">extends</span> <span class="title">PropertyPlaceholderConfigurer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Resource[] locations;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> PropertiesPersister propertiesPersister = <span class="keyword">new</span> DefaultPropertiesPersister();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLocations</span><span class="params">(Resource[] locations)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.locations = locations;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLocalOverride</span><span class="params">(<span class="keyword">boolean</span> localOverride)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.localOverride = localOverride;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 覆盖这个方法，根据启动参数，动态读取配置文件</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> props</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">loadProperties</span><span class="params">(Properties props)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (locations != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// locations 里面就已经包含了那三个定义的文件</span></span><br><span class="line">            <span class="keyword">for</span> (Resource location : <span class="keyword">this</span>.locations) &#123;</span><br><span class="line">                InputStream is = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    String filename = location.getFilename();</span><br><span class="line">                    String env = <span class="string">&quot;application-&quot;</span> + System.getProperty(<span class="string">&quot;spring.profiles.active&quot;</span>, <span class="string">&quot;dev&quot;</span>) + <span class="string">&quot;.properties&quot;</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 找到我们需要的文件，加载</span></span><br><span class="line">                    <span class="keyword">if</span> (filename.contains(env)) &#123;</span><br><span class="line">                        logger.info(<span class="string">&quot;Loading properties file from &quot;</span> + location);</span><br><span class="line">                        is = location.getInputStream();</span><br><span class="line">                        <span class="keyword">this</span>.propertiesPersister.load(props, is);</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">                    logger.info(<span class="string">&quot;读取配置文件失败.....&quot;</span>);</span><br><span class="line">                    <span class="keyword">throw</span> ex;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (is != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        is.close();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置文件：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;PropertyPlaceholderConfigurer&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.core.custom.CustomPropertyConfig&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;locations&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">value</span>&gt;</span>classpath:config/application-dev.properties<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">value</span>&gt;</span>classpath:config/application-test.properties<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">value</span>&gt;</span>classpath:config/application-prod.properties<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;studentService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.core.service.StudentService&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;student.name&#125;&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在 idea 的 VM options 里面增加 <code>-Dspring.profiles.active=dev</code>，标志当前环境为 dev 环境。测试代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;spring.xml&quot;</span>);</span><br><span class="line"></span><br><span class="line">StudentService studentService = (StudentService) context.getBean(<span class="string">&quot;studentService&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;student name:&quot;</span> + studentService.getName());</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">student name:chenssy-dev</span><br></pre></td></tr></table></figure><p>当将 <code>-Dspring.profiles.active</code> 调整为 test，则打印结果则是 chenssy-test，这样就完全实现了根据不同的环境加载不同的配置，如果各位用过 Spring Boot 的话，这个就完全是 Spring Boot 里面的 profiles.active 。</p><p>可以看到，PropertyPlaceholderConfigurer 对于属性的配置非常灵活。</p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
          <category> 《Spring源码分析》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> 转载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IOC之深入分析PropertyPlaceholderConfigurer</title>
      <link href="/blog/2020/01/23/99d35216.html"/>
      <url>/blog/2020/01/23/99d35216.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文作者：chenssy</p><p>出处：<a href="http://cmsblogs.com/?p=3837">http://cmsblogs.com/?p=3837</a></p><p>在学习<code>Spring源码</code>的过程中发现的好站+好贴，原创不易感谢作者。</p><p>Spring版本：<strong>Spring 5.0.6.RELEASE</strong></p></blockquote><p>在上文 <a href="/2020/01/23/81b83a69.html">IOC 之 深入分析 BeanFactoryPostProcessor</a> 介绍了 BeanFactoryPostProcessor，知道 BeanFactoryPostProcessor 作用域容器启动阶段，可以对解析好的 BeanDefinition 进行定制化处理，而其中 PropertyPlaceholderConfigurer 是其一个非常重要的应用，也是其子类，介绍如下：</p><blockquote><p>PropertyPlaceholderConfigurer 允许我们用 Properties 文件中的属性来定义应用上下文（配置文件或者注解）</p></blockquote><p>什么意思，就是说我们在 XML 配置文件（或者其他方式，如注解方式）中使用占位符的方式来定义一些资源，并将这些占位符所代表的资源配置到 Properties 中，这样只需要对 Properties 文件进行修改即可，这个特性非常，在后面来介绍一种我们在项目中经常用到场景。</p><p><img src="https://cdn.jsdelivr.net/gh/cayzlh/git-img-repository@master/2020/05/26/201809161001_Jd3Eac_N7lPj5.png" alt="201809161001"></p><p>从 PropertyPlaceholderConfigurer 的结构图可以看出，它间接实现了 Aware 和 BeanFactoryPostProcessor 两大扩展接口，这里只需要关注 BeanFactoryPostProcessor 即可。</p><p>我们知道 BeanFactoryPostProcessor 提供了 <code>postProcessBeanFactory()</code>，在这个体系中该方法的是在 PropertyResourceConfigurer 中实现，该类为属性资源的配置类，他实现了 BeanFactoryPostProcessor 接口，如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line">  Properties mergedProps = mergeProperties();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 转换合并属性</span></span><br><span class="line">  convertProperties(mergedProps);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 子类处理</span></span><br><span class="line">  processProperties(beanFactory, mergedProps);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> BeanInitializationException(<span class="string">&quot;Could not load properties&quot;</span>, ex);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>mergeProperties()</code>：返回合并的 Properties 实例，Properties 实例维护这一组 key-value ，其实就是 Properties 配置文件中的内容。</li><li><code>convertProperties()</code>：转换合并的值，其实就是将原始值替换为真正的值</li><li><code>processProperties()</code>：前面两个步骤已经将配置文件中的值进行了处理，那么该方法就是真正的替换过程，该方法由子类实现。</li></ul><p>在 PropertyPlaceholderConfigurer 重写 <code>processProperties()</code>:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">processProperties</span><span class="params">(ConfigurableListableBeanFactory beanFactoryToProcess, Properties props)</span></span></span><br><span class="line"><span class="function">  <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"></span><br><span class="line"> StringValueResolver valueResolver = <span class="keyword">new</span> PlaceholderResolvingStringValueResolver(props);</span><br><span class="line"> doProcessProperties(beanFactoryToProcess, valueResolver);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先构造一个 PlaceholderResolvingStringValueResolver 类型的 StringValueResolver 实例。StringValueResolver 为一个解析 String 类型值的策略接口，该接口提供了 <code>resolveStringValue()</code> 方法用于解析 String 值。PlaceholderResolvingStringValueResolver 为其一个解析策略，构造方法如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PlaceholderResolvingStringValueResolver</span><span class="params">(Properties props)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">this</span>.helper = <span class="keyword">new</span> PropertyPlaceholderHelper(</span><br><span class="line">   placeholderPrefix, placeholderSuffix, valueSeparator, ignoreUnresolvablePlaceholders);</span><br><span class="line"> <span class="keyword">this</span>.resolver = <span class="keyword">new</span> PropertyPlaceholderConfigurerResolver(props);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在构造 String 值解析器 StringValueResolver 时，将已经解析的 Properties 实例对象封装在 PlaceholderResolver 实例 resolver 中。PlaceholderResolver 是一个用于解析字符串中包含占位符的替换值的策略接口，该接口有一个 <code>resolvePlaceholder()</code> 方法，用于返回占位符的替换值。还有一个 PropertyPlaceholderHelper 工具，从名字上面看应该是进行替换的。</p><p>得到 String 解析器的实例 valueResolver 后，则会调用 <code>doProcessProperties()</code> 方法来进行诊治的替换操作，该方法在父类 PlaceholderConfigurerSupport 中实现，如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doProcessProperties</span><span class="params">(ConfigurableListableBeanFactory beanFactoryToProcess,</span></span></span><br><span class="line"><span class="function"><span class="params">  StringValueResolver valueResolver)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> BeanDefinitionVisitor visitor = <span class="keyword">new</span> BeanDefinitionVisitor(valueResolver);</span><br><span class="line"></span><br><span class="line"> String[] beanNames = beanFactoryToProcess.getBeanDefinitionNames();</span><br><span class="line"> <span class="keyword">for</span> (String curName : beanNames) &#123;</span><br><span class="line">  <span class="comment">// 校验</span></span><br><span class="line">  <span class="comment">// 1. 当前实例 PlaceholderConfigurerSupport 不在解析范围内</span></span><br><span class="line">     <span class="comment">// 2. 同一个 Spring 容器</span></span><br><span class="line">  <span class="keyword">if</span> (!(curName.equals(<span class="keyword">this</span>.beanName) &amp;&amp; beanFactoryToProcess.equals(<span class="keyword">this</span>.beanFactory))) &#123;</span><br><span class="line">   BeanDefinition bd = beanFactoryToProcess.getBeanDefinition(curName);</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">    visitor.visitBeanDefinition(bd);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(bd.getResourceDescription(), curName, ex.getMessage(), ex);</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 别名的占位符</span></span><br><span class="line"> beanFactoryToProcess.resolveAliases(valueResolver);</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 解析嵌入值的占位符，例如注释属性</span></span><br><span class="line">       beanFactoryToProcess.addEmbeddedValueResolver(valueResolver);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>流程如下：</p><ol><li>根据 String 值解析策略 valueResolver 得到 BeanDefinitionVisitor 实例。BeanDefinitionVisitor 是 BeanDefinition 的访问者，我们通过它可以实现对 BeanDefinition 内容的进行访问，内容很多，例如Scope、PropertyValues、FactoryMethodName 等等。</li><li>得到该容器的所有 BeanName，然后对其进行访问（<code>visitBeanDefinition()</code>）。</li><li>解析别名的占位符</li><li>解析嵌入值的占位符，例如注释属性</li></ol><p>这个方法核心在于 <code>visitBeanDefinition()</code> 的调用，如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitBeanDefinition</span><span class="params">(BeanDefinition beanDefinition)</span> </span>&#123;</span><br><span class="line"> visitParentName(beanDefinition);</span><br><span class="line"> visitBeanClassName(beanDefinition);</span><br><span class="line"> visitFactoryBeanName(beanDefinition);</span><br><span class="line"> visitFactoryMethodName(beanDefinition);</span><br><span class="line"> visitScope(beanDefinition);</span><br><span class="line"> <span class="keyword">if</span> (beanDefinition.hasPropertyValues()) &#123;</span><br><span class="line">  visitPropertyValues(beanDefinition.getPropertyValues());</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">if</span> (beanDefinition.hasConstructorArgumentValues()) &#123;</span><br><span class="line">  ConstructorArgumentValues cas = beanDefinition.getConstructorArgumentValues();</span><br><span class="line">  visitIndexedArgumentValues(cas.getIndexedArgumentValues());</span><br><span class="line">  visitGenericArgumentValues(cas.getGenericArgumentValues());</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到该方法基本访问了 BeanDefinition 中所有值得访问的东西了，包括 parent 、class 、factory-bean 、factory-method 、scope 、property 、constructor-arg ，本篇文章的主题是 property，所以关注 <code>visitPropertyValues()</code> 即可。如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">visitPropertyValues</span><span class="params">(MutablePropertyValues pvs)</span> </span>&#123;</span><br><span class="line"> PropertyValue[] pvArray = pvs.getPropertyValues();</span><br><span class="line"> <span class="keyword">for</span> (PropertyValue pv : pvArray) &#123;</span><br><span class="line">  Object newVal = resolveValue(pv.getValue());</span><br><span class="line">  <span class="keyword">if</span> (!ObjectUtils.nullSafeEquals(newVal, pv.getValue())) &#123;</span><br><span class="line">   pvs.add(pv.getName(), newVal);</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>过程就是对属性数组进行遍历，调用 <code>resolveValue()</code> 对属性进行解析获取最新值，如果新值和旧值不等，则用新值替换旧值。<code>resolveValue()</code> 实现如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">resolveValue</span><span class="params">(<span class="meta">@Nullable</span> Object value)</span> </span>&#123;</span><br><span class="line"> <span class="comment">// 由于 Properties 中的是 String，所以把前面一堆 if 去掉</span></span><br><span class="line"> <span class="keyword">else</span> <span class="keyword">if</span> (value <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">  <span class="keyword">return</span> resolveStringValue((String) value);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于配置的是 String 类型，所以只需要看 String 相关的，<code>resolveStringValue()</code> 实现如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">protected</span> String <span class="title">resolveStringValue</span><span class="params">(String strVal)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">if</span> (<span class="keyword">this</span>.valueResolver == <span class="keyword">null</span>) &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;No StringValueResolver specified - pass a resolver &quot;</span> +</span><br><span class="line">    <span class="string">&quot;object into the constructor or override the &#x27;resolveStringValue&#x27; method&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> String resolvedValue = <span class="keyword">this</span>.valueResolver.resolveStringValue(strVal);</span><br><span class="line"> <span class="keyword">return</span> (strVal.equals(resolvedValue) ? strVal : resolvedValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>valueResolver 是我们在构造 BeanDefinitionVisitor 实例时传入的 String 类型解析器 PlaceholderResolvingStringValueResolver，调用其 <code>resolveStringValue()</code> 如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">resolveStringValue</span><span class="params">(String strVal)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"> String resolved = <span class="keyword">this</span>.helper.replacePlaceholders(strVal, <span class="keyword">this</span>.resolver);</span><br><span class="line"> <span class="keyword">if</span> (trimValues) &#123;</span><br><span class="line">  resolved = resolved.trim();</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> (resolved.equals(nullValue) ? <span class="keyword">null</span> : resolved);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>helper 为 PropertyPlaceholderHelper 实例对象，而 PropertyPlaceholderHelper 则是处理应用程序中包含占位符的字符串工具类。在构造 helper 实例对象时需要传入了几个参数：placeholderPrefix、placeholderSuffix、valueSeparator，这些值在 PlaceholderConfigurerSupport 中定义如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> String placeholderPrefix = <span class="string">&quot;$&#123;&quot;</span>;</span><br><span class="line"><span class="keyword">protected</span> String placeholderSuffix = <span class="string">&quot;&#125;&quot;</span>;</span><br><span class="line"><span class="keyword">protected</span> String valueSeparator = <span class="string">&quot;:&quot;</span>;</span><br></pre></td></tr></table></figure><p>调用 <code>replacePlaceholders()</code> 进行占位符替换，如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">replacePlaceholders</span><span class="params">(String value, PlaceholderResolver placeholderResolver)</span> </span>&#123;</span><br><span class="line"> Assert.notNull(value, <span class="string">&quot;&#x27;value&#x27; must not be null&quot;</span>);</span><br><span class="line"> <span class="keyword">return</span> parseStringValue(value, placeholderResolver, <span class="keyword">new</span> HashSet&lt;&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用 <code>parseStringValue()</code>，这个方法是这篇博客最核心的地方，<code>$&#123;&#125;</code> 占位符的替换：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> String <span class="title">parseStringValue</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  String value, PlaceholderResolver placeholderResolver, Set&lt;String&gt; visitedPlaceholders)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  StringBuilder result = <span class="keyword">new</span> StringBuilder(value);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取前缀 &quot;$&#123;&quot; 的索引位置</span></span><br><span class="line">  <span class="keyword">int</span> startIndex = value.indexOf(<span class="keyword">this</span>.placeholderPrefix);</span><br><span class="line">  <span class="keyword">while</span> (startIndex != -<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 后缀 &quot;&#125;&quot; 的索引位置</span></span><br><span class="line">    <span class="keyword">int</span> endIndex = findPlaceholderEndIndex(result, startIndex);</span><br><span class="line">    <span class="keyword">if</span> (endIndex != -<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 截取 &quot;$&#123;&quot; 和 &quot;&#125;&quot; 中间的内容，这也就是我们在配置文件中对应的值</span></span><br><span class="line">      String placeholder = result.substring(startIndex + <span class="keyword">this</span>.placeholderPrefix.length(), endIndex);</span><br><span class="line">      String originalPlaceholder = placeholder;</span><br><span class="line">      <span class="keyword">if</span> (!visitedPlaceholders.add(originalPlaceholder)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">          <span class="string">&quot;Circular placeholder reference &#x27;&quot;</span> + originalPlaceholder + <span class="string">&quot;&#x27; in property definitions&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 解析占位符键中包含的占位符，真正的值</span></span><br><span class="line">      placeholder = parseStringValue(placeholder, placeholderResolver, visitedPlaceholders);</span><br><span class="line">      <span class="comment">// 从 Properties 中获取 placeHolder 对应的值 propVal</span></span><br><span class="line">      String propVal = placeholderResolver.resolvePlaceholder(placeholder);</span><br><span class="line">      <span class="comment">// 如果不存在</span></span><br><span class="line">      <span class="keyword">if</span> (propVal == <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.valueSeparator != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 查询 : 的位置</span></span><br><span class="line">        <span class="keyword">int</span> separatorIndex = placeholder.indexOf(<span class="keyword">this</span>.valueSeparator);</span><br><span class="line">        <span class="comment">// 如果存在 :</span></span><br><span class="line">        <span class="keyword">if</span> (separatorIndex != -<span class="number">1</span>) &#123;</span><br><span class="line">          <span class="comment">// 获取 : 前面部分 actualPlaceholder</span></span><br><span class="line">          String actualPlaceholder = placeholder.substring(<span class="number">0</span>, separatorIndex);</span><br><span class="line">          <span class="comment">// 获取 : 后面部分 defaultValue</span></span><br><span class="line">          String defaultValue = placeholder.substring(separatorIndex + <span class="keyword">this</span>.valueSeparator.length());</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 从 Properties 中获取 actualPlaceholder 对应的值</span></span><br><span class="line">          propVal = placeholderResolver.resolvePlaceholder(actualPlaceholder);</span><br><span class="line">          <span class="comment">// 如果不存在 则返回 defaultValue</span></span><br><span class="line">          <span class="keyword">if</span> (propVal == <span class="keyword">null</span>) &#123;</span><br><span class="line">            propVal = defaultValue;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (propVal != <span class="keyword">null</span>) &#123;</span><br><span class="line">        propVal = parseStringValue(propVal, placeholderResolver, visitedPlaceholders);</span><br><span class="line">        result.replace(startIndex, endIndex + <span class="keyword">this</span>.placeholderSuffix.length(), propVal);</span><br><span class="line">        <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">          logger.trace(<span class="string">&quot;Resolved placeholder &#x27;&quot;</span> + placeholder + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        startIndex = result.indexOf(<span class="keyword">this</span>.placeholderPrefix, startIndex + propVal.length());</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.ignoreUnresolvablePlaceholders) &#123;</span><br><span class="line">        <span class="comment">// 忽略值</span></span><br><span class="line">        startIndex = result.indexOf(<span class="keyword">this</span>.placeholderPrefix, endIndex + <span class="keyword">this</span>.placeholderSuffix.length());</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Could not resolve placeholder &#x27;&quot;</span> +</span><br><span class="line">                                           placeholder + <span class="string">&quot;&#x27;&quot;</span> + <span class="string">&quot; in value \&quot;&quot;</span> + value + <span class="string">&quot;\&quot;&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">      visitedPlaceholders.remove(originalPlaceholder);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      startIndex = -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回propVal，就是替换之后的值</span></span><br><span class="line">  <span class="keyword">return</span> result.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>流程如下</p><ol><li>获取占位符前缀 “${“ 的索引位置 startIndex</li><li>如果前缀 “${“ 存在，则从 “{” 后面开始获取占位符后缀 “}” 的索引位置 endIndex</li><li>如果前缀 “${” 和后缀 “}” 都存在，则截取中间部分 placeholder</li><li>从 Properties 中获取 placeHolder 对应的值 propVal</li><li>如果 propVal 为空，则判断占位符中是否存在 “:”，如果存在则对占位符进行分割处理，全面部分为 actualPlaceholder，后面部分 defaultValue，尝试从 Properties 中获取 actualPlaceholder 对应的值 propVal，如果不存在，则将 defaultValue 的值赋值给 propVal</li><li>返回 propVal，也就是 Properties 中对应的值</li></ol>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
          <category> 《Spring源码分析》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> 转载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IOC之深入分析BeanFactoryPostProcessor</title>
      <link href="/blog/2020/01/23/81b83a69.html"/>
      <url>/blog/2020/01/23/81b83a69.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文作者：chenssy</p><p>出处：<a href="http://cmsblogs.com/?p=3342">http://cmsblogs.com/?p=3342</a></p><p>在学习<code>Spring源码</code>的过程中发现的好站+好贴，原创不易感谢作者。</p><p>Spring版本：<strong>Spring 5.0.6.RELEASE</strong></p></blockquote><p>在博客 <a href="/2020/01/22/aa8c9efa.html"> IOC 之 深入分析 BeanPostProcessor</a> 深入介绍了 BeanPostProcessor 的实现机制。在这篇文章中提到 BeanPostProcessor 是 Spring 提供一种扩展机制，该机制允许我们在 Bean 实例化之后初始化之际对 Bean 进行增强处理（前、后置处理）。</p><p>同样在 Spring 容器启动阶段，Spring 也提供了一种容器扩展机制：<code>BeanFactoryPostProcessor</code>，该机制作用于容器启动阶段，允许我们在容器实例化 <code>Bean</code> 之前对注册到该容器的 <code>BeanDefinition</code> 做出修改。</p><h2 id="BeanFactoryPostProcessor"><a href="#BeanFactoryPostProcessor" class="headerlink" title="BeanFactoryPostProcessor"></a>BeanFactoryPostProcessor</h2><p>BeanFactoryPostProcessor 的机制就相当于给了我们在 bean 实例化之前最后一次修改 BeanDefinition 的机会，我们可以利用这个机会对 BeanDefinition 来进行一些额外的操作，比如更改某些 bean 的一些属性，给某些 Bean 增加一些其他的信息等等操作。</p><p>定义如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanFactoryPostProcessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 1、Modify the application context&#x27;s internal bean factory after its standard initialization.</span></span><br><span class="line"><span class="comment">  *  </span></span><br><span class="line"><span class="comment">  * 2、All bean definitions will have been loaded, but no beans will have been instantiated yet. This allows for overriding or adding properties even to eager-initializing beans.</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> beanFactory the bean factory used by the application context</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@throws</span> org.springframework.beans.BeansException in case of errors</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>BeanFactoryPostProcessor 接口仅有一个 postProcessBeanFactory 方法，该方法接收一个 ConfigurableListableBeanFactory 类型的 beanFactory 参数。上面有两行注释：</p><ul><li>1、表示了该方法的作用：在 standard initialization（实在是不知道这个怎么翻译：标准初始化？） 之后（已经就是已经完成了 BeanDefinition 的加载）对 bean factory 容器进行修改。其中参数 beanFactory 应该就是已经完成了 standard initialization 的 BeanFactory。</li><li>2、表示作用时机：所有的 BeanDefinition 已经完成了加载即加载至 BeanFactory 中，但是还没有完成初始化。</li></ul><p>所以这里总结一句话就是：**<code>postProcessBeanFactory()</code> 工作于BeanDefinition 加载完成之后，Bean 实例化之前，其主要作用是对加载 BeanDefinition 进行修改。**</p><p><u>有一点需要需要注意的是在 <code>postProcessBeanFactory()</code> 中千万不能进行 Bean 的实例化工作，因为这样会导致 bean 过早实例化，会产生严重后果，我们始终需要注意的是 BeanFactoryPostProcessor 是与 BeanDefinition 打交道的，如果想要与 Bean 打交道，请使用 BeanPostProcessor。</u></p><p>与 BeanPostProcessor 一样，BeanFactoryPostProcessor 同样支持排序，一个容器可以同时拥有多个 BeanFactoryPostProcessor，这个时候如果我们比较在乎他们的顺序的话，可以实现 Ordered 接口。</p><p>如果要自定义 BeanFactoryPostProcessor 直接实现该接口即可。</p><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanFactoryPostProcessor_1</span> <span class="keyword">implements</span> <span class="title">BeanFactoryPostProcessor</span>,<span class="title">Ordered</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;调用 BeanFactoryPostProcessor_1 ...&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;容器中有 BeanDefinition 的个数：&quot;</span> + beanFactory.getBeanDefinitionCount());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取指定的 BeanDefinition</span></span><br><span class="line">        BeanDefinition bd = beanFactory.getBeanDefinition(<span class="string">&quot;studentService&quot;</span>);</span><br><span class="line"></span><br><span class="line">        MutablePropertyValues pvs = bd.getPropertyValues();</span><br><span class="line"></span><br><span class="line">        pvs.addPropertyValue(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;chenssy1&quot;</span>);</span><br><span class="line">        pvs.addPropertyValue(<span class="string">&quot;age&quot;</span>,<span class="number">15</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanFactoryPostProcessor_2</span> <span class="keyword">implements</span> <span class="title">BeanFactoryPostProcessor</span> , <span class="title">Ordered</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;调用 BeanFactoryPostProcessor_2 ...&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取指定的 BeanDefinition</span></span><br><span class="line">        BeanDefinition bd = beanFactory.getBeanDefinition(<span class="string">&quot;studentService&quot;</span>);</span><br><span class="line"></span><br><span class="line">        MutablePropertyValues pvs = bd.getPropertyValues();</span><br><span class="line"></span><br><span class="line">        pvs.addPropertyValue(<span class="string">&quot;age&quot;</span>,<span class="number">18</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>提供了两个自定义的 BeanFactoryPostProcessor ，都继承 BeanFactoryPostProcessor 和 Ordered，其中 BeanFactoryPostProcessor_1 改变 name 和 age 的值，BeanFactoryPostProcessor_2 该变 age 的值。Ordered 分别为 1 和 2。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;studentService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.core.service.StudentService&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;chenssy&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span> <span class="attr">value</span>=<span class="string">&quot;10&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.core.test.BeanFactoryPostProcessor_1&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.core.test.BeanFactoryPostProcessor_2&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>studentService 设置 name 和 age 分别为 chenss 和 10。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;spring.xml&quot;</span>);</span><br><span class="line"></span><br><span class="line">StudentService studentService = (StudentService) context.getBean(<span class="string">&quot;studentService&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;student name:&quot;</span> + studentService.getName() + <span class="string">&quot;-- age:&quot;</span> + studentService.getAge());</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">调用 BeanFactoryPostProcessor_1 ...</span><br><span class="line">容器中有 BeanDefinition 的个数：3</span><br><span class="line">调用 BeanFactoryPostProcessor_2 ...</span><br><span class="line">student name:chenssy1-- age:18</span><br></pre></td></tr></table></figure><p>看到运行结果，其实对上面的运行流程就已经一清二楚了。这里就不过多阐述了。</p><p>在上面测试方法中，我们使用的是 ApplicationContext ，对于 ApplicationContext 来说，使用 BeanFactoryPostProcessor 非常方便，因为他会自动识别配置文件中的 BeanFactoryPostProcessor 并且完成注册和调用，我们只需要简单的配置声明即可。</p><p>而对于 BeanFactory 容器来说则不行，他和 BeanPostProcessor 一样需要容器主动去进行注册调用，方法如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BeanFactoryPostProcessor_1 beanFactoryPostProcessor1 = <span class="keyword">new</span> BeanFactoryPostProcessor_1();</span><br><span class="line">beanFactoryPostProcessor1.postProcessBeanFactory(factory);</span><br></pre></td></tr></table></figure><p>至于 ApplicationContext 是如何自动识别和调用，这个我们后续在分析 ApplicationContext 时会做详细说明的，当然，如果有兴趣的同学可以提前看。</p><p>诚然，一般情况下我们是不会主动去自定义 BeanFactoryPostProcessor ，其实 Spring 为我们提供了几个常用的 BeanFactoryPostProcessor，他们是PropertyPlaceholderConfigurer 和 PropertyOverrideConfigurer ，其中 PropertyPlaceholderConfigurer 允许我们在 XML 配置文件中使用占位符并将这些占位符所代表的资源单独配置到简单的 properties 文件中来加载，PropertyOverrideConfigurer 则允许我们使用占位符来明确表明bean 定义中的 property 与 properties 文件中的各配置项之间的对应关系，这两个类在我们大型项目中有非常重要的作用。</p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
          <category> 《Spring源码分析》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> 转载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IOC之深入分析InitializingBean和init-method</title>
      <link href="/blog/2020/01/23/3af7524a.html"/>
      <url>/blog/2020/01/23/3af7524a.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文作者：chenssy</p><p>出处：<a href="http://cmsblogs.com/?p=3340">http://cmsblogs.com/?p=3340</a></p><p>在学习<code>Spring源码</code>的过程中发现的好站+好贴，感谢作者。Spring版本：<strong>Spring 5.0.6.RELEASE</strong></p></blockquote><p>Spring 在 bean 初始化时进行三个检测扩展，也就是说我们可以对 bean 进行三个不同的定制化处理，前面两篇博客 <a href="/2020/01/22/26a31db5.html">IOC 之 深入分析 Aware 接口</a> 和 <a href="/2020/01/22/aa8c9efa.html">IOC 之 深入分析 BeanPostProcessor</a> 已经分析了 Aware 接口族 和 BeanPostProcessor 接口，这篇分析 InitializingBean 接口和 init-method 方法。</p><h2 id="InitializingBean"><a href="#InitializingBean" class="headerlink" title="InitializingBean"></a>InitializingBean</h2><p>Spring 的 InitializingBean 接口为 bean 提供了定义初始化方法的方式，它仅包含了一个方法：<code>afterPropertiesSet()</code>。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">InitializingBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 该方法在 BeanFactory 设置完了所有属性之后被调用</span></span><br><span class="line"><span class="comment">    * 该方法允许 bean 实例设置了所有 bean 属性时执行初始化工作，如果该过程出现了错误则需要抛出异常</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Spring 在完成实例化后，设置完所有属性，进行 “Aware 接口” 和 “BeanPostProcessor 前置处理”之后，会接着检测当前 bean 对象是否实现了 InitializingBean 接口，如果是，则会调用其 <code>afterPropertiesSet()</code> 进一步调整 bean 实例对象的状态。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InitializingBeanTest</span> <span class="keyword">implements</span> <span class="title">InitializingBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;InitializingBeanTest initializing...&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.name = <span class="string">&quot;chenssy 2 号&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 配置项</span></span><br><span class="line">&lt;bean id=<span class="string">&quot;initializingBeanTest&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;org.springframework.core.test.InitializingBeanTest&quot;</span>&gt;</span><br><span class="line">    &lt;property name=<span class="string">&quot;name&quot;</span> value=<span class="string">&quot;chenssy 1 号&quot;</span>/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试代码</span></span><br><span class="line">InitializingBeanTest test = (InitializingBeanTest) factory.getBean(<span class="string">&quot;initializingBeanTest&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;name ：&quot;</span> + test.getName());</span><br></pre></td></tr></table></figure><p>执行结果：</p><p><img src="https://cdn.jsdelivr.net/gh/cayzlh/git-img-repository@master/2020/05/26/15354197568939_ONaKC8_2DYPnU.jpg" alt="img"></p><p>在这个示例中改变了 InitializingBeanTest 示例的 name 属性，也就是说 在 <code>afterPropertiesSet()</code> 中我们是可以改变 bean 的属性的，这相当于 Spring 容器又给我们提供了一种可以改变 bean 实例对象的方法。</p><p>上面提到 bean 初始化阶段（<code>initializeBean()</code> ） Spring 容器会主动检查当前 bean 是否已经实现了 InitializingBean 接口，如果实现了则会调用其 <code>afterPropertiesSet()</code> ,这个主动检查、调用的动作是由 <code>invokeInitMethods()</code> 来完成的。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">invokeInitMethods</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  String beanName, <span class="keyword">final</span> Object bean, <span class="meta">@Nullable</span> RootBeanDefinition mbd)</span></span></span><br><span class="line"><span class="function">  <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 是否实现 InitializingBean</span></span><br><span class="line">  <span class="comment">// 如果实现了 InitializingBean 接口，则只掉调用bean的 afterPropertiesSet()</span></span><br><span class="line">  <span class="keyword">boolean</span> isInitializingBean = (bean <span class="keyword">instanceof</span> InitializingBean);</span><br><span class="line">  <span class="keyword">if</span> (isInitializingBean &amp;&amp; (mbd == <span class="keyword">null</span> || </span><br><span class="line">                             !mbd.isExternallyManagedInitMethod(<span class="string">&quot;afterPropertiesSet&quot;</span>))) &#123;</span><br><span class="line">    <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">      logger.debug(<span class="string">&quot;Invoking afterPropertiesSet() on bean with name &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        AccessController.doPrivileged((PrivilegedExceptionAction&lt;Object&gt;) () -&gt; &#123;</span><br><span class="line">          ((InitializingBean) bean).afterPropertiesSet();</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;, getAccessControlContext());</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (PrivilegedActionException pae) &#123;</span><br><span class="line">        <span class="keyword">throw</span> pae.getException();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 直接调用 afterPropertiesSet()</span></span><br><span class="line">      ((InitializingBean) bean).afterPropertiesSet();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (mbd != <span class="keyword">null</span> &amp;&amp; bean.getClass() != NullBean.class) &#123;</span><br><span class="line">    <span class="comment">// 判断是否指定了 init-method()，</span></span><br><span class="line">    <span class="comment">// 如果指定了 init-method()，则再调用制定的init-method</span></span><br><span class="line">    String initMethodName = mbd.getInitMethodName();</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.hasLength(initMethodName) &amp;&amp;</span><br><span class="line">        !(isInitializingBean &amp;&amp; <span class="string">&quot;afterPropertiesSet&quot;</span>.equals(initMethodName)) &amp;&amp;</span><br><span class="line">        !mbd.isExternallyManagedInitMethod(initMethodName)) &#123;</span><br><span class="line">      <span class="comment">// 利用反射机制执行</span></span><br><span class="line">      invokeCustomInitMethod(beanName, bean, mbd);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先检测当前 bean 是否实现了 InitializingBean 接口，如果实现了则调用其 <code>afterPropertiesSet()</code>，然后再检查是否也指定了 <code>init-method()</code>，如果指定了则通过反射机制调用指定的 <code>init-method()</code>。</p><p>虽然该接口为 Spring 容器的扩展性立下了汗马功劳，但是如果真的让我们的业务对象来实现这个接口就显得不是那么的友好了，Spring 的一个核心理念就是无侵入性，但是如果我们业务类实现这个接口就显得 Spring 容器具有侵入性了。</p><p>所以 Spring 还提供了另外一种实现的方式：init-method 方法</p><h2 id="init-method"><a href="#init-method" class="headerlink" title="init-method()"></a>init-method()</h2><p>在分析分析 <code>&lt;bean&gt;</code> 标签解析过程中我们提到了有关于 <code>init-method</code> 属性，该属性用于在 bean 初始化时指定执行方法，可以用来替代实现 InitializingBean 接口。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InitializingBeanTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setOtherName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;InitializingBeanTest setOtherName...&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.name = <span class="string">&quot;chenssy 3 号&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置文件：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;initializingBeanTest&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.core.test.InitializingBeanTest&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">init-method</span>=<span class="string">&quot;setOtherName&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;chenssy 1 号&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>执行结果:</p><p><img src="https://cdn.jsdelivr.net/gh/cayzlh/git-img-repository@master/2020/05/26/15354257803206_Yefysp_F6Dnx8.jpg" alt="img"></p><p>完全可以达到和 InitializingBean 一样的效果，而且在代码中我们没有看到丝毫 Spring 侵入的现象。</p><p>所以通过 init-method 我们可以使用业务对象中定义的任何方法来实现 bean 实例对象的初始化定制化，而不再受制于 InitializingBean的 <code>afterPropertiesSet()</code>。同时我们可以使用 <code>&lt;beans&gt;</code> 标签的 <code>default-init-method</code> 属性来统一指定初始化方法，这样就省了需要在每个 <code>&lt;bean&gt;</code> 标签中都设置 <code>init-method</code> 这样的繁琐工作了。</p><p>比如在 <code>default-init-method</code> 规定所有初始化操作全部以 <code>initBean()</code> 命名。如下：</p><p><img src="https://cdn.jsdelivr.net/gh/cayzlh/git-img-repository@master/2020/05/26/15354267698650_XG0QGi_5BPa8h.jpg" alt="img"></p><p>从 <code>invokeInitMethods()</code> 中，我们知道 <code>init-method</code> 指定的方法会在 <code>afterPropertiesSet()</code> 之后执行，如果 <code>afterPropertiesSet()</code> 中出现了异常，则 <code>init-method</code> 是不会执行的，而且由于 <code>init-method</code> 采用的是反射执行的方式，所以 <code>afterPropertiesSet()</code> 的执行效率一般会高些，但是并不能排除我们要优先使用 <code>init-method</code>，主要是因为它消除了 bean 对 Spring 的依赖，Spring 没有侵入到我们业务代码，这样会更加符合 Spring 的理念。</p><p>诚然，<code>init-method</code> 是基于 xml 配置文件的，就目前而言，我们的工程几乎都摒弃了配置，而采用注释的方式，那么 <code>@PreDestory</code> 可能适合你，当然这个注解我们后面分析。</p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
          <category> 《Spring源码分析》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> 转载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IOC之深入分析BeanPostProcessor</title>
      <link href="/blog/2020/01/22/aa8c9efa.html"/>
      <url>/blog/2020/01/22/aa8c9efa.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文作者：chenssy</p><p>出处：<a href="http://cmsblogs.com/?p=3338">http://cmsblogs.com/?p=3338</a></p><p>在学习<code>Spring源码</code>的过程中发现的好站+好贴，感谢作者。Spring版本：<strong>Spring 5.0.6.RELEASE</strong></p></blockquote><p>Spring 作为优秀的开源框架，它为我们提供了丰富的可扩展点，除了前面提到的 Aware 接口，还包括其他部分，其中一个很重要的就是 BeanPostProcessor。</p><p>这篇文章主要介绍 BeanPostProcessor 的使用以及其实现原理。我们先看 BeanPostProcessor 的定位：</p><blockquote><p>BeanPostProcessor 的作用：在 Bean 完成实例化后，如果我们需要对其进行一些配置、增加一些自己的处理逻辑，那么请使用 BeanPostProcessor。</p></blockquote><h2 id="BeanPostProcessor-实例"><a href="#BeanPostProcessor-实例" class="headerlink" title="BeanPostProcessor 实例"></a>BeanPostProcessor 实例</h2><p>首先定义一个类，该类实现 BeanPostProcessor 接口，如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanPostProcessorTest</span> <span class="keyword">implements</span> <span class="title">BeanPostProcessor</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Bean [&quot;</span> + beanName + <span class="string">&quot;] 开始初始化&quot;</span>);</span><br><span class="line">        <span class="comment">// 这里一定要返回 bean，不能返回 null</span></span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Bean [&quot;</span> + beanName + <span class="string">&quot;] 完成初始化&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello BeanPostProcessor!!!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试方法如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ClassPathResource resource = <span class="keyword">new</span> ClassPathResource(<span class="string">&quot;spring.xml&quot;</span>);</span><br><span class="line">DefaultListableBeanFactory factory = <span class="keyword">new</span> DefaultListableBeanFactory();</span><br><span class="line">XmlBeanDefinitionReader reader = <span class="keyword">new</span> XmlBeanDefinitionReader(factory);</span><br><span class="line">reader.loadBeanDefinitions(resource);</span><br><span class="line"></span><br><span class="line">BeanPostProcessorTest test = (BeanPostProcessorTest) factory.getBean(<span class="string">&quot;beanPostProcessorTest&quot;</span>);</span><br><span class="line">test.display();</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://gitee.com/cayzlh/img-repo/raw/master/2020/05/25/201808221005_JdCfC6.png" alt="201808221005"></p><p>运行结果比较奇怪，为什么没有执行 <code>postProcessBeforeInitialization()</code> 和 <code>postProcessAfterInitialization()</code> 呢？</p><p>我们 debug 跟踪下代码，这两个方法在 <code>initializeBean()</code> 方法处调用下，如下：</p><p><img src="https://gitee.com/cayzlh/img-repo/raw/master/2020/05/25/201808221006_MDs9T9_IIu6YA.png" alt="201808221006"></p><p>debug，在 <code>postProcessBeforeInitialization()</code>方法中结果如下：</p><p><img src="https://gitee.com/cayzlh/img-repo/raw/master/2020/05/25/15349468564658_aWOjeh_jNYP3X.jpg" alt="img"></p><p>这段代码是通过迭代 <code>getBeanPostProcessors()</code> 返回的结果集来调用 <code>postProcessBeforeInitialization()</code>，但是在这里我们看到该方法返回的结果集为空，所以肯定不会执行相应的 <code>postProcessBeforeInitialization()</code> 方法咯。怎么办？</p><p>答案不言而喻：只需要 <code>getBeanPostProcessors()</code> 返回的结果集中存在至少一个元素即可，该方法定义如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;BeanPostProcessor&gt; <span class="title">getBeanPostProcessors</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">this</span>.beanPostProcessors;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回的 beanPostProcessors 是一个 private 的 List ，也就是说只要该类中存在 <code>beanPostProcessors.add()</code> 的调用我们就找到了入口，在类 AbstractBeanFactory 中找到了如下代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addBeanPostProcessor</span><span class="params">(BeanPostProcessor beanPostProcessor)</span> </span>&#123;</span><br><span class="line"> Assert.notNull(beanPostProcessor, <span class="string">&quot;BeanPostProcessor must not be null&quot;</span>);</span><br><span class="line"> <span class="keyword">this</span>.beanPostProcessors.remove(beanPostProcessor);</span><br><span class="line"> <span class="keyword">this</span>.beanPostProcessors.add(beanPostProcessor);</span><br><span class="line"> <span class="keyword">if</span> (beanPostProcessor <span class="keyword">instanceof</span> InstantiationAwareBeanPostProcessor) &#123;</span><br><span class="line">  <span class="keyword">this</span>.hasInstantiationAwareBeanPostProcessors = <span class="keyword">true</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">if</span> (beanPostProcessor <span class="keyword">instanceof</span> DestructionAwareBeanPostProcessor) &#123;</span><br><span class="line">  <span class="keyword">this</span>.hasDestructionAwareBeanPostProcessors = <span class="keyword">true</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法是由 AbstractBeanFactory 的父类 ConfigurableBeanFactory 定义，它的核心意思就是将指定 BeanPostProcessor 注册到该 BeanFactory 创建的 bean 中，同时它是按照插入的顺序进行注册的，完全忽略 Ordered 接口所表达任何排序语义（在 BeanPostProcessor 中我们提供一个 Ordered 顺序，这个后面讲解）。</p><p>到这里应该就比较熟悉了，其实只需要显示调用 <code>addBeanPostProcessor()</code> 就可以了，加入如下代码。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BeanPostProcessorTest beanPostProcessorTest = <span class="keyword">new</span> BeanPostProcessorTest();</span><br><span class="line">factory.addBeanPostProcessor(beanPostProcessorTest);</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://gitee.com/cayzlh/img-repo/raw/master/2020/05/25/15349479459608_naPbOK_jwAf6w.jpg" alt="img"></p><p>其实还有一种更加简单的方法，这个我们后面再说，先看 BeanPostProcessor 的原理。</p><h2 id="BeanPostProcessor-基本原理"><a href="#BeanPostProcessor-基本原理" class="headerlink" title="BeanPostProcessor 基本原理"></a>BeanPostProcessor 基本原理</h2><p>BeanPostProcessor 接口定义如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanPostProcessor</span> </span>&#123;</span><br><span class="line"> <span class="meta">@Nullable</span></span><br><span class="line"> <span class="function"><span class="keyword">default</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> </span></span><br><span class="line"><span class="function">   <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> bean;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@Nullable</span></span><br><span class="line"> <span class="function"><span class="keyword">default</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span></span></span><br><span class="line"><span class="function">   <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> bean;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>BeanPostProcessor 可以理解为是 Spring 的一个工厂钩子（其实 Spring 提供一系列的钩子，如 Aware 、InitializingBean、DisposableBean），它是 Spring 提供的对象实例化阶段强有力的扩展点，允许 Spring 在实例化 bean 阶段对其进行定制化修改，比较常见的使用场景是处理标记接口实现类或者为当前对象提供代理实现（例如AOP）。</p><p>一般普通的 BeanFactory 是不支持自动注册 BeanPostProcessor 的，需要我们手动调用 <code>addBeanPostProcessor()</code> 进行注册，注册后的 BeanPostProcessor 适用于所有该 BeanFactory 创建的 bean，但是 ApplicationContext 可以在其 bean 定义中自动检测所有的 BeanPostProcessor 并自动完成注册，同时将他们应用到随后创建的任何 bean 中。</p><p><code>postProcessBeforeInitialization()</code> 和 <code>postProcessAfterInitialization()</code> 两个方法都接收一个 Object 类型的 bean，一个 String 类型的 beanName，其中 bean 是已经实例化了的 instanceBean，能拿到这个你是不是可以对它为所欲为了？ 这两个方法是初始化 bean 的前后置处理器，他们应用 <code>invokeInitMethods()</code> 前后。如下图：</p><p><img src="https://gitee.com/cayzlh/img-repo/raw/master/2020/05/25/201808231001_GnvpHv_yyK7tM.png" alt="201808231001"></p><p>代码层次上面已经贴出来，这里再贴一次：</p><p><img src="https://gitee.com/cayzlh/img-repo/raw/master/2020/05/25/201808221006_MDs9T9-20200525100713002_HB4JRD.png" alt="201808221006"></p><p>两者源码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">applyBeanPostProcessorsBeforeInitialization</span><span class="params">(Object existingBean, String beanName)</span></span></span><br><span class="line"><span class="function">  <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"></span><br><span class="line"> Object result = existingBean;</span><br><span class="line"> <span class="keyword">for</span> (BeanPostProcessor beanProcessor : getBeanPostProcessors()) &#123;</span><br><span class="line">  Object current = beanProcessor.postProcessBeforeInitialization(result, beanName);</span><br><span class="line">  <span class="keyword">if</span> (current == <span class="keyword">null</span>) &#123;</span><br><span class="line">   <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">  result = current;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">applyBeanPostProcessorsAfterInitialization</span><span class="params">(Object existingBean, String beanName)</span></span></span><br><span class="line"><span class="function">  <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"></span><br><span class="line"> Object result = existingBean;</span><br><span class="line"> <span class="keyword">for</span> (BeanPostProcessor beanProcessor : getBeanPostProcessors()) &#123;</span><br><span class="line">  Object current = beanProcessor.postProcessAfterInitialization(result, beanName);</span><br><span class="line">  <span class="keyword">if</span> (current == <span class="keyword">null</span>) &#123;</span><br><span class="line">   <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">  result = current;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>getBeanPostProcessors()</code> 返回的是 beanPostProcessors 集合，该集合里面存放就是我们自定义的 BeanPostProcessor，如果该集合中存在元素则调用相应的方法，否则就直接返回 bean 了。这也是为什么使用 BeanFactory 容器是无法输出自定义 BeanPostProcessor 里面的内容，因为在 <code>BeanFactory.getBean()</code> 的过程中根本就没有将我们自定义的 BeanPostProcessor 注入进来，所以要想 BeanFactory 容器 的 BeanPostProcessor 生效我们必须手动调用 <code>addBeanPostProcessor()</code> 将定义的 BeanPostProcessor 注册到相应的 BeanFactory 中。但是 ApplicationContext 不需要手动，因为 ApplicationContext 会自动检测并完成注册。</p><p>ApplicationContext 实现自动注册的原因在于我们构造一个 ApplicationContext 实例对象的时候会调用 <code>registerBeanPostProcessors()</code> 方法将检测到的 BeanPostProcessor 注入到 ApplicationContext 容器中，同时应用到该容器创建的 bean 中。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 实例化并调用已经注入的 BeanPostProcessor</span></span><br><span class="line"><span class="comment">     * 必须在应用中 bean 实例化之前调用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">registerBeanPostProcessors</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">  PostProcessorRegistrationDelegate.registerBeanPostProcessors(beanFactory, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerBeanPostProcessors</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  ConfigurableListableBeanFactory beanFactory, AbstractApplicationContext applicationContext)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取所有的 BeanPostProcessor 的 beanName</span></span><br><span class="line">  <span class="comment">// 这些 beanName 都已经全部加载到容器中去，但是没有实例化</span></span><br><span class="line">  String[] postProcessorNames = beanFactory.getBeanNamesForType(BeanPostProcessor.class, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 记录所有的beanProcessor数量</span></span><br><span class="line">  <span class="keyword">int</span> beanProcessorTargetCount = beanFactory.getBeanPostProcessorCount() + <span class="number">1</span> + postProcessorNames.length;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 注册 BeanPostProcessorChecker，它主要是用于在 BeanPostProcessor 实例化期间记录日志</span></span><br><span class="line">  <span class="comment">// 当 Spring 中高配置的后置处理器还没有注册就已经开始了 bean 的实例化过程，这个时候便会打印 BeanPostProcessorChecker 中的内容</span></span><br><span class="line">  beanFactory.addBeanPostProcessor(<span class="keyword">new</span> PostProcessorRegistrationDelegate.BeanPostProcessorChecker(beanFactory, beanProcessorTargetCount));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// PriorityOrdered 保证顺序</span></span><br><span class="line">  List&lt;BeanPostProcessor&gt; priorityOrderedPostProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  <span class="comment">// MergedBeanDefinitionPostProcessor</span></span><br><span class="line">  List&lt;BeanPostProcessor&gt; internalPostProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  <span class="comment">// 使用 Ordered 保证顺序</span></span><br><span class="line">  List&lt;String&gt; orderedPostProcessorNames = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  <span class="comment">// 没有顺序</span></span><br><span class="line">  List&lt;String&gt; nonOrderedPostProcessorNames = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  <span class="keyword">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class="line">    <span class="comment">// PriorityOrdered</span></span><br><span class="line">    <span class="keyword">if</span> (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) &#123;</span><br><span class="line">      <span class="comment">// 调用 getBean 获取 bean 实例对象</span></span><br><span class="line">      BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);</span><br><span class="line">      priorityOrderedPostProcessors.add(pp);</span><br><span class="line">      <span class="keyword">if</span> (pp <span class="keyword">instanceof</span> MergedBeanDefinitionPostProcessor) &#123;</span><br><span class="line">        internalPostProcessors.add(pp);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Ordered</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (beanFactory.isTypeMatch(ppName, Ordered.class)) &#123;</span><br><span class="line">      orderedPostProcessorNames.add(ppName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 无序</span></span><br><span class="line">      nonOrderedPostProcessorNames.add(ppName);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 第一步注册所有实现了 PriorityOrdered 的BeanPostProcessor</span></span><br><span class="line">  <span class="comment">// 先排序</span></span><br><span class="line">  sortPostProcessors(priorityOrderedPostProcessors, beanFactory);</span><br><span class="line">  <span class="comment">// 后注册</span></span><br><span class="line">  registerBeanPostProcessors(beanFactory, priorityOrderedPostProcessors);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 第二步注册所有实现了 Ordered 的 BeanPostProcessor</span></span><br><span class="line">  List&lt;BeanPostProcessor&gt; orderedPostProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  <span class="keyword">for</span> (String ppName : orderedPostProcessorNames) &#123;</span><br><span class="line">    BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);</span><br><span class="line">    orderedPostProcessors.add(pp);</span><br><span class="line">    <span class="keyword">if</span> (pp <span class="keyword">instanceof</span> MergedBeanDefinitionPostProcessor) &#123;</span><br><span class="line">      internalPostProcessors.add(pp);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  sortPostProcessors(orderedPostProcessors, beanFactory);</span><br><span class="line">  registerBeanPostProcessors(beanFactory, orderedPostProcessors);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 第三步注册所有无序的 BeanPostProcessor</span></span><br><span class="line">  List&lt;BeanPostProcessor&gt; nonOrderedPostProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  <span class="keyword">for</span> (String ppName : nonOrderedPostProcessorNames) &#123;</span><br><span class="line">    BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);</span><br><span class="line">    nonOrderedPostProcessors.add(pp);</span><br><span class="line">    <span class="keyword">if</span> (pp <span class="keyword">instanceof</span> MergedBeanDefinitionPostProcessor) &#123;</span><br><span class="line">      internalPostProcessors.add(pp);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  registerBeanPostProcessors(beanFactory, nonOrderedPostProcessors);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 最后，注册所有的 MergedBeanDefinitionPostProcessor 类型的 BeanPostProcessor</span></span><br><span class="line">  sortPostProcessors(internalPostProcessors, beanFactory);</span><br><span class="line">  registerBeanPostProcessors(beanFactory, internalPostProcessors);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 加入ApplicationListenerDetector（探测器）</span></span><br><span class="line">  <span class="comment">// 重新注册 BeanPostProcessor 以检测内部 bean，因为 ApplicationListeners 将其移动到处理器链的末尾</span></span><br><span class="line">  beanFactory.addBeanPostProcessor(<span class="keyword">new</span> ApplicationListenerDetector(applicationContext));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法首先 beanFactory 获取注册到该 BeanFactory 中所有 BeanPostProcessor 类型的 beanName，其实就是找所有实现了 BeanPostProcessor 接口的 bean ，然后迭代这些 bean，将其按照PriorityOrdered、Ordered、无序的顺序添加至相应的 List 集合中，最后依次调用 <code>sortPostProcessors()</code> 进行排序处理和 <code>registerBeanPostProcessors()</code> 完成注册。排序很简单，如果 beanFactory 为 DefaultListableBeanFactory 则返回 BeanFactory 所依赖的比较器，否则反正默认的比较器(OrderComparator)，然后调用 <code>sort()</code> 即可。如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sortPostProcessors</span><span class="params">(List&lt;?&gt; postProcessors, ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line"> Comparator&lt;Object&gt; comparatorToUse = <span class="keyword">null</span>;</span><br><span class="line"> <span class="keyword">if</span> (beanFactory <span class="keyword">instanceof</span> DefaultListableBeanFactory) &#123;</span><br><span class="line">  comparatorToUse = ((DefaultListableBeanFactory) beanFactory).getDependencyComparator();</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">if</span> (comparatorToUse == <span class="keyword">null</span>) &#123;</span><br><span class="line">  comparatorToUse = OrderComparator.INSTANCE;</span><br><span class="line"> &#125;</span><br><span class="line"> postProcessors.sort(comparatorToUse);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而对于注册同样是调用 <code>AbstractBeanFactory.addBeanPostProcessor()</code> 方法完成注册，如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerBeanPostProcessors</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  ConfigurableListableBeanFactory beanFactory, List&lt;BeanPostProcessor&gt; postProcessors)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">for</span> (BeanPostProcessor postProcessor : postProcessors) &#123;</span><br><span class="line">  beanFactory.addBeanPostProcessor(postProcessor);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，BeanPostProcessor 已经分析完毕了，这里简单总结下：</p><ol><li>BeanPostProcessor 的作用域是容器级别的，它只和所在的容器相关 ，当 BeanPostProcessor 完成注册后，它会应用于所有跟它在同一个容器内的 bean。</li><li>BeanFactory 和 ApplicationContext 对 BeanPostProcessor 的处理不同，ApplicationContext 会自动检测所有实现了 BeanPostProcessor 接口的 bean，并完成注册，但是使用 BeanFactory 容器时则需要手动调用 <code>addBeanPostProcessor()</code> 完成注册</li><li>ApplicationContext 的 BeanPostProcessor 支持 Ordered，而 BeanFactory 的 BeanPostProcessor 是不支持的，原因在于ApplicationContext 会对 BeanPostProcessor 进行 Ordered 检测并完成排序，而 BeanFactory 中的 BeanPostProcessor 只跟注册的顺序有关。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
          <category> 《Spring源码分析》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> 转载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IOC之深入分析Aware接口</title>
      <link href="/blog/2020/01/22/26a31db5.html"/>
      <url>/blog/2020/01/22/26a31db5.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文作者：chenssy</p><p>出处：<a href="http://cmsblogs.com/?p=3335">http://cmsblogs.com/?p=3335</a></p><p>在学习<code>Spring源码</code>的过程中发现的好站+好贴，感谢作者。Spring版本：<strong>Spring 5.0.6.RELEASE</strong></p></blockquote><p><code>doCreateBean()</code> 方法主要干三件事情：</p><ol><li>实例化 bean 对象：<code>createBeanInstance()</code></li><li>属性注入：<code>populateBean()</code></li><li>初始化 bean 对象：<code>initializeBean()</code></li></ol><p>而初始化 bean 对象时也是干了三件事情：</p><ol><li>激活 Aware 方法</li><li>后置处理器的应用</li><li>激活自定义的 init 方法</li></ol><p>接下来将会详细分析这三件事情，这篇主要分析 Aware 接口。</p><p>Aware 接口定义如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Marker superinterface indicating that a bean is eligible to be</span></span><br><span class="line"><span class="comment"> * notified by the Spring container of a particular framework object</span></span><br><span class="line"><span class="comment"> * through a callback-style method. Actual method signature is</span></span><br><span class="line"><span class="comment"> * determined by individual subinterfaces, but should typically</span></span><br><span class="line"><span class="comment"> * consist of just one void-returning method that accepts a single</span></span><br><span class="line"><span class="comment"> * argument.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Note that merely implementing &#123;<span class="doctag">@link</span> Aware&#125; provides no default</span></span><br><span class="line"><span class="comment"> * functionality. Rather, processing must be done explicitly, for example</span></span><br><span class="line"><span class="comment"> * in a &#123;<span class="doctag">@link</span> org.springframework.beans.factory.config.BeanPostProcessor BeanPostProcessor&#125;.</span></span><br><span class="line"><span class="comment"> * Refer to &#123;<span class="doctag">@link</span> org.springframework.context.support.ApplicationContextAwareProcessor&#125;</span></span><br><span class="line"><span class="comment"> * and &#123;<span class="doctag">@link</span> org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory&#125;</span></span><br><span class="line"><span class="comment"> * for examples of processing &#123;<span class="doctag">@code</span> *Aware&#125; interface callbacks.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Chris Beams</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 3.1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Aware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Aware 接口为 Spring 容器的核心接口，是一个具有标识作用的超级接口，实现了该接口的 bean 是具有被 Spring 容器通知的能力，通知的方式是采用回调的方式。</strong></p><p>Aware 接口是一个空接口，实际的方法签名由各个子接口来确定，且该接口通常只会有一个接收单参数的 set 方法，该 set 方法的命名方式为 set + 去掉接口名中的 Aware 后缀，即 XxxAware 接口，则方法定义为 setXxx()，例如 BeanNameAware（setBeanName），ApplicationContextAware（setApplicationContext）。</p><p>Aware 的子接口需要提供一个 <code>setXxx</code> 方法，我们知道 set 是设置属性值的方法，即 Aware 类接口的 <code>setXxx</code> 方法其实就是设置 xxx 属性值的。</p><p> Aware 的含义是感知的、感应的，那么在 Spring 容器中是如何实现感知并设置属性值得呢？我们可以从初始化 bean 中的激活 Aware 的方法 <code>invokeAwareMethods()</code> 中看到一点点，如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">invokeAwareMethods</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> Object bean)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> Aware) &#123;</span><br><span class="line">    <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> BeanNameAware) &#123;</span><br><span class="line">      ((BeanNameAware) bean).setBeanName(beanName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> BeanClassLoaderAware) &#123;</span><br><span class="line">      ClassLoader bcl = getBeanClassLoader();</span><br><span class="line">      <span class="keyword">if</span> (bcl != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ((BeanClassLoaderAware) bean).setBeanClassLoader(bcl);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> BeanFactoryAware) &#123;</span><br><span class="line">      ((BeanFactoryAware) bean).setBeanFactory(AbstractAutowireCapableBeanFactory.<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先判断 bean 实例是否属于 Aware 接口的范畴，如果是的话，则调用实例的 <code>setXxx()</code> 方法给实例设置 xxx 属性值，在 <code>invokeAwareMethods()</code> 方法主要是设置 beanName，beanClassLoader、BeanFactory 中三个属性值。</p><p>Spring 提供了一系列的 Aware 接口，如下图（部分）：</p><p><img src="https://gitee.com/cayzlh/img-repo/raw/master/2020/05/25/201808210001-20200525092857844_al0UaW.png" alt="201808210001"></p><p>上面只是一部分子类，从这里我们可以看到 Spring 提供的 Aware 接口是是何其多。同时从上图我们也看到了几个比较熟悉的接口，如 <code>BeanClassLoaderAware</code>、<code>BeanFactoryAware</code>、<code>BeanNameAware</code>，下面就这三个接口来做一个简单的演示，先看各自的定义：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanClassLoaderAware</span> <span class="keyword">extends</span> <span class="title">Aware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 将 BeanClassLoader 提供给 bean 实例回调</span></span><br><span class="line"><span class="comment">  * 在 bean 属性填充之后、初始化回调之前回调，</span></span><br><span class="line"><span class="comment">  * 例如InitializingBean的InitializingBean.afterPropertiesSet（）方法或自定义init方法</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">setBeanClassLoader</span><span class="params">(ClassLoader classLoader)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanFactoryAware</span> <span class="keyword">extends</span> <span class="title">Aware</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 将 BeanFactory 提供给 bean 实例回调</span></span><br><span class="line"><span class="comment">  * 调用时机和 setBeanClassLoader 一样</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">setBeanFactory</span><span class="params">(BeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanNameAware</span> <span class="keyword">extends</span> <span class="title">Aware</span> </span>&#123;</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 在创建此 bean 的 bean工厂中设置 beanName</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">setBeanName</span><span class="params">(String name)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ApplicationContextAware</span> <span class="keyword">extends</span> <span class="title">Aware</span> </span>&#123;</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 设置此 bean 对象的 ApplicationContext，通常，该方法用于初始化对象</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面简单演示下上面四个接口的使用方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyApplicationAware</span> <span class="keyword">implements</span> <span class="title">BeanNameAware</span>,<span class="title">BeanFactoryAware</span>,<span class="title">BeanClassLoaderAware</span>,<span class="title">ApplicationContextAware</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String beanName;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> BeanFactory beanFactory;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ClassLoader classLoader;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ApplicationContext applicationContext;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBeanClassLoader</span><span class="params">(ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;调用了 BeanClassLoaderAware 的 setBeanClassLoader 方法&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.classLoader = classLoader;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBeanFactory</span><span class="params">(BeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;调用了 BeanFactoryAware 的 setBeanFactory 方法&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.beanFactory = beanFactory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBeanName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;调用了 BeanNameAware 的 setBeanName 方法&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.beanName = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> </span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;调用了 ApplicationContextAware 的 setApplicationContext 方法&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.applicationContext = applicationContext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;beanName:&quot;</span> + beanName);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;是否为单例：&quot;</span> + beanFactory.isSingleton(beanName));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;系统环境为：&quot;</span> + applicationContext.getEnvironment());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试方法如下:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  ClassPathResource resource = <span class="keyword">new</span> ClassPathResource(<span class="string">&quot;spring.xml&quot;</span>);</span><br><span class="line">  DefaultListableBeanFactory factory = <span class="keyword">new</span> DefaultListableBeanFactory();</span><br><span class="line">  XmlBeanDefinitionReader reader = <span class="keyword">new</span> XmlBeanDefinitionReader(factory);</span><br><span class="line">  reader.loadBeanDefinitions(resource);</span><br><span class="line"></span><br><span class="line">  MyApplicationAware applicationAware = (MyApplicationAware) factory.getBean(<span class="string">&quot;myApplicationAware&quot;</span>);</span><br><span class="line">  applicationAware.display();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://gitee.com/cayzlh/img-repo/raw/master/2020/05/25/201808210002-20200525093149590_fdZ67N.png" alt="201808210002"></p><p>从该运行结果可以看出，这里只执行了三个 Aware 接口的 set 方法，原因就是痛 <code>getBean()</code> 调用时在激活 Aware 接口时只检测了 BeanNameAware、BeanClassLoaderAware、BeanFactoryAware 三个 Aware 接口。如果将测试方法调整为下面：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  ApplicationContext applicationContext = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;spring.xml&quot;</span>);</span><br><span class="line">  MyApplicationAware applicationAware = </span><br><span class="line">    (MyApplicationAware) applicationContext.getBean(<span class="string">&quot;myApplicationAware&quot;</span>);</span><br><span class="line">  applicationAware.display();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>则运行结果如下：</p><p><img src="https://gitee.com/cayzlh/img-repo/raw/master/2020/05/25/201808210003-20200525093254904_40wEa7.png" alt="201808210003"></p><p>从这了我们基本上就可以 Aware 真正的含义是什么了？</p><p>感知，其实是 Spring 容器在初始化主动检测当前 bean 是否实现了 Aware 接口，如果实现了则回调其 set 方法将相应的参数设置给该 bean ，这个时候该 bean 就从 Spring 容器中取得相应的资源。</p><p>最后列出部分常用的 Aware 子接口，便于日后查询：</p><ul><li>LoadTimeWeaverAware：加载Spring Bean时织入第三方模块，如AspectJ</li><li>BeanClassLoaderAware：加载Spring Bean的类加载器</li><li>BootstrapContextAware：资源适配器BootstrapContext，如JCA,CCI</li><li>ResourceLoaderAware：底层访问资源的加载器</li><li>BeanFactoryAware：声明BeanFactory</li><li>PortletConfigAware：PortletConfig</li><li>PortletContextAware：PortletContext</li><li>ServletConfigAware：ServletConfig</li><li>ServletContextAware：ServletContext</li><li>MessageSourceAware：国际化</li><li>ApplicationEventPublisherAware：应用事件</li><li>NotificationPublisherAware：JMX通知</li><li>BeanNameAware：声明Spring Bean的名字</li></ul>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
          <category> 《Spring源码分析》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> 转载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IOC之加载Bean——总结篇</title>
      <link href="/blog/2020/01/21/abeafe18.html"/>
      <url>/blog/2020/01/21/abeafe18.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文作者：chenssy</p><p>出处：<a href="http://cmsblogs.com/?p=2905">http://cmsblogs.com/?p=2905</a></p><p>在学习<code>Spring源码</code>的过程中发现的好站+好贴，感谢作者。Spring版本：<strong>Spring 5.0.6.RELEASE</strong></p></blockquote><p>在<strong>Spring bean 解析篇</strong>深入分析了一个配置文件经历了哪些过程转变成了 BeanDefinition，但是这个 BeanDefinition 并不是我们真正想要的想要的 bean，因为它还仅仅只是承载了我们需要的目标 bean 的信息，从 BeanDefinition 到我们需要的目标还需要一个漫长的 bean 的初始化阶段。</p><p>在 <strong>Spring bean 加载阶段</strong>已经详细分析了初始化 bean 的过程，所以这里做一个概括性的总结。 </p><p>bean 的初始化节点由第一次调用 <code>getBean()</code>(显式或者隐式)开启，所以我们从这个方法开始。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getBean</span><span class="params">(String name)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> doGetBean(name, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function">T <span class="title">doGetBean</span><span class="params">(<span class="keyword">final</span> String name, <span class="meta">@Nullable</span> <span class="keyword">final</span> Class&lt;T&gt; requiredType,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="meta">@Nullable</span> <span class="keyword">final</span> Object[] args, <span class="keyword">boolean</span> typeCheckOnly)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取 beanName，这里是一个转换动作，将 name 转换Wie beanName</span></span><br><span class="line">  <span class="keyword">final</span> String beanName = transformedBeanName(name);</span><br><span class="line">  Object bean;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 从缓存中或者实例工厂中获取 bean</span></span><br><span class="line">  <span class="comment">// *** 这里会涉及到解决循环依赖 bean 的问题</span></span><br><span class="line">  Object sharedInstance = getSingleton(beanName);</span><br><span class="line">  <span class="keyword">if</span> (sharedInstance != <span class="keyword">null</span> &amp;&amp; args == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">        logger.debug(<span class="string">&quot;Returning eagerly cached instance of singleton bean &#x27;&quot;</span> + beanName +</span><br><span class="line">                     <span class="string">&quot;&#x27; that is not fully initialized yet - a consequence of a circular reference&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        logger.debug(<span class="string">&quot;Returning cached instance of singleton bean &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    bean = getObjectForBeanInstance(sharedInstance, name, beanName, <span class="keyword">null</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 因为 Spring 只解决单例模式下得循环依赖，在原型模式下如果存在循环依赖则会抛出异常</span></span><br><span class="line">    <span class="comment">// **关于循环依赖后续会单独出文详细说明**</span></span><br><span class="line">    <span class="keyword">if</span> (isPrototypeCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BeanCurrentlyInCreationException(beanName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果容器中没有找到，则从父类容器中加载</span></span><br><span class="line">    BeanFactory parentBeanFactory = getParentBeanFactory();</span><br><span class="line">    <span class="keyword">if</span> (parentBeanFactory != <span class="keyword">null</span> &amp;&amp; !containsBeanDefinition(beanName)) &#123;</span><br><span class="line">      String nameToLookup = originalBeanName(name);</span><br><span class="line">      <span class="keyword">if</span> (parentBeanFactory <span class="keyword">instanceof</span> AbstractBeanFactory) &#123;</span><br><span class="line">        <span class="keyword">return</span> ((AbstractBeanFactory) parentBeanFactory).doGetBean(</span><br><span class="line">          nameToLookup, requiredType, args, typeCheckOnly);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (args != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> (T) parentBeanFactory.getBean(nameToLookup, args);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> parentBeanFactory.getBean(nameToLookup, requiredType);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果不是仅仅做类型检查则是创建bean，这里需要记录</span></span><br><span class="line">    <span class="keyword">if</span> (!typeCheckOnly) &#123;</span><br><span class="line">      markBeanAsCreated(beanName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 从容器中获取 beanName 相应的 GenericBeanDefinition，并将其转换为 RootBeanDefinition</span></span><br><span class="line">      <span class="keyword">final</span> RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 检查给定的合并的 BeanDefinition</span></span><br><span class="line">      checkMergedBeanDefinition(mbd, beanName, args);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 处理所依赖的 bean</span></span><br><span class="line">      String[] dependsOn = mbd.getDependsOn();</span><br><span class="line">      <span class="keyword">if</span> (dependsOn != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (String dep : dependsOn) &#123;</span><br><span class="line">          <span class="comment">// 若给定的依赖 bean 已经注册为依赖给定的b ean</span></span><br><span class="line">          <span class="comment">// 循环依赖的情况</span></span><br><span class="line">          <span class="keyword">if</span> (isDependent(beanName, dep)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line">                                            <span class="string">&quot;Circular depends-on relationship between &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27; and &#x27;&quot;</span> + dep + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// 缓存依赖调用</span></span><br><span class="line">          registerDependentBean(dep, beanName);</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            getBean(dep);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">catch</span> (NoSuchBeanDefinitionException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line">                                            <span class="string">&quot;&#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27; depends on missing bean &#x27;&quot;</span> + dep + <span class="string">&quot;&#x27;&quot;</span>, ex);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// bean 实例化</span></span><br><span class="line">      <span class="comment">// 单例模式</span></span><br><span class="line">      <span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">        sharedInstance = getSingleton(beanName, () -&gt; &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">            <span class="comment">// 显示从单利缓存中删除 bean 实例</span></span><br><span class="line">            <span class="comment">// 因为单例模式下为了解决循环依赖，可能他已经存在了，所以销毁它</span></span><br><span class="line">            destroySingleton(beanName);</span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 原型模式</span></span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (mbd.isPrototype()) &#123;</span><br><span class="line">        <span class="comment">// It&#x27;s a prototype -&gt; create a new instance.</span></span><br><span class="line">        Object prototypeInstance = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          beforePrototypeCreation(beanName);</span><br><span class="line">          prototypeInstance = createBean(beanName, mbd, args);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">          afterPrototypeCreation(beanName);</span><br><span class="line">        &#125;</span><br><span class="line">        bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 从指定的 scope 下创建 bean</span></span><br><span class="line">        String scopeName = mbd.getScope();</span><br><span class="line">        <span class="keyword">final</span> Scope scope = <span class="keyword">this</span>.scopes.get(scopeName);</span><br><span class="line">        <span class="keyword">if</span> (scope == <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;No Scope registered for scope name &#x27;&quot;</span> + scopeName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          Object scopedInstance = scope.get(beanName, () -&gt; &#123;</span><br><span class="line">            beforePrototypeCreation(beanName);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">finally</span> &#123;</span><br><span class="line">              afterPrototypeCreation(beanName);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;);</span><br><span class="line">          bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (IllegalStateException ex) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(beanName,</span><br><span class="line">                                          <span class="string">&quot;Scope &#x27;&quot;</span> + scopeName + <span class="string">&quot;&#x27; is not active for the current thread; consider &quot;</span> +</span><br><span class="line">                                          <span class="string">&quot;defining a scoped proxy for this bean if you intend to refer to it from a singleton&quot;</span>,</span><br><span class="line">                                          ex);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">      cleanupAfterBeanCreationFailure(beanName);</span><br><span class="line">      <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 检查需要的类型是否符合 bean 的实际类型</span></span><br><span class="line">  <span class="keyword">if</span> (requiredType != <span class="keyword">null</span> &amp;&amp; !requiredType.isInstance(bean)) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      T convertedBean = getTypeConverter().convertIfNecessary(bean, requiredType);</span><br><span class="line">      <span class="keyword">if</span> (convertedBean == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> convertedBean;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (TypeMismatchException ex) &#123;</span><br><span class="line">      <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">        logger.debug(<span class="string">&quot;Failed to convert bean &#x27;&quot;</span> + name + <span class="string">&quot;&#x27; to required type &#x27;&quot;</span> +</span><br><span class="line">                     ClassUtils.getQualifiedName(requiredType) + <span class="string">&quot;&#x27;&quot;</span>, ex);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (T) bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内部调用 <code>doGetBean()</code> 方法，<code>doGetBean()</code> 的代码量比较多，从这里就可以看出 bean 的加载过程是一个非常复杂的过程，会涉及到各种各样的情况处理。<code>doGetBean()</code> 可以分为以下几个过程。</p><ol><li>转换 beanName。因为我们调用 <code>getBean()</code> 方法传入的 name 并不一定就是 beanName，可以传入 aliasName，FactoryBean，所以这里需要进行简单的转换过程。</li><li>尝试从缓存中加载单例 bean。</li><li>bean 的实例化。</li><li>原型模式的依赖检查。因为 Spring 只会解决单例模式的循环依赖，对于原型模式的循环依赖都是直接抛出 BeanCurrentlyInCreationException 异常。</li><li>尝试从 parentBeanFactory 获取 bean 实例。如果 <code>parentBeanFactory != null &amp;&amp; !containsBeanDefinition(beanName)</code> 则尝试从 parentBeanFactory 中获取 bean 实例对象，因为 <code>!containsBeanDefinition(beanName)</code> 就意味着定义的 xml 文件中没有 beanName 相应的配置，这个时候就只能从 parentBeanFactory 中获取。</li><li>获取 RootBeanDefinition，并对其进行合并检查。从缓存中获取已经解析的 RootBeanDefinition，同时如果父类不为 null 的话，则会合并父类的属性。</li><li>依赖检查。某个 bean 依赖其他 bean ，则需要先加载依赖的 bean。</li><li>对不同的 scope 进行处理。</li><li>类型转换处理。如果传递的 requiredType 不为 null，则需要检测所得到 bean 的类型是否与该 requiredType 一致，如果不一致则尝试转换，当然也要能够转换成功，否则抛出 BeanNotOfRequiredTypeException 异常。</li></ol><p>下面就以下几个方面进行阐述，说明 Spring bean 的加载过程。</p><ol><li>从缓存中获取 bean</li><li>创建 bean 实例对象</li><li>从 bean 实例中获取对象</li></ol><h2 id="从缓存中获取-bean"><a href="#从缓存中获取-bean" class="headerlink" title="从缓存中获取 bean"></a>从缓存中获取 bean</h2><p>Spring 中根据 scope 可以将 bean 分为以下几类：singleton、prototype 和 其他，这样分的原因在于 Spring 在对不同 scope 处理的时候是这么处理的。</p><ul><li>singleton：在 Spring 的 IoC 容器中只存在一个对象实例，所有该对象的引用都共享这个实例。Spring 容器只会创建该 bean 定义的唯一实例，这个实例会被保存到缓存中，并且对该bean的所有后续请求和引用都将返回该缓存中的对象实例。</li><li>prototype：每次对该bean的请求都会创建一个新的实例</li><li>其他：其他包括 request、session、global session：<ul><li>request：每次 http 请求将会有各自的 bean 实例。</li><li>session：在一个 http session 中，一个 bean 定义对应一个 bean 实例。</li><li>global session：在一个全局的 http session 中，一个 bean 定义对应一个 bean 实例。</li></ul></li></ul><p>所以从缓存中获取的 bean 一定是 singleton bean，这也是 Spring 为何只解决 singleton bean 的循环依赖。调用 <code>getSingleton()</code> 从缓存中获取 singleton bean。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getSingleton</span><span class="params">(String beanName)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getSingleton(beanName, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">getSingleton</span><span class="params">(String beanName, <span class="keyword">boolean</span> allowEarlyReference)</span> </span>&#123;</span><br><span class="line">    Object singletonObject = <span class="keyword">this</span>.singletonObjects.get(beanName);</span><br><span class="line">    <span class="keyword">if</span> (singletonObject == <span class="keyword">null</span> &amp;&amp; isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonObjects) &#123;</span><br><span class="line">            singletonObject = <span class="keyword">this</span>.earlySingletonObjects.get(beanName);</span><br><span class="line">            <span class="keyword">if</span> (singletonObject == <span class="keyword">null</span> &amp;&amp; allowEarlyReference) &#123;</span><br><span class="line">                ObjectFactory&lt;?&gt; singletonFactory = <span class="keyword">this</span>.singletonFactories.get(beanName);</span><br><span class="line">                <span class="keyword">if</span> (singletonFactory != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    singletonObject = singletonFactory.getObject();</span><br><span class="line">                    <span class="keyword">this</span>.earlySingletonObjects.put(beanName, singletonObject);</span><br><span class="line">                    <span class="keyword">this</span>.singletonFactories.remove(beanName);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> singletonObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>getSingleton()</code> 就是从 singletonObjects、earlySingletonObjects、 singletonFactories 三个缓存中获取，这里也是 Spring 解决 bean 循环依赖的关键之处。详细内容请查看如下内容：</p><ul><li><a href="/2020/01/16/c9c155de.html">IOC之从单例缓存中获取单例 bean</a></li></ul><h2 id="创建-bean-实例对象"><a href="#创建-bean-实例对象" class="headerlink" title="创建 bean 实例对象"></a>创建 bean 实例对象</h2><p>如果缓存中没有，也没有 parentBeanFactory ，则会调用 <code>createBean()</code> 创建 bean 实例，该方法主要是在处理不同 scope 的 bean 的时候进行调用。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> Object <span class="title">createBean</span><span class="params">(String beanName, RootBeanDefinition mbd, <span class="meta">@Nullable</span> Object[] args)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> BeanCreationException</span></span><br></pre></td></tr></table></figure><p>该方法是定义在 AbstractBeanFactory 中的虚拟方法，其含义是根据给定的 BeanDefinition 和 args实例化一个 bean 对象，如果该 BeanDefinition 存在父类，则该 BeanDefinition 已经合并了父类的属性。所有 Bean 实例的创建都会委托给该方法实现。 方法接受三个参数：</p><ul><li>beanName：bean 的名字</li><li>mbd：已经合并了父类属性的（如果有的话）BeanDefinition</li><li>args：用于构造函数或者工厂方法创建 bean 实例对象的参数</li></ul><p>该抽象方法的默认实现是在类 AbstractAutowireCapableBeanFactory 中实现，该方法其实只是做一些检查和验证工作，真正的初始化工作是由 <code>doCreateBean()</code> 实现，如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">doCreateBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> RootBeanDefinition mbd, <span class="keyword">final</span> <span class="meta">@Nullable</span> Object[] args)</span></span></span><br><span class="line"><span class="function">  <span class="keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// BeanWrapper是对Bean的包装，其接口中所定义的功能很简单包括设置获取被包装的对象，获取被包装bean的属性描述器</span></span><br><span class="line">  BeanWrapper instanceWrapper = <span class="keyword">null</span>;</span><br><span class="line">  <span class="comment">// 单例模型，则从未完成的 FactoryBean 缓存中删除</span></span><br><span class="line">  <span class="keyword">if</span> (mbd.isSingleton()) &#123;anceWrapper = <span class="keyword">this</span>.factoryBeanInstanceCache.remove(beanName);</span><br><span class="line">                         &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 使用合适的实例化策略来创建新的实例：工厂方法、构造函数自动注入、简单初始化</span></span><br><span class="line">  <span class="keyword">if</span> (instanceWrapper == <span class="keyword">null</span>) &#123;</span><br><span class="line">    instanceWrapper = createBeanInstance(beanName, mbd, args);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 包装的实例对象</span></span><br><span class="line">  <span class="keyword">final</span> Object bean = instanceWrapper.getWrappedInstance();</span><br><span class="line">  <span class="comment">// 包装的实例对象的类型</span></span><br><span class="line">  Class&lt;?&gt; beanType = instanceWrapper.getWrappedClass();</span><br><span class="line">  <span class="keyword">if</span> (beanType != NullBean.class) &#123;</span><br><span class="line">    mbd.resolvedTargetType = beanType;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 检测是否有后置处理</span></span><br><span class="line">  <span class="comment">// 如果有后置处理，则允许后置处理修改 BeanDefinition</span></span><br><span class="line">  <span class="keyword">synchronized</span> (mbd.postProcessingLock) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!mbd.postProcessed) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// applyMergedBeanDefinitionPostProcessors</span></span><br><span class="line">        <span class="comment">// 后置处理修改 BeanDefinition</span></span><br><span class="line">        applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line">                                        <span class="string">&quot;Post-processing of merged bean definition failed&quot;</span>, ex);</span><br><span class="line">      &#125;</span><br><span class="line">      mbd.postProcessed = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 解决单例模式的循环依赖</span></span><br><span class="line">  <span class="comment">// 单例模式 &amp; 运行循环依赖&amp;当前单例 bean 是否正在被创建</span></span><br><span class="line">  <span class="keyword">boolean</span> earlySingletonExposure = (mbd.isSingleton() &amp;&amp; <span class="keyword">this</span>.allowCircularReferences &amp;&amp;</span><br><span class="line">                                    isSingletonCurrentlyInCreation(beanName));</span><br><span class="line">  <span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">    <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">      logger.debug(<span class="string">&quot;Eagerly caching bean &#x27;&quot;</span> + beanName +</span><br><span class="line">                   <span class="string">&quot;&#x27; to allow for resolving potential circular references&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 提前将创建的 bean 实例加入到ectFactory 中</span></span><br><span class="line">    <span class="comment">// 这里是为了后期避免循环依赖</span></span><br><span class="line">    addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 开始初始化 bean 实例对象</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">  Object exposedObject = bean;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 对 bean 进行填充，将各个属性值注入，其中，可能存在依赖于其他 bean 的属性</span></span><br><span class="line">    <span class="comment">// 则会递归初始依赖 bean</span></span><br><span class="line">    populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line">    <span class="comment">// 调用初始化方法</span></span><br><span class="line">    exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">    <span class="keyword">if</span> (ex <span class="keyword">instanceof</span> BeanCreationException &amp;&amp; beanName.equals(((BeanCreationException) ex).getBeanName())) &#123;</span><br><span class="line">      <span class="keyword">throw</span> (BeanCreationException) ex;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">        mbd.getResourceDescription(), beanName, <span class="string">&quot;Initialization of bean failed&quot;</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 循环依赖处理</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">  <span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">    <span class="comment">// 获取 earlySingletonReference</span></span><br><span class="line">    Object earlySingletonReference = getSingleton(beanName, <span class="keyword">false</span>);</span><br><span class="line">    <span class="comment">// 只有在存在循环依赖的情况下，earlySingletonReference 才不会为空</span></span><br><span class="line">    <span class="keyword">if</span> (earlySingletonReference != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 如果 exposedObject 没有在初始化方法中被改变，也就是没有被增强</span></span><br><span class="line">      <span class="keyword">if</span> (exposedObject == bean) &#123;</span><br><span class="line">        exposedObject = earlySingletonReference;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 处理依赖</span></span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="keyword">this</span>.allowRawInjectionDespiteWrapping &amp;&amp; hasDependentBean(beanName)) &#123;</span><br><span class="line">        String[] dependentBeans = getDependentBeans(beanName);</span><br><span class="line">        Set&lt;String&gt; actualDependentBeans = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(dependentBeans.length);</span><br><span class="line">        <span class="keyword">for</span> (String dependentBean : dependentBeans) &#123;</span><br><span class="line">          <span class="keyword">if</span> (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) &#123;</span><br><span class="line">            actualDependentBeans.add(dependentBean);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!actualDependentBeans.isEmpty()) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> BeanCurrentlyInCreationException(beanName,</span><br><span class="line">                                                     <span class="string">&quot;Bean with name &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27; has been injected into other beans [&quot;</span> +</span><br><span class="line">                                                     StringUtils.collectionToCommaDelimitedString(actualDependentBeans) +</span><br><span class="line">                                                     <span class="string">&quot;] in its raw version as part of a circular reference, but has eventually been &quot;</span> +</span><br><span class="line">                                                     <span class="string">&quot;wrapped. This means that said other beans do not use the final version of the &quot;</span> +</span><br><span class="line">                                                     <span class="string">&quot;bean. This is often the result of over-eager type matching - consider using &quot;</span> +</span><br><span class="line">                                                     <span class="string">&quot;&#x27;getBeanNamesOfType&#x27; with the &#x27;allowEagerInit&#x27; flag turned off, for example.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 注册 bean</span></span><br><span class="line">    registerDisposableBeanIfNecessary(beanName, bean, mbd);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (BeanDefinitionValidationException ex) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">      mbd.getResourceDescription(), beanName, <span class="string">&quot;Invalid destruction signature&quot;</span>, ex);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> exposedObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>doCreateBean()</code> 是创建 bean 实例的核心方法，它的整体思路是：</p><ol><li>如果是单例模式，则清除 factoryBeanInstanceCache 缓存，同时返回 BeanWrapper 实例对象，当然如果存在。</li><li>如果缓存中没有 BeanWrapper 或者不是单例模式，则调用 <code>createBeanInstance()</code> 实例化 bean，主要是将 BeanDefinition 转换为 BeanWrapper</li><li>MergedBeanDefinitionPostProcessor 的应用</li><li>单例模式的循环依赖处理</li><li>调用 <code>populateBean()</code> 进行属性填充。将所有属性填充至 bean 的实例中</li><li>调用 <code>initializeBean()</code> 初始化 bean</li><li>依赖检查</li><li>注册 DisposableBean</li></ol><h3 id="实例化-bean"><a href="#实例化-bean" class="headerlink" title="实例化 bean"></a>实例化 bean</h3><p>如果缓存中没有 BeanWrapper 实例对象或者该 bean 不是 singleton，则调用 <code>createBeanInstance()</code> 创建 bean 实例。该方法主要是根据参数 BeanDefinition、args[] 来调用构造函数实例化 bean 对象。过程较为复杂，如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> BeanWrapper <span class="title">createBeanInstance</span><span class="params">(String beanName, RootBeanDefinition mbd, <span class="meta">@Nullable</span> Object[] args)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 解析 bean，将 bean 类名解析为 class 引用</span></span><br><span class="line">  Class&lt;?&gt; beanClass = resolveBeanClass(mbd, beanName);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (beanClass != <span class="keyword">null</span> &amp;&amp; !Modifier.isPublic(beanClass.getModifiers()) &amp;&amp; !mbd.isNonPublicAccessAllowed()) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line">                                    <span class="string">&quot;Bean class isn&#x27;t public, and non-public access not allowed: &quot;</span> + beanClass.getName());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果存在 Supplier 回调，则使用给定的回调方法初始化策略</span></span><br><span class="line">  Supplier&lt;?&gt; instanceSupplier = mbd.getInstanceSupplier();</span><br><span class="line">  <span class="keyword">if</span> (instanceSupplier != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> obtainFromSupplier(instanceSupplier, beanName);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果工厂方法不为空，则使用工厂方法初始化策略</span></span><br><span class="line">  <span class="keyword">if</span> (mbd.getFactoryMethodName() != <span class="keyword">null</span>)  &#123;</span><br><span class="line">    <span class="keyword">return</span> instantiateUsingFactoryMethod(beanName, mbd, args);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">boolean</span> resolved = <span class="keyword">false</span>;</span><br><span class="line">  <span class="keyword">boolean</span> autowireNecessary = <span class="keyword">false</span>;</span><br><span class="line">  <span class="keyword">if</span> (args == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// constructorArgumentLock 构造函数的常用锁</span></span><br><span class="line">    <span class="keyword">synchronized</span> (mbd.constructorArgumentLock) &#123;</span><br><span class="line">      <span class="comment">// 如果已缓存的解析的构造函数或者工厂方法不为空，则可以利用构造函数解析</span></span><br><span class="line">      <span class="comment">// 因为需要根据参数确认到底使用哪个构造函数，该过程比较消耗性能，所有采用缓存机制</span></span><br><span class="line">      <span class="keyword">if</span> (mbd.resolvedConstructorOrFactoryMethod != <span class="keyword">null</span>) &#123;</span><br><span class="line">        resolved = <span class="keyword">true</span>;</span><br><span class="line">        autowireNecessary = mbd.constructorArgumentsResolved;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 已经解析好了，直接注入即可</span></span><br><span class="line">  <span class="keyword">if</span> (resolved) &#123;</span><br><span class="line">    <span class="comment">// 自动注入，调用构造函数自动注入</span></span><br><span class="line">    <span class="keyword">if</span> (autowireNecessary) &#123;</span><br><span class="line">      <span class="keyword">return</span> autowireConstructor(beanName, mbd, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 使用默认构造函数构造</span></span><br><span class="line">      <span class="keyword">return</span> instantiateBean(beanName, mbd);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 确定解析的构造函数</span></span><br><span class="line">  <span class="comment">// 主要是检查已经注册的 SmartInstantiationAwareBeanPostProcessor</span></span><br><span class="line">  Constructor&lt;?&gt;[] ctors = determineConstructorsFromBeanPostProcessors(beanClass, beanName);</span><br><span class="line">  <span class="keyword">if</span> (ctors != <span class="keyword">null</span> ||</span><br><span class="line">      mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_CONSTRUCTOR ||</span><br><span class="line">      mbd.hasConstructorArgumentValues() || !ObjectUtils.isEmpty(args))  &#123;</span><br><span class="line">    <span class="comment">// 构造函数自动注入</span></span><br><span class="line">    <span class="keyword">return</span> autowireConstructor(beanName, mbd, ctors, args);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//使用默认构造函数注入</span></span><br><span class="line">  <span class="keyword">return</span> instantiateBean(beanName, mbd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实例化 bean 是一个复杂的过程，其主要的逻辑为：</p><ul><li>如果存在 Supplier 回调，则调用 <code>obtainFromSupplier()</code> 进行初始化</li><li>如果存在工厂方法，则使用工厂方法进行初始化</li><li>首先判断缓存，如果缓存中存在，即已经解析过了，则直接使用已经解析了的，根据 constructorArgumentsResolved 参数来判断是使用构造函数自动注入还是默认构造函数</li><li>如果缓存中没有，则需要先确定到底使用哪个构造函数来完成解析工作，因为一个类有多个构造函数，每个构造函数都有不同的构造参数，所以需要根据参数来锁定构造函数并完成初始化，如果存在参数则使用相应的带有参数的构造函数，否则使用默认构造函数。</li></ul><p>其实核心思想还是在于根据不同的情况执行不同的实例化策略，主要是包括如下四种策略：</p><ol><li>Supplier 回调</li><li><code>instantiateUsingFactoryMethod()</code> 工厂方法初始化</li><li><code>autowireConstructor()</code>，构造函数自动注入初始化</li><li><code>instantiateBean()</code>，默认构造函数注入</li></ol><p>其实无论哪种策略，他们的实现逻辑都差不多：确定构造函数和构造方法，然后实例化。只不过相对于 Supplier 回调和默认构造函数注入而言，工厂方法初始化和构造函数自动注入初始化会比较复杂，因为他们构造函数和构造参数的不确定性，Spring 需要花大量的精力来确定构造函数和构造参数，如果确定了则好办，直接选择实例化策略即可。当然在实例化的时候会根据是否有需要覆盖或者动态替换掉的方法，因为存在覆盖或者织入的话需要创建动态代理将方法织入，这个时候就只能选择 CGLIB 的方式来实例化，否则直接利用反射的方式即可。</p><h3 id="属性填充"><a href="#属性填充" class="headerlink" title="属性填充"></a>属性填充</h3><p>属性填充其实就是将 BeanDefinition 的属性值赋值给 BeanWrapper 实例对象的过程。在填充的过程需要根据注入的类型不同来区分是根据类型注入还是名字注入，当然在这个过程还会涉及循环依赖的问题的。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">populateBean</span><span class="params">(String beanName, RootBeanDefinition mbd, <span class="meta">@Nullable</span> BeanWrapper bw)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 没有实例化对象</span></span><br><span class="line">  <span class="keyword">if</span> (bw == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 有属性抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (mbd.hasPropertyValues()) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">        mbd.getResourceDescription(), beanName, <span class="string">&quot;Cannot apply property values to null instance&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 没有属性直接返回</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在设置属性之前给 InstantiationAwareBeanPostProcessors 最后一次改变 bean 的机会</span></span><br><span class="line">  <span class="keyword">boolean</span> continueWithPropertyPopulation = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// bena 不是&quot;合成&quot;的，即未由应用程序本身定义</span></span><br><span class="line">  <span class="comment">// 是否持有 InstantiationAwareBeanPostProcessor</span></span><br><span class="line">  <span class="keyword">if</span> (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) &#123;</span><br><span class="line">    <span class="comment">// 迭代所有的 BeanPostProcessors</span></span><br><span class="line">    <span class="keyword">for</span> (BeanPostProcessor bp : getBeanPostProcessors()) &#123;</span><br><span class="line">      <span class="comment">// 如果为 InstantiationAwareBeanPostProcessor</span></span><br><span class="line">      <span class="keyword">if</span> (bp <span class="keyword">instanceof</span> InstantiationAwareBeanPostProcessor) &#123;</span><br><span class="line">        InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;</span><br><span class="line">        <span class="comment">// 返回值为是否继续填充 bean</span></span><br><span class="line">        <span class="comment">// postProcessAfterInstantiation：如果应该在 bean上面设置属性则返回true，否则返回false</span></span><br><span class="line">        <span class="comment">// 一般情况下，应该是返回true，返回 false 的话，</span></span><br><span class="line">        <span class="comment">// 将会阻止在此 Bean 实例上调用任何后续的 InstantiationAwareBeanPostProcessor 实例。</span></span><br><span class="line">        <span class="keyword">if</span> (!ibp.postProcessAfterInstantiation(bw.getWrappedInstance(), beanName)) &#123;</span><br><span class="line">          continueWithPropertyPopulation = <span class="keyword">false</span>;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果后续处理器发出停止填充命令，则终止后续操作</span></span><br><span class="line">  <span class="keyword">if</span> (!continueWithPropertyPopulation) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// bean 的属性值</span></span><br><span class="line">  PropertyValues pvs = (mbd.hasPropertyValues() ? mbd.getPropertyValues() : <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_NAME ||</span><br><span class="line">      mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_TYPE) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 PropertyValues 封装成 MutablePropertyValues 对象</span></span><br><span class="line">    <span class="comment">// MutablePropertyValues 允许对属性进行简单的操作，</span></span><br><span class="line">    <span class="comment">// 并提供构造函数以支持Map的深度复制和构造。</span></span><br><span class="line">    MutablePropertyValues newPvs = <span class="keyword">new</span> MutablePropertyValues(pvs);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据名称自动注入</span></span><br><span class="line">    <span class="keyword">if</span> (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_NAME) &#123;</span><br><span class="line">      autowireByName(beanName, mbd, bw, newPvs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据类型自动注入</span></span><br><span class="line">    <span class="keyword">if</span> (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_TYPE) &#123;</span><br><span class="line">      autowireByType(beanName, mbd, bw, newPvs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pvs = newPvs;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 是否已经注册了 InstantiationAwareBeanPostProcessors</span></span><br><span class="line">  <span class="keyword">boolean</span> hasInstAwareBpps = hasInstantiationAwareBeanPostProcessors();</span><br><span class="line">  <span class="comment">// 是否需要进行依赖检查</span></span><br><span class="line">  <span class="keyword">boolean</span> needsDepCheck = (mbd.getDependencyCheck() != RootBeanDefinition.DEPENDENCY_CHECK_NONE);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (hasInstAwareBpps || needsDepCheck) &#123;</span><br><span class="line">    <span class="keyword">if</span> (pvs == <span class="keyword">null</span>) &#123;</span><br><span class="line">      pvs = mbd.getPropertyValues();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从 bw 对象中提取 PropertyDescriptor 结果集</span></span><br><span class="line">    <span class="comment">// PropertyDescriptor：可以通过一对存取方法提取一个属性</span></span><br><span class="line">    PropertyDescriptor[] filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);</span><br><span class="line">    <span class="keyword">if</span> (hasInstAwareBpps) &#123;</span><br><span class="line">      <span class="keyword">for</span> (BeanPostProcessor bp : getBeanPostProcessors()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (bp <span class="keyword">instanceof</span> InstantiationAwareBeanPostProcessor) &#123;</span><br><span class="line">          InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;</span><br><span class="line">          <span class="comment">// 对所有需要依赖检查的属性进行后处理</span></span><br><span class="line">          pvs = ibp.postProcessPropertyValues(pvs, filteredPds, bw.getWrappedInstance(), beanName);</span><br><span class="line">          <span class="keyword">if</span> (pvs == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (needsDepCheck) &#123;</span><br><span class="line">      <span class="comment">// 依赖检查，对应 depends-on 属性</span></span><br><span class="line">      checkDependencies(beanName, mbd, filteredPds, pvs);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (pvs != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 将属性应用到 bean 中</span></span><br><span class="line">    applyPropertyValues(beanName, mbd, bw, pvs);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>处理流程如下：</p><ol><li>根据 hasInstantiationAwareBeanPostProcessors 属性来判断是否需要在注入属性之前给 InstantiationAwareBeanPostProcessors 最后一次改变 bean 的机会，此过程可以控制 Spring 是否继续进行属性填充。</li><li>根据注入类型的不同来判断是根据名称来自动注入（<code>autowireByName()</code>）还是根据类型来自动注入（<code>autowireByType()</code>），统一存入到 PropertyValues 中，PropertyValues 用于描述 bean 的属性。</li><li>判断是否需要进行 BeanPostProcessor 和 依赖检测。</li><li>将所有 PropertyValues 中的属性填充到 BeanWrapper 中。</li></ol><h3 id="初始化-bean"><a href="#初始化-bean" class="headerlink" title="初始化 bean"></a>初始化 bean</h3><p>初始化 bean 为 <code>createBean()</code> 的最后一个过程，该过程主要做三件事情：</p><ol><li>激活 Aware 方法</li><li>后置处理器的应用</li><li>激活自定义的 init 方法</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">initializeBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> Object bean, <span class="meta">@Nullable</span> RootBeanDefinition mbd)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">    AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; &#123;</span><br><span class="line">      <span class="comment">// 激活 Aware 方法</span></span><br><span class="line">      invokeAwareMethods(beanName, bean);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;, getAccessControlContext());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 对特殊的 bean 处理：Aware、BeanClassLoaderAware、BeanFactoryAware</span></span><br><span class="line">    invokeAwareMethods(beanName, bean);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Object wrappedBean = bean;</span><br><span class="line">  <span class="keyword">if</span> (mbd == <span class="keyword">null</span> || !mbd.isSynthetic()) &#123;</span><br><span class="line">    <span class="comment">// 后处理器</span></span><br><span class="line">    wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 激活用户自定义的 init 方法</span></span><br><span class="line">    invokeInitMethods(beanName, wrappedBean, mbd);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">      (mbd != <span class="keyword">null</span> ? mbd.getResourceDescription() : <span class="keyword">null</span>),</span><br><span class="line">      beanName, <span class="string">&quot;Invocation of init method failed&quot;</span>, ex);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (mbd == <span class="keyword">null</span> || !mbd.isSynthetic()) &#123;</span><br><span class="line">    <span class="comment">// 后处理器</span></span><br><span class="line">    wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> wrappedBean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="从-bean-实例中获取对象"><a href="#从-bean-实例中获取对象" class="headerlink" title="从 bean 实例中获取对象"></a>从 bean 实例中获取对象</h2><p>无论是从单例缓存中获取的 bean 实例 还是通过 <code>createBean()</code> 创建的 bean 实例，最终都会调用 <code>getObjectForBeanInstance()</code> ，该方法是根据传入的 bean 实例获取对象，按照 Spring 的传统，该方法也只是做一些检测工作，真正的实现逻辑是委托给 <code>getObjectFromFactoryBean()</code> 实现。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">getObjectFromFactoryBean</span><span class="params">(FactoryBean&lt;?&gt; factory, String beanName, <span class="keyword">boolean</span> shouldPostProcess)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 为单例模式且缓存中存在</span></span><br><span class="line">  <span class="keyword">if</span> (factory.isSingleton() &amp;&amp; containsSingleton(beanName)) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (getSingletonMutex()) &#123;</span><br><span class="line">      <span class="comment">// 从缓存中获取指定的 factoryBean</span></span><br><span class="line">      Object object = <span class="keyword">this</span>.factoryBeanObjectCache.get(beanName);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (object == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 为空，则从 FactoryBean 中获取对象</span></span><br><span class="line">        object = doGetObjectFromFactoryBean(factory, beanName);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从缓存中获取</span></span><br><span class="line">        Object alreadyThere = <span class="keyword">this</span>.factoryBeanObjectCache.get(beanName);</span><br><span class="line">        <span class="comment">// **我实在是不明白这里这么做的原因，这里是干嘛？？？**</span></span><br><span class="line">        <span class="keyword">if</span> (alreadyThere != <span class="keyword">null</span>) &#123;</span><br><span class="line">          object = alreadyThere;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 需要后续处理</span></span><br><span class="line">          <span class="keyword">if</span> (shouldPostProcess) &#123;</span><br><span class="line">            <span class="comment">// 若该 bean 处于创建中，则返回非处理对象，而不是存储它</span></span><br><span class="line">            <span class="keyword">if</span> (isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">              <span class="keyword">return</span> object;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 前置处理</span></span><br><span class="line">            beforeSingletonCreation(beanName);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="comment">// 对从 FactoryBean 获取的对象进行后处理</span></span><br><span class="line">              <span class="comment">// 生成的对象将暴露给bean引用</span></span><br><span class="line">              object = postProcessObjectFromFactoryBean(object, beanName);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">              <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(beanName,</span><br><span class="line">                                              <span class="string">&quot;Post-processing of FactoryBean&#x27;s singleton object failed&quot;</span>, ex);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">finally</span> &#123;</span><br><span class="line">              <span class="comment">// 后置处理</span></span><br><span class="line">              afterSingletonCreation(beanName);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// 缓存</span></span><br><span class="line">          <span class="keyword">if</span> (containsSingleton(beanName)) &#123;</span><br><span class="line">            <span class="keyword">this</span>.factoryBeanObjectCache.put(beanName, object);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> object;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 非单例</span></span><br><span class="line">    Object object = doGetObjectFromFactoryBean(factory, beanName);</span><br><span class="line">    <span class="keyword">if</span> (shouldPostProcess) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        object = postProcessObjectFromFactoryBean(object, beanName);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(beanName, <span class="string">&quot;Post-processing of FactoryBean&#x27;s object failed&quot;</span>, ex);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> object;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要流程如下：</p><ul><li>若为单例且单例 bean 缓存中存在 beanName，则进行后续处理（跳转到下一步），否则则从 FactoryBean 中获取 bean 实例对象，如果接受后置处理，则调用 <code>postProcessObjectFromFactoryBean()</code> 进行后置处理。</li><li>首先获取锁（其实我们在前面篇幅中发现了大量的同步锁，锁住的对象都是 this.singletonObjects， 主要是因为在单例模式中必须要保证全局唯一），然后从 factoryBeanObjectCache 缓存中获取实例对象 object，若 object 为空，则调用 <code>doGetObjectFromFactoryBean()</code>方法从 FactoryBean 获取对象，其实内部就是调用 <code>FactoryBean.getObject()</code>。</li><li>如果需要后续处理，则进行进一步处理，步骤如下：<ul><li>若该 bean 处于创建中（isSingletonCurrentlyInCreation），则返回非处理对象，而不是存储它</li><li>调用 <code>beforeSingletonCreation()</code> 进行创建之前的处理。默认实现将该 bean 标志为当前创建的。</li><li>调用 <code>postProcessObjectFromFactoryBean()</code> 对从 FactoryBean 获取的 bean 实例对象进行后置处理，默认实现是按照原样直接返回，具体实现是在 AbstractAutowireCapableBeanFactory 中实现的，当然子类也可以重写它，比如应用后置处理</li><li>调用 <code>afterSingletonCreation()</code> 进行创建 bean 之后的处理，默认实现是将该 bean 标记为不再在创建中。</li></ul></li><li>最后加入到 FactoryBeans 缓存中。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
          <category> 《Spring源码分析》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> 转载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IOC之Bean的初始化</title>
      <link href="/blog/2020/01/21/e8e94997.html"/>
      <url>/blog/2020/01/21/e8e94997.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文作者：chenssy</p><p>出处：<a href="http://cmsblogs.com/?p=2890">http://cmsblogs.com/?p=2890</a></p><p>在学习<code>Spring源码</code>的过程中发现的好站+好贴，感谢作者。Spring版本：<strong>Spring 5.0.6.RELEASE</strong></p></blockquote><p>一个 bean 经历了 <code>createBeanInstance()</code> 被创建出来，然后又经过一番属性注入，依赖处理，历经千辛万苦，千锤百炼，终于有点儿 bean 实例的样子，能堪大任了，只需要经历最后一步就破茧成蝶了。</p><p>这最后一步就是初始化，也就是 <code>initializeBean()</code>，所以这篇文章我们分析 <code>doCreateBean()</code> 中最后一步：初始化 bean。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">initializeBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> Object bean, <span class="meta">@Nullable</span> RootBeanDefinition mbd)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">    AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; &#123;</span><br><span class="line">      <span class="comment">// 激活 Aware 方法</span></span><br><span class="line">      invokeAwareMethods(beanName, bean);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;, getAccessControlContext());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 对特殊的 bean 处理：Aware、BeanClassLoaderAware、BeanFactoryAware</span></span><br><span class="line">    invokeAwareMethods(beanName, bean);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Object wrappedBean = bean;</span><br><span class="line">  <span class="keyword">if</span> (mbd == <span class="keyword">null</span> || !mbd.isSynthetic()) &#123;</span><br><span class="line">    <span class="comment">// 后处理器</span></span><br><span class="line">    wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 激活用户自定义的 init 方法</span></span><br><span class="line">    invokeInitMethods(beanName, wrappedBean, mbd);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">      (mbd != <span class="keyword">null</span> ? mbd.getResourceDescription() : <span class="keyword">null</span>),</span><br><span class="line">      beanName, <span class="string">&quot;Invocation of init method failed&quot;</span>, ex);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (mbd == <span class="keyword">null</span> || !mbd.isSynthetic()) &#123;</span><br><span class="line">    <span class="comment">// 后处理器</span></span><br><span class="line">    wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> wrappedBean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始化 bean 的方法其实就是三个步骤的处理，而这三个步骤主要还是根据用户设定的来进行初始化，这三个过程为：</p><ol><li>激活 Aware 方法</li><li>后置处理器的应用</li><li>激活自定义的 init 方法</li></ol><p><strong>激活 Aware 方法</strong> Aware ,英文翻译是意识到的，感知的，Spring 提供了诸多类似<code>xxxxAware</code> 的接口用于辅助 Spring Bean 以编程的方式调用 Spring 容器，通过实现这些接口，可以增强 Spring Bean 的功能。 </p><p>Spring 提供了如下系列的 Aware 接口：</p><ul><li><code>LoadTimeWeaverAware</code>：加载Spring Bean时织入第三方模块，如AspectJ</li><li><code>BeanClassLoaderAware</code>：加载Spring Bean的类加载器</li><li><code>BootstrapContextAware</code>：资源适配器BootstrapContext，如JCA,CCI</li><li><code>ResourceLoaderAware</code>：底层访问资源的加载器</li><li><code>BeanFactoryAware</code>：声明BeanFactory</li><li><code>PortletConfigAware</code>：PortletConfig</li><li><code>PortletContextAware</code>：PortletContext</li><li><code>ServletConfigAware</code>：ServletConfig</li><li><code>ServletContextAware</code>：ServletContext</li><li><code>MessageSourceAware</code>：国际化</li><li><code>ApplicationEventPublisherAware</code>：应用事件</li><li><code>NotificationPublisherAware</code>：JMX通知</li><li><code>BeanNameAware</code>：声明Spring Bean的名字</li></ul><p><code>invokeAwareMethods()</code> 源码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">invokeAwareMethods</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> Object bean)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> Aware) &#123;</span><br><span class="line">    <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> BeanNameAware) &#123;</span><br><span class="line">      ((BeanNameAware) bean).setBeanName(beanName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> BeanClassLoaderAware) &#123;</span><br><span class="line">      ClassLoader bcl = getBeanClassLoader();</span><br><span class="line">      <span class="keyword">if</span> (bcl != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ((BeanClassLoaderAware) bean).setBeanClassLoader(bcl);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> BeanFactoryAware) &#123;</span><br><span class="line">      ((BeanFactoryAware) bean).setBeanFactory(AbstractAutowireCapableBeanFactory.<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里代码就没有什么好说的，主要是处理 BeanNameAware、BeanClassLoaderAware、BeanFactoryAware。</p><p><strong>后置处理器的应用</strong> BeanPostProcessor 在前面介绍 bean 加载的过程曾多次遇到，这是 Spring 中开放式框架中必不可少的一个亮点。 </p><p>BeanPostProcessor 的作用是：<u>如果我们想要在 Spring 容器完成 Bean 的实例化，配置和其他的初始化后添加一些自己的逻辑处理，那么请使用该接口，这个接口给与了用户充足的权限去更改或者扩展 Spring，是我们对 Spring 进行扩展和增强处理一个必不可少的接口。</u></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">applyBeanPostProcessorsBeforeInitialization</span><span class="params">(Object existingBean, String beanName)</span></span></span><br><span class="line"><span class="function">  <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"></span><br><span class="line">  Object result = existingBean;</span><br><span class="line">  <span class="keyword">for</span> (BeanPostProcessor beanProcessor : getBeanPostProcessors()) &#123;</span><br><span class="line">    Object current = beanProcessor.postProcessBeforeInitialization(result, beanName);</span><br><span class="line">    <span class="keyword">if</span> (current == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    result = current;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">applyBeanPostProcessorsAfterInitialization</span><span class="params">(Object existingBean, String beanName)</span></span></span><br><span class="line"><span class="function">  <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"></span><br><span class="line">  Object result = existingBean;</span><br><span class="line">  <span class="keyword">for</span> (BeanPostProcessor beanProcessor : getBeanPostProcessors()) &#123;</span><br><span class="line">    Object current = beanProcessor.postProcessAfterInitialization(result, beanName);</span><br><span class="line">    <span class="keyword">if</span> (current == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    result = current;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实逻辑就是通过 <code>getBeanPostProcessors()</code> 获取定义的 BeanPostProcessor ，然后分别调用其 <code>postProcessBeforeInitialization()</code>、<code>postProcessAfterInitialization()</code> 进行业务处理。</p><p><strong>激活自定义的 init 方法</strong> 如果熟悉 <code>&lt;bean&gt;</code> 标签的配置，一定不会忘记 <code>init-method</code> 方法，该方法的执行就是在这里执行的。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">invokeInitMethods</span><span class="params">(String beanName, <span class="keyword">final</span> Object bean, <span class="meta">@Nullable</span> RootBeanDefinition mbd)</span></span></span><br><span class="line"><span class="function">  <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">  <span class="comment">// 首先会检查是否是 InitializingBean ，如果是的话需要调用 afterPropertiesSet()</span></span><br><span class="line">  <span class="keyword">boolean</span> isInitializingBean = (bean <span class="keyword">instanceof</span> InitializingBean);</span><br><span class="line">  <span class="keyword">if</span> (isInitializingBean &amp;&amp; (mbd == <span class="keyword">null</span> || !mbd.isExternallyManagedInitMethod(<span class="string">&quot;afterPropertiesSet&quot;</span>))) &#123;</span><br><span class="line">    <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">      logger.debug(<span class="string">&quot;Invoking afterPropertiesSet() on bean with name &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        AccessController.doPrivileged((PrivilegedExceptionAction&lt;Object&gt;) () -&gt; &#123;</span><br><span class="line">          ((InitializingBean) bean).afterPropertiesSet();</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;, getAccessControlContext());</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (PrivilegedActionException pae) &#123;</span><br><span class="line">        <span class="keyword">throw</span> pae.getException();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 属性初始化的处理</span></span><br><span class="line">      ((InitializingBean) bean).afterPropertiesSet();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (mbd != <span class="keyword">null</span> &amp;&amp; bean.getClass() != NullBean.class) &#123;</span><br><span class="line">    String initMethodName = mbd.getInitMethodName();</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.hasLength(initMethodName) &amp;&amp;</span><br><span class="line">        !(isInitializingBean &amp;&amp; <span class="string">&quot;afterPropertiesSet&quot;</span>.equals(initMethodName)) &amp;&amp;</span><br><span class="line">        !mbd.isExternallyManagedInitMethod(initMethodName)) &#123;</span><br><span class="line">      <span class="comment">// 激活用户自定义的 初始化方法</span></span><br><span class="line">      invokeCustomInitMethod(beanName, bean, mbd);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先检查是否为 InitializingBean ，如果是的话需要执行 <code>afterPropertiesSet()</code>，因为我们除了可以使用 <code>init-method</code> 来自定初始化方法外，还可以实现 InitializingBean 接口，该接口仅有一个 <code>afterPropertiesSet()</code> 方法，而两者的执行先后顺序是先 <code>afterPropertiesSet()</code> 后 <code>init-method</code>。 </p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
          <category> 《Spring源码分析》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> 转载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IOC之循环依赖</title>
      <link href="/blog/2020/01/21/7ee1f554.html"/>
      <url>/blog/2020/01/21/7ee1f554.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文作者：chenssy</p><p>出处：<a href="http://cmsblogs.com/?p=2887">http://cmsblogs.com/?p=2887</a></p><p>在学习<code>Spring源码</code>的过程中发现的好站+好贴，感谢作者。Spring版本：<strong>Spring 5.0.6.RELEASE</strong></p></blockquote><p>这篇分析 <code>doCreateBean()</code> 第三个过程：循环依赖处理。</p><p>其实循环依赖并不仅仅只是在 <code>doCreateBean()</code> 中处理，其实在整个加载 bean 的过程中都有涉及，所以下篇内容并不仅仅只局限于 <code>doCreateBean()</code>，而是从整个 Bean 的加载过程进行分析。</p><h2 id="什么是循环依赖"><a href="#什么是循环依赖" class="headerlink" title="什么是循环依赖"></a>什么是循环依赖</h2><p>循环依赖其实就是循环引用，就是两个或者两个以上的 bean 互相引用对方，最终形成一个闭环，如 A 依赖 B，B 依赖 C，C 依赖 A，如下：</p><p><a href="https://gitee.com/chenssy/blog-home/raw/master/image/201811/201808131001.png"><img src="https://gitee.com/cayzlh/img-repo/raw/master/2020/05/24/201808131001_mrtCpY.png" alt="201808131001"></a></p><p>循环依赖 其实就是一个死循环的过程，在初始化 A 的时候发现引用了 B，这时就会去初始化 B，然后又发现 B 引用 C，跑去初始化 C，初始化 C 的时候发现引用了 A，则又会去初始化 A，依次循环永不退出，除非有终结条件。 Spring 循环依赖的场景有两种：</p><ol><li><u>构造器的循环依赖</u></li><li><u>field 属性的循环依赖</u></li></ol><p>对于<strong>构造器的循环依赖</strong>，Spring 是无法解决的，只能抛出 BeanCurrentlyInCreationException 异常表示循环依赖，所以下面我们分析的都是基于 field 属性的循环依赖。</p><p> 在博客 <a href="/2020/01/15/27d87789.html"> IOC 之开启 bean 的加载</a> 中提到，Spring 只解决 scope 为 singleton 的循环依赖，对于scope 为 prototype 的 bean Spring 无法解决，直接抛出 BeanCurrentlyInCreationException 异常。</p><p>为什么 Spring 不处理 prototype bean，其实如果理解 Spring 是如何解决 singleton bean 的循环依赖就明白了。</p><h2 id="解决循环依赖"><a href="#解决循环依赖" class="headerlink" title="解决循环依赖"></a>解决循环依赖</h2><p>我们先从加载 bean 最初始的方法 <code>doGetBean()</code> 开始。 在 <code>doGetBean()</code> 中，首先会根据 beanName 从单例 bean 缓存中获取，如果不为空则直接返回。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object sharedInstance = getSingleton(beanName);</span><br></pre></td></tr></table></figure><p>调用 <code>getSingleton()</code> 方法从单例缓存中获取，如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">getSingleton</span><span class="params">(String beanName, <span class="keyword">boolean</span> allowEarlyReference)</span> </span>&#123;</span><br><span class="line">  Object singletonObject = <span class="keyword">this</span>.singletonObjects.get(beanName);</span><br><span class="line">  <span class="keyword">if</span> (singletonObject == <span class="keyword">null</span> &amp;&amp; isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonObjects) &#123;</span><br><span class="line">      singletonObject = <span class="keyword">this</span>.earlySingletonObjects.get(beanName);</span><br><span class="line">      <span class="keyword">if</span> (singletonObject == <span class="keyword">null</span> &amp;&amp; allowEarlyReference) &#123;</span><br><span class="line">        ObjectFactory&lt;?&gt; singletonFactory = <span class="keyword">this</span>.singletonFactories.get(beanName);</span><br><span class="line">        <span class="keyword">if</span> (singletonFactory != <span class="keyword">null</span>) &#123;</span><br><span class="line">          singletonObject = singletonFactory.getObject();</span><br><span class="line">          <span class="keyword">this</span>.earlySingletonObjects.put(beanName, singletonObject);</span><br><span class="line">          <span class="keyword">this</span>.singletonFactories.remove(beanName);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> singletonObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法主要是从三个缓存中获取，分别是：<code>singletonObjects</code>、<code>earlySingletonObjects</code>、<code>singletonFactories</code>，三者定义如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** Cache of singleton objects: bean name --&gt; bean instance */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; singletonObjects = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="number">256</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Cache of singleton factories: bean name --&gt; ObjectFactory */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">16</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Cache of early singleton objects: bean name --&gt; bean instance */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; earlySingletonObjects = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">16</span>);</span><br></pre></td></tr></table></figure><p>意义如下：</p><ul><li>singletonObjects：单例对象的cache</li><li>singletonFactories ： 单例对象工厂的cache</li><li>earlySingletonObjects ：提前暴光的单例对象的Cache</li></ul><p>他们就是 Spring 解决 singleton bean 循环依赖的关键因素所在，我称他们为三级缓存，第一级为 singletonObjects，第二级为 earlySingletonObjects，第三级为 singletonFactories。</p><p>这里我们可以通过 <code>getSingleton()</code> 看到他们是如何配合的，这分析该方法之前，提下其中的 <code>isSingletonCurrentlyInCreation()</code> 和 <code>allowEarlyReference</code>。</p><ul><li><code>isSingletonCurrentlyInCreation()</code>：判断当前 singleton bean 是否处于创建中。bean 处于创建中也就是说 bean 在初始化但是没有完成初始化，有一个这样的过程其实和 Spring 解决 bean 循环依赖的理念相辅相成，因为 Spring 解决 singleton bean 的核心就在于提前曝光 bean。</li><li><code>allowEarlyReference</code>：从字面意思上面理解就是允许提前拿到引用。其实真正的意思是是否允许从 singletonFactories 缓存中通过 <code>getObject()</code> 拿到对象，为什么会有这样一个字段呢？原因就在于 singletonFactories 才是 Spring 解决 singleton bean 的诀窍所在，这个我们后续分析。</li></ul><p><code>getSingleton()</code> 整个过程如下：</p><ul><li>首先从一级缓存 singletonObjects 获取</li><li>如果没有且当前指定的 beanName 正在创建，就再从二级缓存中 earlySingletonObjects 获取</li><li>如果还是没有获取到且运行 singletonFactories 通过 <code>getObject()</code> 获取，则从三级缓存 singletonFactories 获取</li><li>如果获取到则，通过其 <code>getObject()</code> 获取对象，并将其加入到二级缓存 earlySingletonObjects 中 从三级缓存 singletonFactories 删除，如下：</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">singletonObject = singletonFactory.getObject();</span><br><span class="line"><span class="keyword">this</span>.earlySingletonObjects.put(beanName, singletonObject);</span><br><span class="line"><span class="keyword">this</span>.singletonFactories.remove(beanName);</span><br></pre></td></tr></table></figure><p>这样就从三级缓存升级到二级缓存了。 上面是从缓存中获取，但是缓存中的数据从哪里添加进来的呢？一直往下跟会发现在 <code>doCreateBean()</code> ( AbstractAutowireCapableBeanFactory ) 中，有这么一段代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">boolean</span> earlySingletonExposure = (mbd.isSingleton() &amp;&amp; <span class="keyword">this</span>.allowCircularReferences &amp;&amp; isSingletonCurrentlyInCreation(beanName));</span><br><span class="line"><span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">    <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">        logger.debug(<span class="string">&quot;Eagerly caching bean &#x27;&quot;</span> + beanName +</span><br><span class="line">                        <span class="string">&quot;&#x27; to allow for resolving potential circular references&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果 <code>earlySingletonExposure == true</code> 的话，则调用 <code>addSingletonFactory()</code> 将他们添加到缓存中，但是一个 bean 要具备如下条件才会添加至缓存中：</p><ul><li>单例</li><li>运行提前暴露 bean</li><li>当前 bean 正在创建中</li></ul><p><code>addSingletonFactory()</code> 代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">addSingletonFactory</span><span class="params">(String beanName, ObjectFactory&lt;?&gt; singletonFactory)</span> </span>&#123;</span><br><span class="line">  Assert.notNull(singletonFactory, <span class="string">&quot;Singleton factory must not be null&quot;</span>);</span><br><span class="line">  <span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonObjects) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.singletonObjects.containsKey(beanName)) &#123;</span><br><span class="line">      <span class="keyword">this</span>.singletonFactories.put(beanName, singletonFactory);</span><br><span class="line">      <span class="keyword">this</span>.earlySingletonObjects.remove(beanName);</span><br><span class="line">      <span class="keyword">this</span>.registeredSingletons.add(beanName);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从这段代码我们可以看出 singletonFactories 这个三级缓存才是解决 Spring Bean 循环依赖的诀窍所在。</p><p><strong>同时这段代码发生在 <code>createBeanInstance()</code> 方法之后，也就是说这个 bean 其实已经被创建出来了，但是它还不是很完美（没有进行属性填充和初始化），但是对于其他依赖它的对象而言已经足够了（可以根据对象引用定位到堆中对象），能够被认出来了，所以 Spring 在这个时候选择将该对象提前曝光出来让大家认识认识。</strong> </p><p>介绍到这里我们发现三级缓存 singletonFactories 和 二级缓存 earlySingletonObjects 中的值都有出处了，那一级缓存在哪里设置的呢？在类 DefaultSingletonBeanRegistry 中可以发现这个 <code>addSingleton()</code> 方法，源码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">addSingleton</span><span class="params">(String beanName, Object singletonObject)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonObjects) &#123;</span><br><span class="line">    <span class="keyword">this</span>.singletonObjects.put(beanName, singletonObject);</span><br><span class="line">    <span class="keyword">this</span>.singletonFactories.remove(beanName);</span><br><span class="line">    <span class="keyword">this</span>.earlySingletonObjects.remove(beanName);</span><br><span class="line">    <span class="keyword">this</span>.registeredSingletons.add(beanName);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>添加至一级缓存，同时从二级、三级缓存中删除。这个方法在我们创建 bean 的链路中有哪个地方引用呢？</p><p>在 <code>doGetBean()</code> 处理不同 scope 时，如果是 singleton，则调用 <code>getSingleton()</code>，如下：</p><p><a href="https://gitee.com/chenssy/blog-home/raw/master/image/201811/15341402420152.jpg"><img src="https://gitee.com/cayzlh/img-repo/raw/master/2020/05/24/15341402420152_OJNpZi.jpg" alt="img"></a></p><p>前面几篇博客已经分析了 <code>createBean()</code>，这里就不再阐述了，我们关注方法 <code>getSingleton()</code> 代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getSingleton</span><span class="params">(String beanName, ObjectFactory&lt;?&gt; singletonFactory)</span> </span>&#123;</span><br><span class="line">  Assert.notNull(beanName, <span class="string">&quot;Bean name must not be null&quot;</span>);</span><br><span class="line">  <span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonObjects) &#123;</span><br><span class="line">    Object singletonObject = <span class="keyword">this</span>.singletonObjects.get(beanName);</span><br><span class="line">    <span class="keyword">if</span> (singletonObject == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">//....</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        singletonObject = singletonFactory.getObject();</span><br><span class="line">        newSingleton = <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//.....</span></span><br><span class="line">      <span class="keyword">if</span> (newSingleton) &#123;</span><br><span class="line">        addSingleton(beanName, singletonObject);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> singletonObject;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，Spring 关于 singleton bean 循环依赖已经分析完毕了。</p><p>我们基本上可以确定 Spring 解决循环依赖的方案了：</p><p>Spring 在创建 bean 的时候并不是等它完全完成，而是在创建过程中将创建中的 bean 的 ObjectFactory 提前曝光（即加入到 singletonFactories 缓存中），这样一旦下一个 bean 创建的时候需要依赖 bean ，则直接使用 ObjectFactory 的 <code>getObject()</code> 获取了，也就是 <code>getSingleton()</code> 中的代码片段了。 到这里，关于 Spring 解决 bean 循环依赖就已经分析完毕了。</p><p>最后来描述下就上面那个循环依赖 Spring 解决的过程：</p><p>首先 A 完成初始化第一步并将自己提前曝光出来（通过 ObjectFactory 将自己提前曝光），在初始化的时候，发现自己依赖对象 B，此时就会去尝试 get(B)，这个时候发现 B 还没有被创建出来，然后 B 就走创建流程，在 B 初始化的时候，同样发现自己依赖 C，C 也没有被创建出来，这个时候 C 又开始初始化进程，但是在初始化的过程中发现自己依赖 A，于是尝试 get(A)，这个时候由于 A 已经添加至缓存中（一般都是添加至三级缓存 singletonFactories ），通过 ObjectFactory 提前曝光，所以可以通过 <code>ObjectFactory.getObject()</code> 拿到 A 对象，C 拿到 A 对象后顺利完成初始化，然后将自己添加到一级缓存中，回到 B ，B 也可以拿到 C 对象，完成初始化，A 可以顺利拿到 B 完成初始化。到这里整个链路就已经完成了初始化过程了。</p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
          <category> 《Spring源码分析》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> 转载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IOC之属性填充</title>
      <link href="/blog/2020/01/20/1293fb33.html"/>
      <url>/blog/2020/01/20/1293fb33.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文作者：chenssy</p><p>出处：<a href="http://cmsblogs.com/?p=2885">http://cmsblogs.com/?p=2885</a></p><p>在学习<code>Spring源码</code>的过程中发现的好站+好贴，感谢作者。Spring版本：<strong>Spring 5.0.6.RELEASE</strong></p></blockquote><p><code>doCreateBean()</code> 主要用于完成 bean 的创建和初始化工作，我们可以将其分为四个过程：</p><p><img src="https://gitee.com/cayzlh/img-repo/raw/master/2020/05/23/image-20200523100857745_W6BGWx.png" alt="image-20200523100857745"></p><p>第一个过程实例化 bean 已经在前面两篇博客分析完毕了，这篇博客开始分析 属性填充，也就是 <code>populateBean()</code>，该函数的作用是将 BeanDefinition 中的属性值赋值给 BeanWrapper 实例对象。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">populateBean</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  ]String beanName, RootBeanDefinition mbd, <span class="meta">@Nullable</span> BeanWrapper bw)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 没有实例化对象</span></span><br><span class="line">  <span class="keyword">if</span> (bw == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 有属性抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (mbd.hasPropertyValues()) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">        mbd.getResourceDescription(),</span><br><span class="line">        beanName, <span class="string">&quot;Cannot apply property values to null instance&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 没有属性直接返回</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在设置属性之前给 InstantiationAwareBeanPostProcessors 最后一次改变 bean 的机会</span></span><br><span class="line">  <span class="keyword">boolean</span> continueWithPropertyPopulation = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// bena 不是&quot;合成&quot;的，即未由应用程序本身定义</span></span><br><span class="line">  <span class="comment">// 是否持有 InstantiationAwareBeanPostProcessor</span></span><br><span class="line">  <span class="keyword">if</span> (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) &#123;</span><br><span class="line">    <span class="comment">// 迭代所有的 BeanPostProcessors</span></span><br><span class="line">    <span class="keyword">for</span> (BeanPostProcessor bp : getBeanPostProcessors()) &#123;</span><br><span class="line">      <span class="comment">// 如果为 InstantiationAwareBeanPostProcessor</span></span><br><span class="line">      <span class="keyword">if</span> (bp <span class="keyword">instanceof</span> InstantiationAwareBeanPostProcessor) &#123;</span><br><span class="line">        InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;</span><br><span class="line">        <span class="comment">// 返回值为是否继续填充 bean</span></span><br><span class="line">        <span class="comment">// postProcessAfterInstantiation：如果应该在 bean上面设置属性则返回true，否则返回false</span></span><br><span class="line">        <span class="comment">// 一般情况下，应该是返回true，返回 false 的话，</span></span><br><span class="line">        <span class="comment">// 将会阻止在此 Bean 实例上调用任何后续的 InstantiationAwareBeanPostProcessor 实例。</span></span><br><span class="line">        <span class="keyword">if</span> (!ibp.postProcessAfterInstantiation(bw.getWrappedInstance(), beanName)) &#123;</span><br><span class="line">          continueWithPropertyPopulation = <span class="keyword">false</span>;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果后续处理器发出停止填充命令，则终止后续操作</span></span><br><span class="line">  <span class="keyword">if</span> (!continueWithPropertyPopulation) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// bean 的属性值</span></span><br><span class="line">  PropertyValues pvs = (mbd.hasPropertyValues() ? mbd.getPropertyValues() : <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_NAME ||</span><br><span class="line">      mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_TYPE) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 PropertyValues 封装成 MutablePropertyValues 对象</span></span><br><span class="line">    <span class="comment">// MutablePropertyValues 允许对属性进行简单的操作，</span></span><br><span class="line">    <span class="comment">// 并提供构造函数以支持Map的深度复制和构造。</span></span><br><span class="line">    MutablePropertyValues newPvs = <span class="keyword">new</span> MutablePropertyValues(pvs);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据名称自动注入</span></span><br><span class="line">    <span class="keyword">if</span> (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_NAME) &#123;</span><br><span class="line">      autowireByName(beanName, mbd, bw, newPvs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据类型自动注入</span></span><br><span class="line">    <span class="keyword">if</span> (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_TYPE) &#123;</span><br><span class="line">      autowireByType(beanName, mbd, bw, newPvs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pvs = newPvs;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 是否已经注册了 InstantiationAwareBeanPostProcessors</span></span><br><span class="line">  <span class="keyword">boolean</span> hasInstAwareBpps = hasInstantiationAwareBeanPostProcessors();</span><br><span class="line">  <span class="comment">// 是否需要进行依赖检查</span></span><br><span class="line">  <span class="keyword">boolean</span> needsDepCheck = (mbd.getDependencyCheck() != RootBeanDefinition.DEPENDENCY_CHECK_NONE);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (hasInstAwareBpps || needsDepCheck) &#123;</span><br><span class="line">    <span class="keyword">if</span> (pvs == <span class="keyword">null</span>) &#123;</span><br><span class="line">      pvs = mbd.getPropertyValues();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从 bw 对象中提取 PropertyDescriptor 结果集</span></span><br><span class="line">    <span class="comment">// PropertyDescriptor：可以通过一对存取方法提取一个属性</span></span><br><span class="line">    PropertyDescriptor[] filteredPds = </span><br><span class="line">      filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);</span><br><span class="line">    <span class="keyword">if</span> (hasInstAwareBpps) &#123;</span><br><span class="line">      <span class="keyword">for</span> (BeanPostProcessor bp : getBeanPostProcessors()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (bp <span class="keyword">instanceof</span> InstantiationAwareBeanPostProcessor) &#123;</span><br><span class="line">          InstantiationAwareBeanPostProcessor ibp = </span><br><span class="line">            (InstantiationAwareBeanPostProcessor) bp;</span><br><span class="line">          <span class="comment">// 对所有需要依赖检查的属性进行后处理</span></span><br><span class="line">          pvs = ibp.postProcessPropertyValues(</span><br><span class="line">            pvs, filteredPds, bw.getWrappedInstance(), beanName);</span><br><span class="line">          <span class="keyword">if</span> (pvs == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (needsDepCheck) &#123;</span><br><span class="line">      <span class="comment">// 依赖检查，对应 depends-on 属性</span></span><br><span class="line">      checkDependencies(beanName, mbd, filteredPds, pvs);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (pvs != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 将属性应用到 bean 中</span></span><br><span class="line">    applyPropertyValues(beanName, mbd, bw, pvs);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>处理流程如下：</p><ol><li>根据 hasInstantiationAwareBeanPostProcessors 属性来判断是否需要在注入属性之前给 InstantiationAwareBeanPostProcessors 最后一次改变 bean 的机会，此过程可以控制 Spring 是否继续进行属性填充。</li><li>根据注入类型的不同来判断是根据名称来自动注入（<code>autowireByName()</code>）还是根据类型来自动注入（<code>autowireByType()</code>），统一存入到 PropertyValues 中，PropertyValues 用于描述 bean 的属性。</li><li>判断是否需要进行 BeanPostProcessor 和 依赖检测。</li><li>将所有 PropertyValues 中的属性填充到 BeanWrapper 中。</li></ol><h2 id="自动注入"><a href="#自动注入" class="headerlink" title="自动注入"></a>自动注入</h2><p>Spring 会根据注入类型（ byName / byType ）的不同，调用不同的方法（<code>autowireByName()</code> / <code>autowireByType()</code>）来注入属性值。</p><p><strong>autowireByName()</strong> 方法 <code>autowireByName()</code> 是根据属性名称完成自动依赖注入的，代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">autowireByName</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  String beanName, AbstractBeanDefinition mbd, </span></span></span><br><span class="line"><span class="function"><span class="params">  BeanWrapper bw, MutablePropertyValues pvs)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 对 Bean 对象中非简单属性</span></span><br><span class="line">  String[] propertyNames = unsatisfiedNonSimpleProperties(mbd, bw);</span><br><span class="line">  <span class="keyword">for</span> (String propertyName : propertyNames) &#123;</span><br><span class="line">    <span class="comment">// 如果容器中包含指定名称的 bean，则将该 bean 注入到 bean中</span></span><br><span class="line">    <span class="keyword">if</span> (containsBean(propertyName)) &#123;</span><br><span class="line">      <span class="comment">// 递归初始化相关 bean</span></span><br><span class="line">      Object bean = getBean(propertyName);</span><br><span class="line">      <span class="comment">// 为指定名称的属性赋予属性值  </span></span><br><span class="line">      pvs.add(propertyName, bean);</span><br><span class="line">      <span class="comment">// 属性依赖注入</span></span><br><span class="line">      registerDependentBean(propertyName, beanName);</span><br><span class="line">      <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">        logger.debug(</span><br><span class="line">          <span class="string">&quot;Added autowiring by name from bean name &#x27;&quot;</span> + beanName </span><br><span class="line">          + <span class="string">&quot;&#x27; via property &#x27;&quot;</span> + propertyName + <span class="string">&quot;&#x27; to bean named &#x27;&quot;</span> + propertyName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">        logger.trace(<span class="string">&quot;Not autowiring property &#x27;&quot;</span> + propertyName + <span class="string">&quot;&#x27; of bean &#x27;&quot;</span> + beanName +</span><br><span class="line">                     <span class="string">&quot;&#x27; by name: no matching bean found&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法逻辑很简单，获取该 bean 的非简单属性，什么叫做非简单属性呢？就是类型为对象类型的属性，但是这里并不是将所有的对象类型都都会找到，比如 8 个原始类型，String 类型 ，Number类型、Date类型、URL类型、URI类型等都会被忽略，如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> String[] unsatisfiedNonSimpleProperties(</span><br><span class="line">  AbstractBeanDefinition mbd, BeanWrapper bw) &#123;</span><br><span class="line">  Set&lt;String&gt; result = <span class="keyword">new</span> TreeSet&lt;&gt;();</span><br><span class="line">  PropertyValues pvs = mbd.getPropertyValues();</span><br><span class="line">  PropertyDescriptor[] pds = bw.getPropertyDescriptors();</span><br><span class="line">  <span class="keyword">for</span> (PropertyDescriptor pd : pds) &#123;</span><br><span class="line">    <span class="keyword">if</span> (pd.getWriteMethod() != <span class="keyword">null</span> </span><br><span class="line">        &amp;&amp; !isExcludedFromDependencyCheck(pd) </span><br><span class="line">        &amp;&amp; !pvs.contains(pd.getName()) </span><br><span class="line">        &amp;&amp; !BeanUtils.isSimpleProperty(pd.getPropertyType())) &#123;</span><br><span class="line">      result.add(pd.getName());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> StringUtils.toStringArray(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>过滤条件为：<strong>有可写方法</strong>、<strong>依赖检测中没有被忽略</strong>、<strong>不是简单属性类型</strong>。其实这里获取的就是需要依赖注入的属性。 获取需要依赖注入的属性后，通过迭代、递归的方式初始化相关的 bean，然后调用 <code>registerDependentBean()</code> 完成注册依赖，如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerDependentBean</span><span class="params">(String beanName, String dependentBeanName)</span> </span>&#123;</span><br><span class="line">  String canonicalName = canonicalName(beanName);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">synchronized</span> (<span class="keyword">this</span>.dependentBeanMap) &#123;</span><br><span class="line">    Set&lt;String&gt; dependentBeans =</span><br><span class="line">      <span class="keyword">this</span>.dependentBeanMap.computeIfAbsent(canonicalName, k -&gt; <span class="keyword">new</span> LinkedHashSet&lt;&gt;(<span class="number">8</span>));</span><br><span class="line">    <span class="keyword">if</span> (!dependentBeans.add(dependentBeanName)) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">synchronized</span> (<span class="keyword">this</span>.dependenciesForBeanMap) &#123;</span><br><span class="line">    Set&lt;String&gt; dependenciesForBean =</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">this</span>.dependenciesForBeanMap.computeIfAbsent(dependentBeanName, </span><br><span class="line">                                                  k -&gt; <span class="keyword">new</span> LinkedHashSet&lt;&gt;(<span class="number">8</span>));</span><br><span class="line">    dependenciesForBean.add(canonicalName);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>autowireByType()</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">autowireByType</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  String beanName, AbstractBeanDefinition mbd,</span></span></span><br><span class="line"><span class="function"><span class="params">  BeanWrapper bw, MutablePropertyValues pvs)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取 TypeConverter 实例</span></span><br><span class="line">  <span class="comment">// 使用自定义的 TypeConverter，用于取代默认的 PropertyEditor 机制</span></span><br><span class="line">  TypeConverter converter = getCustomTypeConverter();</span><br><span class="line">  <span class="keyword">if</span> (converter == <span class="keyword">null</span>) &#123;</span><br><span class="line">    converter = bw;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Set&lt;String&gt; autowiredBeanNames = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(<span class="number">4</span>);</span><br><span class="line">  <span class="comment">// 获取非简单属性</span></span><br><span class="line">  String[] propertyNames = unsatisfiedNonSimpleProperties(mbd, bw);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (String propertyName : propertyNames) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 获取 PropertyDescriptor 实例</span></span><br><span class="line">      PropertyDescriptor pd = bw.getPropertyDescriptor(propertyName);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 不要尝试按类型</span></span><br><span class="line">      <span class="keyword">if</span> (Object.class != pd.getPropertyType()) &#123;</span><br><span class="line">        <span class="comment">// 探测指定属性的 set 方法</span></span><br><span class="line">        MethodParameter methodParam = BeanUtils.getWriteMethodParameter(pd);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> eager = !PriorityOrdered.class.isInstance(bw.getWrappedInstance());</span><br><span class="line">        DependencyDescriptor desc = </span><br><span class="line">          <span class="keyword">new</span> AbstractAutowireCapableBeanFactory</span><br><span class="line">          .AutowireByTypeDependencyDescriptor(methodParam, eager);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 解析指定 beanName 的属性所匹配的值，并把解析到的属性名称存储在 autowiredBeanNames 中</span></span><br><span class="line">        <span class="comment">// 当属性存在过个封装 bean 时将会找到所有匹配的 bean 并将其注入</span></span><br><span class="line">        Object autowiredArgument = </span><br><span class="line">          resolveDependency(desc, beanName, autowiredBeanNames, converter);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (autowiredArgument != <span class="keyword">null</span>) &#123;</span><br><span class="line">          pvs.add(propertyName, autowiredArgument);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 迭代方式注入 bean </span></span><br><span class="line">        <span class="keyword">for</span> (String autowiredBeanName : autowibeanredBeanNames) &#123;</span><br><span class="line">          registerDependentBean(autowiredBeanName, beanName);</span><br><span class="line">          <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">            logger.debug(<span class="string">&quot;Autowiring by type from bean name &#x27;&quot;</span> </span><br><span class="line">                         + beanName + <span class="string">&quot;&#x27; via property &#x27;&quot;</span> +</span><br><span class="line">                         propertyName + <span class="string">&quot;&#x27; to bean named &#x27;&quot;</span> + autowiredBeanName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        autowiredBeanNames.clear();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> UnsatisfiedDependencyException(</span><br><span class="line">        mbd.getResourceDescription(), beanName, propertyName, ex);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实主要过程和根据名称自动注入差不多都是找到需要依赖注入的属性，然后通过迭代的方式寻找所匹配的 bean，最后调用 <code>registerDependentBean()</code> 注册依赖。不过相对于 <code>autowireByName()</code> 而言，根据类型寻找相匹配的 bean 过程比较复杂，下面我们就分析这个复杂的过程，如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">resolveDependency</span><span class="params">(DependencyDescriptor descriptor, <span class="meta">@Nullable</span> String requestingBeanName,</span></span></span><br><span class="line"><span class="function"><span class="params">                                <span class="meta">@Nullable</span> Set&lt;String&gt; autowiredBeanNames, <span class="meta">@Nullable</span> TypeConverter typeConverter)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化参数名称发现器，该方法并不会在这个时候尝试检索参数名称</span></span><br><span class="line">    <span class="comment">// getParameterNameDiscoverer 返回 parameterNameDiscoverer 实例，parameterNameDiscoverer 方法参数名称的解析器</span></span><br><span class="line">    descriptor.initParameterNameDiscovery(getParameterNameDiscoverer());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 依赖类型为 Optional 类型</span></span><br><span class="line">    <span class="keyword">if</span> (Optional.class == descriptor.getDependencyType()) &#123;</span><br><span class="line">        <span class="comment">// 创建 Optional 实例依赖类型</span></span><br><span class="line">        <span class="keyword">return</span> createOptionalDependency(descriptor, requestingBeanName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 依赖类型为ObjectFactory、ObjectProvider</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (ObjectFactory.class == descriptor.getDependencyType() ||</span><br><span class="line">            ObjectProvider.class == descriptor.getDependencyType()) &#123;</span><br><span class="line">        <span class="comment">// ObjectFactory / ObjectProvider 用于 用于延迟解析依赖项</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DefaultListableBeanFactory.DependencyObjectProvider(descriptor, requestingBeanName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (javaxInjectProviderClass == descriptor.getDependencyType()) &#123;</span><br><span class="line">        <span class="comment">// javaxInjectProviderClass 类注入的特殊处理</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DefaultListableBeanFactory.Jsr330ProviderFactory().createDependencyProvider(descriptor, requestingBeanName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 为实际依赖关系目标的延迟解析构建代理</span></span><br><span class="line">        <span class="comment">// 默认实现返回 null</span></span><br><span class="line">        Object result = getAutowireCandidateResolver().getLazyResolutionProxyIfNecessary(</span><br><span class="line">                descriptor, requestingBeanName);</span><br><span class="line">        <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 通用处理逻辑</span></span><br><span class="line">            result = doResolveDependency(descriptor, requestingBeanName, autowiredBeanNames, typeConverter);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们关注通用处理逻辑：<code>doResolveDependency()</code>，如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">doResolveDependency</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  DependencyDescriptor descriptor, </span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="meta">@Nullable</span> String beanName,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="meta">@Nullable</span> Set&lt;String&gt; autowiredBeanNames, </span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="meta">@Nullable</span> TypeConverter typeConverter)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 注入点</span></span><br><span class="line">  InjectionPoint previousInjectionPoint = </span><br><span class="line">    ConstructorResolver.setCurrentInjectionPoint(descriptor);</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 针对给定的工厂给定一个快捷实现的方式，例如考虑一些预先解析的信息</span></span><br><span class="line">    <span class="comment">// 在进入所有bean的常规类型匹配算法之前，解析算法将首先尝试通过此方法解析快捷方式。</span></span><br><span class="line">    <span class="comment">// 子类可以覆盖此方法</span></span><br><span class="line">    Object shortcut = descriptor.resolveShortcut(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">if</span> (shortcut != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 返回快捷的解析信息</span></span><br><span class="line">      <span class="keyword">return</span> shortcut;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 依赖的类型</span></span><br><span class="line">    Class&lt;?&gt; type = descriptor.getDependencyType();</span><br><span class="line">    <span class="comment">// 支持 Spring 的注解 @value</span></span><br><span class="line">    Object value = getAutowireCandidateResolver().getSuggestedValue(descriptor);</span><br><span class="line">    <span class="keyword">if</span> (value != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (value <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">        String strVal = resolveEmbeddedValue((String) value);</span><br><span class="line">        BeanDefinition bd = (beanName != <span class="keyword">null</span> &amp;&amp; containsBean(beanName) ? </span><br><span class="line">                             getMergedBeanDefinition(beanName) : <span class="keyword">null</span>);</span><br><span class="line">        value = evaluateBeanDefinitionString(strVal, bd);</span><br><span class="line">      &#125;</span><br><span class="line">      TypeConverter converter = </span><br><span class="line">        (typeConverter != <span class="keyword">null</span> ? typeConverter : getTypeConverter());</span><br><span class="line">      <span class="keyword">return</span> (descriptor.getField() != <span class="keyword">null</span> ?</span><br><span class="line">              converter.convertIfNecessary(value, type, descriptor.getField()) :</span><br><span class="line">              converter.convertIfNecessary(value, type, descriptor.getMethodParameter()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析复合 bean，其实就是对 bean 的属性进行解析</span></span><br><span class="line">    <span class="comment">// 包括：数组、Collection 、Map 类型</span></span><br><span class="line">    Object multipleBeans = </span><br><span class="line">      resolveMultipleBeans(descriptor, beanName, autowiredBeanNames, typeConverter);</span><br><span class="line">    <span class="keyword">if</span> (multipleBeans != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> multipleBeans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找与类型相匹配的 bean</span></span><br><span class="line">    <span class="comment">// 返回值构成为：key = 匹配的 beanName，value = beanName 对应的实例化 bean</span></span><br><span class="line">    Map&lt;String, Object&gt; matchingBeans = findAutowireCandidates(beanName, type, descriptor);</span><br><span class="line">    <span class="comment">// 没有找到，检验 @autowire  的 require 是否为 true</span></span><br><span class="line">    <span class="keyword">if</span> (matchingBeans.isEmpty()) &#123;</span><br><span class="line">      <span class="comment">// 如果 @autowire 的 require 属性为 true ，但是没有找到相应的匹配项，则抛出异常</span></span><br><span class="line">      <span class="keyword">if</span> (isRequired(descriptor)) &#123;</span><br><span class="line">        raiseNoMatchingBeanFound(type, descriptor.getResolvableType(), descriptor);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String autowiredBeanName;</span><br><span class="line">    Object instanceCandidate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (matchingBeans.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="comment">//  确认给定 bean autowire 的候选者</span></span><br><span class="line">      <span class="comment">// 按照 @Primary 和 @Priority 的顺序</span></span><br><span class="line">      autowiredBeanName = determineAutowireCandidate(matchingBeans, descriptor);</span><br><span class="line">      <span class="keyword">if</span> (autowiredBeanName == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isRequired(descriptor) || !indicatesMultipleBeans(type)) &#123;</span><br><span class="line">          <span class="comment">// 唯一性处理</span></span><br><span class="line">          <span class="keyword">return</span> descriptor.resolveNotUnique(type, matchingBeans);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 在可选的Collection / Map的情况下，</span></span><br><span class="line">          <span class="comment">// 默默地忽略一个非唯一的情况：可能它是一个多个常规bean的空集合</span></span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      instanceCandidate = matchingBeans.get(autowiredBeanName);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// We have exactly one match.</span></span><br><span class="line">      Map.Entry&lt;Staring, Object&gt; entry = matchingBeans.entrySet().iterator().next();</span><br><span class="line">      autowiredBeanName = entry.getKey();</span><br><span class="line">      instanceCandidate = entry.getValue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (autowiredBeanNames != <span class="keyword">null</span>) &#123;</span><br><span class="line">      autowiredBeanNames.add(autowiredBeanName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (instanceCandidate <span class="keyword">instanceof</span> Class) &#123;</span><br><span class="line">      instanceCandidate = descriptor.resolveCandidate(autowiredBeanName, type, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Object result = instanceCandidate;</span><br><span class="line">    <span class="keyword">if</span> (result <span class="keyword">instanceof</span> NullBean) &#123;</span><br><span class="line">      <span class="keyword">if</span> (isRequired(descriptor)) &#123;</span><br><span class="line">        raiseNoMatchingBeanFound(type, descriptor.getResolvableType(), descriptor);</span><br><span class="line">      &#125;</span><br><span class="line">      result = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!ClassUtils.isAssignableValue(type, result)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BeanNotOfRequiredTypeException(</span><br><span class="line">        autowiredBeanName, type, instanceCandidate.getClass());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    ConstructorResolver.setCurrentInjectionPoint(previousInjectionPoint);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里就已经完成了所有属性的注入了。<code>populateBean()</code> 该方法就已经完成了一大半工作了，下一步则是对依赖 bean 的检测和 PostProcessor 处理，这个我们后面分析，下面分析该方法的最后一步：<code>applyPropertyValues()</code></p><h2 id="applyPropertyValues"><a href="#applyPropertyValues" class="headerlink" title="applyPropertyValues"></a>applyPropertyValues</h2><p>其实上面只是完成了所有注入属性的获取，将获取的属性封装在 PropertyValues 的实例对象 pvs 中，并没有应用到已经实例化的 bean 中，而 <code>applyPropertyValues()</code> 则是完成这一步骤的。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">applyPropertyValues</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  String beanName, BeanDefinition mbd, BeanWrapper bw, PropertyValues pvs)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (pvs.isEmpty()) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span> &amp;&amp; bw <span class="keyword">instanceof</span> BeanWrapperImpl) &#123;</span><br><span class="line">    ((BeanWrapperImpl) bw).setSecurityContext(getAccessControlContext());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// MutablePropertyValues 类型属性</span></span><br><span class="line">  MutablePropertyValues mpvs = <span class="keyword">null</span>;</span><br><span class="line">  <span class="comment">// 原始类型</span></span><br><span class="line">  List&lt;PropertyValue&gt; original;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (pvs <span class="keyword">instanceof</span> MutablePropertyValues) &#123;</span><br><span class="line">    mpvs = (MutablePropertyValues) pvs;</span><br><span class="line">    <span class="keyword">if</span> (mpvs.isConverted()) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 设置到 BeanWrapper 中去</span></span><br><span class="line">        bw.setPropertyValues(mpvs);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">          mbd.getResourceDescription(), beanName, <span class="string">&quot;Error setting property values&quot;</span>, ex);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    original = mpvs.getPropertyValueList();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 如果 pvs 不是 MutablePropertyValues 类型，则直接使用原始类型</span></span><br><span class="line">    original = Arrays.asList(pvs.getPropertyValues());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取 TypeConverter</span></span><br><span class="line">  TypeConverter converter = getCustomTypeConverter();</span><br><span class="line">  <span class="keyword">if</span> (converter == <span class="keyword">null</span>) &#123;</span><br><span class="line">    converter = bw;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取对应的解析器</span></span><br><span class="line">  BeanDefinitionValueResolver valueResolver </span><br><span class="line">    = <span class="keyword">new</span> BeanDefinitionValueResolver(<span class="keyword">this</span>, beanName, mbd, converter);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Create a deep copy, resolving any references for values.</span></span><br><span class="line">  List&lt;PropertyValue&gt; deepCopy = <span class="keyword">new</span> ArrayList&lt;&gt;(original.size());</span><br><span class="line">  <span class="keyword">boolean</span> resolveNecessary = <span class="keyword">false</span>;</span><br><span class="line">  <span class="comment">// 遍历属性，将属性转换为对应类的对应属性的类型</span></span><br><span class="line">  <span class="keyword">for</span> (PropertyValue pv : original) &#123;</span><br><span class="line">    <span class="keyword">if</span> (pv.isConverted()) &#123;</span><br><span class="line">      deepCopy.add(pv);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      String propertyName = pv.getName();</span><br><span class="line">      Object originalValue = pv.getValue();</span><br><span class="line">      Object resolvedValue = valueResolver.resolveValueIfNecessary(pv, originalValue);</span><br><span class="line">      Object convertedValue = resolvedValue;</span><br><span class="line">      <span class="keyword">boolean</span> convertible = bw.isWritableProperty(propertyName) &amp;&amp;</span><br><span class="line">        !PropertyAccessorUtils.isNestedOrIndexedProperty(propertyName);</span><br><span class="line">      <span class="keyword">if</span> (convertible) &#123;</span><br><span class="line">        convertedValue = convertForProperty(resolvedValue, propertyName, bw, converter);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// Possibly store converted value in merged bean definition,</span></span><br><span class="line">      <span class="comment">// in order to avoid re-conversion for every created bean instance.</span></span><br><span class="line">      <span class="keyword">if</span> (resolvedValue == originalValue) &#123;</span><br><span class="line">        <span class="keyword">if</span> (convertible) &#123;</span><br><span class="line">          pv.setConvertedValue(convertedValue);</span><br><span class="line">        &#125;</span><br><span class="line">        deepCopy.add(pv);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (convertible &amp;&amp; originalValue <span class="keyword">instanceof</span> TypedStringValue &amp;&amp;</span><br><span class="line">               !((TypedStringValue) originalValue).isDynamic() &amp;&amp;</span><br><span class="line">               !(convertedValue <span class="keyword">instanceof</span> Collection || </span><br><span class="line">                 ObjectUtils.isArray(convertedValue))) &#123;</span><br><span class="line">        pv.setConvertedValue(convertedValue);</span><br><span class="line">        deepCopy.add(pv);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        resolveNecessary = <span class="keyword">true</span>;</span><br><span class="line">        deepCopy.add(<span class="keyword">new</span> PropertyValue(pv, convertedValue));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (mpvs != <span class="keyword">null</span> &amp;&amp; !resolveNecessary) &#123;</span><br><span class="line">    mpvs.setConverted();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Set our (possibly massaged) deep copy.</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    bw.setPropertyValues(<span class="keyword">new</span> MutablePropertyValues(deepCopy));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">      mbd.getResourceDescription(), beanName, <span class="string">&quot;Error setting property values&quot;</span>, ex);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，<code>doCreateBean()</code> 第二个过程：属性填充 已经分析完成了。</p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
          <category> 《Spring源码分析》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> 转载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IOC之构造函数实例化bean</title>
      <link href="/blog/2020/01/20/cdc6fa32.html"/>
      <url>/blog/2020/01/20/cdc6fa32.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文作者：chenssy</p><p>出处：<a href="http://cmsblogs.com/?p=2850">http://cmsblogs.com/?p=2850</a></p><p>在学习<code>Spring源码</code>的过程中发现的好站+好贴，感谢作者。Spring版本：<strong>Spring 5.0.6.RELEASE</strong></p></blockquote><p><code>createBeanInstance()</code> 用于实例化 bean，它会根据不同情况选择不同的实例化策略来完成 bean 的初始化，主要包括：</p><ul><li>Supplier 回调：<code>obtainFromSupplier()</code></li><li>工厂方法初始化：<code>instantiateUsingFactoryMethod()</code></li><li>构造函数自动注入初始化：<code>autowireConstructor()</code></li><li>默认构造函数注入：<code>instantiateBean()</code></li></ul><p>在(<a href="/2020/01/19/6271d9d2.html"> IOC 之 Factory 实例化 bean</a>) 中分析了 Supplier 回调和工厂方法初始化，这篇分析两个构造函数注入。</p><h2 id="autowireConstructor"><a href="#autowireConstructor" class="headerlink" title="autowireConstructor()"></a>autowireConstructor()</h2><p>这个初始化方法我们可以简单理解为是带有参数的初始化 bean 。代码段如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> BeanWrapper <span class="title">autowireConstructor</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">final</span> String beanName, </span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">final</span> RootBeanDefinition mbd,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="meta">@Nullable</span> Constructor&lt;?&gt;[] chosenCtors, </span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="meta">@Nullable</span> <span class="keyword">final</span> Object[] explicitArgs)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 封装 BeanWrapperImpl  并完成初始化</span></span><br><span class="line">  BeanWrapperImpl bw = <span class="keyword">new</span> BeanWrapperImpl();</span><br><span class="line">  <span class="keyword">this</span>.beanFactory.initBeanWrapper(bw);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 构造函数</span></span><br><span class="line">  Constructor&lt;?&gt; constructorToUse = <span class="keyword">null</span>;</span><br><span class="line">  <span class="comment">// 构造参数</span></span><br><span class="line">  ArgumentsHolder argsHolderToUse = <span class="keyword">null</span>;</span><br><span class="line">  Object[] argsToUse = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 确定构造参数</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">  <span class="comment">// 如果 getBean() 已经传递，则直接使用</span></span><br><span class="line">  <span class="keyword">if</span> (explicitArgs != <span class="keyword">null</span>) &#123;</span><br><span class="line">    argsToUse = explicitArgs;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">             *  尝试从缓存中获取</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">    Object[] argsToResolve = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">synchronized</span> (mbd.constructorArgumentLock) &#123;</span><br><span class="line">      <span class="comment">// 缓存中的构造函数或者工厂方法</span></span><br><span class="line">      constructorToUse = (Constructor&lt;?&gt;) mbd.resolvedConstructorOrFactoryMethod;</span><br><span class="line">      <span class="keyword">if</span> (constructorToUse != <span class="keyword">null</span> &amp;&amp; mbd.constructorArgumentsResolved) &#123;</span><br><span class="line">        <span class="comment">// 缓存中的构造参数</span></span><br><span class="line">        argsToUse = mbd.resolvedConstructorArguments;</span><br><span class="line">        <span class="keyword">if</span> (argsToUse == <span class="keyword">null</span>) &#123;</span><br><span class="line">          argsToResolve = mbd.preparedConstructorArguments;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 缓存中存在,则解析存储在 BeanDefinition 中的参数</span></span><br><span class="line">    <span class="comment">// 如给定方法的构造函数 A(int ,int )，则通过此方法后就会把配置文件中的(&quot;1&quot;,&quot;1&quot;)转换为 (1,1)</span></span><br><span class="line">    <span class="comment">// 缓存中的值可能是原始值也有可能是最终值</span></span><br><span class="line">    <span class="keyword">if</span> (argsToResolve != <span class="keyword">null</span>) &#123;</span><br><span class="line">      argsToUse = </span><br><span class="line">        resolvePreparedArguments(beanName, mbd, bw, </span><br><span class="line">                                 constructorToUse, argsToResolve);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 没有缓存，则尝试从配置文件中获取</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">  <span class="keyword">if</span> (constructorToUse == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 是否需要解析构造器</span></span><br><span class="line">    <span class="keyword">boolean</span> autowiring = (</span><br><span class="line">      chosenCtors != <span class="keyword">null</span> ||</span><br><span class="line">      mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用于承载解析后的构造函数参数的值</span></span><br><span class="line">    ConstructorArgumentValues resolvedValues = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> minNrOfArgs;</span><br><span class="line">    <span class="keyword">if</span> (explicitArgs != <span class="keyword">null</span>) &#123;</span><br><span class="line">      minNrOfArgs = explicitArgs.length;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 从 BeanDefinition 中获取构造参数，也就是从配置文件中提取构造参数</span></span><br><span class="line">      ConstructorArgumentValues cargs = mbd.getConstructorArgumentValues();</span><br><span class="line"></span><br><span class="line">      resolvedValues = <span class="keyword">new</span> ConstructorArgumentValues();</span><br><span class="line">      <span class="comment">// 解析构造函数的参数</span></span><br><span class="line">      <span class="comment">// 将该 bean 的构造函数参数解析为 resolvedValues 对象，其中会涉及到其他 bean</span></span><br><span class="line">      minNrOfArgs = resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 获取指定的构造函数</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">    <span class="comment">// 根据前面的判断，chosenCtors 应该为 null</span></span><br><span class="line">    Constructor&lt;?&gt;[] candidates = chosenCtors;</span><br><span class="line">    <span class="keyword">if</span> (candidates == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 获取 bean 的 class</span></span><br><span class="line">      Class&lt;?&gt; beanClass = mbd.getBeanClass();</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 根据 class 获取所有的构造函数</span></span><br><span class="line">        candidates = (mbd.isNonPublicAccessAllowed() ?</span><br><span class="line">                      beanClass.getDeclaredConstructors() </span><br><span class="line">                      : beanClass.getConstructors());</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">          mbd.getResourceDescription(), beanName,</span><br><span class="line">          <span class="string">&quot;Resolution of declared constructors on bean Class [&quot;</span> </span><br><span class="line">          + beanClass.getName() +</span><br><span class="line">          <span class="string">&quot;] from ClassLoader [&quot;</span> + beanClass.getClassLoader() + <span class="string">&quot;] failed&quot;</span>, ex);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对构造函数进行排序处理</span></span><br><span class="line">    <span class="comment">// public 构造函数优先参数数量降序，非public 构造函数参数数量降序</span></span><br><span class="line">    AutowireUtils.sortConstructors(candidates);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最小参数类型权重</span></span><br><span class="line">    <span class="keyword">int</span> minTypeDiffWeight = Integer.MAX_VALUE;</span><br><span class="line">    Set&lt;Constructor&lt;?&gt;&gt; ambiguousConstructors = <span class="keyword">null</span>;</span><br><span class="line">    LinkedList&lt;UnsatisfiedDependencyException&gt; causes = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 迭代所有构造函数</span></span><br><span class="line">    <span class="keyword">for</span> (Constructor&lt;?&gt; candidate : candidates) &#123;</span><br><span class="line">      <span class="comment">// 获取该构造函数的参数类型</span></span><br><span class="line">      Class&lt;?&gt;[] paramTypes = candidate.getParameterTypes();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如果已经找到选用的构造函数或者需要的参数个数小于当前的构造函数参数个数，则终止</span></span><br><span class="line">      <span class="comment">// 因为已经按照参数个数降序排列了</span></span><br><span class="line">      <span class="keyword">if</span> (constructorToUse != <span class="keyword">null</span> &amp;&amp; argsToUse.length &gt; paramTypes.length) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 参数个数不等，继续</span></span><br><span class="line">      <span class="keyword">if</span> (paramTypes.length &lt; minNrOfArgs) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 参数持有者</span></span><br><span class="line">      ArgumentsHolder argsHolder;</span><br><span class="line">      <span class="comment">// 有参数</span></span><br><span class="line">      <span class="keyword">if</span> (resolvedValues != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">// 注释上获取参数名称</span></span><br><span class="line">          String[] paramNames = </span><br><span class="line">            ConstructorPropertiesChecker.evaluate(candidate, paramTypes.length);</span><br><span class="line">          <span class="keyword">if</span> (paramNames == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 获取构造函数、方法参数的探测器</span></span><br><span class="line">            ParameterNameDiscoverer pnd = <span class="keyword">this</span>.beanFactory.getParameterNameDiscoverer();</span><br><span class="line">            <span class="keyword">if</span> (pnd != <span class="keyword">null</span>) &#123;</span><br><span class="line">              <span class="comment">// 通过探测器获取构造函数的参数名称</span></span><br><span class="line">              paramNames = pnd.getParameterNames(candidate);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 根据构造函数和构造参数创建参数持有者</span></span><br><span class="line">          argsHolder = createArgumentArray(</span><br><span class="line">            beanName, mbd, resolvedValues, bw, paramTypes, paramNames,</span><br><span class="line">            getUserDeclaredConstructor(candidate), autowiring);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (UnsatisfiedDependencyException ex) &#123;</span><br><span class="line">          <span class="keyword">if</span> (<span class="keyword">this</span>.beanFactory.logger.isTraceEnabled()) &#123;</span><br><span class="line">            <span class="keyword">this</span>.beanFactory.logger.trace(</span><br><span class="line">              <span class="string">&quot;Ignoring constructor [&quot;</span> + candidate + <span class="string">&quot;] of bean &#x27;&quot;</span> </span><br><span class="line">              + beanName + <span class="string">&quot;&#x27;: &quot;</span> + ex);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// Swallow and try next constructor.</span></span><br><span class="line">          <span class="keyword">if</span> (causes == <span class="keyword">null</span>) &#123;</span><br><span class="line">            causes = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">          &#125;</span><br><span class="line">          causes.add(ex);</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 构造函数没有参数</span></span><br><span class="line">        <span class="keyword">if</span> (paramTypes.length != explicitArgs.length) &#123;</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        argsHolder = <span class="keyword">new</span> ArgumentsHolder(explicitArgs);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// isLenientConstructorResolution 判断解析构造函数的时候是否以宽松模式还是严格模式</span></span><br><span class="line">      <span class="comment">// 严格模式：解析构造函数时，必须所有的都需要匹配，否则抛出异常</span></span><br><span class="line">      <span class="comment">// 宽松模式：使用具有&quot;最接近的模式&quot;进行匹配</span></span><br><span class="line">      <span class="comment">// typeDiffWeight：类型差异权重</span></span><br><span class="line">      <span class="keyword">int</span> typeDiffWeight = (mbd.isLenientConstructorResolution() ?</span><br><span class="line">           argsHolder.getTypeDifferenceWeight(paramTypes) :</span><br><span class="line">                            argsHolder.getAssignabilityWeight(paramTypes));</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如果它代表着当前最接近的匹配则选择其作为构造函数</span></span><br><span class="line">      <span class="keyword">if</span> (typeDiffWeight &lt; minTypeDiffWeight) &#123;</span><br><span class="line">        constructorToUse = candidate;</span><br><span class="line">        argsHolderToUse = argsHolder;</span><br><span class="line">        argsToUse = argsHolder.arguments;</span><br><span class="line">        minTypeDiffWeight = typeDiffWeight;</span><br><span class="line">        ambiguousConstructors = <span class="keyword">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (constructorToUse != <span class="keyword">null</span> &amp;&amp; typeDiffWeight == minTypeDiffWeight) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ambiguousConstructors == <span class="keyword">null</span>) &#123;</span><br><span class="line">          ambiguousConstructors = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line">          ambiguousConstructors.add(constructorToUse);</span><br><span class="line">        &#125;</span><br><span class="line">        ambiguousConstructors.add(candidate);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (constructorToUse == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (causes != <span class="keyword">null</span>) &#123;</span><br><span class="line">        UnsatisfiedDependencyException ex = causes.removeLast();</span><br><span class="line">        <span class="keyword">for</span> (Exception cause : causes) &#123;</span><br><span class="line">          <span class="keyword">this</span>.beanFactory.onSuppressedException(cause);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">        mbd.getResourceDescription(), beanName,</span><br><span class="line">        <span class="string">&quot;Could not resolve matching constructor &quot;</span> +</span><br><span class="line">        <span class="string">&quot;(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (ambiguousConstructors != <span class="keyword">null</span> &amp;&amp; !mbd.isLenientConstructorResolution()) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">        mbd.getResourceDescription(), beanName,</span><br><span class="line">        <span class="string">&quot;Ambiguous constructor matches found in bean &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27; &quot;</span> +</span><br><span class="line">        <span class="string">&quot;(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): &quot;</span> +</span><br><span class="line">        ambiguousConstructors);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将构造函数、构造参数保存到缓存中</span></span><br><span class="line">    <span class="keyword">if</span> (explicitArgs == <span class="keyword">null</span>) &#123;</span><br><span class="line">      argsHolderToUse.storeCache(mbd, constructorToUse);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 获取创建 bean 的策略</span></span><br><span class="line">    <span class="keyword">final</span> InstantiationStrategy strategy = beanFactory.getInstantiationStrategy();</span><br><span class="line">    Object beanInstance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">final</span> Constructor&lt;?&gt; ctorToUse = constructorToUse;</span><br><span class="line">      <span class="keyword">final</span> Object[] argumentsToUse = argsToUse;</span><br><span class="line">      <span class="comment">// 实例化 bean</span></span><br><span class="line">      beanInstance = </span><br><span class="line">        AccessController.doPrivileged(</span><br><span class="line">        (PrivilegedAction&lt;Object&gt;) () -&gt;</span><br><span class="line">        strategy.instantiate(mbd, beanName, beanFactory, ctorToUse, argumentsToUse),</span><br><span class="line">        beanFactory.getAccessControlContext());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 实例化bean</span></span><br><span class="line">      beanInstance = strategy.instantiate(</span><br><span class="line">        mbd, beanName, <span class="keyword">this</span>.beanFactory, constructorToUse, argsToUse);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将构造的 bean 加入到 BeanWrapper 实例中</span></span><br><span class="line">    bw.setBeanInstance(beanInstance);</span><br><span class="line">    <span class="keyword">return</span> bw;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">      mbd.getResourceDescription(), beanName,</span><br><span class="line">      <span class="string">&quot;Bean instantiation via constructor failed&quot;</span>, ex);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码与 <code>instantiateUsingFactoryMethod()</code> 一样，又长又难懂，但是如果理解了 <code>instantiateUsingFactoryMethod()</code> 初始化 bean 的过程，那么 <code>autowireConstructor()</code> 也不存在什么难的地方了，一句话概括：首先确定构造函数参数、构造函数，然后调用相应的初始化策略进行 bean 的初始化。关于如何确定构造函数、构造参数，该部分逻辑和 <code>instantiateUsingFactoryMethod()</code> 基本一致，所以这里不再重复阐述了，具体过程请移步<a href="/2020/01/19/6271d9d2.html">IOC 之 Factory 实例化 bean</a>，这里我们重点分析初始化策略。 对于初始化策略，首先是获取实例化 bean 的策略，如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> InstantiationStrategy strategy = beanFactory.getInstantiationStrategy();</span><br></pre></td></tr></table></figure><p>然后是调用其 <code>instantiate()</code>方法，该方法在 SimpleInstantiationStrategy 中实现，如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">instantiate</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  RootBeanDefinition bd, <span class="meta">@Nullable</span> String beanName, BeanFactory owner)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 没有覆盖</span></span><br><span class="line">  <span class="comment">// 直接使用反射实例化即可</span></span><br><span class="line">  <span class="keyword">if</span> (!bd.hasMethodOverrides()) &#123;</span><br><span class="line">    <span class="comment">// 重新检测获取下构造函数</span></span><br><span class="line">    <span class="comment">// 该构造函数是经过前面 N 多复杂过程确认的构造函数</span></span><br><span class="line">    Constructor&lt;?&gt; constructorToUse;</span><br><span class="line">    <span class="keyword">synchronized</span> (bd.constructorArgumentLock) &#123;</span><br><span class="line">      <span class="comment">// 获取已经解析的构造函数</span></span><br><span class="line">      constructorToUse = (Constructor&lt;?&gt;) bd.resolvedConstructorOrFactoryMethod;</span><br><span class="line">      <span class="comment">// 如果为 null，从 class 中解析获取，并设置</span></span><br><span class="line">      <span class="keyword">if</span> (constructorToUse == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">final</span> Class&lt;?&gt; clazz = bd.getBeanClass();</span><br><span class="line">        <span class="keyword">if</span> (clazz.isInterface()) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> BeanInstantiationException(clazz, <span class="string">&quot;Specified class is an interface&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            constructorToUse = AccessController.doPrivileged(</span><br><span class="line">              (PrivilegedExceptionAction&lt;Constructor&lt;?&gt;&gt;) clazz::getDeclaredConstructor);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span> &#123;</span><br><span class="line">            constructorToUse =  clazz.getDeclaredConstructor();</span><br><span class="line">          &#125;</span><br><span class="line">          bd.resolvedConstructorOrFactoryMethod = constructorToUse;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> BeanInstantiationException(clazz, <span class="string">&quot;No default constructor found&quot;</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过BeanUtils直接使用构造器对象实例化bean</span></span><br><span class="line">    <span class="keyword">return</span> BeanUtils.instantiateClass(constructorToUse);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 生成CGLIB创建的子类对象</span></span><br><span class="line">    <span class="keyword">return</span> instantiateWithMethodInjection(bd, beanName, owner);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果该 bean 没有配置 lookup-method、replaced-method 标签或者 @Lookup 注解，则直接通过反射的方式实例化 bean 即可，方便快捷，但是如果存在需要覆盖的方法或者动态替换的方法则需要使用 CGLIB 进行动态代理，因为可以在创建代理的同时将动态方法织入类中。 <strong>反射</strong> 调用工具类 BeanUtils 的 <code>instantiateClass()</code> 方法完成反射工作：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">instantiateClass</span><span class="params">(Constructor&lt;T&gt; ctor, Object... args)</span> <span class="keyword">throws</span> BeanInstantiationException </span>&#123;</span><br><span class="line">  Assert.notNull(ctor, <span class="string">&quot;Constructor must not be null&quot;</span>);</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    ReflectionUtils.makeAccessible(ctor);</span><br><span class="line">    <span class="keyword">return</span> (KotlinDetector.isKotlinType(ctor.getDeclaringClass()) ?</span><br><span class="line">            KotlinDelegate.instantiateClass(ctor, args) : ctor.newInstance(args));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 省略一些 catch </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>CGLIB</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">instantiateWithMethodInjection</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  RootBeanDefinition bd, <span class="meta">@Nullable</span> String beanName, BeanFactory owner)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(</span><br><span class="line">    <span class="string">&quot;Method Injection not supported in SimpleInstantiationStrategy&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法默认是没有实现的，具体过程由其子类 CglibSubclassingInstantiationStrategy 实现：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">instantiateWithMethodInjection</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  RootBeanDefinition bd, <span class="meta">@Nullable</span> String beanName, BeanFactory owner)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> instantiateWithMethodInjection(bd, beanName, owner, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> Object instantiateWithMethodInjection</span><br><span class="line">  (RootBeanDefinition bd, <span class="meta">@Nullable</span> String beanName, BeanFactory owner,</span><br><span class="line">   <span class="meta">@Nullable</span> Constructor&lt;?&gt; ctor, <span class="meta">@Nullable</span> Object... args) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 通过CGLIB生成一个子类对象</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> CglibSubclassCreator(bd, owner).instantiate(ctor, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建一个 CglibSubclassCreator 对象，调用其 <code>instantiate()</code> 方法生成其子类对象：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">instantiate</span><span class="params">(<span class="meta">@Nullable</span> Constructor&lt;?&gt; ctor, <span class="meta">@Nullable</span> Object... args)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 通过 Cglib 创建一个代理类</span></span><br><span class="line">  Class&lt;?&gt; subclass = createEnhancedSubclass(<span class="keyword">this</span>.beanDefinition);</span><br><span class="line">  Object instance;</span><br><span class="line">  <span class="comment">// 没有构造器，通过 BeanUtils 使用默认构造器创建一个bean实例</span></span><br><span class="line">  <span class="keyword">if</span> (ctor == <span class="keyword">null</span>) &#123;</span><br><span class="line">    instance = BeanUtils.instantiateClass(subclass);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 获取代理类对应的构造器对象，并实例化 bean</span></span><br><span class="line">      Constructor&lt;?&gt; enhancedSubclassConstructor = </span><br><span class="line">        subclass.getConstructor(ctor.getParameterTypes());</span><br><span class="line">      instance = enhancedSubclassConstructor.newInstance(args);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BeanInstantiationException(</span><br><span class="line">        <span class="keyword">this</span>.beanDefinition.getBeanClass(),</span><br><span class="line">        <span class="string">&quot;Failed to invoke constructor for CGLIB enhanced subclass [&quot;</span> </span><br><span class="line">        + subclass.getName() + <span class="string">&quot;]&quot;</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 为了避免memory leaks异常，直接在bean实例上设置回调对象</span></span><br><span class="line">  Factory factory = (Factory) instance;</span><br><span class="line">  factory.setCallbacks(<span class="keyword">new</span> Callback[] &#123;</span><br><span class="line">    NoOp.INSTANCE,</span><br><span class="line">    <span class="keyword">new</span> CglibSubclassingInstantiationStrategy</span><br><span class="line">      .LookupOverrideMethodInterceptor(</span><br><span class="line">      <span class="keyword">this</span>.beanDefinition, <span class="keyword">this</span>.owner),</span><br><span class="line">    <span class="keyword">new</span> CglibSubclassingInstantiationStrategy</span><br><span class="line">      .ReplaceOverrideMethodInterceptor(<span class="keyword">this</span>.beanDefinition, <span class="keyword">this</span>.owner)&#125;);</span><br><span class="line">  <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这类 CGLIB 的方式分析完毕了，当然这里还没有具体分析 CGLIB 生成子类的详细过程，具体的过程等后续分析 AOP 的时候再详细地介绍。</p><h2 id="instantiateBean"><a href="#instantiateBean" class="headerlink" title="instantiateBean()"></a>instantiateBean()</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> BeanWrapper <span class="title">instantiateBean</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">final</span> String beanName, <span class="keyword">final</span> RootBeanDefinition mbd)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    Object beanInstance;</span><br><span class="line">    <span class="keyword">final</span> BeanFactory parent = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">      beanInstance = AccessController</span><br><span class="line">        .doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt;</span><br><span class="line">                      getInstantiationStrategy()</span><br><span class="line">                      .instantiate(mbd, beanName, parent),</span><br><span class="line">                      getAccessControlContext());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      beanInstance = getInstantiationStrategy().instantiate(mbd, beanName, parent);</span><br><span class="line">    &#125;</span><br><span class="line">    BeanWrapper bw = <span class="keyword">new</span> BeanWrapperImpl(beanInstance);</span><br><span class="line">    initBeanWrapper(bw);</span><br><span class="line">    <span class="keyword">return</span> bw;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">      mbd.getResourceDescription(), beanName, <span class="string">&quot;Instantiation of bean failed&quot;</span>, ex);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法相比于 <code>instantiateUsingFactoryMethod()</code> 、 <code>autowireConstructor()</code> 方法实在是太简单了，因为它没有参数，所以不需要确认经过复杂的过来来确定构造器、构造参数，所以这里就不过多阐述了。 </p><p>对于 <code>createBeanInstance()</code> 而言，他就是选择合适实例化策略来为 bean 创建实例对象，具体的策略有：<strong>Supplier 回调方式</strong>、<strong>工厂方法初始化</strong>、<strong>构造函数自动注入初始化</strong>、<strong>默认构造函数注入</strong>。</p><p>其中<u><em>工厂方法初始化</em></u>和<u><em>构造函数自动注入初始化</em></u>两种方式最为复杂，主要是因为构造函数和构造参数的不确定性，<strong>Spring 需要花大量的精力来确定构造函数和构造参数</strong>，如果确定了则好办，直接选择实例化策略即可。当然在实例化的时候会根据是否有需要覆盖或者动态替换掉的方法，因为存在覆盖或者织入的话需要创建动态代理将方法织入，这个时候就只能选择 CGLIB 的方式来实例化，否则直接利用反射的方式即可，方便快捷。 到这里 <code>createBeanInstance()</code> 的过程就已经分析完毕了。</p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
          <category> 《Spring源码分析》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> 转载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IOC之Factory实例化bean</title>
      <link href="/blog/2020/01/19/6271d9d2.html"/>
      <url>/blog/2020/01/19/6271d9d2.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文作者：chenssy</p><p>出处：<a href="http://cmsblogs.com/?p=2848">http://cmsblogs.com/?p=2848</a></p><p>在学习<code>Spring源码</code>的过程中发现的好站+好贴，感谢作者。Spring版本：<strong>Spring 5.0.6.RELEASE</strong></p></blockquote><p>这篇我们关注创建 bean 过程中的第一个步骤：实例化 bean，对应的方法为：<code>createBeanInstance()</code>，如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> BeanWrapper <span class="title">createBeanInstance</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  String beanName, RootBeanDefinition mbd, <span class="meta">@Nullable</span> Object[] args)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 解析 bean，将 bean 类名解析为 class 引用</span></span><br><span class="line">  Class&lt;?&gt; beanClass = resolveBeanClass(mbd, beanName);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (beanClass != <span class="keyword">null</span> &amp;&amp; </span><br><span class="line">      !Modifier.isPublic(beanClass.getModifiers()) &amp;&amp; </span><br><span class="line">      !mbd.isNonPublicAccessAllowed()) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">      mbd.getResourceDescription(), beanName,</span><br><span class="line">      <span class="string">&quot;Bean class isn&#x27;t public, and non-public access not allowed: &quot;</span> </span><br><span class="line">      + beanClass.getName());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果存在 Supplier 回调，则使用给定的回调方法初始化策略</span></span><br><span class="line">  Supplier&lt;?&gt; instanceSupplier = mbd.getInstanceSupplier();</span><br><span class="line">  <span class="keyword">if</span> (instanceSupplier != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> obtainFromSupplier(instanceSupplier, beanName);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果工厂方法不为空，则使用工厂方法初始化策略</span></span><br><span class="line">  <span class="keyword">if</span> (mbd.getFactoryMethodName() != <span class="keyword">null</span>)  &#123;</span><br><span class="line">    <span class="keyword">return</span> instantiateUsingFactoryMethod(beanName, mbd, args);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">boolean</span> resolved = <span class="keyword">false</span>;</span><br><span class="line">  <span class="keyword">boolean</span> autowireNecessary = <span class="keyword">false</span>;</span><br><span class="line">  <span class="keyword">if</span> (args == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// constructorArgumentLock 构造函数的常用锁</span></span><br><span class="line">    <span class="keyword">synchronized</span> (mbd.constructorArgumentLock) &#123;</span><br><span class="line">      <span class="comment">// 如果已缓存的解析的构造函数或者工厂方法不为空，则可以利用构造函数解析</span></span><br><span class="line">      <span class="comment">// 因为需要根据参数确认到底使用哪个构造函数，该过程比较消耗性能，所有采用缓存机制</span></span><br><span class="line">      <span class="keyword">if</span> (mbd.resolvedConstructorOrFactoryMethod != <span class="keyword">null</span>) &#123;</span><br><span class="line">        resolved = <span class="keyword">true</span>;</span><br><span class="line">        autowireNecessary = mbd.constructorArgumentsResolved;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 已经解析好了，直接注入即可</span></span><br><span class="line">  <span class="keyword">if</span> (resolved) &#123;</span><br><span class="line">    <span class="comment">// 自动注入，调用构造函数自动注入</span></span><br><span class="line">    <span class="keyword">if</span> (autowireNecessary) &#123;</span><br><span class="line">      <span class="keyword">return</span> autowireConstructor(beanName, mbd, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 使用默认构造函数构造</span></span><br><span class="line">      <span class="keyword">return</span> instantiateBean(beanName, mbd);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 确定解析的构造函数</span></span><br><span class="line">  <span class="comment">// 主要是检查已经注册的 SmartInstantiationAwareBeanPostProcessor</span></span><br><span class="line">  Constructor&lt;?&gt;[] ctors = determineConstructorsFromBeanPostProcessors(beanClass, beanName);</span><br><span class="line">  <span class="keyword">if</span> (ctors != <span class="keyword">null</span> ||</span><br><span class="line">      mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_CONSTRUCTOR ||</span><br><span class="line">      mbd.hasConstructorArgumentValues() || !ObjectUtils.isEmpty(args))  &#123;</span><br><span class="line">    <span class="comment">// 构造函数自动注入</span></span><br><span class="line">    <span class="keyword">return</span> autowireConstructor(beanName, mbd, ctors, args);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//使用默认构造函数注入</span></span><br><span class="line">  <span class="keyword">return</span> instantiateBean(beanName, mbd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实例化 bean 是一个复杂的过程，其主要的逻辑为：</p><ul><li>如果存在 Supplier 回调，则调用 <code>obtainFromSupplier()</code> 进行初始化</li><li>如果存在工厂方法，则使用工厂方法进行初始化</li><li>首先判断缓存，如果缓存中存在，即已经解析过了，则直接使用已经解析了的，根据 constructorArgumentsResolved 参数来判断是使用构造函数自动注入还是默认构造函数</li><li>如果缓存中没有，则需要先确定到底使用哪个构造函数来完成解析工作，因为一个类有多个构造函数，每个构造函数都有不同的构造参数，所以需要根据参数来锁定构造函数并完成初始化，如果存在参数则使用相应的带有参数的构造函数，否则使用默认构造函数。</li></ul><p>下面就上面四种情况做分别说明。</p><h2 id="obtainFromSupplier"><a href="#obtainFromSupplier" class="headerlink" title="obtainFromSupplier()"></a>obtainFromSupplier()</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Supplier&lt;?&gt; instanceSupplier = mbd.getInstanceSupplier();</span><br><span class="line"><span class="keyword">if</span> (instanceSupplier != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> obtainFromSupplier(instanceSupplier, beanName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先从 BeanDefinition 中获取 Supplier，如果不为空，则调用 <code>obtainFromSupplier()</code> 。那么 Supplier 是什么呢？在这之前也没有提到过这个字段。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Supplier</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">T <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Supplier 接口仅有一个功能性的 <code>get()</code>，该方法会返回一个 T 类型的对象，有点儿类似工厂方法。这个接口有什么作用？用于指定创建 bean 的回调，如果我们设置了这样的回调，那么其他的构造器或者工厂方法都会没有用。在什么设置该参数呢？Spring 提供了相应的 <code>setter</code> 方法，如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setInstanceSupplier</span><span class="params">(<span class="meta">@Nullable</span> Supplier&lt;?&gt; instanceSupplier)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.instanceSupplier = instanceSupplier;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在构造 BeanDefinition 的时候设置了该值，如下（以 RootBeanDefinition 为例）：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; RootBeanDefinition(<span class="meta">@Nullable</span> Class&lt;T&gt; beanClass, String scope, <span class="meta">@Nullable</span> Supplier&lt;T&gt; instanceSupplier) &#123;</span><br><span class="line">  <span class="keyword">super</span>();</span><br><span class="line">  setBeanClass(beanClass);</span><br><span class="line">  setScope(scope);</span><br><span class="line">  setInstanceSupplier(instanceSupplier);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果设置了 instanceSupplier 则调用 <code>obtainFromSupplier()</code> 完成 bean 的初始化，如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> BeanWrapper <span class="title">obtainFromSupplier</span><span class="params">(Supplier&lt;?&gt; instanceSupplier, String beanName)</span> </span>&#123;</span><br><span class="line">  String outerBean = <span class="keyword">this</span>.currentlyCreatedBean.get();</span><br><span class="line">  <span class="keyword">this</span>.currentlyCreatedBean.set(beanName);</span><br><span class="line">  Object instance;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 调用 Supplier 的 get()，返回一个对象</span></span><br><span class="line">    instance = instanceSupplier.get();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (outerBean != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.currentlyCreatedBean.set(outerBean);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.currentlyCreatedBean.remove();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 根据对象构造 BeanWrapper 对象</span></span><br><span class="line">  BeanWrapper bw = <span class="keyword">new</span> BeanWrapperImpl(instance);</span><br><span class="line">  <span class="comment">// 初始化 BeanWrapper</span></span><br><span class="line">  initBeanWrapper(bw);</span><br><span class="line">  <span class="keyword">return</span> bw;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码很简单，调用 调用 Supplier 的 <code>get()</code> 方法，获得一个 bean 实例对象，然后根据该实例对象构造一个 BeanWrapper 对象 bw，最后初始化该对象。有关于 BeanWrapper 后面专门出文讲解。</p><h2 id="instantiateUsingFactoryMethod"><a href="#instantiateUsingFactoryMethod" class="headerlink" title="instantiateUsingFactoryMethod()"></a>instantiateUsingFactoryMethod()</h2><p>如果存在工厂方法，则调用 <code>instantiateUsingFactoryMethod()</code> 完成 bean 的初始化工作（方法实现比较长，细节比较复杂，各位就硬着头皮看吧）。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> BeanWrapper <span class="title">instantiateUsingFactoryMethod</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  String beanName, RootBeanDefinition mbd, <span class="meta">@Nullable</span> Object[] explicitArgs)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> ConstructorResolver(<span class="keyword">this</span>)</span><br><span class="line">    .instantiateUsingFactoryMethod(beanName, mbd, explicitArgs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造一个 ConstructorResolver 对象，然后调用其 <code>instantiateUsingFactoryMethod()</code> 方法。ConstructorResolver 是构造方法或者工厂类初始化 bean 的委托类。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> BeanWrapper <span class="title">instantiateUsingFactoryMethod</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">final</span> String beanName, <span class="keyword">final</span> RootBeanDefinition mbd, </span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="meta">@Nullable</span> <span class="keyword">final</span> Object[] explicitArgs)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 构造 BeanWrapperImpl 对象</span></span><br><span class="line">  BeanWrapperImpl bw = <span class="keyword">new</span> BeanWrapperImpl();</span><br><span class="line">  <span class="comment">// 初始化 BeanWrapperImpl</span></span><br><span class="line">  <span class="comment">// 向BeanWrapper对象中添加 ConversionService 对象和属性编辑器 PropertyEditor 对象</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="keyword">this</span>.beanFactory.initBeanWrapper(bw);</span><br><span class="line"></span><br><span class="line">  Object factoryBean;</span><br><span class="line">  Class&lt;?&gt; factoryClass;</span><br><span class="line">  <span class="keyword">boolean</span> isStatic;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 工厂名不为空</span></span><br><span class="line">  String factoryBeanName = mbd.getFactoryBeanName();</span><br><span class="line">  <span class="keyword">if</span> (factoryBeanName != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (factoryBeanName.equals(beanName)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(</span><br><span class="line">        mbd.getResourceDescription(), beanName,</span><br><span class="line"><span class="string">&quot;factory-bean reference points back to the same bean definition&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取工厂实例</span></span><br><span class="line">    factoryBean = <span class="keyword">this</span>.beanFactory.getBean(factoryBeanName);</span><br><span class="line">    <span class="keyword">if</span> (mbd.isSingleton() &amp;&amp; <span class="keyword">this</span>.beanFactory.containsSingleton(beanName)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> ImplicitlyAppearedSingletonException();</span><br><span class="line">    &#125;</span><br><span class="line">    factoryClass = factoryBean.getClass();</span><br><span class="line">    isStatic = <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 工厂名为空，则其可能是一个静态工厂</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态工厂创建bean，必须要提供工厂的全类名</span></span><br><span class="line">    <span class="keyword">if</span> (!mbd.hasBeanClass()) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(</span><br><span class="line">        mbd.getResourceDescription(), beanName,</span><br><span class="line"><span class="string">&quot;bean definition declares neither a bean class nor a factory-bean reference&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    factoryBean = <span class="keyword">null</span>;</span><br><span class="line">    factoryClass = mbd.getBeanClass();</span><br><span class="line">    isStatic = <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 工厂方法</span></span><br><span class="line">  Method factoryMethodToUse = <span class="keyword">null</span>;</span><br><span class="line">  ConstructorResolver.ArgumentsHolder argsHolderToUse = <span class="keyword">null</span>;</span><br><span class="line">  <span class="comment">// 参数</span></span><br><span class="line">  Object[] argsToUse = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 工厂方法的参数</span></span><br><span class="line">  <span class="comment">// 如果指定了构造参数则直接使用</span></span><br><span class="line">  <span class="comment">// 在调用 getBean 方法的时候指定了方法参数</span></span><br><span class="line">  <span class="keyword">if</span> (explicitArgs != <span class="keyword">null</span>) &#123;</span><br><span class="line">    argsToUse = explicitArgs;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 没有指定，则尝试从配置文件中解析</span></span><br><span class="line">    Object[] argsToResolve = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 首先尝试从缓存中获取</span></span><br><span class="line">    <span class="keyword">synchronized</span> (mbd.constructorArgumentLock) &#123;</span><br><span class="line">      <span class="comment">// 获取缓存中的构造函数或者工厂方法</span></span><br><span class="line">      factoryMethodToUse = (Method) mbd.resolvedConstructorOrFactoryMethod;</span><br><span class="line">      <span class="keyword">if</span> (factoryMethodToUse != <span class="keyword">null</span> &amp;&amp; mbd.constructorArgumentsResolved) &#123;</span><br><span class="line">        <span class="comment">// 获取缓存中的构造参数</span></span><br><span class="line">        argsToUse = mbd.resolvedConstructorArguments;</span><br><span class="line">        <span class="keyword">if</span> (argsToUse == <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="comment">// 获取缓存中的构造函数参数的包可见字段</span></span><br><span class="line">          argsToResolve = mbd.preparedConstructorArguments;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 缓存中存在,则解析存储在 BeanDefinition 中的参数</span></span><br><span class="line">    <span class="comment">// 如给定方法的构造函数 A(int ,int )，则通过此方法后就会把配置文件中的(&quot;1&quot;,&quot;1&quot;)转换为 (1,1)</span></span><br><span class="line">    <span class="comment">// 缓存中的值可能是原始值也有可能是最终值</span></span><br><span class="line">    <span class="keyword">if</span> (argsToResolve != <span class="keyword">null</span>) &#123;</span><br><span class="line">      argsToUse = </span><br><span class="line">        resolvePreparedArguments(</span><br><span class="line">        beanName, mbd, bw, factoryMethodToUse, argsToResolve);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="keyword">if</span> (factoryMethodToUse == <span class="keyword">null</span> || argsToUse == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 获取工厂方法的类全名称</span></span><br><span class="line">    factoryClass = ClassUtils.getUserClass(factoryClass);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取所有待定方法</span></span><br><span class="line">    Method[] rawCandidates = getCandidateMethods(factoryClass, mbd);</span><br><span class="line">    <span class="comment">// 检索所有方法，这里是对方法进行过滤</span></span><br><span class="line">    List&lt;Method&gt; candidateSet = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Method candidate : rawCandidates) &#123;</span><br><span class="line">      <span class="comment">// 如果有static 且为工厂方法，则添加到 candidateSet 中</span></span><br><span class="line">      <span class="keyword">if</span> (Modifier.isStatic(candidate.getModifiers()) == isStatic &amp;&amp; </span><br><span class="line">          mbd.isFactoryMethod(candidate)) &#123;</span><br><span class="line">        candidateSet.add(candidate);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Method[] candidates = candidateSet.toArray(<span class="keyword">new</span> Method[<span class="number">0</span>]);</span><br><span class="line">    <span class="comment">// 排序构造函数</span></span><br><span class="line">    <span class="comment">// public 构造函数优先参数数量降序，非public 构造函数参数数量降序</span></span><br><span class="line">    AutowireUtils.sortFactoryMethods(candidates);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用于承载解析后的构造函数参数的值</span></span><br><span class="line">    ConstructorArgumentValues resolvedValues = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">boolean</span> autowiring = (mbd.getResolvedAutowireMode() == </span><br><span class="line">                          RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);</span><br><span class="line">    <span class="keyword">int</span> minTypeDiffWeight = Integer.MAX_VALUE;</span><br><span class="line">    Set&lt;Method&gt; ambiguousFactoryMethods = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> minNrOfArgs;</span><br><span class="line">    <span class="keyword">if</span> (explicitArgs != <span class="keyword">null</span>) &#123;</span><br><span class="line">      minNrOfArgs = explicitArgs.length;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// getBean() 没有传递参数，则需要解析保存在 BeanDefinition 构造函数中指定的参数</span></span><br><span class="line">      <span class="keyword">if</span> (mbd.hasConstructorArgumentValues()) &#123;</span><br><span class="line">        <span class="comment">// 构造函数的参数</span></span><br><span class="line">        ConstructorArgumentValues cargs = mbd.getConstructorArgumentValues();</span><br><span class="line">        resolvedValues = <span class="keyword">new</span> ConstructorArgumentValues();</span><br><span class="line">        <span class="comment">// 解析构造函数的参数</span></span><br><span class="line">        <span class="comment">// 将该 bean 的构造函数参数解析为 resolvedValues 对象，其中会涉及到其他 bean</span></span><br><span class="line">        minNrOfArgs = </span><br><span class="line">          resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        minNrOfArgs = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    LinkedList&lt;UnsatisfiedDependencyException&gt; causes = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Method candidate : candidates) &#123;</span><br><span class="line">      <span class="comment">// 方法体的参数</span></span><br><span class="line">      Class&lt;?&gt;[] paramTypes = candidate.getParameterTypes();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (paramTypes.length &gt;= minNrOfArgs) &#123;</span><br><span class="line">        <span class="comment">// 保存参数的对象</span></span><br><span class="line">        ArgumentsHolder argsHolder;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// getBean()传递了参数</span></span><br><span class="line">        <span class="keyword">if</span> (explicitArgs != <span class="keyword">null</span>)&#123;</span><br><span class="line">          <span class="comment">// 显示给定参数，参数长度必须完全匹配</span></span><br><span class="line">          <span class="keyword">if</span> (paramTypes.length != explicitArgs.length) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// 根据参数创建参数持有者</span></span><br><span class="line">          argsHolder = <span class="keyword">new</span> ArgumentsHolder(explicitArgs);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 为提供参数，解析构造参数</span></span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            String[] paramNames = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">// 获取 ParameterNameDiscoverer 对象</span></span><br><span class="line">            <span class="comment">// ParameterNameDiscoverer 是用于解析方法和构造函数的参数名称的接口，为参数名称探测器</span></span><br><span class="line">            ParameterNameDiscoverer pnd = <span class="keyword">this</span>.beanFactory.getParameterNameDiscoverer();</span><br><span class="line">            <span class="keyword">if</span> (pnd != <span class="keyword">null</span>) &#123;</span><br><span class="line">              <span class="comment">// 获取指定构造函数的参数名称</span></span><br><span class="line">              paramNames = pnd.getParameterNames(candidate);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 在已经解析的构造函数参数值的情况下，创建一个参数持有者对象</span></span><br><span class="line">            argsHolder = createArgumentArray(</span><br><span class="line">              beanName, mbd, resolvedValues, bw, </span><br><span class="line">              paramTypes, paramNames, candidate, autowiring);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">catch</span> (UnsatisfiedDependencyException ex) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.beanFactory.logger.isTraceEnabled()) &#123;</span><br><span class="line">              <span class="keyword">this</span>.beanFactory.logger.trace(</span><br><span class="line">                <span class="string">&quot;Ignoring factory method [&quot;</span> + candidate +</span><br><span class="line"><span class="string">&quot;] of bean &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27;: &quot;</span> + ex);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (causes == <span class="keyword">null</span>) &#123;</span><br><span class="line">              causes = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">            &#125;</span><br><span class="line">            causes.add(ex);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// isLenientConstructorResolution 判断解析构造函数的时候是否以宽松模式还是严格模式</span></span><br><span class="line">        <span class="comment">// 严格模式：解析构造函数时，必须所有的都需要匹配，否则抛出异常</span></span><br><span class="line">        <span class="comment">// 宽松模式：使用具有&quot;最接近的模式&quot;进行匹配</span></span><br><span class="line">        <span class="comment">// typeDiffWeight：类型差异权重</span></span><br><span class="line">        <span class="keyword">int</span> typeDiffWeight = </span><br><span class="line">          (mbd.isLenientConstructorResolution() ?                   </span><br><span class="line">           argsHolder.getTypeDifferenceWeight(paramTypes) </span><br><span class="line">           :argsHolder.getAssignabilityWeight(paramTypes));</span><br><span class="line">        <span class="comment">// 代表最接近的类型匹配，则选择作为构造函数</span></span><br><span class="line">        <span class="keyword">if</span> (typeDiffWeight &lt; minTypeDiffWeight) &#123;</span><br><span class="line">          factoryMethodToUse = candidate;</span><br><span class="line">          argsHolderToUse = argsHolder;</span><br><span class="line">          argsToUse = argsHolder.arguments;</span><br><span class="line">          minTypeDiffWeight = typeDiffWeight;</span><br><span class="line">          ambiguousFactoryMethods = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果具有相同参数数量的方法具有相同的类型差异权重，则收集此类型选项</span></span><br><span class="line">        <span class="comment">// 但是，仅在非宽松构造函数解析模式下执行该检查，并显式忽略重写方法（具有相同的参数签名）</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (factoryMethodToUse != <span class="keyword">null</span> &amp;&amp; typeDiffWeight == minTypeDiffWeight &amp;&amp;</span><br><span class="line">                 !mbd.isLenientConstructorResolution() &amp;&amp;</span><br><span class="line">                 paramTypes.length == factoryMethodToUse.getParameterCount() &amp;&amp;</span><br><span class="line">                 !Arrays.equals(paramTypes, factoryMethodToUse.getParameterTypes())) &#123;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 查找到多个可匹配的方法</span></span><br><span class="line">          <span class="keyword">if</span> (ambiguousFactoryMethods == <span class="keyword">null</span>) &#123;</span><br><span class="line">            ambiguousFactoryMethods = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line">            ambiguousFactoryMethods.add(factoryMethodToUse);</span><br><span class="line">          &#125;</span><br><span class="line">          ambiguousFactoryMethods.add(candidate);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 没有可执行的工厂方法，抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (factoryMethodToUse == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (causes != <span class="keyword">null</span>) &#123;</span><br><span class="line">        UnsatisfiedDependencyException ex = causes.removeLast();</span><br><span class="line">        <span class="keyword">for</span> (Exception cause : causes) &#123;</span><br><span class="line">          <span class="keyword">this</span>.beanFactory.onSuppressedException(cause);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">      &#125;</span><br><span class="line">      List&lt;String&gt; argTypes = <span class="keyword">new</span> ArrayList&lt;&gt;(minNrOfArgs);</span><br><span class="line">      <span class="keyword">if</span> (explicitArgs != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Object arg : explicitArgs) &#123;</span><br><span class="line">          argTypes.add(arg != <span class="keyword">null</span> ? arg.getClass().getSimpleName() : <span class="string">&quot;null&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (resolvedValues != <span class="keyword">null</span>)&#123;</span><br><span class="line">        Set&lt;ConstructorArgumentValues.ValueHolder&gt; valueHolders = </span><br><span class="line">          <span class="keyword">new</span> LinkedHashSet&lt;&gt;(resolvedValues.getArgumentCount());</span><br><span class="line">        valueHolders.addAll(resolvedValues.getIndexedArgumentValues().values());</span><br><span class="line">        valueHolders.addAll(resolvedValues.getGenericArgumentValues());</span><br><span class="line">        <span class="keyword">for</span> (ConstructorArgumentValues.ValueHolder value : valueHolders) &#123;</span><br><span class="line">          String argType = (value.getType() != <span class="keyword">null</span> ? </span><br><span class="line">                            ClassUtils.getShortName(value.getType()) :</span><br><span class="line">                            (value.getValue() != <span class="keyword">null</span> ? </span><br><span class="line">                             value.getValue().getClass().getSimpleName() : <span class="string">&quot;null&quot;</span>));</span><br><span class="line">          argTypes.add(argType);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      String argDesc = StringUtils.collectionToCommaDelimitedString(argTypes);</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">        mbd.getResourceDescription(), beanName,</span><br><span class="line"><span class="string">&quot;No matching factory method found: &quot;</span> +                              </span><br><span class="line">        (mbd.getFactoryBeanName() != <span class="keyword">null</span> ?</span><br><span class="line">         <span class="string">&quot;factory bean &#x27;&quot;</span> + mbd.getFactoryBeanName() + <span class="string">&quot;&#x27;; &quot;</span> : <span class="string">&quot;&quot;</span>) +</span><br><span class="line">        <span class="string">&quot;factory method &#x27;&quot;</span> + mbd.getFactoryMethodName() + </span><br><span class="line">        <span class="string">&quot;(&quot;</span> + argDesc + <span class="string">&quot;)&#x27;. &quot;</span> +</span><br><span class="line">        <span class="string">&quot;Check that a method with the specified name &quot;</span> +</span><br><span class="line">(minNrOfArgs &gt; <span class="number">0</span> ? <span class="string">&quot;and arguments &quot;</span> : <span class="string">&quot;&quot;</span>) +                              </span><br><span class="line">        <span class="string">&quot;exists and that it is &quot;</span> +</span><br><span class="line">        (isStatic ? <span class="string">&quot;static&quot;</span> : <span class="string">&quot;non-static&quot;</span>) + <span class="string">&quot;.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">void</span>.class == factoryMethodToUse.getReturnType()) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">        mbd.getResourceDescription(), beanName,</span><br><span class="line">        <span class="string">&quot;Invalid factory method &#x27;&quot;</span> + mbd.getFactoryMethodName() +</span><br><span class="line">        <span class="string">&quot;&#x27;: needs to have a non-void return type!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (ambiguousFactoryMethods != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">        mbd.getResourceDescription(), beanName,</span><br><span class="line">        <span class="string">&quot;Ambiguous factory method matches found in bean &#x27;&quot;</span> </span><br><span class="line">        + beanName + <span class="string">&quot;&#x27; &quot;</span> +</span><br><span class="line">        <span class="string">&quot;(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): &quot;</span> +</span><br><span class="line">        ambiguousFactoryMethods);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (explicitArgs == <span class="keyword">null</span> &amp;&amp; argsHolderToUse != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 将解析的构造函数加入缓存</span></span><br><span class="line">      argsHolderToUse.storeCache(mbd, factoryMethodToUse);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 实例化 bean</span></span><br><span class="line">    Object beanInstance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">final</span> Object fb = factoryBean;</span><br><span class="line">      <span class="keyword">final</span> Method factoryMethod = factoryMethodToUse;</span><br><span class="line">      <span class="keyword">final</span> Object[] args = argsToUse;</span><br><span class="line">      <span class="comment">// 通过执行工厂方法来创建bean示例</span></span><br><span class="line">      beanInstance = AccessController.doPrivileged(</span><br><span class="line">        (PrivilegedAction&lt;Object&gt;) () -&gt;      </span><br><span class="line">        beanFactory.getInstantiationStrategy()</span><br><span class="line">        .instantiate(</span><br><span class="line">          mbd, beanName, beanFactory, fb, factoryMethod, args),</span><br><span class="line">        beanFactory.getAccessControlContext());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 通过执行工厂方法来创建bean示例</span></span><br><span class="line">      beanInstance = <span class="keyword">this</span>.beanFactory.getInstantiationStrategy().instantiate(</span><br><span class="line">        mbd, beanName, <span class="keyword">this</span>.beanFactory, factoryBean, factoryMethodToUse, argsToUse);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 包装为 BeanWraper 对象</span></span><br><span class="line">    bw.setBeanInstance(beanInstance);</span><br><span class="line">    <span class="keyword">return</span> bw;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">      mbd.getResourceDescription(), beanName,</span><br><span class="line"><span class="string">&quot;Bean instantiation via factory method failed&quot;</span>, ex);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>instantiateUsingFactoryMethod()</code> 方法体实在是太大了，处理细节感觉很复杂，中间断断续续的。吐槽这里的代码风格，完全不符合我们前面看的 Spring 代码风格。Spring 的一贯做法是将一个复杂逻辑进行拆分，分为多个细小的模块进行嵌套，每个模块负责一部分功能，模块与模块之间层层嵌套，上一层一般都是对下一层的总结和概括，这样就会使得每一层的逻辑变得清晰易懂。 回归到上面的方法体，虽然代码体量大，但是总体我们还是可看清楚这个方法要做的事情。</p><blockquote><p>一句话概括就是：确定工厂对象，然后获取构造函数和构造参数，最后调用 InstantiationStrategy 对象的 <code>instantiate()</code> 来创建 bean 实例。</p></blockquote><p>下面我们就这个句概括的话进行拆分并详细说明。 </p><ul><li><p><strong>确定工厂对象</strong>首先获取工厂方法名，若工厂方法名不为空，则调用 <code>beanFactory.getBean()</code> 获取工厂对象，若为空，则可能为一个静态工厂，对于静态工厂则必须提供工厂类的全类名，同时设置 <code>factoryBean = null</code> </p></li><li><p><strong>构造参数确认</strong> 工厂对象确定后，则是确认构造参数。构造参数的确认主要分为三种情况：explicitArgs 参数、缓存中获取、配置文件中解析。 </p><ul><li><p><strong>explicitArgs 参数</strong> explicitArgs 参数是我们调用 <code>getBean()</code> 时传递景来，一般该参数，该参数就是用于初始化 bean 时所传递的参数，如果该参数不为空，则可以确定构造函数的参数就是它了。</p></li><li><p> <strong>缓存中获取</strong> 在该方法的最后，我们会发现这样一段代码：<code>argsHolderToUse.storeCache(mbd, factoryMethodToUse)</code> ，这段代码主要是将构造函数、构造参数保存到缓存中，如下：</p></li></ul>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">storeCache</span><span class="params">(RootBeanDefinition mbd, Executable constructorOrFactoryMethod)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">synchronized</span> (mbd.constructorArgumentLock) &#123;</span><br><span class="line">    mbd.resolvedConstructorOrFactoryMethod = constructorOrFactoryMethod;</span><br><span class="line">    mbd.constructorArgumentsResolved = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.resolveNecessary) &#123;</span><br><span class="line">      mbd.preparedConstructorArguments = <span class="keyword">this</span>.preparedArguments;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      mbd.resolvedConstructorArguments = <span class="keyword">this</span>.arguments;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  其中涉及到的几个参数 constructorArgumentLock、resolvedConstructorOrFactoryMethod、constructorArgumentsResolved、resolvedConstructorArguments。这些参数都是跟构造函数、构造函数缓存有关的。</p><ul><li><p>constructorArgumentLock：构造函数的缓存锁</p></li><li><p>resolvedConstructorOrFactoryMethod：缓存已经解析的构造函数或者工厂方法</p></li><li><p>constructorArgumentsResolved：标记字段，标记构造函数、参数已经解析了。默认为false</p></li><li><p>resolvedConstructorArguments：缓存已经解析的构造函数参数，包可见字段</p></li></ul><p>所以从缓存中获取就是提取这几个参数的值，如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (mbd.constructorArgumentLock) &#123;</span><br><span class="line">    <span class="comment">// 获取缓存中的构造函数或者工厂方法</span></span><br><span class="line">    factoryMethodToUse = (Method) mbd.resolvedConstructorOrFactoryMethod;</span><br><span class="line">    <span class="keyword">if</span> (factoryMethodToUse != <span class="keyword">null</span> &amp;&amp; mbd.constructorArgumentsResolved) &#123;</span><br><span class="line">      <span class="comment">// 获取缓存中的构造参数</span></span><br><span class="line">      argsToUse = mbd.resolvedConstructorArguments;</span><br><span class="line">      <span class="keyword">if</span> (argsToUse == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 获取缓存中的构造函数参数的包可见字段</span></span><br><span class="line">        argsToResolve = mbd.preparedConstructorArguments;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>如果缓存中存在构造参数，则需要调用 <code>resolvePreparedArguments()</code> 方法进行转换，因为缓存中的值有可能是最终值也有可能不是最终值，比如我们构造函数中的类型为 Integer 类型的 1 ，但是原始的参数类型有可能是 String 类型的 1 ，所以即便是从缓存中得到了构造参数也需要经过一番的类型转换确保参数类型完全对应。 <strong>配置文件中解析</strong> 即没有通过传递参数的方式传递构造参数，缓存中也没有，那就只能通过解析配置文件获取构造参数了。 在 bean 解析类的博文中我们了解了，配置文件中的信息都会转换到 BeanDefinition 实例对象中，所以配置文件中的参数可以直接通过 BeanDefinition 对象获取。代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (mbd.hasConstructorArgumentValues()) &#123;</span><br><span class="line">    <span class="comment">// 构造函数的参数</span></span><br><span class="line">    ConstructorArgumentValues cargs = mbd.getConstructorArgumentValues();</span><br><span class="line">    resolvedValues = <span class="keyword">new</span> ConstructorArgumentValues();</span><br><span class="line">    <span class="comment">// 解析构造函数的参数</span></span><br><span class="line">    <span class="comment">// 将该 bean 的构造函数参数解析为 resolvedValues 对象，其中会涉及到其他 bean</span></span><br><span class="line">    minNrOfArgs = resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 BeanDefinition 的 <code>getConstructorArgumentValues()</code> 就可以获取构造信息了，有了构造信息就可以获取相关的参数值信息了，获取的参数信息包括直接值和引用，这一步骤的处理交由 <code>resolveConstructorArguments()</code> 完成，该方法会将构造参数信息解析为 resolvedValues 对象 并返回解析到的参数个数。 </p><ul><li><p><strong>构造函数</strong> 确定构造参数后，下一步则是确定构造函数。第一步则是通过 <code>getCandidateMethods()</code> 获取所有的构造方法，同时对构造方法进行刷选，然后在对其进行排序处理（<code>AutowireUtils.sortFactoryMethods(candidates)</code>），排序的主要目的是为了能够更加方便的找到匹配的构造函数，因为构造函数的确认是根据参数个数确认的。</p><p>排序的规则是：public 构造函数优先参数数量降序、非 public 构造参数数量降序。 通过迭代 candidates（包含了所有要匹配的构造函数）的方式，一次比较其参数，如果显示提供了参数（explicitArgs != null），则直接比较两者是否相等，如果相等则表示找到了，否则继续比较。</p><p>如果没有显示提供参数，则需要获取 ParameterNameDiscoverer 对象，该对象为参数名称探测器，主要用于发现方法和构造函数的参数名称。 将参数包装成 ArgumentsHolder 对象，该对象用于保存参数，我们称之为参数持有者。当将对象包装成 ArgumentsHolder 对象后，我们就可以通过它来进行构造函数匹配，匹配分为严格模式和宽松模式。</p><ul><li>严格模式：解析构造函数时，必须所有参数都需要匹配，否则抛出异常</li><li>宽松模式：使用具有”最接近的模式”进行匹配</li></ul></li></ul><p>判断的依据是根据 BeanDefinition 的 isLenientConstructorResolution 属性（该参数是我们在构造 AbstractBeanDefinition 对象是传递的）来获取类型差异权重（typeDiffWeight） 的。如果 <code>typeDiffWeight &lt; minTypeDiffWeight</code> ，则代表“最接近的模式”，选择其作为构造函数，否则只有两者具有相同的参数数量且类型差异权重相等才会纳入考虑范围。 至此，构造函数已经确认了。 </p><ul><li><strong>创建 bean 实例</strong> 工厂对象、构造函数、构造参数都已经确认了，则最后一步就是调用 InstantiationStrategy 对象的 <code>instantiate()</code> 来创建 bean 实例，如下：</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">instantiate</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  RootBeanDefinition bd, <span class="meta">@Nullable</span> String beanName, BeanFactory owner,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="meta">@Nullable</span> Object factoryBean, <span class="keyword">final</span> Method factoryMethod, <span class="meta">@Nullable</span> Object... args)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">      AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; &#123;</span><br><span class="line">        ReflectionUtils.makeAccessible(factoryMethod);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      ReflectionUtils.makeAccessible(factoryMethod);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Method priorInvokedFactoryMethod = currentlyInvokedFactoryMethod.get();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      currentlyInvokedFactoryMethod.set(factoryMethod);</span><br><span class="line">      <span class="comment">// 执行工厂方法，并返回实例</span></span><br><span class="line">      Object result = factoryMethod.invoke(factoryBean, args);</span><br><span class="line">      <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line">        result = <span class="keyword">new</span> NullBean();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (priorInvokedFactoryMethod != <span class="keyword">null</span>) &#123;</span><br><span class="line">        currentlyInvokedFactoryMethod.set(priorInvokedFactoryMethod);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        currentlyInvokedFactoryMethod.remove();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 省略一波 catch</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>instantiate()</code> 最核心的部分就是利用 Java 反射执行工厂方法并返回创建好的实例，也就是这段代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Object result &#x3D; factoryMethod.invoke(factoryBean, args);</span><br></pre></td></tr></table></figure><p>到这里 <code>instantiateUsingFactoryMethod()</code> 已经分析完毕了。</p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
          <category> 《Spring源码分析》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> 转载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IOC之开启Bean的实例化进程</title>
      <link href="/blog/2020/01/19/1ad7c22b.html"/>
      <url>/blog/2020/01/19/1ad7c22b.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文作者：chenssy</p><p>出处：<a href="http://cmsblogs.com/?p=2846">http://cmsblogs.com/?p=2846</a></p><p>在学习<code>Spring源码</code>的过程中发现的好站+好贴，感谢作者。Spring版本：<strong>Spring 5.0.6.RELEASE</strong></p></blockquote><p>在上篇博客<a href="/2020/01/18/13d2205c.html">IOC 之 分析各 scope 的 bean 创建</a>中有一个核心方法没有讲到 <code>createBean()</code> ，该方法的如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> Object <span class="title">createBean</span><span class="params">(String beanName, RootBeanDefinition mbd, <span class="meta">@Nullable</span> Object[] args)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> BeanCreationException</span>;</span><br></pre></td></tr></table></figure><p>该方法定义在 AbstractBeanFactory 中。其含义是根据给定的 BeanDefinition 和 args实例化一个 bean 对象，如果该 BeanDefinition 存在父类，则该 BeanDefinition 已经合并了父类的属性。所有 Bean 实例的创建都会委托给该方法实现。 方法接受三个参数：</p><ul><li>beanName：bean 的名字</li><li>mbd：已经合并了父类属性的（如果有的话）BeanDefinition</li><li>args：用于构造函数或者工厂方法创建 bean 实例对象的参数</li></ul><p>该抽象方法的默认实现是在类 AbstractAutowireCapableBeanFactory 中实现，如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">createBean</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  String beanName, </span></span></span><br><span class="line"><span class="function"><span class="params">  RootBeanDefinition mbd, <span class="meta">@Nullable</span> Object[] args)</span></span></span><br><span class="line"><span class="function">  <span class="keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">    logger.debug(<span class="string">&quot;Creating instance of bean &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  RootBeanDefinition mbdToUse = mbd;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 确保此时的 bean 已经被解析了</span></span><br><span class="line">  <span class="comment">// 如果获取的class 属性不为null，则克隆该 BeanDefinition</span></span><br><span class="line">  <span class="comment">// 主要是因为该动态解析的 class 无法保存到到共享的 BeanDefinition</span></span><br><span class="line">  Class&lt;?&gt; resolvedClass = resolveBeanClass(mbd, beanName);</span><br><span class="line">  <span class="keyword">if</span> (resolvedClass != <span class="keyword">null</span> &amp;&amp; !mbd.hasBeanClass() </span><br><span class="line">      &amp;&amp; mbd.getBeanClassName() != <span class="keyword">null</span>) &#123;</span><br><span class="line">    mbdToUse = <span class="keyword">new</span> RootBeanDefinition(mbd);</span><br><span class="line">    mbdToUse.setBeanClass(resolvedClass);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 验证和准备覆盖方法</span></span><br><span class="line">    mbdToUse.prepareMethodOverrides();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (BeanDefinitionValidationException ex) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(mbdToUse.getResourceDescription(),</span><br><span class="line">                                           beanName, <span class="string">&quot;Validation of method overrides failed&quot;</span>, ex);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 给 BeanPostProcessors 一个机会用来返回一个代理类而不是真正的类实例</span></span><br><span class="line">    <span class="comment">// AOP 的功能就是基于这个地方</span></span><br><span class="line">    Object bean = resolveBeforeInstantiation(beanName, mbdToUse);</span><br><span class="line">    <span class="keyword">if</span> (bean != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbdToUse.getResourceDescription(), beanName,</span><br><span class="line">                                    <span class="string">&quot;BeanPostProcessor before instantiation of bean failed&quot;</span>, ex);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 执行真正创建 bean 的过程</span></span><br><span class="line">    Object beanInstance = doCreateBean(beanName, mbdToUse, args);</span><br><span class="line">    <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">      logger.debug(<span class="string">&quot;Finished creating instance of bean &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> beanInstance;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (BeanCreationException | ImplicitlyAppearedSingletonException ex) &#123;</span><br><span class="line">    <span class="keyword">throw</span> ex;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">      mbdToUse.getResourceDescription(), </span><br><span class="line">      beanName, <span class="string">&quot;Unexpected exception during bean creation&quot;</span>, ex);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>过程如下：</p><ul><li>解析指定 BeanDefinition 的 class</li><li>处理 override 属性</li><li>实例化的前置处理</li><li>创建 bean</li></ul><p><strong>解析指定 BeanDefinition 的 class</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class&lt;?&gt; resolvedClass = resolveBeanClass(mbd, beanName)</span><br></pre></td></tr></table></figure><p>这个方法主要是解析 bean definition 的 class 类，并将已经解析的 Class 存储在 bean definition 中以供后面使用。如果解析的 class 不为空，则会将该 BeanDefinition 进行克隆至 mbdToUse，这样做的主要目的是以为动态解析的 class 是无法保存到共享的 BeanDefinition 中。 <strong>处理 override 属性</strong>大家还记得 lookup-method 和 replace-method 这两个配置功能？在博客 <a href="http://cmsblogs.com/?p=2846">【死磕 Spring】—– IOC 之解析Bean：解析 bean 标签（三）</a> 中已经详细分析了这两个标签的用法和解析过程，知道解析过程其实就是讲这两个配置存放在 BeanDefinition 中的 methodOverrides 属性中，我们知道在 bean 实例化的过程中如果检测到存在 methodOverrides，则会动态地位为当前 bean 生成代理并使用对应的拦截器为 bean 做增强处理。具体的实现我们后续分析，现在先看 <code>mbdToUse.prepareMethodOverrides()</code> 都干了些什么事，如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">prepareMethodOverrides</span><span class="params">()</span> <span class="keyword">throws</span> BeanDefinitionValidationException </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (hasMethodOverrides()) &#123;</span><br><span class="line">    Set&lt;MethodOverride&gt; overrides = getMethodOverrides().getOverrides();</span><br><span class="line">    <span class="keyword">synchronized</span> (overrides) &#123;</span><br><span class="line">      <span class="keyword">for</span> (MethodOverride mo : overrides) &#123;</span><br><span class="line">        prepareMethodOverride(mo);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果存在 methodOverrides 则获取所有的 override method ，然后通过迭代的方法一次调用 <code>prepareMethodOverride()</code> ，如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">prepareMethodOverride</span><span class="params">(MethodOverride mo)</span> <span class="keyword">throws</span> BeanDefinitionValidationException </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> count = ClassUtils.getMethodCountForName(getBeanClass(), mo.getMethodName());</span><br><span class="line">  <span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionValidationException(</span><br><span class="line">      <span class="string">&quot;Invalid method override: no method with name &#x27;&quot;</span> + mo.getMethodName() +</span><br><span class="line">      <span class="string">&quot;&#x27; on class [&quot;</span> + getBeanClassName() + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (count == <span class="number">1</span>) &#123;</span><br><span class="line">    mo.setOverloaded(<span class="keyword">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据方法名称从 class 中获取该方法名的个数，如果为 0 则抛出异常，如果 为 1 则设置该重载方法没有被重载。若一个类中存在多个重载方法，则在方法调用的时候还需要根据参数类型来判断到底重载的是哪个方法。在设置重载的时候其实这里做了一个小小优化，那就是当 <code>count == 1</code> 时，设置 <code>overloaded = false</code>，这样表示该方法没有重载，这样在后续调用的时候便可以直接找到方法而不需要进行方法参数的校验。 诚然，其实 <code>mbdToUse.prepareMethodOverrides()</code> 并没有做什么实质性的工作，只是对 methodOverrides 属性做了一些简单的校验而已。 <strong>实例化的前置处理</strong> <code>resolveBeforeInstantiation()</code> 的作用是给 BeanPostProcessors 后置处理器返回一个代理对象的机会，其实在调用该方法之前 Spring 一直都没有创建 bean ，那么这里返回一个 bean 的代理类有什么作用呢？作用体现在后面的 <code>if</code> 判断：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (bean != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果代理对象不为空，则直接返回代理对象，这一步骤有非常重要的作用，Spring 后续实现 AOP 就是基于这个地方判断的。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">resolveBeforeInstantiation</span><span class="params">(String beanName, RootBeanDefinition mbd)</span> </span>&#123;</span><br><span class="line">  Object bean = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">if</span> (!Boolean.FALSE.equals(mbd.beforeInstantiationResolved)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) &#123;</span><br><span class="line">      Class&lt;?&gt; targetType = determineTargetType(beanName, mbd);</span><br><span class="line">      <span class="keyword">if</span> (targetType != <span class="keyword">null</span>) &#123;</span><br><span class="line">        bean = applyBeanPostProcessorsBeforeInstantiation(targetType, beanName);</span><br><span class="line">        <span class="keyword">if</span> (bean != <span class="keyword">null</span>) &#123;</span><br><span class="line">          bean = applyBeanPostProcessorsAfterInitialization(bean, beanName);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    mbd.beforeInstantiationResolved = (bean != <span class="keyword">null</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法核心就在于 <code>applyBeanPostProcessorsBeforeInstantiation()</code> 和 <code>applyBeanPostProcessorsAfterInitialization()</code> 两个方法，before 为实例化前的后处理器应用，after 为实例化后的后处理器应用，由于本文的主题是创建 bean，关于 Bean 的增强处理后续 LZ 会单独出博文来做详细说明。 <strong>创建 bean</strong> 如果没有代理对象，就只能走常规的路线进行 bean 的创建了，该过程有 <code>doCreateBean()</code> 实现，如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">doCreateBean</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">final</span> String beanName, <span class="keyword">final</span> RootBeanDefinition mbd, <span class="keyword">final</span> <span class="meta">@Nullable</span> Object[] args)</span></span></span><br><span class="line"><span class="function">  <span class="keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// BeanWrapper是对Bean的包装，其接口中所定义的功能很简单包括设置获取被包装的对象，</span></span><br><span class="line">  <span class="comment">// 获取被包装bean的属性描述器</span></span><br><span class="line">  BeanWrapper instanceWrapper = <span class="keyword">null</span>;</span><br><span class="line">  <span class="comment">// 单例模型，则从未完成的 FactoryBean 缓存中删除</span></span><br><span class="line">  <span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">    anceWrapper = <span class="keyword">this</span>.factoryBeanInstanceCache.remove(beanName);   </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 使用合适的实例化策略来创建新的实例：工厂方法、构造函数自动注入、简单初始化</span></span><br><span class="line">  <span class="keyword">if</span> (instanceWrapper == <span class="keyword">null</span>) &#123;</span><br><span class="line">    instanceWrapper = createBeanInstance(beanName, mbd, args);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 包装的实例对象</span></span><br><span class="line">  <span class="keyword">final</span> Object bean = instanceWrapper.getWrappedInstance();</span><br><span class="line">  <span class="comment">// 包装的实例对象的类型</span></span><br><span class="line">  Class&lt;?&gt; beanType = instanceWrapper.getWrappedClass();</span><br><span class="line">  <span class="keyword">if</span> (beanType != NullBean.class) &#123;</span><br><span class="line">    mbd.resolvedTargetType = beanType;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 检测是否有后置处理</span></span><br><span class="line">  <span class="comment">// 如果有后置处理，则允许后置处理修改 BeanDefinition</span></span><br><span class="line">  <span class="keyword">synchronized</span> (mbd.postProcessingLock) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!mbd.postProcessed) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// applyMergedBeanDefinitionPostProcessors</span></span><br><span class="line">        <span class="comment">// 后置处理修改 BeanDefinition</span></span><br><span class="line">        applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">          mbd.getResourceDescription(), </span><br><span class="line">          beanName,</span><br><span class="line">          <span class="string">&quot;Post-processing of merged bean definition failed&quot;</span>, ex);</span><br><span class="line">      &#125;</span><br><span class="line">      mbd.postProcessed = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 解决单例模式的循环依赖</span></span><br><span class="line">  <span class="comment">// 单例模式 &amp; 运行循环依赖&amp;当前单例 bean 是否正在被创建</span></span><br><span class="line">  <span class="keyword">boolean</span> earlySingletonExposure = </span><br><span class="line">    (mbd.isSingleton() &amp;&amp; <span class="keyword">this</span>.allowCircularReferences &amp;&amp;</span><br><span class="line">                                    isSingletonCurrentlyInCreation(beanName));</span><br><span class="line">  <span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">    <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">      logger.debug(<span class="string">&quot;Eagerly caching bean &#x27;&quot;</span> + beanName +</span><br><span class="line">                   <span class="string">&quot;&#x27; to allow for resolving potential circular references&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 提前将创建的 bean 实例加入到ectFactory 中</span></span><br><span class="line">    <span class="comment">// 这里是为了后期避免循环依赖</span></span><br><span class="line">    addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 开始初始化 bean 实例对象</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">  Object exposedObject = bean;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 对 bean 进行填充，将各个属性值注入，其中，可能存在依赖于其他 bean 的属性</span></span><br><span class="line">    <span class="comment">// 则会递归初始依赖 bean</span></span><br><span class="line">    populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line">    <span class="comment">// 调用初始化方法</span></span><br><span class="line">    exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">    <span class="keyword">if</span> (ex <span class="keyword">instanceof</span> BeanCreationException &amp;&amp; beanName.equals(((BeanCreationException) ex).getBeanName())) &#123;</span><br><span class="line">      <span class="keyword">throw</span> (BeanCreationException) ex;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">        mbd.getResourceDescription(), beanName, <span class="string">&quot;Initialization of bean failed&quot;</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 循环依赖处理</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">  <span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">    <span class="comment">// 获取 earlySingletonReference</span></span><br><span class="line">    Object earlySingletonReference = getSingleton(beanName, <span class="keyword">false</span>);</span><br><span class="line">    <span class="comment">// 只有在存在循环依赖的情况下，earlySingletonReference 才不会为空</span></span><br><span class="line">    <span class="keyword">if</span> (earlySingletonReference != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 如果 exposedObject 没有在初始化方法中被改变，也就是没有被增强</span></span><br><span class="line">      <span class="keyword">if</span> (exposedObject == bean) &#123;</span><br><span class="line">        exposedObject = earlySingletonReference;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 处理依赖</span></span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="keyword">this</span>.allowRawInjectionDespiteWrapping &amp;&amp; hasDependentBean(beanName)) &#123;</span><br><span class="line">        String[] dependentBeans = getDependentBeans(beanName);</span><br><span class="line">        Set&lt;String&gt; actualDependentBeans = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(dependentBeans.length);</span><br><span class="line">        <span class="keyword">for</span> (String dependentBean : dependentBeans) &#123;</span><br><span class="line">          <span class="keyword">if</span> (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) &#123;</span><br><span class="line">            actualDependentBeans.add(dependentBean);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!actualDependentBeans.isEmpty()) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> BeanCurrentlyInCreationException(</span><br><span class="line">            beanName,</span><br><span class="line">            <span class="string">&quot;Bean with name &#x27;&quot;</span> + beanName + </span><br><span class="line">            <span class="string">&quot;&#x27; has been injected into other beans [&quot;</span> +</span><br><span class="line">            StringUtils.collectionToCommaDelimitedString(actualDependentBeans) +                                         </span><br><span class="line">            <span class="string">&quot;] in its raw version as part of a circular reference, but has eventually been &quot;</span> +<span class="string">&quot;wrapped. This means that said other beans do not use the final version of the &quot;</span> +</span><br><span class="line">            <span class="string">&quot;bean. This is often the result of over-eager type matching - consider using &quot;</span> +</span><br><span class="line">            <span class="string">&quot;&#x27;getBeanNamesOfType&#x27; with the &#x27;allowEagerInit&#x27; flag turned off, for example.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 注册 bean</span></span><br><span class="line">    registerDisposableBeanIfNecessary(beanName, bean, mbd);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (BeanDefinitionValidationException ex) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">      mbd.getResourceDescription(), beanName, <span class="string">&quot;Invalid destruction signature&quot;</span>, ex);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> exposedObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整体的思路：</p><ol><li>如果是单例模式，则清除 factoryBeanInstanceCache 缓存，同时返回 BeanWrapper 实例对象，当然如果存在。</li><li>如果缓存中没有 BeanWrapper 或者不是单例模式，则调用 <code>createBeanInstance()</code> 实例化 bean，主要是将 BeanDefinition 转换为 BeanWrapper</li></ol><ul><li>MergedBeanDefinitionPostProcessor 的应用 </li><li>单例模式的循环依赖处理 </li><li>调用 <code>populateBean()</code> 进行属性填充。将所有属性填充至 bean 的实例中 </li><li>调用 <code>initializeBean()</code> 初始化 bean </li><li>依赖检查 </li><li>注册 DisposableBean <code>doCreateBean()</code> 完成 bean 的创建和初始化工作，内容太多，这里就只列出整体思路，下文开始将该方法进行拆分进行详细讲解，分布从以下几个方面进行阐述：<ul><li><code>createBeanInstance()</code> 实例化 bean</li><li><code>populateBean()</code> 属性填充</li><li>循环依赖的处理</li><li><code>initializeBean()</code> 初始化 bean</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
          <category> 《Spring源码分析》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> 转载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IOC之分析各scope的bean创建</title>
      <link href="/blog/2020/01/18/13d2205c.html"/>
      <url>/blog/2020/01/18/13d2205c.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文作者：chenssy</p><p>出处：<a href="http://cmsblogs.com/?p=2839">http://cmsblogs.com/?p=2839</a></p><p>在学习<code>Spring源码</code>的过程中发现的好站+好贴，感谢作者。Spring版本：<strong>Spring 5.0.6.RELEASE</strong></p></blockquote><p><strong>singleton</strong> Spring 的 scope 默认为 singleton，其初始化的代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">  sharedInstance = getSingleton(beanName, () -&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">      destroySingleton(beanName);</span><br><span class="line">      <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一部分分析了从缓存中获取单例模式的 bean，但是如果缓存中不存在呢？</p><p>则需要从头开始加载 bean，这个过程由 <code>getSingleton()</code> 实现。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getSingleton</span><span class="params">(String beanName, ObjectFactory&lt;?&gt; singletonFactory)</span> </span>&#123;</span><br><span class="line">  Assert.notNull(beanName, <span class="string">&quot;Bean name must not be null&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 全局加锁</span></span><br><span class="line">  <span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonObjects) &#123;</span><br><span class="line">    <span class="comment">// 从缓存中检查一遍</span></span><br><span class="line">    <span class="comment">// 因为 singleton 模式其实就是复用已经创建的 bean 所以这步骤必须检查</span></span><br><span class="line">    Object singletonObject = <span class="keyword">this</span>.singletonObjects.get(beanName);</span><br><span class="line">    <span class="comment">//  为空，开始加载过程</span></span><br><span class="line">    <span class="keyword">if</span> (singletonObject == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 省略 部分代码</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// 加载前置处理</span></span><br><span class="line">      beforeSingletonCreation(beanName);</span><br><span class="line">      <span class="keyword">boolean</span> newSingleton = <span class="keyword">false</span>;</span><br><span class="line">      <span class="comment">// 省略代码</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 初始化 bean</span></span><br><span class="line">        <span class="comment">// 这个过程其实是调用 createBean() 方法</span></span><br><span class="line">        singletonObject = singletonFactory.getObject();</span><br><span class="line">        newSingleton = <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 省略 catch 部分</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="comment">// 后置处理</span></span><br><span class="line">      afterSingletonCreation(beanName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 加入缓存中</span></span><br><span class="line">    <span class="keyword">if</span> (newSingleton) &#123;</span><br><span class="line">      addSingleton(beanName, singletonObject);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 直接返回</span></span><br><span class="line">  <span class="keyword">return</span> singletonObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实这个过程并没有真正创建 bean，仅仅只是做了一部分准备和预处理步骤，真正获取单例 bean 的方法其实是由 <code>singletonFactory.getObject()</code> 这部分实现，而 singletonFactory 由回调方法产生。</p><p><em>那么这个方法做了哪些准备呢？</em></p><ol><li>再次检查缓存是否已经加载过，如果已经加载了则直接返回，否则开始加载过程。</li><li>调用 <code>beforeSingletonCreation()</code> 记录加载单例 bean 之前的加载状态，即前置处理。</li><li>调用参数传递的 ObjectFactory 的 <code>getObject()</code> 实例化 bean。</li><li>调用 <code>afterSingletonCreation()</code> 进行加载单例后的后置处理。</li><li>将结果记录并加入值缓存中，同时删除加载 bean 过程中所记录的一些辅助状态。</li></ol><p>流程中涉及的三个方法 <code>beforeSingletonCreation()</code> 与 <code>afterSingletonCreation()</code> 在博客 <a href="/archives/c9c155de.html">IOC 之 缓存中获取单例 bean </a>中分析过了，所以这里不再阐述了，我们看另外一个方法 <code>addSingleton()</code>。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">addSingleton</span><span class="params">(String beanName, Object singletonObject)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonObjects) &#123;</span><br><span class="line">    <span class="keyword">this</span>.singletonObjects.put(beanName, singletonObject);</span><br><span class="line">    <span class="keyword">this</span>.singletonFactories.remove(beanName);</span><br><span class="line">    <span class="keyword">this</span>.earlySingletonObjects.remove(beanName);</span><br><span class="line">    <span class="keyword">this</span>.registeredSingletons.add(beanName);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个 put、一个 add、两个 remove。</p><ul><li><p><code>singletonObjects</code> 单例 bean 的缓存</p></li><li><p><code>singletonFactories</code> 单例 bean Factory 的缓存</p></li><li><p><code>earlySingletonObjects</code> “早期”创建的单例 bean 的缓存</p></li><li><p><code>registeredSingletons</code> 已经注册的单例缓存。 </p></li></ul><p>加载了单例 bean 后，调用 <code>getObjectForBeanInstance()</code> 从 bean 实例中获取对象。该方法已经在 <a href="/2020/01/16/c9c155de.html">IOC 之 缓存中获取单例 bean </a> 详细分析了。 </p><p><strong>原型模式</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (mbd.isPrototype()) &#123;</span><br><span class="line">  Object prototypeInstance = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    beforePrototypeCreation(beanName);</span><br><span class="line">    prototypeInstance = createBean(beanName, mbd, args);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">finally</span> &#123;</span><br><span class="line">    afterPrototypeCreation(beanName);</span><br><span class="line">  &#125;</span><br><span class="line">  bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原型模式的初始化过程很简单：<strong>直接创建一个新的实例就可以了。</strong></p><p>过程如下：</p><ol><li>调用 <code>beforeSingletonCreation()</code> 记录加载原型模式 bean 之前的加载状态，即前置处理。</li><li>调用 <code>createBean()</code> 创建一个 bean 实例对象。</li><li>调用 <code>afterSingletonCreation()</code> 进行加载原型模式 bean 后的后置处理。</li><li>调用 <code>getObjectForBeanInstance()</code> 从 bean 实例中获取对象。</li></ol><p><strong>其他作用域</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String scopeName = mbd.getScope();</span><br><span class="line"><span class="keyword">final</span> Scope scope = <span class="keyword">this</span>.scopes.get(scopeName);</span><br><span class="line"><span class="keyword">if</span> (scope == <span class="keyword">null</span>) &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">    <span class="string">&quot;No Scope registered for scope name &#x27;&quot;</span> + scopeName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  Object scopedInstance = scope.get(beanName, () -&gt; &#123;</span><br><span class="line">    beforePrototypeCreation(beanName);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">      afterPrototypeCreation(beanName);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (IllegalStateException ex) &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">    beanName,</span><br><span class="line">    <span class="string">&quot;Scope &#x27;&quot;</span> + scopeName + </span><br><span class="line">    <span class="string">&quot;&#x27; is not active for the current thread; consider &quot;</span> </span><br><span class="line">    + <span class="string">&quot;defining a scoped proxy for this bean if you intend to refer to it from a singleton&quot;</span>,</span><br><span class="line">     ex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>核心流程和原型模式一样，只不过获取 bean 实例是由 <code>scope.get()</code> 实现，如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">(String name, ObjectFactory&lt;?&gt; objectFactory)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 获取 scope 缓存</span></span><br><span class="line">  Map&lt;String, Object&gt; scope = <span class="keyword">this</span>.threadScope.get();</span><br><span class="line">  Object scopedObject = scope.get(name);</span><br><span class="line">  <span class="keyword">if</span> (scopedObject == <span class="keyword">null</span>) &#123;</span><br><span class="line">    scopedObject = objectFactory.getObject();</span><br><span class="line">    <span class="comment">// 加入缓存</span></span><br><span class="line">    scope.put(name, scopedObject);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> scopedObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于上面三个模块，其中最重要的有两个方法： <code>createBean() </code>和<code>getObjectForBeanInstance()</code>。</p><p>这两个方法在上面三个模块都有调用，<code>createBean()</code> 后续详细说明，<code>getObjectForBeanInstance()</code> 在博客<a href="/archives/c9c155de.html">IOC 之 缓存中获取单例 bean </a> 中有详细讲解，这里再次阐述下（此段内容来自《Spring 源码深度解析》）：<strong>这个方法主要是验证以下我们得到的 bean 的正确性，其实就是检测当前 bean 是否是 FactoryBean 类型的 bean，如果是，那么需要调用该 bean 对应的 FactoryBean 实例的 <code>getObject()</code> 作为返回值。无论是从缓存中获得到的 bean 还是通过不同的 scope 策略加载的 bean 都只是最原始的 bean 状态，并不一定就是我们最终想要的 bean。</strong></p><p>举个例子，加入我们需要对工厂 bean 进行处理，那么这里得到的其实是工厂 bean 的初始状态，但是我们真正需要的是工厂 bean 中定义 factory-method 方法中返回的 bean，而 <code>getObjectForBeanInstance()</code> 就是完成这个工作的。</p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
          <category> 《Spring源码分析》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> 死磕Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IOC之parentBeanFactory与依赖处理</title>
      <link href="/blog/2020/01/17/c4a8e2a2.html"/>
      <url>/blog/2020/01/17/c4a8e2a2.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文作者：chenssy</p><p>出处：<a href="http://cmsblogs.com/?p=2810">http://cmsblogs.com/?p=2810</a></p><p>在学习<code>Spring源码</code>的过程中发现的好站+好贴，感谢作者。Spring版本：<strong>Spring 5.0.6.RELEASE</strong></p></blockquote><p>继上篇博客 <a href="/2020/01/16/c9c155de.html"> 加载 bean 之 缓存中获取单例 bean</a>,如果从单例缓存中没有获取到单例 bean，则说明两种情况：</p><ol><li>该 bean 的 scope 不是 singleton</li><li>该 bean 的 scope 是 singleton ,但是没有初始化完成</li></ol><p>针对这两种情况 Spring 是如何处理的呢？<strong>统一加载并完成初始化！</strong></p><p>这部分内容的篇幅较长，拆分为两部分：</p><p>第一部分主要是一些检测、parentBeanFactory 以及依赖处理。</p><p>第二部分则是各个 scope 的初始化。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (isPrototypeCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> BeanCurrentlyInCreationException(beanName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Check if bean definition exists in this factory.</span></span><br><span class="line">BeanFactory parentBeanFactory = getParentBeanFactory();</span><br><span class="line"><span class="keyword">if</span> (parentBeanFactory != <span class="keyword">null</span> &amp;&amp; !containsBeanDefinition(beanName)) &#123;</span><br><span class="line">  <span class="comment">// Not found -&gt; check parent.</span></span><br><span class="line">  String nameToLookup = originalBeanName(name);</span><br><span class="line">  <span class="keyword">if</span> (parentBeanFactory <span class="keyword">instanceof</span> AbstractBeanFactory) &#123;</span><br><span class="line">    <span class="keyword">return</span> ((AbstractBeanFactory) parentBeanFactory).doGetBean(</span><br><span class="line">      nameToLookup, requiredType, args, typeCheckOnly);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (args != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// Delegation to parent with explicit args.</span></span><br><span class="line">    <span class="keyword">return</span> (T) parentBeanFactory.getBean(nameToLookup, args);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// No args -&gt; delegate to standard getBean method.</span></span><br><span class="line">    <span class="keyword">return</span> parentBeanFactory.getBean(nameToLookup, requiredType);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!typeCheckOnly) &#123;</span><br><span class="line">  markBeanAsCreated(beanName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">final</span> RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line">  checkMergedBeanDefinition(mbd, beanName, args);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Guarantee initialization of beans that the current bean depends on.</span></span><br><span class="line">  String[] dependsOn = mbd.getDependsOn();</span><br><span class="line">  <span class="keyword">if</span> (dependsOn != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (String dep : dependsOn) &#123;</span><br><span class="line">      <span class="keyword">if</span> (isDependent(beanName, dep)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">          mbd.getResourceDescription(), </span><br><span class="line">          beanName,</span><br><span class="line">          <span class="string">&quot;Circular depends-on relationship between &#x27;&quot;</span> </span><br><span class="line">          + beanName + <span class="string">&quot;&#x27; and &#x27;&quot;</span> + dep + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      registerDependentBean(dep, beanName);</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        getBean(dep);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (NoSuchBeanDefinitionException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">          mbd.getResourceDescription(), </span><br><span class="line">          beanName,</span><br><span class="line">          <span class="string">&quot;&#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27; depends on missing bean &#x27;&quot;</span> + dep + <span class="string">&quot;&#x27;&quot;</span>, ex);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 省略很多代码</span></span><br></pre></td></tr></table></figure><p>这段代码主要处理如下几个部分：</p><ol><li>检测。若当前 bean 在创建，则抛出 BeanCurrentlyInCreationException 异常。</li><li>如果 beanDefinitionMap 中不存在 beanName 的 BeanDefinition（即在 Spring bean 初始化过程中没有加载），则尝试从 parentBeanFactory 中加载。</li><li>判断是否为类型检查。</li><li>从 mergedBeanDefinitions 中获取 beanName 对应的 RootBeanDefinition，如果这个 BeanDefinition 是子 Bean 的话，则会合并父类的相关属性。</li><li>依赖处理。</li></ol><p><strong>检测</strong> 在前面就提过，Spring 只解决单例模式下的循环依赖，对于原型模式的循环依赖则是抛出 BeanCurrentlyInCreationException 异常，所以首先检查该 beanName 是否处于原型模式下的循环依赖。如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (isPrototypeCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BeanCurrentlyInCreationException(beanName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用 <code>isPrototypeCurrentlyInCreation()</code> 判断当前 bean 是否正在创建，如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isPrototypeCurrentlyInCreation</span><span class="params">(String beanName)</span> </span>&#123;</span><br><span class="line">  Object curVal = <span class="keyword">this</span>.prototypesCurrentlyInCreation.get();</span><br><span class="line">  <span class="keyword">return</span> (curVal != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">          (curVal.equals(beanName) || </span><br><span class="line">           (curVal <span class="keyword">instanceof</span> Set &amp;&amp; ((Set&lt;?&gt;) curVal).contains(beanName))));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实检测逻辑和单例模式一样，一个“集合”存放着正在创建的 bean，从该集合中进行判断即可，只不过单例模式的“集合”为 Set ，而原型模式的则是 ThreadLocal，prototypesCurrentlyInCreation 定义如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ThreadLocal&lt;Object&gt; prototypesCurrentlyInCreation </span><br><span class="line">  = <span class="keyword">new</span> NamedThreadLocal&lt;&gt;(<span class="string">&quot;Prototype beans currently in creation&quot;</span>);</span><br></pre></td></tr></table></figure><p><strong>检查父类 BeanFactory</strong> 若 containsBeanDefinition 中不存在 beanName 相对应的 BeanDefinition，则从 parentBeanFactory 中获取。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取 parentBeanFactory</span></span><br><span class="line">BeanFactory parentBeanFactory = getParentBeanFactory();</span><br><span class="line"><span class="comment">// parentBeanFactory 不为空且 beanDefinitionMap 中不存该 name 的 BeanDefinition</span></span><br><span class="line"><span class="keyword">if</span> (parentBeanFactory != <span class="keyword">null</span> &amp;&amp; !containsBeanDefinition(beanName)) &#123;</span><br><span class="line">  <span class="comment">// 确定原始 beanName</span></span><br><span class="line">  String nameToLookup = originalBeanName(name);</span><br><span class="line">  <span class="comment">// 若为 AbstractBeanFactory 类型，委托父类处理</span></span><br><span class="line">  <span class="keyword">if</span> (parentBeanFactory <span class="keyword">instanceof</span> AbstractBeanFactory) &#123;</span><br><span class="line">    <span class="keyword">return</span> ((AbstractBeanFactory) parentBeanFactory).doGetBean(</span><br><span class="line">      nameToLookup, requiredType, args, typeCheckOnly);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (args != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 委托给构造函数 getBean() 处理</span></span><br><span class="line">    <span class="keyword">return</span> (T) parentBeanFactory.getBean(nameToLookup, args);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 没有 args，委托给标准的 getBean() 处理</span></span><br><span class="line">    <span class="keyword">return</span> parentBeanFactory.getBean(nameToLookup, requiredType);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整个过程较为简单，都是委托 parentBeanFactory 的 <code>getBean()</code> 进行处理，只不过在获取之前对 name 进行简单的处理，主要是想获取原始的 beanName，如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> String <span class="title">originalBeanName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">  String beanName = transformedBeanName(name);</span><br><span class="line">  <span class="keyword">if</span> (name.startsWith(FACTORY_BEAN_PREFIX)) &#123;</span><br><span class="line">    beanName = FACTORY_BEAN_PREFIX + beanName;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> beanName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>transformedBeanName()</code> 是对 name 进行转换，获取真正的 beanName，因为我们传递的可能是 aliasName（这个过程在博客 <a href="/2020/01/15/27d87789.html"> IOC 之 开启 bean 的加载</a> 中分析 <code>transformedBeanName()</code> 有详细说明），如果 name 是以 “&amp;” 开头的，则加上 “&amp;”，因为在 <code>transformedBeanName()</code> 将 “&amp;” 去掉了，这里补上。 <strong>类型检查</strong> 参数 typeCheckOnly 是用来判断调用 <code>getBean()</code> 是否为类型检查获取 bean。如果不是仅仅做类型检查则是创建bean，则需要调用 <code>markBeanAsCreated()</code> 记录：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">markBeanAsCreated</span><span class="params">(String beanName)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 没有创建</span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">this</span>.alreadyCreated.contains(beanName)) &#123;</span><br><span class="line">    <span class="comment">// 加上全局锁</span></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>.mergedBeanDefinitions) &#123;</span><br><span class="line">      <span class="comment">// 再次检查一次：DCL 双检查模式</span></span><br><span class="line">      <span class="keyword">if</span> (!<span class="keyword">this</span>.alreadyCreated.contains(beanName)) &#123;</span><br><span class="line">        <span class="comment">// 从 mergedBeanDefinitions 中删除 beanName，</span></span><br><span class="line">        <span class="comment">// 并在下次访问时重新创建它。</span></span><br><span class="line">        clearMergedBeanDefinition(beanName);</span><br><span class="line">        <span class="comment">// 添加到已创建bean 集合中</span></span><br><span class="line">        <span class="keyword">this</span>.alreadyCreated.add(beanName);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>获取 RootBeanDefinition</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);</span><br></pre></td></tr></table></figure><p>调用 <code>getMergedLocalBeanDefinition()</code> 获取相对应的 BeanDefinition，如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> RootBeanDefinition <span class="title">getMergedLocalBeanDefinition</span><span class="params">(String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">  <span class="comment">// 快速从缓存中获取，如果不为空，则直接返回</span></span><br><span class="line">  RootBeanDefinition mbd = <span class="keyword">this</span>.mergedBeanDefinitions.get(beanName);</span><br><span class="line">  <span class="keyword">if</span> (mbd != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> mbd;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 获取 RootBeanDefinition，</span></span><br><span class="line">  <span class="comment">// 如果返回的 BeanDefinition 是子类 bean 的话，则合并父类相关属性</span></span><br><span class="line">  <span class="keyword">return</span> getMergedBeanDefinition(beanName, getBeanDefinition(beanName));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先直接从 mergedBeanDefinitions 缓存中获取相应的 RootBeanDefinition，如果存在则直接返回否则调用 <code>getMergedBeanDefinition()</code> 获取 RootBeanDefinition，若获取的 BeanDefinition 为子 BeanDefinition，则需要合并父类的相关属性。 <strong>处理依赖</strong> 如果一个 bean 有依赖 bean 的话，那么在初始化该 bean 时是需要先初始化它所依赖的 bean。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取依赖。</span></span><br><span class="line"><span class="comment">// 在初始化 bean 时解析 depends-on 标签时设置</span></span><br><span class="line">String[] dependsOn = mbd.getDependsOn();</span><br><span class="line"><span class="keyword">if</span> (dependsOn != <span class="keyword">null</span>) &#123;</span><br><span class="line">  <span class="comment">// 迭代依赖</span></span><br><span class="line">  <span class="keyword">for</span> (String dep : dependsOn) &#123;</span><br><span class="line">    <span class="comment">// 检验依赖的bean 是否已经注册给当前 bean 获取其他传递依赖bean</span></span><br><span class="line">    <span class="keyword">if</span> (isDependent(beanName, dep)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line">                                      <span class="string">&quot;Circular depends-on relationship between &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27; and &#x27;&quot;</span> + dep + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 注册到依赖bean中</span></span><br><span class="line">    registerDependentBean(dep, beanName);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 调用 getBean 初始化依赖bean</span></span><br><span class="line">      getBean(dep);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (NoSuchBeanDefinitionException ex) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line">                                      <span class="string">&quot;&#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27; depends on missing bean &#x27;&quot;</span> + dep + <span class="string">&quot;&#x27;&quot;</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码逻辑是：通过迭代的方式依次对依赖 bean 进行检测、校验，如果通过则调用 <code>getBean()</code> 实例化依赖 bean。 <code>isDependent()</code> 是校验该依赖是否已经注册给当前 bean。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isDependent</span><span class="params">(String beanName, String dependentBeanName)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">synchronized</span> (<span class="keyword">this</span>.dependentBeanMap) &#123;</span><br><span class="line">    <span class="keyword">return</span> isDependent(beanName, dependentBeanName, <span class="keyword">null</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同步加锁给 dependentBeanMap 对象，然后调用 <code>isDependent()</code> 校验。dependentBeanMap 对象保存的是依赖 beanName 之间的映射关系：beanName - &gt; 依赖 beanName 的集合</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isDependent</span><span class="params">(String beanName, </span></span></span><br><span class="line"><span class="function"><span class="params">                            String dependentBeanName, </span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="meta">@Nullable</span> Set&lt;String&gt; alreadySeen)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// alreadySeen 已经检测的依赖 bean</span></span><br><span class="line">  <span class="keyword">if</span> (alreadySeen != <span class="keyword">null</span> &amp;&amp; alreadySeen.contains(beanName)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 获取原始 beanName</span></span><br><span class="line">  String canonicalName = canonicalName(beanName);</span><br><span class="line">  <span class="comment">// 获取当前 beanName 的依赖集合</span></span><br><span class="line">  Set&lt;String&gt; dependentBeans = <span class="keyword">this</span>.dependentBeanMap.get(canonicalName);</span><br><span class="line">  <span class="comment">// 不存在依赖，返回false</span></span><br><span class="line">  <span class="keyword">if</span> (dependentBeans == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 存在，则证明存在已经注册的依赖</span></span><br><span class="line">  <span class="keyword">if</span> (dependentBeans.contains(dependentBeanName)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 递归检测依赖</span></span><br><span class="line">  <span class="keyword">for</span> (String transitiveDependency : dependentBeans) &#123;</span><br><span class="line">    <span class="keyword">if</span> (alreadySeen == <span class="keyword">null</span>) &#123;</span><br><span class="line">      alreadySeen = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    alreadySeen.add(beanName);</span><br><span class="line">    <span class="keyword">if</span> (isDependent(transitiveDependency, dependentBeanName, alreadySeen)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果校验成功，则调用 <code>registerDependentBean()</code> 将该依赖进行注册，便于在销毁 bean 之前对其进行销毁。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerDependentBean</span><span class="params">(String beanName, String dependentBeanName)</span> </span>&#123;</span><br><span class="line">  String canonicalName = canonicalName(beanName);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">synchronized</span> (<span class="keyword">this</span>.dependentBeanMap) &#123;</span><br><span class="line">    Set&lt;String&gt; dependentBeans =</span><br><span class="line">      <span class="keyword">this</span>.dependentBeanMap.computeIfAbsent(</span><br><span class="line">      canonicalName, k -&gt; <span class="keyword">new</span> LinkedHashSet&lt;&gt;(<span class="number">8</span>));</span><br><span class="line">    <span class="keyword">if</span> (!dependentBeans.add(dependentBeanName)) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">synchronized</span> (<span class="keyword">this</span>.dependenciesForBeanMap) &#123;</span><br><span class="line">    Set&lt;String&gt; dependenciesForBean =</span><br><span class="line">      <span class="keyword">this</span>.dependenciesForBeanMap.computeIfAbsent(</span><br><span class="line">      dependentBeanName, k -&gt; <span class="keyword">new</span> LinkedHashSet&lt;&gt;(<span class="number">8</span>));</span><br><span class="line">    dependenciesForBean.add(canonicalName);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实将就是该映射关系保存到两个集合中：dependentBeanMap、dependenciesForBeanMap。 最后调用 <code>getBean()</code> 实例化依赖 bean。 至此，加载 bean 的第二个部分也分析完毕了。</p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
          <category> 《Spring源码分析》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> 死磕Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IOC之从单例缓存中获取单例bean</title>
      <link href="/blog/2020/01/16/c9c155de.html"/>
      <url>/blog/2020/01/16/c9c155de.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文作者：chenssy</p><p>出处：<a href="http://cmsblogs.com/?p=2808">http://cmsblogs.com/?p=2808</a></p><p>在学习<code>Spring源码</code>的过程中发现的好站+好贴，感谢作者。Spring版本：<strong>Spring 5.0.6.RELEASE</strong></p></blockquote><p>从这篇博客开始我们开始加载 bean 的第一个步骤，从缓存中获取 bean，代码片段如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object sharedInstance = getSingleton(beanName);</span><br><span class="line"><span class="keyword">if</span> (sharedInstance != <span class="keyword">null</span> &amp;&amp; args == <span class="keyword">null</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">      logger.debug(<span class="string">&quot;Returning eagerly cached instance of singleton bean &#x27;&quot;</span> </span><br><span class="line">+ beanName +</span><br><span class="line"><span class="string">&quot;&#x27; that is not fully initialized yet - a consequence of a circular reference&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      logger.debug(<span class="string">&quot;Returning cached instance of singleton bean &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  bean = getObjectForBeanInstance(sharedInstance, name, beanName, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先调用 <code>getSingleton()</code> 从缓存中获取 bean，在上篇博客 <a href="/2020/01/15/27d87789.html">IOC 之 开启 bean 的加载</a> 提到过，Spring 对单例模式的 bean 只会创建一次，后续如果再获取该 bean 则是直接从单例缓存中获取，该过程就体现在 <code>getSingleton()</code> 中。如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getSingleton</span><span class="params">(String beanName)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> getSingleton(beanName, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">getSingleton</span><span class="params">(String beanName, <span class="keyword">boolean</span> allowEarlyReference)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 从单例缓冲中加载 bean</span></span><br><span class="line">  Object singletonObject = <span class="keyword">this</span>.singletonObjects.get(beanName);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 缓存中的 bean 为空，且当前 bean 正在创建</span></span><br><span class="line">  <span class="keyword">if</span> (singletonObject == <span class="keyword">null</span> &amp;&amp; isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">    <span class="comment">// 加锁</span></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonObjects) &#123;</span><br><span class="line">      <span class="comment">// 从 earlySingletonObjects 获取</span></span><br><span class="line">      singletonObject = <span class="keyword">this</span>.earlySingletonObjects.get(beanName);</span><br><span class="line">      <span class="comment">// earlySingletonObjects 中没有，且允许提前创建</span></span><br><span class="line">      <span class="keyword">if</span> (singletonObject == <span class="keyword">null</span> &amp;&amp; allowEarlyReference) &#123;</span><br><span class="line">        <span class="comment">// 从 singletonFactories 中获取对应的 ObjectFactory</span></span><br><span class="line">        ObjectFactory&lt;?&gt; singletonFactory = <span class="keyword">this</span>.singletonFactories.get(beanName);</span><br><span class="line">        <span class="comment">// ObjectFactory 不为空，则创建 bean</span></span><br><span class="line">        <span class="keyword">if</span> (singletonFactory != <span class="keyword">null</span>) &#123;</span><br><span class="line">          singletonObject = singletonFactory.getObject();</span><br><span class="line">          <span class="keyword">this</span>.earlySingletonObjects.put(beanName, singletonObject);</span><br><span class="line">          <span class="keyword">this</span>.singletonFactories.remove(beanName);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> singletonObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码非常简单，首先从 <code>singletonObjects</code> 中获取，若为空且当前 <code>bean</code> 正在创建中，则从 <code>earlySingletonObjects</code> 中获取，若为空且允许提前创建则从 <code>singletonFactories</code> 中获取相应的 <code>ObjectFactory</code> ，若不为空，则调用其 <code>getObject()</code> 创建 <code>bean</code>，然后将其加入到 <code>earlySingletonObjects</code>，然后从 <code>singletonFactories</code> 删除。</p><p>总体逻辑就是根据 <code>beanName</code> 依次检测这三个 <code>Map</code>，若为空，从下一个，否则返回。</p><p><strong>这三个 <code>Map</code> 存放的都有各自的功能，如下：</strong></p><ul><li><strong>singletonObjects</strong> ：存放的是单例 bean，对应关系为 <code>bean name --&gt; bean instance</code></li><li><strong>earlySingletonObjects</strong>：存放的是早期的 bean，对应关系也是 <code>bean name --&gt; bean instance</code>。它与 singletonObjects 区别在于 earlySingletonObjects 中存放的 bean 不一定是完整的，从上面过程中我们可以了解，bean 在创建过程中就已经加入到 earlySingletonObjects 中了，所以当在 bean 的创建过程中就可以通过 <code>getBean()</code> 方法获取。这个 Map 也是解决循环依赖的关键所在。</li><li><strong>singletonFactories</strong>：存放的是 ObjectFactory，可以理解为创建单例 bean 的 factory，对应关系是 <code>bean name --&gt; ObjectFactory</code></li></ul><p>在上面代码中还有一个非常重要的检测方法 <code>isSingletonCurrentlyInCreation(beanName)</code>，该方法用于判断该 beanName 对应的 bean 是否在创建过程中，注意这个过程讲的是整个工厂中。如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSingletonCurrentlyInCreation</span><span class="params">(String beanName)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.singletonsCurrentlyInCreation.contains(beanName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从这段代码中我们可以预测，在 <code>bean</code> 创建过程中都会将其加入到 <code>singletonsCurrentlyInCreation</code> 集合中，<em>具体是在什么时候加的，我们后面分析</em>。 </p><p>到这里从缓存中获取 <code>bean</code> 的过程已经分析完毕了，我们再看开篇的代码段，从缓存中获取 <code>bean</code> 后，若其不为 <code>null</code> 且 <code>args</code> 为空，则会调用 <code>getObjectForBeanInstance()</code> 处理。</p><p>为什么会有这么一段呢？因为我们从缓存中获取的 <code>bean</code> 是最原始的 <code>bean</code> 并不一定使我们最终想要的 <code>bean</code>，怎么办呢？调用 <code>getObjectForBeanInstance()</code> 进行处理，该方法的定义为获取给定 <code>bean</code> 实例的对象，该对象要么是 <code>bean</code> 实例本身，要么就是 <code>FactoryBean</code> 创建的对象，如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">getObjectForBeanInstance</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  Object beanInstance, String name, String beanName, <span class="meta">@Nullable</span> RootBeanDefinition mbd)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 若为工厂类引用（name 以 &amp; 开头）</span></span><br><span class="line">  <span class="keyword">if</span> (BeanFactoryUtils.isFactoryDereference(name)) &#123;</span><br><span class="line">    <span class="comment">// 如果是 NullBean，则直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (beanInstance <span class="keyword">instanceof</span> NullBean) &#123;</span><br><span class="line">      <span class="keyword">return</span> beanInstance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果 beanInstance 不是 FactoryBean 类型，则抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (!(beanInstance <span class="keyword">instanceof</span> FactoryBean)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BeanIsNotAFactoryException(transformedBeanName(name), beanInstance.getClass());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 到这里我们就有了一个 bean 实例，当然该实例可能是会是是一个正常的 bean 又或者是一个 FactoryBean</span></span><br><span class="line">  <span class="comment">// 如果是 FactoryBean，我我们则创建该 bean</span></span><br><span class="line">  <span class="keyword">if</span> (!(beanInstance <span class="keyword">instanceof</span> FactoryBean) || BeanFactoryUtils.isFactoryDereference(name)) &#123;</span><br><span class="line">    <span class="keyword">return</span> beanInstance;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 加载 FactoryBean</span></span><br><span class="line">  Object object = <span class="keyword">null</span>;</span><br><span class="line">  <span class="comment">// 若 BeanDefinition 为 null，则从缓存中加载</span></span><br><span class="line">  <span class="keyword">if</span> (mbd == <span class="keyword">null</span>) &#123;</span><br><span class="line">    object = getCachedObjectForFactoryBean(beanName);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 若 object 依然为空，则可以确认，beanInstance 一定是 FactoryBean</span></span><br><span class="line">  <span class="keyword">if</span> (object == <span class="keyword">null</span>) &#123;</span><br><span class="line">    FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) beanInstance;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">if</span> (mbd == <span class="keyword">null</span> &amp;&amp; containsBeanDefinition(beanName)) &#123;</span><br><span class="line">      mbd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 是否是用户定义的而不是应用程序本身定义的</span></span><br><span class="line">    <span class="keyword">boolean</span> synthetic = (mbd != <span class="keyword">null</span> &amp;&amp; mbd.isSynthetic());</span><br><span class="line">    <span class="comment">// 核心处理类</span></span><br><span class="line">    object = getObjectFromFactoryBean(factory, beanName, !synthetic);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> object;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法主要是进行检测工作的，主要如下：</p><ul><li>若 name 为工厂相关的（以 &amp; 开头），且 beanInstance 为 NullBean 类型则直接返回，如果 beanInstance 不为 FactoryBean 类型则抛出 BeanIsNotAFactoryException 异常。这里主要是校验 beanInstance 的正确性。</li><li>如果 beanInstance 不为 FactoryBean 类型或者 name 也不是与工厂相关的，则直接返回。这里主要是对非 FactoryBean 类型处理。</li><li>如果 BeanDefinition 为空，则从 factoryBeanObjectCache 中加载，如果还是空，则可以断定 beanInstance 一定是 FactoryBean 类型，则委托 <code>getObjectFromFactoryBean()</code> 方法处理</li></ul><p>从上面可以看出 <code>getObjectForBeanInstance()</code> 主要是返回给定的 <code>bean</code> 实例对象，当然该实例对象为非 <code>FactoryBean</code> 类型，对于 <code>FactoryBean</code> 类型的 <code>bean</code>，则是委托 <code>getObjectFromFactoryBean()</code> 从 <code>FactoryBean</code> 获取 <code>bean</code> 实例对象。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">getObjectFromFactoryBean</span><span class="params">(FactoryBean&lt;?&gt; factory, String beanName, <span class="keyword">boolean</span> shouldPostProcess)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 为单例模式且缓存中存在</span></span><br><span class="line">  <span class="keyword">if</span> (factory.isSingleton() &amp;&amp; containsSingleton(beanName)) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (getSingletonMutex()) &#123;</span><br><span class="line">      <span class="comment">// 从缓存中获取指定的 factoryBean</span></span><br><span class="line">      Object object = <span class="keyword">this</span>.factoryBeanObjectCache.get(beanName);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (object == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 为空，则从 FactoryBean 中获取对象</span></span><br><span class="line">        object = doGetObjectFromFactoryBean(factory, beanName);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从缓存中获取</span></span><br><span class="line">        Object alreadyThere = <span class="keyword">this</span>.factoryBeanObjectCache.get(beanName);</span><br><span class="line">        <span class="comment">// **我实在是不明白这里这么做的原因，这里是干嘛？？？**</span></span><br><span class="line">        <span class="keyword">if</span> (alreadyThere != <span class="keyword">null</span>) &#123;</span><br><span class="line">          object = alreadyThere;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 需要后续处理</span></span><br><span class="line">          <span class="keyword">if</span> (shouldPostProcess) &#123;</span><br><span class="line">            <span class="comment">// 若该 bean 处于创建中，则返回非处理对象，而不是存储它</span></span><br><span class="line">            <span class="keyword">if</span> (isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">              <span class="keyword">return</span> object;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 前置处理</span></span><br><span class="line">            beforeSingletonCreation(beanName);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="comment">// 对从 FactoryBean 获取的对象进行后处理</span></span><br><span class="line">              <span class="comment">// 生成的对象将暴露给bean引用</span></span><br><span class="line">              object = postProcessObjectFromFactoryBean(object, beanName);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">              <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">                beanName,                 </span><br><span class="line">                <span class="string">&quot;Post-processing of FactoryBean&#x27;s singleton object failed&quot;</span>, ex);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">finally</span> &#123;</span><br><span class="line">              <span class="comment">// 后置处理</span></span><br><span class="line">              afterSingletonCreation(beanName);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// 缓存</span></span><br><span class="line">          <span class="keyword">if</span> (containsSingleton(beanName)) &#123;</span><br><span class="line">            <span class="keyword">this</span>.factoryBeanObjectCache.put(beanName, object);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> object;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 非单例</span></span><br><span class="line">    Object object = doGetObjectFromFactoryBean(factory, beanName);</span><br><span class="line">    <span class="keyword">if</span> (shouldPostProcess) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        object = postProcessObjectFromFactoryBean(object, beanName);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">          beanName, </span><br><span class="line">          <span class="string">&quot;Post-processing of FactoryBean&#x27;s object failed&quot;</span>, ex);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> object;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要流程如下：</p><ul><li>若为单例且单例 bean 缓存中存在 beanName，则进行后续处理（跳转到下一步），否则则从 FactoryBean 中获取 bean 实例对象，如果接受后置处理，则调用 <code>postProcessObjectFromFactoryBean()</code> 进行后置处理。</li><li>首先获取锁（其实我们在前面篇幅中发现了大量的同步锁，锁住的对象都是 this.singletonObjects， 主要是因为在单例模式中必须要保证全局唯一），然后从 factoryBeanObjectCache 缓存中获取实例对象 object，若 object 为空，则调用 <code>doGetObjectFromFactoryBean()</code>方法从 FactoryBean 获取对象，其实内部就是调用 <code>FactoryBean.getObject()</code>。</li><li>如果需要后续处理，则进行进一步处理，步骤如下：<ul><li>若该 bean 处于创建中（isSingletonCurrentlyInCreation），则返回非处理对象，而不是存储它</li><li>调用 <code>beforeSingletonCreation()</code> 进行创建之前的处理。默认实现将该 bean 标志为当前创建的。</li><li>调用 <code>postProcessObjectFromFactoryBean()</code> 对从 FactoryBean 获取的 bean 实例对象进行后置处理，默认实现是按照原样直接返回，具体实现是在 AbstractAutowireCapableBeanFactory 中实现的，当然子类也可以重写它，比如应用后置处理</li><li>调用 <code>afterSingletonCreation()</code> 进行创建 bean 之后的处理，默认实现是将该 bean 标记为不再在创建中。</li></ul></li><li>最后加入到 FactoryBeans 缓存中。</li></ul><p>该方法应该就是创建 bean 实例对象中的核心方法之一了。这里我们关注三个方法：<code>beforeSingletonCreation()</code> 、 <code>afterSingletonCreation()</code> 、 <code>postProcessObjectFromFactoryBean()</code>。可能有小伙伴觉得前面两个方法不是很重要，LZ 可以肯定告诉你，这两方法是非常重要的操作，因为<strong>他们记录着 bean 的加载状态，是检测当前 bean 是否处于创建中的关键之处，对解决 bean 循环依赖起着关键作用</strong>。before 方法用于标志当前 bean 处于创建中，after 则是移除。其实在这篇博客刚刚开始就已经提到了 <code>isSingletonCurrentlyInCreation()</code> 是用于检测当前 bean 是否处于创建之中，如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSingletonCurrentlyInCreation</span><span class="params">(String beanName)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.singletonsCurrentlyInCreation.contains(beanName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是根据 singletonsCurrentlyInCreation 集合中是否包含了 beanName，集合的元素则一定是在 <code>beforeSingletonCreation()</code> 中添加的，如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">beforeSingletonCreation</span><span class="params">(String beanName)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">this</span>.inCreationCheckExclusions.contains(beanName) &amp;&amp; !<span class="keyword">this</span>.singletonsCurrentlyInCreation.add(beanName)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BeanCurrentlyInCreationException(beanName);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>afterSingletonCreation()</code> 为移除，则一定就是对 <code>singletonsCurrentlyInCreation</code> 集合 <code>remove</code> 了，如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">afterSingletonCreation</span><span class="params">(String beanName)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">this</span>.inCreationCheckExclusions.contains(beanName) &amp;&amp; !<span class="keyword">this</span>.singletonsCurrentlyInCreation.remove(beanName)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Singleton &#x27;&quot;</span> </span><br><span class="line">                                    + beanName + <span class="string">&quot;&#x27; isn&#x27;t currently in creation&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>postProcessObjectFromFactoryBean()</code> 是对从 <code>FactoryBean</code> 处获取的 <code>bean</code> 实例对象进行后置处理，其默认实现是直接返回 <code>object</code> 对象，不做任何处理，子类可以重写，例如应用后处理器。</p><p><code>AbstractAutowireCapableBeanFactory</code> 对其提供了实现，如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">postProcessObjectFromFactoryBean</span><span class="params">(Object object, String beanName)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> applyBeanPostProcessorsAfterInitialization(object, beanName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法的定义为：对所有的 {@code postProcessAfterInitialization} 进行回调注册 BeanPostProcessors，让他们能够后期处理从 FactoryBean 中获取的对象。下面是具体实现：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">applyBeanPostProcessorsAfterInitialization</span><span class="params">(Object existingBean, String beanName)</span></span></span><br><span class="line"><span class="function">  <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"></span><br><span class="line">  Object result = existingBean;</span><br><span class="line">  <span class="keyword">for</span> (BeanPostProcessor beanProcessor : getBeanPostProcessors()) &#123;</span><br><span class="line">    Object current = beanProcessor.postProcessAfterInitialization(result, beanName);</span><br><span class="line">    <span class="keyword">if</span> (current == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    result = current;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于后置处理器，这里我们不做过多阐述，后面会专门的博文进行详细介绍，</p><p>这里我们只需要记住一点：尽可能保证所有 <code>bean</code> 初始化后都会调用注册的 <code>BeanPostProcessor.postProcessAfterInitialization()</code> 方法进行处理，在实际开发过程中大可以针对此特性设计自己的业务逻辑。 至此，从缓存中获取 bean 对象过程已经分析完毕了。 </p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
          <category> 《Spring源码分析》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> 死磕Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IOC之开启bean的加载</title>
      <link href="/blog/2020/01/15/27d87789.html"/>
      <url>/blog/2020/01/15/27d87789.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文作者：chenssy</p><p>出处：<a href="http://cmsblogs.com/?p=2806">http://cmsblogs.com/?p=2806</a></p><p>在学习<code>Spring源码</code>的过程中发现的好站+好贴，感谢作者。Spring版本：<strong>Spring 5.0.6.RELEASE</strong></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/cayzlh/git-img-repository@master/2020/05/10/gEeFMx.jpg" alt="img"></p><p>(此图来自《Spring 揭秘》) <code>Spring IOC</code>容器所起的作用如上图所示，它会以某种方式加载 <code>Configuration Metadata</code>，将其解析注册到容器内部，然后回根据这些信息绑定整个系统的对象，最终组装成一个可用的基于轻量级容器的应用系统。</p><p> <code>Spring</code> 在实现上述功能中，将整个流程分为两个阶段：<strong>容器初始化阶段</strong>和<strong>加载bean 阶段</strong>。</p><ul><li><strong>容器初始化阶段</strong>：首先通过某种方式加载 Configuration Metadata (主要是依据 Resource、ResourceLoader 两个体系)，然后容器会对加载的 Configuration MetaData 进行解析和分析，并将分析的信息组装成 BeanDefinition，并将其保存注册到相应的 BeanDefinitionRegistry 中。至此，Spring IOC 的初始化工作完成。</li><li><strong>加载 bean 阶段</strong>：经过容器初始化阶段后，应用程序中定义的 bean 信息已经全部加载到系统中了，当我们显示或者隐式地调用 <code>getBean()</code> 时，则会触发加载 bean 阶段。在这阶段，容器会首先检查所请求的对象是否已经初始化完成了，如果没有，则会根据注册的 bean 信息实例化请求的对象，并为其注册依赖，然后将其返回给请求方。至此第二个阶段也已经完成。</li></ul><p>当我们显示或者隐式地调用 <code>getBean()</code> 时，则会触发加载 <code>bean</code> 阶段。如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getBean</span><span class="params">(String name)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> doGetBean(name, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内部调用 <code>doGetBean()</code> 方法，其接受四个参数：</p><ul><li><strong>name</strong>：要获取 bean 的名字</li><li><strong>requiredType</strong>：要获取 bean 的类型</li><li><strong>args</strong>：创建 bean 时传递的参数。这个参数仅限于创建 bean 时使用</li><li><strong>typeCheckOnly</strong>：是否为类型检查</li></ul><p>这个方法的代码比较长，各位耐心看下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function">T <span class="title">doGetBean</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">final</span> String name, <span class="meta">@Nullable</span> <span class="keyword">final</span> Class&lt;T&gt; requiredType,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="meta">@Nullable</span> <span class="keyword">final</span> Object[] args, <span class="keyword">boolean</span> typeCheckOnly)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取 beanName，这里是一个转换动作，将 name 转换Wie beanName</span></span><br><span class="line">  <span class="keyword">final</span> String beanName = transformedBeanName(name);</span><br><span class="line">  Object bean;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 从缓存中或者实例工厂中获取 bean</span></span><br><span class="line">  <span class="comment">// *** 这里会涉及到解决循环依赖 bean 的问题</span></span><br><span class="line">  Object sharedInstance = getSingleton(beanName);</span><br><span class="line">  <span class="keyword">if</span> (sharedInstance != <span class="keyword">null</span> &amp;&amp; args == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">        logger.debug(<span class="string">&quot;Returning eagerly cached instance of singleton bean &#x27;&quot;</span> </span><br><span class="line">         + beanName </span><br><span class="line">         +</span><br><span class="line">        <span class="string">&quot;&#x27; that is not fully initialized yet - a consequence of a circular reference&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        logger.debug(<span class="string">&quot;Returning cached instance of singleton bean &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    bean = getObjectForBeanInstance(sharedInstance, name, beanName, <span class="keyword">null</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 因为 Spring 只解决单例模式下得循环依赖，在原型模式下如果存在循环依赖则会抛出异常</span></span><br><span class="line">    <span class="comment">// **关于循环依赖后续会单独出文详细说明**</span></span><br><span class="line">    <span class="keyword">if</span> (isPrototypeCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BeanCurrentlyInCreationException(beanName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果容器中没有找到，则从父类容器中加载</span></span><br><span class="line">    BeanFactory parentBeanFactory = getParentBeanFactory();</span><br><span class="line">    <span class="keyword">if</span> (parentBeanFactory != <span class="keyword">null</span> &amp;&amp; !containsBeanDefinition(beanName)) &#123;</span><br><span class="line">      String nameToLookup = originalBeanName(name);</span><br><span class="line">      <span class="keyword">if</span> (parentBeanFactory <span class="keyword">instanceof</span> AbstractBeanFactory) &#123;</span><br><span class="line">        <span class="keyword">return</span> ((AbstractBeanFactory) parentBeanFactory).doGetBean(</span><br><span class="line">          nameToLookup, requiredType, args, typeCheckOnly);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (args != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> (T) parentBeanFactory.getBean(nameToLookup, args);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> parentBeanFactory.getBean(nameToLookup, requiredType);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果不是仅仅做类型检查则是创建bean，这里需要记录</span></span><br><span class="line">    <span class="keyword">if</span> (!typeCheckOnly) &#123;</span><br><span class="line">      markBeanAsCreated(beanName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 从容器中获取 beanName 相应的 GenericBeanDefinition，并将其转换为 RootBeanDefinition</span></span><br><span class="line">      <span class="keyword">final</span> RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 检查给定的合并的 BeanDefinition</span></span><br><span class="line">      checkMergedBeanDefinition(mbd, beanName, args);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 处理所依赖的 bean</span></span><br><span class="line">      String[] dependsOn = mbd.getDependsOn();</span><br><span class="line">      <span class="keyword">if</span> (dependsOn != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (String dep : dependsOn) &#123;</span><br><span class="line">          <span class="comment">// 若给定的依赖 bean 已经注册为依赖给定的b ean</span></span><br><span class="line">          <span class="comment">// 循环依赖的情况</span></span><br><span class="line">          <span class="keyword">if</span> (isDependent(beanName, dep)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">              mbd.getResourceDescription(), </span><br><span class="line">              beanName,</span><br><span class="line">                                            </span><br><span class="line">              <span class="string">&quot;Circular depends-on relationship between &#x27;&quot;</span> </span><br><span class="line">              + beanName + <span class="string">&quot;&#x27; and &#x27;&quot;</span> + dep + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// 缓存依赖调用</span></span><br><span class="line">          registerDependentBean(dep, beanName);</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            getBean(dep);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">catch</span> (NoSuchBeanDefinitionException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">              mbd.getResourceDescription(), </span><br><span class="line">              beanName,</span><br><span class="line">                                            </span><br><span class="line">              <span class="string">&quot;&#x27;&quot;</span> + beanName </span><br><span class="line">              + <span class="string">&quot;&#x27; depends on missing bean &#x27;&quot;</span> + dep + <span class="string">&quot;&#x27;&quot;</span>, ex);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// bean 实例化</span></span><br><span class="line">      <span class="comment">// 单例模式</span></span><br><span class="line">      <span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">        sharedInstance = getSingleton(beanName, () -&gt; &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">            <span class="comment">// 显示从单利缓存中删除 bean 实例</span></span><br><span class="line">            <span class="comment">// 因为单例模式下为了解决循环依赖，可能他已经存在了，所以销毁它</span></span><br><span class="line">            destroySingleton(beanName);</span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 原型模式</span></span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (mbd.isPrototype()) &#123;</span><br><span class="line">        <span class="comment">// It&#x27;s a prototype -&gt; create a new instance.</span></span><br><span class="line">        Object prototypeInstance = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          beforePrototypeCreation(beanName);</span><br><span class="line">          prototypeInstance = createBean(beanName, mbd, args);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">          afterPrototypeCreation(beanName);</span><br><span class="line">        &#125;</span><br><span class="line">        bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 从指定的 scope 下创建 bean</span></span><br><span class="line">        String scopeName = mbd.getScope();</span><br><span class="line">        <span class="keyword">final</span> Scope scope = <span class="keyword">this</span>.scopes.get(scopeName);</span><br><span class="line">        <span class="keyword">if</span> (scope == <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">            <span class="string">&quot;No Scope registered for scope name &#x27;&quot;</span> + scopeName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          Object scopedInstance = scope.get(beanName, () -&gt; &#123;</span><br><span class="line">            beforePrototypeCreation(beanName);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">finally</span> &#123;</span><br><span class="line">              afterPrototypeCreation(beanName);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;);</span><br><span class="line">          bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (IllegalStateException ex) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">            beanName,</span><br><span class="line">                                          </span><br><span class="line">            <span class="string">&quot;Scope &#x27;&quot;</span> + scopeName </span><br><span class="line">            + <span class="string">&quot;&#x27; is not active for the current thread; consider &quot;</span> </span><br><span class="line">            + <span class="string">&quot;defining a scoped proxy for this bean if you intend to refer to it from a singleton&quot;</span>,</span><br><span class="line">                                          </span><br><span class="line">            ex);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">      cleanupAfterBeanCreationFailure(beanName);</span><br><span class="line">      <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 检查需要的类型是否符合 bean 的实际类型</span></span><br><span class="line">  <span class="keyword">if</span> (requiredType != <span class="keyword">null</span> &amp;&amp; !requiredType.isInstance(bean)) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      T convertedBean = getTypeConverter().convertIfNecessary(bean, requiredType);</span><br><span class="line">      <span class="keyword">if</span> (convertedBean == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> convertedBean;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (TypeMismatchException ex) &#123;</span><br><span class="line">      <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">        logger.debug(<span class="string">&quot;Failed to convert bean &#x27;&quot;</span> + name + <span class="string">&quot;&#x27; to required type &#x27;&quot;</span> +</span><br><span class="line">                     ClassUtils.getQualifiedName(requiredType) + <span class="string">&quot;&#x27;&quot;</span>, ex);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (T) bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码是相当长，处理逻辑也是相当复杂，下面将其进行拆分阐述。 </p><p><strong>1.获取 beanName</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> String beanName = transformedBeanName(name);</span><br></pre></td></tr></table></figure><p>这里传递的是 name，不一定就是 beanName，可能是 aliasName，也有可能是 FactoryBean，所以这里需要调用 <code>transformedBeanName()</code> 方法对 name 进行一番转换，主要如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> String <span class="title">transformedBeanName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> canonicalName(BeanFactoryUtils.transformedBeanName(name));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 去除 FactoryBean 的修饰符</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">transformedBeanName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">  Assert.notNull(name, <span class="string">&quot;&#x27;name&#x27; must not be null&quot;</span>);</span><br><span class="line">  String beanName = name;</span><br><span class="line">  <span class="keyword">while</span> (beanName.startsWith(BeanFactory.FACTORY_BEAN_PREFIX)) &#123;</span><br><span class="line">    beanName = beanName.substring(BeanFactory.FACTORY_BEAN_PREFIX.length());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> beanName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转换 aliasName</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">canonicalName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">  String canonicalName = name;</span><br><span class="line">  <span class="comment">// Handle aliasing...</span></span><br><span class="line">  String resolvedName;</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    resolvedName = <span class="keyword">this</span>.aliasMap.get(canonicalName);</span><br><span class="line">    <span class="keyword">if</span> (resolvedName != <span class="keyword">null</span>) &#123;</span><br><span class="line">      canonicalName = resolvedName;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (resolvedName != <span class="keyword">null</span>);</span><br><span class="line">  <span class="keyword">return</span> canonicalName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要处理过程包括两步：</p><ol><li>去除 FactoryBean 的修饰符。如果 name 以 “&amp;” 为前缀，那么会去掉该 “&amp;”，例如，<code>name = &quot;&amp;studentService&quot;</code>，则会是 <code>name = &quot;studentService&quot;</code>。</li><li>取指定的 alias 所表示的最终 beanName。主要是一个循环获取 beanName 的过程，例如别名 A 指向名称为 B 的 bean 则返回 B，若 别名 A 指向别名 B，别名 B 指向名称为 C 的 bean，则返回 C。</li></ol><p><strong>2.从单例 bean 缓存中获取 bean</strong> 对应代码段如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object sharedInstance = getSingleton(beanName);</span><br><span class="line"><span class="keyword">if</span> (sharedInstance != <span class="keyword">null</span> &amp;&amp; args == <span class="keyword">null</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">      logger.debug(<span class="string">&quot;Returning eagerly cached instance of singleton bean &#x27;&quot;</span> + beanName +</span><br><span class="line">                   <span class="string">&quot;&#x27; that is not fully initialized yet - a consequence of a circular reference&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      logger.debug(<span class="string">&quot;Returning cached instance of singleton bean &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  bean = getObjectForBeanInstance(sharedInstance, name, beanName, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们知道单例模式的 bean 在整个过程中只会被创建一次，第一次创建后会将该 bean 加载到缓存中，后面在获取 bean 就会直接从单例缓存中获取。如果从缓存中得到了 bean，则需要调用 <code>getObjectForBeanInstance()</code> 对 bean 进行实例化处理，因为缓存中记录的是最原始的 bean 状态，我们得到的不一定是我们最终想要的 bean。 </p><p><strong>3.原型模式依赖检查与 parentBeanFactory</strong> 对应代码段</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (isPrototypeCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> BeanCurrentlyInCreationException(beanName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Check if bean definition exists in this factory.</span></span><br><span class="line">BeanFactory parentBeanFactory = getParentBeanFactory();</span><br><span class="line"><span class="keyword">if</span> (parentBeanFactory != <span class="keyword">null</span> &amp;&amp; !containsBeanDefinition(beanName)) &#123;</span><br><span class="line">  <span class="comment">// Not found -&gt; check parent.</span></span><br><span class="line">  String nameToLookup = originalBeanName(name);</span><br><span class="line">  <span class="keyword">if</span> (parentBeanFactory <span class="keyword">instanceof</span> AbstractBeanFactory) &#123;</span><br><span class="line">    <span class="keyword">return</span> ((AbstractBeanFactory) parentBeanFactory).doGetBean(</span><br><span class="line">      nameToLookup, requiredType, args, typeCheckOnly);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (args != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// Delegation to parent with explicit args.</span></span><br><span class="line">    <span class="keyword">return</span> (T) parentBeanFactory.getBean(nameToLookup, args);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// No args -&gt; delegate to standard getBean method.</span></span><br><span class="line">    <span class="keyword">return</span> parentBeanFactory.getBean(nameToLookup, requiredType);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Spring 只处理单例模式下得循环依赖，对于原型模式的循环依赖直接抛出异常。主要原因还是在于 Spring 解决循环依赖的策略有关。对于单例模式 Spring 在创建 bean 的时候并不是等 bean 完全创建完成后才会将 bean 添加至缓存中，而是不等 bean 创建完成就会将创建 bean 的 ObjectFactory 提早加入到缓存中，这样一旦下一个 bean 创建的时候需要依赖 bean 时则直接使用 ObjectFactroy。但是原型模式我们知道是没法使用缓存的，所以 Spring 对原型模式的循环依赖处理策略则是不处理（关于循环依赖后面会有单独文章说明）。 如果容器缓存中没有相对应的 BeanDefinition 则会尝试从父类工厂（parentBeanFactory）中加载，然后再去递归调用 <code>getBean()</code>。 </p><p><strong>4. 依赖处理</strong> 对应源码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] dependsOn = mbd.getDependsOn();</span><br><span class="line"><span class="keyword">if</span> (dependsOn != <span class="keyword">null</span>) &#123;</span><br><span class="line">  <span class="keyword">for</span> (String dep : dependsOn) &#123;</span><br><span class="line">    <span class="keyword">if</span> (isDependent(beanName, dep)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">        mbd.getResourceDescription(), </span><br><span class="line">        beanName,</span><br><span class="line">                                      </span><br><span class="line">        <span class="string">&quot;Circular depends-on relationship between &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27; and &#x27;&quot;</span> + dep + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    registerDependentBean(dep, beanName);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      getBean(dep);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (NoSuchBeanDefinitionException ex) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">        mbd.getResourceDescription(), </span><br><span class="line">        beanName,                  </span><br><span class="line">        <span class="string">&quot;&#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27; depends on missing bean &#x27;&quot;</span> + dep + <span class="string">&quot;&#x27;&quot;</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每个 bean 都不是单独工作的，它会依赖其他 bean，其他 bean 也会依赖它，对于依赖的 bean ，它会优先加载，所以在 Spring 的加载顺序中，在初始化某一个 bean 的时候首先会初始化这个 bean 的依赖。 </p><p><strong>作用域处理</strong> Spring bean 的作用域默认为 singleton，当然还有其他作用域，如prototype、request、session 等，不同的作用域会有不同的初始化策略。 </p><p><strong>类型转换</strong> 在调用 <code>doGetBean()</code> 方法时，有一个 requiredType 参数，该参数的功能就是将返回的 bean 转换为 requiredType 类型。当然就一般而言我们是不需要进行类型转换的，也就是 requiredType 为空（比如 <code>getBean(String name)</code>），但有可能会存在这种情况，比如我们返回的 bean 类型为 String，我们在使用的时候需要将其转换为 Integer，那么这个时候 requiredType 就有用武之地了。当然我们一般是不需要这样做的。 至此 <code>getBean()</code> 过程讲解完了。后续将会对该过程进行拆分，更加详细的说明，弄清楚其中的来龙去脉，所以这篇博客只能算是 Spring bean 加载过程的一个概览。</p><p>拆分主要是分为三个部分：</p><ol><li>分析从缓存中获取单例 bean，以及对 bean 的实例中获取对象</li><li>如果从单例缓存中获取 bean，Spring 是怎么加载的呢？所以第二部分是分析 bean 加载，以及 bean 的依赖处理</li><li>bean 已经加载了，依赖也处理完毕了，第三部分则分析各个作用域的 bean 初始化过程。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
          <category> 《Spring源码分析》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> 死磕Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IoC之装载BeanDefinitions总结</title>
      <link href="/blog/2020/01/14/af13201.html"/>
      <url>/blog/2020/01/14/af13201.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文作者：chenssy</p><p>出处：<a href="http://cmsblogs.com/?p=todo">http://cmsblogs.com/?p=todo</a></p><p>在学习<code>Spring源码</code>的过程中发现的好站+好贴，感谢作者。Spring版本：<strong>Spring 5.0.6.RELEASE</strong></p></blockquote><hr><p>前面分析了 <code>IoC BeanDefinition</code> 装载的整个过程，这篇就这些内容做一个总结将其连贯起来。</p><p>在前文提过，<code>IoC</code> 容器的初始化过程分为三步骤：<code>Resource 定位</code>、<code>BeanDefinition 的载入</code>和<code>解析</code>，<code>BeanDefinition 注册</code>。</p><p><img src="https://cdn.jsdelivr.net/gh/cayzlh/git-img-repository@master/uPic/szYKeg.jpg" alt="szYKeg"></p><ul><li><p><strong>Resource 定位</strong>。我们一般用外部资源来描述 Bean 对象，所以在初始化 IoC 容器的第一步就是需要定位这个外部资源。在上一篇博客（<a href="/2020/01/02/8f7aa5ac.html">《IoC 之 Spring 统一资源加载策略》</a>）已经详细说明了资源加载的过程。</p></li><li><p><strong>BeanDefinition 的装载和解析</strong></p><p><em>装载就是 BeanDefinition 的载入。</em></p></li></ul><blockquote><p>读取、解析 Resource 资源，也就是将用户定义的 Bean 表示成 IoC 容器的内部数据结构：BeanDefinition</p></blockquote><ul><li><p>在 IoC 容器内部维护着一个 BeanDefinition Map 的数据结构</p></li><li><p>在配置文件中每一个 <bean> 都对应着一个 BeanDefinition 对象。</p></li><li><p><strong>BeanDefinition 注册</strong></p><p>向 <code>IoC</code> 容器注册在第二步解析好的 <code>BeanDefinition</code>，这个过程是通过 <code>BeanDefinitionRegistry</code> 接口来实现的。</p><p><em>在 <code>IoC</code> 容器内部其实是将第二个过程解析得到的 <code>BeanDefinition</code> 注入到一个 <code>HashMap</code> 容器中，<code>IoC</code> 容器就是通过这个 <code>HashMap</code> 来维护这些 <code>BeanDefinition</code> 的。</em></p><ul><li>在这里需要注意的一点是这个过程并没有完成依赖注入（Bean 创建），<code>Bean</code> 创建是发生在应用第一次调用 <code>#getBean(...)</code> 方法，向容器索要 <code>Bean</code> 时。</li><li>当然我们可以通过设置预处理，即对某个 <code>Bean</code> 设置 <code>lazyinit = false</code> 属性，那么这个 <code>Bean</code> 的依赖注入就会在容器初始化的时候完成。</li></ul></li></ul><p>在博客 <a href="/2020/01/03/a6d994a0.html">《 IoC 之加载 BeanDefinition》</a> 中提供过一段代码，这里我们同样也以这段代码作为我们研究 <code>IoC</code> 初始化过程的开端，如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ClassPathResource resource = <span class="keyword">new</span> ClassPathResource(<span class="string">&quot;bean.xml&quot;</span>);</span><br><span class="line">DefaultListableBeanFactory factory = <span class="keyword">new</span> DefaultListableBeanFactory();</span><br><span class="line">XmlBeanDefinitionReader reader = <span class="keyword">new</span> XmlBeanDefinitionReader(factory);</span><br><span class="line">reader.loadBeanDefinitions(resource);</span><br></pre></td></tr></table></figure><p>刚刚开始的时候可能对上面这几行代码不知道什么意思，现在应该就一目了然了：</p><ul><li><p><code>ClassPathResource resource = new ClassPathResource(&quot;bean.xml&quot;);</code> ： 根据 <code>Xml</code> 配置文件创建 <code>Resource</code> 资源对象。</p><blockquote><p><code>ClassPathResource</code> 是 <code>Resource</code> 接口的子类，<code>bean.xml</code> 文件中的内容是我们定义的 <code>Bean</code> 信息。</p></blockquote></li><li><p><code>DefaultListableBeanFactory factory = new DefaultListableBeanFactory();</code> ：创建一个 BeanFactory 。</p><p><code>DefaultListableBeanFactory</code> 是 <code>BeanFactory</code> 的一个子类，<code>BeanFactory</code> 作为一个接口，其实它本身是不具有独立使用的功能的，而 <code>DefaultListableBeanFactory</code> 则是真正可以独立使用的 <code>IoC</code> 容器，它是整个 <code>Spring IoC</code> 的<strong>始祖</strong>，在后续会有专门的文章来分析它。</p></li><li><p><code>XmlBeanDefinitionReader reader = new XmlBeanDefinitionReader(factory);</code> ：创建 <code>XmlBeanDefinitionReader</code> 读取器，用于载入 <code>BeanDefinition</code> 。</p></li><li><p><code>reader.loadBeanDefinitions(resource);</code>：开始 <code>BeanDefinition</code> 的载入和注册进程，完成后的 <code>BeanDefinition</code> 放置在 <code>IoC</code> 容器中。</p></li></ul><h1 id="1-Resource-定位"><a href="#1-Resource-定位" class="headerlink" title="1. Resource 定位"></a>1. Resource 定位</h1><p>Spring 为了解决资源定位的问题，提供了两个接口：Resource、ResourceLoader，其中：</p><ul><li>Resource 接口是 Spring 统一资源的抽象接口</li><li>ResourceLoader 则是 Spring 资源加载的统一抽象。</li><li>关于Resource、ResourceLoader 的更多知识请关注 <a href="/2020/01/02/8f7aa5ac.html">《IoC 之 Spring 统一资源加载策略》</a></li></ul><p>Resource 资源的定位需要 Resource 和 ResourceLoader 两个接口互相配合，在上面那段代码中 <code>new ClassPathResource(&quot;bean.xml&quot;)</code> 为我们定义了资源，那么 <code>ResourceLoader</code> 则是在什么时候初始化的呢？</p><p>看 <code>XmlBeanDefinitionReader</code> 构造方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// XmlBeanDefinitionReader.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">XmlBeanDefinitionReader</span><span class="params">(BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">super</span>(registry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>直接调用父类 <code>AbstractBeanDefinitionReader</code> 构造方法，代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// AbstractBeanDefinitionReader.java</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">AbstractBeanDefinitionReader</span><span class="params">(BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">Assert.notNull(registry, <span class="string">&quot;BeanDefinitionRegistry must not be null&quot;</span>);</span><br><span class="line"><span class="keyword">this</span>.registry = registry;</span><br><span class="line"><span class="comment">// Determine ResourceLoader to use.</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.registry <span class="keyword">instanceof</span> ResourceLoader) &#123;</span><br><span class="line"><span class="keyword">this</span>.resourceLoader = (ResourceLoader) <span class="keyword">this</span>.registry;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">this</span>.resourceLoader = <span class="keyword">new</span> PathMatchingResourcePatternResolver();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Inherit Environment if possible</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.registry <span class="keyword">instanceof</span> EnvironmentCapable) &#123;</span><br><span class="line"><span class="keyword">this</span>.environment = ((EnvironmentCapable) <span class="keyword">this</span>.registry).getEnvironment();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">this</span>.environment = <span class="keyword">new</span> StandardEnvironment();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>核心在于设置 <code>resourceLoader</code> 这段，如果设置了 <code>ResourceLoader</code> 则用设置的，否则使用 <code>PathMatchingResourcePatternResolver</code> ，该类是一个集大成者的 <code>ResourceLoader</code>。</li></ul></li></ul><h1 id="2-BeanDefinition-的载入和解析"><a href="#2-BeanDefinition-的载入和解析" class="headerlink" title="2. BeanDefinition 的载入和解析"></a>2. BeanDefinition 的载入和解析</h1><p><code>reader.loadBeanDefinitions(resource);</code> 代码段，开启 <code>BeanDefinition</code> 的解析过程。如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// XmlBeanDefinitionReader.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">loadBeanDefinitions</span><span class="params">(Resource resource)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line"><span class="keyword">return</span> loadBeanDefinitions(<span class="keyword">new</span> EncodedResource(resource));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>在这个方法会将资源 <code>resource</code> 包装成一个 <code>EncodedResource</code> 实例对象，然后调用 <code>#loadBeanDefinitions(EncodedResource encodedResource)</code> 方法。</p><p>而将 <code>Resource</code> 封装成 <code>EncodedResource</code> 主要是为了对 <code>Resource</code> 进行编码，保证内容读取的正确性。代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="comment">// XmlBeanDefinitionReader.java</span></span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">loadBeanDefinitions</span><span class="params">(EncodedResource encodedResource)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line">  <span class="comment">// ... 省略一些代码</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">// 将资源文件转为 InputStream 的 IO 流</span></span><br><span class="line">  InputStream inputStream = encodedResource.getResource().getInputStream();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">// 从 InputStream 中得到 XML 的解析源</span></span><br><span class="line">  InputSource inputSource = <span class="keyword">new</span> InputSource(inputStream);</span><br><span class="line">  <span class="keyword">if</span> (encodedResource.getEncoding() != <span class="keyword">null</span>) &#123;</span><br><span class="line">  inputSource.setEncoding(encodedResource.getEncoding());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ... 具体的读取过程</span></span><br><span class="line">  <span class="keyword">return</span> doLoadBeanDefinitions(inputSource, encodedResource.getResource());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">finally</span> &#123;</span><br><span class="line">  inputStream.close();</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 省略一些代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>从 <code>encodedResource</code> 源中获取 <code>xml</code> 的解析源，然后调用 <code>#doLoadBeanDefinitions(InputSource inputSource, Resource resource)</code> 方法，执行具体的解析过程。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="comment">// XmlBeanDefinitionReader.java</span></span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">doLoadBeanDefinitions</span><span class="params">(InputSource inputSource, Resource resource)</span></span></span><br><span class="line"><span class="function">  <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">// 获取 XML Document 实例</span></span><br><span class="line">  Document doc = doLoadDocument(inputSource, resource);</span><br><span class="line">  <span class="comment">// 根据 Document 实例，注册 Bean 信息</span></span><br><span class="line">  <span class="keyword">int</span> count = registerBeanDefinitions(doc, resource);</span><br><span class="line">  <span class="keyword">return</span> count;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ... 省略一堆配置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在该方法中主要做两件事：</li><li>1、根据 <code>xml</code> 解析源获取相应的 <code>Document</code> 对象。</li><li>2、调用 <code>#registerBeanDefinitions(Document doc, Resource resource)</code> 方法，开启 BeanDefinition 的解析注册过程。</li></ul></li></ul></li></ul><h2 id="2-1-转换为-Document-对象"><a href="#2-1-转换为-Document-对象" class="headerlink" title="2.1 转换为 Document 对象"></a>2.1 转换为 Document 对象</h2><p>调用 <code>#doLoadDocument(InputSource inputSource, Resource resource)</code> 方法，会将 <code>Bean</code> 定义的资源转换为 <code>Document</code> 对象。代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// XmlBeanDefinitionReader.java</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Document <span class="title">doLoadDocument</span><span class="params">(InputSource inputSource, Resource resource)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.documentLoader.loadDocument(inputSource, getEntityResolver(), <span class="keyword">this</span>.errorHandler,</span><br><span class="line">getValidationModeForResource(resource), isNamespaceAware());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法接受五个参数：</p><ul><li><p><code>inputSource</code> ：加载 <code>Document</code> 的 <code>Resource</code> 源。</p></li><li><p><code>entityResolver</code>：解析文件的解析器。</p><ul><li>【重要】详细解析，见 <a href="/2020/01/05/13336b20.html">《 IoC 之获取 Document 对象》</a> 。</li></ul></li><li><p><code>errorHandler</code> ：处理加载 <code>Document</code> 对象的过程的错误。</p></li><li><p> <code>validationMode</code> ：验证模式。</p></li><li><p>【重要】详细解析，见 <a href="/2020/01/04/4e0696ee.html">《 IoC 之获取验证模型》</a> 。</p></li><li><p><code>namespaceAware</code> ：命名空间支持。如果要提供对 XML 名称空间的支持，则为 <code>true</code> 。</p></li></ul><hr><p><code>#loadDocument(InputSource inputSource, EntityResolver entityResolver, ErrorHandler errorHandler, int validationMode, boolean namespaceAware)</code> 方法，在类 DefaultDocumentLoader 中提供了实现。代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// DefaultDocumentLoader.java</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Document <span class="title">loadDocument</span><span class="params">(InputSource inputSource, EntityResolver entityResolver,</span></span></span><br><span class="line"><span class="function"><span class="params">ErrorHandler errorHandler, <span class="keyword">int</span> validationMode, <span class="keyword">boolean</span> namespaceAware)</span> </span></span><br><span class="line"><span class="function">  <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="comment">// 创建 DocumentBuilderFactory</span></span><br><span class="line">DocumentBuilderFactory factory = createDocumentBuilderFactory(validationMode, namespaceAware);</span><br><span class="line"><span class="comment">// 创建 DocumentBuilder</span></span><br><span class="line">DocumentBuilder builder = </span><br><span class="line">    createDocumentBuilder(factory, entityResolver, errorHandler);</span><br><span class="line"><span class="comment">// 解析 XML InputSource 返回 Document 对象</span></span><br><span class="line"><span class="keyword">return</span> builder.parse(inputSource);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-2-注册-BeanDefinition-流程"><a href="#2-2-注册-BeanDefinition-流程" class="headerlink" title="2.2 注册 BeanDefinition 流程"></a>2.2 注册 BeanDefinition 流程</h2><p>这到这里，就已经将定义的 <code>Bean</code> 资源文件，载入并转换为 <code>Document</code> 对象了。</p><p>那么，下一步就是如何将其解析为 <code>SpringIoC</code> 管理的 <code>BeanDefinition</code> 对象，并将其注册到容器中。</p><p>这个过程由方法 <code>#registerBeanDefinitions(Document doc, Resource resource)</code> 方法来实现。代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// XmlBeanDefinitionReader.java</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">registerBeanDefinitions</span><span class="params">(Document doc, Resource resource)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line"><span class="comment">// 创建 BeanDefinitionDocumentReader 对象</span></span><br><span class="line">BeanDefinitionDocumentReader documentReader = createBeanDefinitionDocumentReader();</span><br><span class="line"><span class="comment">// 获取已注册的 BeanDefinition 数量</span></span><br><span class="line"><span class="keyword">int</span> countBefore = getRegistry().getBeanDefinitionCount();</span><br><span class="line"><span class="comment">// 创建 XmlReaderContext 对象</span></span><br><span class="line"><span class="comment">// 注册 BeanDefinition</span></span><br><span class="line">documentReader.registerBeanDefinitions(doc, createReaderContext(resource));</span><br><span class="line"><span class="comment">// 计算新注册的 BeanDefinition 数量</span></span><br><span class="line"><span class="keyword">return</span> getRegistry().getBeanDefinitionCount() - countBefore;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>首先，创建 <code>BeanDefinition</code> 的解析器 <code>BeanDefinitionDocumentReader</code> 。</p></li><li><p>然后，调用该 <code>BeanDefinitionDocumentReader</code> 的 <code>#registerBeanDefinitions(Document doc, XmlReaderContext readerContext)</code> 方法，开启解析过程，这里使用的是委派模式，具体的实现由子类 <code>DefaultBeanDefinitionDocumentReader</code> 完成。代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// DefaultBeanDefinitionDocumentReader.java</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(Document doc, XmlReaderContext readerContext)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.readerContext = readerContext;</span><br><span class="line">    <span class="comment">// 获得 XML Document Root Element</span></span><br><span class="line">    <span class="comment">// 执行注册 BeanDefinition</span></span><br><span class="line">    doRegisterBeanDefinitions(doc.getDocumentElement());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-2-1-对-Document-对象的解析"><a href="#2-2-1-对-Document-对象的解析" class="headerlink" title="2.2.1 对 Document 对象的解析"></a>2.2.1 对 Document 对象的解析</h3><p>从 <code>Document</code> 对象中获取根元素 <code>root</code>，然后调用 ``#doRegisterBeanDefinitions(Element root)` 方法，开启真正的解析过程。代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// DefaultBeanDefinitionDocumentReader.java</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doRegisterBeanDefinitions</span><span class="params">(Element root)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ... 省略部分代码（非核心）</span></span><br><span class="line">    <span class="keyword">this</span>.delegate = createDelegate(getReaderContext(), root, parent);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析前处理</span></span><br><span class="line">    preProcessXml(root);</span><br><span class="line">    <span class="comment">// 解析</span></span><br><span class="line">    parseBeanDefinitions(root, <span class="keyword">this</span>.delegate);</span><br><span class="line">    <span class="comment">// 解析后处理</span></span><br><span class="line">    postProcessXml(root);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><code>#preProcessXml(Element root)</code>、<code>#postProcessXml(Element root)</code> 为前置、后置增强处理，目前 Spring 中都是空实现。</p></li><li><p><code>#parseBeanDefinitions(Element root, BeanDefinitionParserDelegate delegate)</code> 是对根元素 root 的解析注册过程。代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// DefaultBeanDefinitionDocumentReader.java</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">parseBeanDefinitions</span><span class="params">(Element root, BeanDefinitionParserDelegate delegate)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果根节点使用默认命名空间，执行默认解析</span></span><br><span class="line">    <span class="keyword">if</span> (delegate.isDefaultNamespace(root)) &#123;</span><br><span class="line">        <span class="comment">// 遍历子节点</span></span><br><span class="line">        NodeList nl = root.getChildNodes();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nl.getLength(); i++) &#123;</span><br><span class="line">            Node node = nl.item(i);</span><br><span class="line">            <span class="keyword">if</span> (node <span class="keyword">instanceof</span> Element) &#123;</span><br><span class="line">                Element ele = (Element) node;</span><br><span class="line">                <span class="comment">// 如果该节点使用默认命名空间，执行默认解析</span></span><br><span class="line">                <span class="keyword">if</span> (delegate.isDefaultNamespace(ele)) &#123;</span><br><span class="line">                    parseDefaultElement(ele, delegate);</span><br><span class="line">                <span class="comment">// 如果该节点非默认命名空间，执行自定义解析</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    delegate.parseCustomElement(ele);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">// 如果根节点非默认命名空间，执行自定义解析</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        delegate.parseCustomElement(root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>迭代 root 元素的所有子节点，对其进行判断：<ul><li>若节点为默认命名空间，则调用 <code>#parseDefaultElement(Element ele, BeanDefinitionParserDelegate delegate)</code> 方法，开启默认标签的解析注册过程。</li><li>否则，调用 <code>BeanDefinitionParserDelegate#parseCustomElement(Element ele)</code> 方法，开启自定义标签的解析注册过程。</li></ul></li></ul></li></ul><h4 id="2-2-1-1-默认标签解析"><a href="#2-2-1-1-默认标签解析" class="headerlink" title="2.2.1.1 默认标签解析"></a>2.2.1.1 默认标签解析</h4><p>若定义的元素节点使用的是 <code>Spring</code> 默认命名空间，则调用 <code>#parseDefaultElement(Element ele, BeanDefinitionParserDelegate delegate)</code> 方法，进行默认标签解析。代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// DefaultBeanDefinitionDocumentReader.java</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parseDefaultElement</span><span class="params">(Element ele, BeanDefinitionParserDelegate delegate)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (delegate.nodeNameEquals(ele, IMPORT_ELEMENT)) &#123; <span class="comment">// import</span></span><br><span class="line">importBeanDefinitionResource(ele);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (delegate.nodeNameEquals(ele, ALIAS_ELEMENT)) &#123; <span class="comment">// alias</span></span><br><span class="line">processAliasRegistration(ele);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (delegate.nodeNameEquals(ele, BEAN_ELEMENT)) &#123; <span class="comment">// bean</span></span><br><span class="line">processBeanDefinition(ele, delegate);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (delegate.nodeNameEquals(ele, NESTED_BEANS_ELEMENT)) &#123; <span class="comment">// beans</span></span><br><span class="line"><span class="comment">// recurse</span></span><br><span class="line">doRegisterBeanDefinitions(ele);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对四大标签：<code>import</code>、<code>alias</code>、<code>bean</code>、<code>beans</code>进行解析。<strong>其中 <code>bean</code> 标签的解析为核心工作</strong>。</p><h4 id="2-2-1-2-自定义标签解析"><a href="#2-2-1-2-自定义标签解析" class="headerlink" title="2.2.1.2 自定义标签解析"></a>2.2.1.2 自定义标签解析</h4><p>对于默认标签则由 <code>parseCustomElement(Element ele)</code> 方法，负责解析。代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// BeanDefinitionParserDelegate.java</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BeanDefinition <span class="title">parseCustomElement</span><span class="params">(Element ele)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> parseCustomElement(ele, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BeanDefinition <span class="title">parseCustomElement</span><span class="params">(Element ele, </span></span></span><br><span class="line"><span class="function"><span class="params">                                         <span class="meta">@Nullable</span> BeanDefinition containingBd)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取 namespaceUri</span></span><br><span class="line">    String namespaceUri = getNamespaceURI(ele);</span><br><span class="line">    <span class="keyword">if</span> (namespaceUri == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 根据 namespaceUri 获取相应的 Handler</span></span><br><span class="line">    NamespaceHandler handler = <span class="keyword">this</span>.readerContext.getNamespaceHandlerResolver().resolve(namespaceUri);</span><br><span class="line">    <span class="keyword">if</span> (handler == <span class="keyword">null</span>) &#123;</span><br><span class="line">        error(<span class="string">&quot;Unable to locate Spring NamespaceHandler for XML schema namespace [&quot;</span> + namespaceUri + <span class="string">&quot;]&quot;</span>, ele);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 调用自定义的 Handler 处理</span></span><br><span class="line">    <span class="keyword">return</span> handler.parse(ele, <span class="keyword">new</span> ParserContext(<span class="keyword">this</span>.readerContext, <span class="keyword">this</span>, containingBd));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取节点的 <code>namespaceUri</code>，然后根据该 <code>namespaceUri</code> 获取相对应的 <code>NamespaceHandler</code>，最后调用 <code>NamespaceHandler</code> 的 <code>#parse(Element element, ParserContext parserContext)</code> 方法，<code>即完成自定义标签的解析和注入</code>。</p><h3 id="2-2-2-注册-BeanDefinition"><a href="#2-2-2-注册-BeanDefinition" class="headerlink" title="2.2.2 注册 BeanDefinition"></a>2.2.2 注册 BeanDefinition</h3><p>经过上面的解析，则将 <code>Document</code> 对象里面的 <code>Bean</code> 标签解析成了一个个的 <code>BeanDefinition</code> ，下一步则是将这些 <code>BeanDefinition</code> 注册到 <code>IoC</code> 容器中。动作的触发是在解析 <code>Bean</code> 标签完成后，代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// DefaultBeanDefinitionDocumentReader.java</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">processBeanDefinition</span><span class="params">(Element ele, </span></span></span><br><span class="line"><span class="function"><span class="params">                                     BeanDefinitionParserDelegate delegate)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 进行 bean 元素解析。</span></span><br><span class="line">    <span class="comment">// 如果解析成功，则返回 BeanDefinitionHolder 对象。</span></span><br><span class="line">    <span class="comment">// 而 BeanDefinitionHolder 为 name 和 alias 的 BeanDefinition 对象</span></span><br><span class="line">    <span class="comment">// 如果解析失败，则返回 null 。</span></span><br><span class="line">    BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);</span><br><span class="line">    <span class="keyword">if</span> (bdHolder != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 进行自定义标签处理</span></span><br><span class="line">        bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 进行 BeanDefinition 的注册</span></span><br><span class="line">            <span class="comment">// Register the final decorated instance.</span></span><br><span class="line">            BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, </span><br><span class="line">                                                     getReaderContext().getRegistry());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (BeanDefinitionStoreException ex) &#123;</span><br><span class="line">            getReaderContext().error(<span class="string">&quot;Failed to register bean definition with name &#x27;&quot;</span> +</span><br><span class="line">                    bdHolder.getBeanName() + <span class="string">&quot;&#x27;&quot;</span>, ele, ex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 发出响应事件，通知相关的监听器，已完成该 Bean 标签的解析。</span></span><br><span class="line">        <span class="comment">// Send registration event.</span></span><br><span class="line">        getReaderContext().fireComponentRegistered(</span><br><span class="line">          <span class="keyword">new</span> BeanComponentDefinition(bdHolder));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>调用 <code>BeanDefinitionReaderUtils.registerBeanDefinition()</code> 方法，来注册。</p><p>其实，这里面也是调用 <code>BeanDefinitionRegistry</code> 的 <code>#registerBeanDefinition(String beanName, BeanDefinition beanDefinition)</code> 方法，来注册 <code>BeanDefinition</code> 。</p><p>不过，最终的实现是在 <code>DefaultListableBeanFactory</code> 中实现，代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// DefaultListableBeanFactory.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinition</span><span class="params">(String beanName, BeanDefinition beanDefinition)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line">    <span class="comment">// ...省略校验相关的代码</span></span><br><span class="line">    <span class="comment">// 从缓存中获取指定 beanName 的 BeanDefinition</span></span><br><span class="line">    BeanDefinition existingDefinition = <span class="keyword">this</span>.beanDefinitionMap.get(beanName);</span><br><span class="line">    <span class="comment">// 如果已经存在</span></span><br><span class="line">    <span class="keyword">if</span> (existingDefinition != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果存在但是不允许覆盖，抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (!isAllowBeanDefinitionOverriding()) &#123;</span><br><span class="line">             <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionOverrideException(beanName, </span><br><span class="line">                                              beanDefinition,existingDefinition);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">// ...省略 logger 打印日志相关的代码</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 【重点】允许覆盖，直接覆盖原有的 BeanDefinition 到 beanDefinitionMap 中。</span></span><br><span class="line">        <span class="keyword">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">    <span class="comment">// 如果未存在</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// ... 省略非核心的代码</span></span><br><span class="line">        <span class="comment">// 【重点】添加到 BeanDefinition 到 beanDefinitionMap 中。</span></span><br><span class="line">        <span class="keyword">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 重新设置 beanName 对应的缓存</span></span><br><span class="line">  <span class="keyword">if</span> (existingDefinition != <span class="keyword">null</span> || containsSingleton(beanName)) &#123;</span><br><span class="line">        resetBeanDefinition(beanName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>这段代码最核心的部分是这句 <code>this.beanDefinitionMap.put(beanName, beanDefinition)</code> 代码段。所以，注册过程也不是那么的高大上，就是利用一个 Map 的集合对象来存放：<code>key</code> 是 <code>beanName</code>，<code>value</code> 是 <code>BeanDefinition</code> 对象。</li></ul></li></ul><h1 id="3-小结"><a href="#3-小结" class="headerlink" title="3. 小结"></a>3. 小结</h1><p>至此，整个 <code>IoC</code> 的初始化过程就已经完成了，从 <code>Bean</code> 资源的定位，转换为 <code>Document</code> 对象，接着对其进行解析，最后注册到 <code>IoC</code> 容器中，都已经完美地完成了。</p><p>现在 <code>IoC</code> 容器中已经建立了整个 <code>Bean</code> 的配置信息，这些 <code>Bean</code> 可以被检索、使用、维护，他们是控制反转的基础，是后面注入 <code>Bean</code> 的依赖。最后用一张流程图来结束这篇总结之文。</p><p><img src="https://cdn.jsdelivr.net/gh/cayzlh/git-img-repository@master/uPic/vRTCJi.jpg" alt="vRTCJi"></p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
          <category> 《Spring源码分析》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> 死磕Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IoC之注册解析的BeanDefinitions</title>
      <link href="/blog/2020/01/13/a9bec556.html"/>
      <url>/blog/2020/01/13/a9bec556.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文作者：chenssy</p><p>出处：<a href="http://cmsblogs.com/?p=2763">http://cmsblogs.com/?p=2763</a></p><p>在学习<code>Spring源码</code>的过程中发现的好站+好贴，感谢作者。Spring版本：<strong>Spring 5.0.6.RELEASE</strong></p></blockquote><hr><p><code>DefaultBeanDefinitionDocumentReader.processBeanDefinition()</code> 完成 <code>Bean</code> 标签解析的核心工作，如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">processBeanDefinition</span><span class="params">(Element ele, </span></span></span><br><span class="line"><span class="function"><span class="params">                                     BeanDefinitionParserDelegate delegate)</span> </span>&#123;</span><br><span class="line">  BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);</span><br><span class="line">  <span class="keyword">if</span> (bdHolder != <span class="keyword">null</span>) &#123;</span><br><span class="line">    bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// Register the final decorated instance.</span></span><br><span class="line">      BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder,</span><br><span class="line">                                                       getReaderContext().getRegistry());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (BeanDefinitionStoreException ex) &#123;</span><br><span class="line">      getReaderContext().error(<span class="string">&quot;Failed to register bean definition with name &#x27;&quot;</span> </span><br><span class="line">                               +</span><br><span class="line">                               bdHolder.getBeanName() + <span class="string">&quot;&#x27;&quot;</span>, ele, ex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Send registration event.</span></span><br><span class="line">    getReaderContext().fireComponentRegistered(</span><br><span class="line">      <span class="keyword">new</span> BeanComponentDefinition(bdHolder));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解析工作分为三步：</p><ol><li>解析默认标签；</li><li>解析默认标签后下得自定义标签；</li><li>注册解析后的 <code>BeanDefinition</code>。</li></ol><p>经过前面两个步骤的解析，这时的 <code>BeanDefinition</code> 已经可以满足后续的使用要求了，那么接下来的工作就是将这些 <code>BeanDefinition</code> 进行注册，也就是完成第三步。 注册 <code>BeanDefinition</code> 由 <code>BeanDefinitionReaderUtils.registerBeanDefinition()</code> 完成。</p><p>如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerBeanDefinition</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry)</span></span></span><br><span class="line"><span class="function">  <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 注册 beanName</span></span><br><span class="line">  String beanName = definitionHolder.getBeanName();</span><br><span class="line">  registry.registerBeanDefinition(beanName, </span><br><span class="line">                                  definitionHolder.getBeanDefinition());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 注册 alias </span></span><br><span class="line">  String[] aliases = definitionHolder.getAliases();</span><br><span class="line">  <span class="keyword">if</span> (aliases != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (String alias : aliases) &#123;</span><br><span class="line">      registry.registerAlias(beanName, alias);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>首先通过 <code>beanName</code> 注册 <code>BeanDefinition</code> ，</li><li>然后再注册别名 <code>alias</code>。</li></ul><blockquote><p><code>BeanDefinition</code> 的注册由接口 <code>BeanDefinitionRegistry</code> 定义。 </p></blockquote><p><strong>通过 beanName 注册</strong> <code>BeanDefinitionRegistry.registerBeanDefinition()</code> 实现通过 <code>beanName</code> 注册 <code>BeanDefinition</code>，如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinition</span><span class="params">(String beanName, </span></span></span><br><span class="line"><span class="function"><span class="params">                                   BeanDefinition beanDefinition)</span></span></span><br><span class="line"><span class="function">  <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 校验 beanName 与 beanDefinition</span></span><br><span class="line">  Assert.hasText(beanName, <span class="string">&quot;Bean name must not be empty&quot;</span>);</span><br><span class="line">  Assert.notNull(beanDefinition, <span class="string">&quot;BeanDefinition must not be null&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (beanDefinition <span class="keyword">instanceof</span> AbstractBeanDefinition) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 校验 BeanDefinition</span></span><br><span class="line">      <span class="comment">// 这是注册前的最后一次校验了，主要是对属性 methodOverrides 进行校验</span></span><br><span class="line">      ((AbstractBeanDefinition) beanDefinition).validate();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (BeanDefinitionValidationException ex) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(</span><br><span class="line">        beanDefinition.getResourceDescription(), </span><br><span class="line">        beanName,<span class="string">&quot;Validation of bean definition failed&quot;</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  BeanDefinition oldBeanDefinition;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 从缓存中获取指定 beanName 的 BeanDefinition</span></span><br><span class="line">  oldBeanDefinition = <span class="keyword">this</span>.beanDefinitionMap.get(beanName);</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 如果存在</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">  <span class="keyword">if</span> (oldBeanDefinition != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果存在但是不允许覆盖，抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (!isAllowBeanDefinitionOverriding()) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(</span><br><span class="line">        beanDefinition.getResourceDescription(), </span><br><span class="line">        beanName,</span><br><span class="line">        <span class="string">&quot;Cannot register bean definition [&quot;</span> </span><br><span class="line">        + beanDefinition + <span class="string">&quot;] for bean &#x27;&quot;</span> </span><br><span class="line">        + beanName +</span><br><span class="line">        <span class="string">&quot;&#x27;: There is already [&quot;</span> + oldBeanDefinition + <span class="string">&quot;] bound.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldBeanDefinition.getRole() &lt; beanDefinition.getRole()) &#123;</span><br><span class="line">      <span class="comment">// e.g. was ROLE_APPLICATION, </span></span><br><span class="line">      <span class="comment">// now overriding with ROLE_SUPPORT or ROLE_INFRASTRUCTURE</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.logger.isWarnEnabled()) &#123;</span><br><span class="line">        <span class="keyword">this</span>.logger.warn(</span><br><span class="line">          <span class="string">&quot;Overriding user-defined bean definition for bean &#x27;&quot;</span> </span><br><span class="line">          + beanName </span><br><span class="line">          + <span class="string">&quot;&#x27; with a framework-generated bean definition: replacing [&quot;</span> </span><br><span class="line">          + oldBeanDefinition + <span class="string">&quot;] with [&quot;</span> + beanDefinition + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 覆盖 beanDefinition 与 被覆盖的 beanDefinition 不是同类</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!beanDefinition.equals(oldBeanDefinition)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.logger.isInfoEnabled()) &#123;</span><br><span class="line">        <span class="keyword">this</span>.logger.info(</span><br><span class="line">          <span class="string">&quot;Overriding bean definition for bean &#x27;&quot;</span> </span><br><span class="line">          + beanName </span><br><span class="line">          + <span class="string">&quot;&#x27; with a different definition: replacing [&quot;</span> </span><br><span class="line">          + oldBeanDefinition </span><br><span class="line">          + <span class="string">&quot;] with [&quot;</span> + beanDefinition + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.logger.isDebugEnabled()) &#123;</span><br><span class="line">        <span class="keyword">this</span>.logger.debug(</span><br><span class="line">          <span class="string">&quot;Overriding bean definition for bean &#x27;&quot;</span> </span><br><span class="line">          + beanName </span><br><span class="line">          + <span class="string">&quot;&#x27; with an equivalent definition: replacing [&quot;</span> </span><br><span class="line">          + oldBeanDefinition </span><br><span class="line">          + <span class="string">&quot;] with [&quot;</span> + beanDefinition + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 允许覆盖，直接覆盖原有的 BeanDefinition</span></span><br><span class="line">    <span class="keyword">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 不存在</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检测创建 Bean 阶段是否已经开启，如果开启了则需要对 beanDefinitionMap 进行并发控制</span></span><br><span class="line">    <span class="keyword">if</span> (hasBeanCreationStarted()) &#123;</span><br><span class="line">      <span class="comment">// beanDefinitionMap 为全局变量，避免并发情况</span></span><br><span class="line">      <span class="keyword">synchronized</span> (<span class="keyword">this</span>.beanDefinitionMap) &#123;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="keyword">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">        List&lt;String&gt; updatedDefinitions = </span><br><span class="line">          <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="keyword">this</span>.beanDefinitionNames.size() + <span class="number">1</span>);</span><br><span class="line">        updatedDefinitions.addAll(<span class="keyword">this</span>.beanDefinitionNames);</span><br><span class="line">        updatedDefinitions.add(beanName);</span><br><span class="line">        <span class="keyword">this</span>.beanDefinitionNames = updatedDefinitions;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.manualSingletonNames.contains(beanName)) &#123;</span><br><span class="line">          Set&lt;String&gt; updatedSingletons = </span><br><span class="line">            <span class="keyword">new</span> LinkedHashSet&lt;&gt;(<span class="keyword">this</span>.manualSingletonNames);</span><br><span class="line">          updatedSingletons.remove(beanName);</span><br><span class="line">          <span class="keyword">this</span>.manualSingletonNames = updatedSingletons;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 不会存在并发情况，直接设置</span></span><br><span class="line">      <span class="keyword">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">      <span class="keyword">this</span>.beanDefinitionNames.add(beanName);</span><br><span class="line">      <span class="keyword">this</span>.manualSingletonNames.remove(beanName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.frozenBeanDefinitionNames = <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (oldBeanDefinition != <span class="keyword">null</span> || containsSingleton(beanName)) &#123;</span><br><span class="line">    <span class="comment">// 重新设置 beanName 对应的缓存</span></span><br><span class="line">    resetBeanDefinition(beanName);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>处理过程如下：</p><ul><li>首先 <code>BeanDefinition</code> 进行校验，该校验也是注册过程中的最后一次校验了，主要是对 <code>AbstractBeanDefinition</code> 的 <code>methodOverrides</code> 属性进行校验</li><li>根据 <code>beanName</code> 从缓存中获取 <code>BeanDefinition</code>，如果缓存中存在，则根据 allowBeanDefinitionOverriding 标志来判断是否允许覆盖，如果允许则直接覆盖，否则抛出 BeanDefinitionStoreException 异常</li><li>若缓存中没有指定 <code>beanName</code> 的 <code>BeanDefinition</code>，则判断当前阶段是否已经开始了 <code>Bean</code> 的创建阶段&lt;&gt;，如果是，则需要对 <code>beanDefinitionMap</code> 进行加锁控制并发问题，否则直接设置即可。对于 <code>hasBeanCreationStarted()</code> 方法后续做详细介绍，这里不过多阐述。</li><li>若缓存中存在该 <code>beanName</code> 或者 单利 <code>bean</code> 集合中存在该 <code>beanName</code>，则调用 <code>resetBeanDefinition()</code> 重置 <code>BeanDefinition</code> 缓存。</li></ul><p>其实整段代码的核心就在于 <code>this.beanDefinitionMap.put(beanName, beanDefinition);</code> 。</p><blockquote><p><code>BeanDefinition</code> 的缓存也不是神奇的东西，就是定义 <code>map</code> ，<code>key</code> 为 <code>beanName</code>，<code>value</code> 为 <code>BeanDefinition</code>。 </p></blockquote><p><strong>注册 alias</strong> <code>BeanDefinitionRegistry.registerAlias</code> 完成 <code>alias</code> 的注册。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerAlias</span><span class="params">(String name, String alias)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 校验 name 、 alias</span></span><br><span class="line">  Assert.hasText(name, <span class="string">&quot;&#x27;name&#x27; must not be empty&quot;</span>);</span><br><span class="line">  Assert.hasText(alias, <span class="string">&quot;&#x27;alias&#x27; must not be empty&quot;</span>);</span><br><span class="line">  <span class="keyword">synchronized</span> (<span class="keyword">this</span>.aliasMap) &#123;</span><br><span class="line">    <span class="comment">// name == alias 则去掉alias</span></span><br><span class="line">    <span class="keyword">if</span> (alias.equals(name)) &#123;</span><br><span class="line">      <span class="keyword">this</span>.aliasMap.remove(alias);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 缓存缓存记录</span></span><br><span class="line">      String registeredName = <span class="keyword">this</span>.aliasMap.get(alias);</span><br><span class="line">      <span class="keyword">if</span> (registeredName != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 缓存中的相等，则直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (registeredName.equals(name)) &#123;</span><br><span class="line">          <span class="comment">// An existing alias - no need to re-register</span></span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 不允许则抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (!allowAliasOverriding()) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">            <span class="string">&quot;Cannot register alias &#x27;&quot;</span> + alias + <span class="string">&quot;&#x27; for name &#x27;&quot;</span> </span><br><span class="line">            + name + <span class="string">&quot;&#x27;: It is already registered for name &#x27;&quot;</span> </span><br><span class="line">            + registeredName + <span class="string">&quot;&#x27;.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 当 A --&gt; B 存在时，如果再次出现 A --&gt; B --&gt; C 则抛出异常</span></span><br><span class="line">      checkForAliasCircle(name, alias);</span><br><span class="line">      <span class="comment">// 注册 alias</span></span><br><span class="line">      <span class="keyword">this</span>.aliasMap.put(alias, name);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注册 <code>alias</code> 和注册 <code>BeanDefinition</code> 的过程差不多。在最后调用了 <code>checkForAliasCircle()</code> 来对别名进行了检测。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasAlias</span><span class="params">(String name, String alias)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (Map.Entry&lt;String, String&gt; entry : <span class="keyword">this</span>.aliasMap.entrySet()) &#123;</span><br><span class="line">    String registeredName = entry.getValue();</span><br><span class="line">    <span class="keyword">if</span> (registeredName.equals(name)) &#123;</span><br><span class="line">      String registeredAlias = entry.getKey();</span><br><span class="line">      <span class="keyword">return</span> (registeredAlias.equals(alias) || hasAlias(registeredAlias, alias));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果 <code>name</code> 、 <code>alias</code> 为 <strong>1</strong> 、<strong>3</strong> ，则构成 <strong>（1,3）</strong>，加入集合中存在<strong>（A,1）</strong>、<strong>（3,A）</strong>的情况则会出错。 到这里 <code>BeanDefinition</code>、<code>alias</code> 都已经注入到缓存中，下一步则是等待初始化使用了。</p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
          <category> 《Spring源码分析》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> 死磕Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IoC之解析bean标签：解析自定义标签</title>
      <link href="/blog/2020/01/12/61e43345.html"/>
      <url>/blog/2020/01/12/61e43345.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文作者：chenssy</p><p>出处：<a href="http://cmsblogs.com/?p=2841">http://cmsblogs.com/?p=2841</a></p><p>在学习<code>Spring源码</code>的过程中发现的好站+好贴，感谢作者。Spring版本：<strong>Spring 5.0.6.RELEASE</strong></p></blockquote><hr><p>获取 <code>Document</code> 对象后，会根据该对象和 <code>Resource</code> 资源对象调用 <code>registerBeanDefinitions()</code> 方法，开始注册 <code>BeanDefinitions</code> 之旅。在注册 <code>BeanDefinitions</code> 过程中会调用 <code>parseBeanDefinitions()</code> 开启 <code>BeanDefinition</code> 的解析过程。在该方法中，它会根据命名空间的不同调用不同的方法进行解析，如果是默认的命名空间，则调用 <code>parseDefaultElement()</code> 进行默认标签解析，否则调用 <code>parseCustomElement()</code> 方法进行自定义标签解析。</p><h2 id="使用自定义标签"><a href="#使用自定义标签" class="headerlink" title="使用自定义标签"></a>使用自定义标签</h2><p>扩展 <code>Spring</code> 自定义标签配置一般需要以下几个步骤：</p><ol><li>创建一个需要扩展的组件</li><li>定义一个 <code>XSD</code> 文件，用于描述组件内容</li><li>创建一个实现 <code>AbstractSingleBeanDefinitionParser</code> 接口的类，用来解析 <code>XSD</code> 文件中的定义和组件定义</li><li>创建一个 <code>Handler</code>，继承 <code>NamespaceHandlerSupport</code> ，用于将组件注册到 Spring 容器</li><li>编写 <code>Spring.handlers</code> 和 <code>Spring.schemas</code> 文件</li></ol><p>下面就按照上面的步骤来实现一个自定义标签组件。 <strong>创建组件</strong> 该组件就是一个普通的 <code>JavaBean</code>，没有任何特别之处。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="定义-XSD-文件"><a href="#定义-XSD-文件" class="headerlink" title="定义 XSD 文件"></a>定义 XSD 文件</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">xsd:schema</span> <span class="attr">xmlns:xsd</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">xmlns</span>=<span class="string">&quot;http://www.cmsblogs.com/schema/user&quot;</span> <span class="attr">targetNamespace</span>=<span class="string">&quot;http://www.cmsblogs.com/schema/user&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">elementFormDefault</span>=<span class="string">&quot;qualified&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xsd:element</span> <span class="attr">name</span>=<span class="string">&quot;user&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">xsd:complexType</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">xsd:attribute</span> <span class="attr">name</span>=<span class="string">&quot;id&quot;</span> <span class="attr">type</span>=<span class="string">&quot;xsd:string&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">xsd:attribute</span> <span class="attr">name</span>=<span class="string">&quot;userName&quot;</span> <span class="attr">type</span>=<span class="string">&quot;xsd:string&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">xsd:attribute</span> <span class="attr">name</span>=<span class="string">&quot;email&quot;</span> <span class="attr">type</span>=<span class="string">&quot;xsd:string&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">xsd:complexType</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">xsd:element</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">xsd:schema</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上面除了对 <code>User</code> 这个 <code>JavaBean</code> 进行了描述外，还定义了 <code>xmlns=&quot;http://www.cmsblogs.com/schema/user&quot; targetNamespace=&quot;http://www.cmsblogs.com/schema/user&quot;</code> 这两个值，这两个值在后面是有大作用的。</p><h4 id="Parser-类"><a href="#Parser-类" class="headerlink" title="Parser 类"></a>Parser 类</h4><p>定义一个 <code>Parser</code> 类，该类继承 <code>AbstractSingleBeanDefinitionParser</code> ，并实现 <code>getBeanClass()</code> 和 <code>doParse()</code> 两个方法。主要是用于解析 XSD 文件中的定义和组件定义。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDefinitionParser</span> <span class="keyword">extends</span> <span class="title">AbstractSingleBeanDefinitionParser</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; getBeanClass(Element element) &#123;</span><br><span class="line">        <span class="keyword">return</span> User.class;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doParse</span><span class="params">(Element element, BeanDefinitionBuilder builder)</span> </span>&#123;</span><br><span class="line">        String id = element.getAttribute(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">        String userName=element.getAttribute(<span class="string">&quot;userName&quot;</span>);</span><br><span class="line">        String email=element.getAttribute(<span class="string">&quot;email&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(StringUtils.hasText(id))&#123;</span><br><span class="line">            builder.addPropertyValue(<span class="string">&quot;id&quot;</span>,id);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(StringUtils.hasText(userName))&#123;</span><br><span class="line">            builder.addPropertyValue(<span class="string">&quot;userName&quot;</span>, userName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(StringUtils.hasText(email))&#123;</span><br><span class="line">            builder.addPropertyValue(<span class="string">&quot;email&quot;</span>, email);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Handler-类"><a href="#Handler-类" class="headerlink" title="Handler 类"></a>Handler 类</h4><p>定义 Handler 类，继承 NamespaceHandlerSupport ,主要目的是将组件注册到 Spring 容器中。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserNamespaceHandler</span> <span class="keyword">extends</span> <span class="title">NamespaceHandlerSupport</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        registerBeanDefinitionParser(<span class="string">&quot;user&quot;</span>,<span class="keyword">new</span> UserDefinitionParser());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Spring-handlers"><a href="#Spring-handlers" class="headerlink" title="Spring.handlers"></a>Spring.handlers</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">http://www.cmsblogs.com/schema/user=org.springframework.core.customelement.UserNamespaceHandler</span><br></pre></td></tr></table></figure><h4 id="Spring-schemas"><a href="#Spring-schemas" class="headerlink" title="Spring.schemas"></a>Spring.schemas</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">http://www.cmsblogs.com/schema/user.xsd=user.xsd</span><br></pre></td></tr></table></figure><p>经过上面几个步骤，就可以使用自定义的标签了。在 <code>xml</code> 配置文件中使用如下：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:myTag</span>=<span class="string">&quot;http://www.cmsblogs.com/schema/user&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.cmsblogs.com/schema/user http://www.cmsblogs.com/schema/user.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">myTag:user</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">email</span>=<span class="string">&quot;12233445566@qq.com&quot;</span> <span class="attr">userName</span>=<span class="string">&quot;chenssy&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">  ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;spring.xml&quot;</span>);</span><br><span class="line"></span><br><span class="line">  User user = (User) context.getBean(<span class="string">&quot;user&quot;</span>);</span><br><span class="line"></span><br><span class="line">  System.out.println(user.getUserName() + <span class="string">&quot;----&quot;</span> + user.getEmail());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://gitee.com/cayzlh/img-repo/raw/master/uPic/OFykq0.jpg" alt="运行结果"></p><h2 id="解析自定义标签"><a href="#解析自定义标签" class="headerlink" title="解析自定义标签"></a>解析自定义标签</h2><p>上面已经演示了 <code>Spring</code> 自定义标签的使用，下面就来分析自定义标签的解析过程。<code>DefaultBeanDefinitionDocumentReader.parseBeanDefinitions()</code> 负责标签的解析工作，其中它根据命名空间的不同进行不同标签的解析，其中自定义标签由 <code>delegate.parseCustomElement()</code> 实现。如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> BeanDefinition <span class="title">parseCustomElement</span><span class="params">(Element ele)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> parseCustomElement(ele, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用 <code>parseCustomElement()</code> 方法，如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> BeanDefinition <span class="title">parseCustomElement</span><span class="params">(Element ele, </span></span></span><br><span class="line"><span class="function"><span class="params">                                         <span class="meta">@Nullable</span> BeanDefinition containingBd)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 获取 namespaceUri</span></span><br><span class="line">  String namespaceUri = getNamespaceURI(ele);</span><br><span class="line">  <span class="keyword">if</span> (namespaceUri == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 根据 namespaceUri 获取相应的 Handler</span></span><br><span class="line">  NamespaceHandler handler = <span class="keyword">this</span>.readerContext.getNamespaceHandlerResolver().resolve(namespaceUri);</span><br><span class="line">  <span class="keyword">if</span> (handler == <span class="keyword">null</span>) &#123;</span><br><span class="line">    error(<span class="string">&quot;Unable to locate Spring NamespaceHandler for XML schema namespace [&quot;</span> </span><br><span class="line">          + namespaceUri + <span class="string">&quot;]&quot;</span>, ele);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 调用自定义的 Handler 处理</span></span><br><span class="line">  <span class="keyword">return</span> handler.parse(ele, <span class="keyword">new</span> ParserContext(<span class="keyword">this</span>.readerContext, <span class="keyword">this</span>, containingBd));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>处理过程分为三步：</p><ol><li>获取 <code>namespaceUri</code></li><li>根据 <code>namespaceUri</code> 获取相应的 <code>Handler</code></li><li>调用自定义的 <code>Handler</code> 处理</li></ol><p>这个处理过程很简单明了，根据 namespaceUri 获取 Handler，这个映射关系我们在 Spring.handlers 中已经定义了，所以只需要找到该类，然后初始化返回，最后调用该 Handler 对象的 <code>parse()</code> 方法处理，该方法我们也提供了实现。所以上面的核心就在于怎么找到该 Handler 类。调用方法为：<code>this.readerContext.getNamespaceHandlerResolver().resolve(namespaceUri)``getNamespaceHandlerResolver()</code> 方法返回的命名空间的解析器，该解析定义在 <code>XmlReaderContext</code> 中，如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> NamespaceHandlerResolver <span class="title">getNamespaceHandlerResolver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.namespaceHandlerResolver;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这里直接返回，那是在什么时候初始化的呢？</p></blockquote><p>这里需要回退到博文：<a href="/2020/01/13/9de498cf.html">IoC之注册BeanDefinitions</a> ，在这篇博客中提到在注册 <code>BeanDefinition</code> 时：</p><ul><li>首先是通过 <code>createBeanDefinitionDocumentReader()</code> 获取 <code>Document</code> 解析器 <code>BeanDefinitionDocumentReader</code> 实例</li><li>然后调用该实例 <code>registerBeanDefinitions()</code> 方法进行注册。</li></ul><p><code>registerBeanDefinitions()</code>方法需要提供两个参数：</p><ul><li>一个是 <code>Document</code> 实例 <code>doc</code></li><li>一个是 XmlReaderContext 实例 readerContext</li></ul><p><code>readerContext</code> 实例对象由 <code>createReaderContext()</code> 方法提供。<code>namespaceHandlerResolver</code> 实例对象就是在这个时候初始化的。如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> XmlReaderContext <span class="title">createReaderContext</span><span class="params">(Resource resource)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> XmlReaderContext(resource, <span class="keyword">this</span>.problemReporter, <span class="keyword">this</span>.eventListener,</span><br><span class="line">                              <span class="keyword">this</span>.sourceExtractor, <span class="keyword">this</span>, getNamespaceHandlerResolver());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>XmlReaderContext</code> 构造函数中最后一个参数就是 <code>NamespaceHandlerResolver</code> 对象，该对象由 <code>getNamespaceHandlerResolver()</code> 提供，如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> NamespaceHandlerResolver <span class="title">getNamespaceHandlerResolver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.namespaceHandlerResolver == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.namespaceHandlerResolver = createDefaultNamespaceHandlerResolver();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.namespaceHandlerResolver;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> NamespaceHandlerResolver <span class="title">createDefaultNamespaceHandlerResolver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ClassLoader cl = (getResourceLoader() != </span><br><span class="line">                    <span class="keyword">null</span> ? getResourceLoader().getClassLoader() : getBeanClassLoader());</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> DefaultNamespaceHandlerResolver(cl);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以 <code>getNamespaceHandlerResolver().resolve(namespaceUri)</code> 调用的就是 <code>DefaultNamespaceHandlerResolver</code> 的 <code>resolve()</code>。如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> NamespaceHandler <span class="title">resolve</span><span class="params">(String namespaceUri)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 获取所有已经配置的 Handler 映射</span></span><br><span class="line">  Map&lt;String, Object&gt; handlerMappings = getHandlerMappings();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 根据 namespaceUri 获取 handler的信息：这里一般都是类路径</span></span><br><span class="line">  Object handlerOrClassName = handlerMappings.get(namespaceUri);</span><br><span class="line">  <span class="keyword">if</span> (handlerOrClassName == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (handlerOrClassName <span class="keyword">instanceof</span> NamespaceHandler) &#123;</span><br><span class="line">    <span class="comment">// 如果已经做过解析，直接返回</span></span><br><span class="line">    <span class="keyword">return</span> (NamespaceHandler) handlerOrClassName;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    String className = (String) handlerOrClassName;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">      Class&lt;?&gt; handlerClass = ClassUtils.forName(className, <span class="keyword">this</span>.classLoader);</span><br><span class="line">      <span class="keyword">if</span> (!NamespaceHandler.class.isAssignableFrom(handlerClass)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> FatalBeanException(<span class="string">&quot;Class [&quot;</span> </span><br><span class="line">                                     + className + <span class="string">&quot;] for namespace [&quot;</span> + namespaceUri +</span><br><span class="line">                                     <span class="string">&quot;] does not implement the [&quot;</span> </span><br><span class="line">                                     + NamespaceHandler.class.getName() + <span class="string">&quot;] interface&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 初始化类</span></span><br><span class="line">      NamespaceHandler namespaceHandler = </span><br><span class="line">        (NamespaceHandler) BeanUtils.instantiateClass(handlerClass);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 调用 init() 方法</span></span><br><span class="line">      namespaceHandler.init();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 记录在缓存</span></span><br><span class="line">      handlerMappings.put(namespaceUri, namespaceHandler);</span><br><span class="line">      <span class="keyword">return</span> namespaceHandler;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> FatalBeanException(<span class="string">&quot;Could not find NamespaceHandler class [&quot;</span> </span><br><span class="line">                                   + className +</span><br><span class="line">                                   <span class="string">&quot;] for namespace [&quot;</span> </span><br><span class="line">                                   + namespaceUri + <span class="string">&quot;]&quot;</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (LinkageError err) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> FatalBeanException(</span><br><span class="line">        <span class="string">&quot;Unresolvable class definition for NamespaceHandler class [&quot;</span> </span><br><span class="line">                                   +</span><br><span class="line">                                   className </span><br><span class="line">                                   + <span class="string">&quot;] for namespace [&quot;</span> </span><br><span class="line">                                   + namespaceUri + <span class="string">&quot;]&quot;</span>, err);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先调用 <code>getHandlerMappings()</code> 获取所有配置文件中的映射关系 <code>handlerMappings</code> ，该关系为 &lt;命名空间,类路径&gt;，然后根据命名空间 <code>namespaceUri</code> 从映射关系中获取相应的信息，如果为空或者已经初始化了就直接返回，否则根据反射对其进行初始化，同时调用其 <code>init()</code> 方法，最后将该 Handler 对象缓存。 <code>init()</code> 方法主要是将自定义标签解析器进行注册，如我们自定义的 <code>init()</code> ：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  registerBeanDefinitionParser(<span class="string">&quot;user&quot;</span>,<span class="keyword">new</span> UserDefinitionParser());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接调用父类的 <code>registerBeanDefinitionParser()</code> 方法进行注册：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitionParser</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  String elementName, BeanDefinitionParser parser)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.parsers.put(elementName, parser);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实就是将映射关系放在一个 <code>Map</code> 结构的 <code>parsers</code> 对象中：<code>private final Map parsers</code> 。</p><p> 完成后返回 <code>NamespaceHandler</code> 对象，然后调用其 <code>parse()</code> 方法开始自定义标签的解析，如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> BeanDefinition <span class="title">parse</span><span class="params">(Element element, ParserContext parserContext)</span> </span>&#123;</span><br><span class="line">  BeanDefinitionParser parser = findParserForElement(element, parserContext);</span><br><span class="line">  <span class="keyword">return</span> (parser != <span class="keyword">null</span> ? parser.parse(element, parserContext) : <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用 <code>findParserForElement()</code> 方法获取 <code>BeanDefinitionParser</code> 实例，其实就是获取在 <code>init()</code> 方法里面注册的实例对象。如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> BeanDefinitionParser <span class="title">findParserForElement</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  Element element, ParserContext parserContext)</span> </span>&#123;</span><br><span class="line">  String localName = parserContext.getDelegate().getLocalName(element);</span><br><span class="line">  BeanDefinitionParser parser = <span class="keyword">this</span>.parsers.get(localName);</span><br><span class="line">  <span class="keyword">if</span> (parser == <span class="keyword">null</span>) &#123;</span><br><span class="line">    parserContext.getReaderContext().fatal(</span><br><span class="line">      <span class="string">&quot;Cannot locate BeanDefinitionParser for element [&quot;</span></span><br><span class="line">      + localName + <span class="string">&quot;]&quot;</span>, element);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> parser;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>获取 <code>localName</code>，在上面的例子中就是 ： <code>user</code></li><li>然后从 <code>Map</code> 实例 <code>parsers</code> 中获取 <code>BeanDefinitionParser</code> 对象。</li><li>返回 <code>BeanDefinitionParser</code> 对象后，调用其 <code>parse()</code>，该方法在 <code>AbstractBeanDefinitionParser</code> 中实现：</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> BeanDefinition <span class="title">parse</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  Element element, ParserContext parserContext)</span> </span>&#123;</span><br><span class="line">  AbstractBeanDefinition definition = parseInternal(element, parserContext);</span><br><span class="line">  <span class="keyword">if</span> (definition != <span class="keyword">null</span> &amp;&amp; !parserContext.isNested()) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      String id = resolveId(element, definition, parserContext);</span><br><span class="line">      <span class="keyword">if</span> (!StringUtils.hasText(id)) &#123;</span><br><span class="line">        parserContext.getReaderContext().error(</span><br><span class="line">          <span class="string">&quot;Id is required for element &#x27;&quot;</span> </span><br><span class="line">          + parserContext.getDelegate().getLocalName(element)</span><br><span class="line">          + <span class="string">&quot;&#x27; when used as a top-level tag&quot;</span>, element);</span><br><span class="line">      &#125;</span><br><span class="line">      String[] aliases = <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">if</span> (shouldParseNameAsAliases()) &#123;</span><br><span class="line">        String name = element.getAttribute(NAME_ATTRIBUTE);</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.hasLength(name)) &#123;</span><br><span class="line">          aliases = StringUtils.trimArrayElements(</span><br><span class="line">            StringUtils.commaDelimitedListToStringArray(name));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      BeanDefinitionHolder holder = <span class="keyword">new</span> BeanDefinitionHolder(definition, id, aliases);</span><br><span class="line">      registerBeanDefinition(holder, parserContext.getRegistry());</span><br><span class="line">      <span class="keyword">if</span> (shouldFireEvents()) &#123;</span><br><span class="line">        BeanComponentDefinition componentDefinition = </span><br><span class="line">          <span class="keyword">new</span> BeanComponentDefinition(holder);</span><br><span class="line">        postProcessComponentDefinition(componentDefinition);</span><br><span class="line">        parserContext.registerComponent(componentDefinition);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (BeanDefinitionStoreException ex) &#123;</span><br><span class="line">      String msg = ex.getMessage();</span><br><span class="line">      parserContext.getReaderContext().error((msg != <span class="keyword">null</span> ? </span><br><span class="line">                                              msg : ex.toString()), element);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> definition;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>核心在方法 <code>parseInternal()</code> 为什么这么说，以为该方法返回的是 <code>AbstractBeanDefinition</code> 对象，从前面默认标签的解析工作中我们就可以判断该方法就是将标签解析为 <code>AbstractBeanDefinition</code> ，且后续代码都是将 <code>AbstractBeanDefinition</code> 转换为 <code>BeanDefinitionHolder</code>，所以真正的解析工作都交由 <code>parseInternal()</code> 实现，如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> AbstractBeanDefinition <span class="title">parseInternal</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  Element element, ParserContext parserContext)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 获取</span></span><br><span class="line">  BeanDefinitionBuilder builder = BeanDefinitionBuilder.genericBeanDefinition();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取父类元素</span></span><br><span class="line">  String parentName = getParentName(element);</span><br><span class="line">  <span class="keyword">if</span> (parentName != <span class="keyword">null</span>) &#123;</span><br><span class="line">    builder.getRawBeanDefinition().setParentName(parentName);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取自定义标签中的 class，这个时候会去调用自定义解析中的 getBeanClass()</span></span><br><span class="line">  Class&lt;?&gt; beanClass = getBeanClass(element);</span><br><span class="line">  <span class="keyword">if</span> (beanClass != <span class="keyword">null</span>) &#123;</span><br><span class="line">    builder.getRawBeanDefinition().setBeanClass(beanClass);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// beanClass 为 null，意味着子类并没有重写 getBeanClass() 方法，</span></span><br><span class="line">    <span class="comment">// 则尝试去判断是否重写了 getBeanClassName()</span></span><br><span class="line">    String beanClassName = getBeanClassName(element);</span><br><span class="line">    <span class="keyword">if</span> (beanClassName != <span class="keyword">null</span>) &#123;</span><br><span class="line">      builder.getRawBeanDefinition().setBeanClassName(beanClassName);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  builder.getRawBeanDefinition().setSource(parserContext.extractSource(element));</span><br><span class="line">  BeanDefinition containingBd = parserContext.getContainingBeanDefinition();</span><br><span class="line">  <span class="keyword">if</span> (containingBd != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// Inner bean definition must receive same scope as containing bean.</span></span><br><span class="line">    builder.setScope(containingBd.getScope());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (parserContext.isDefaultLazyInit()) &#123;</span><br><span class="line">    <span class="comment">// Default-lazy-init applies to custom bean definitions as well.</span></span><br><span class="line">    builder.setLazyInit(<span class="keyword">true</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 调用子类的 doParse() 进行解析</span></span><br><span class="line">  doParse(element, parserContext, builder);</span><br><span class="line">  <span class="keyword">return</span> builder.getBeanDefinition();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在该方法中我们主要关注两个方法：<code>getBeanClass()</code> 、<code>doParse()</code>。对于 <code>getBeanClass()</code> 方法，<code>AbstractSingleBeanDefinitionParser</code> 类并没有提供具体实现，而是直接返回 <code>null</code>，意味着它希望子类能够重写该方法，当然如果没有重写该方法，这会去调用 <code>getBeanClassName()</code> ，判断子类是否已经重写了该方法。对于 <code>doParse()</code> 则是直接空实现。所以对于 <code>parseInternal()</code> 而言它总是期待它的子类能够实现 <code>getBeanClass()</code>、<code>doParse()</code>，其中 <code>doParse()</code> 尤为重要，如果你不提供实现，怎么来解析自定义标签呢？最后将自定义的解析器：<code>UserDefinitionParser</code> 再次回观。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDefinitionParser</span> <span class="keyword">extends</span> <span class="title">AbstractSingleBeanDefinitionParser</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; getBeanClass(Element element) &#123;</span><br><span class="line">        <span class="keyword">return</span> User.class;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doParse</span><span class="params">(Element element, BeanDefinitionBuilder builder)</span> </span>&#123;</span><br><span class="line">        String id = element.getAttribute(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">        String userName=element.getAttribute(<span class="string">&quot;userName&quot;</span>);</span><br><span class="line">        String email=element.getAttribute(<span class="string">&quot;email&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(StringUtils.hasText(id))&#123;</span><br><span class="line">            builder.addPropertyValue(<span class="string">&quot;id&quot;</span>,id);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(StringUtils.hasText(userName))&#123;</span><br><span class="line">            builder.addPropertyValue(<span class="string">&quot;userName&quot;</span>, userName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(StringUtils.hasText(email))&#123;</span><br><span class="line">            builder.addPropertyValue(<span class="string">&quot;email&quot;</span>, email);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，自定义标签的解析过程已经分析完成了。其实整个过程还是较为简单：</p><ol><li><p>首先会加载 <code>handlers</code> 文件，将其中内容进行一个解析，形成 &lt;namespaceUri,类路径&gt; 这样的一个映射</p></li><li><p>然后根据获取的 <code>namespaceUri</code> 就可以得到相应的类路径，对其进行初始化等到相应的 Handler 对象</p></li><li><p>调用 <code>parse()</code> 方法，在该方法中根据标签的 <code>localName</code> 得到相应的 <code>BeanDefinitionParser</code> 实例对象</p></li><li><p>调用 <code>parse()</code> ，该方法定义在 AbstractBeanDefinitionParser 抽象类中，核心逻辑封装在其 <code>parseInternal()</code> 中，该方法返回一个 AbstractBeanDefinition 实例对象，其主要是在 AbstractSingleBeanDefinitionParser 中实现，对于自定义的 Parser 类，其需要实现 <code>getBeanClass()</code> 或者 <code>getBeanClassName()</code> 和 <code>doParse()</code>。</p><p><img src="https://gitee.com/cayzlh/img-repo/raw/master/uPic/wyvMAV.jpg" alt="wyvMAV"></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
          <category> 《Spring源码分析》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> 死磕Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IOC之解析bean标签：constructor-arg、property子元素</title>
      <link href="/blog/2020/01/11/686a3d12.html"/>
      <url>/blog/2020/01/11/686a3d12.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文作者：chenssy</p><p>出处：<a href="http://cmsblogs.com/?p=2754">http://cmsblogs.com/?p=2754</a></p><p>在学习<code>Spring源码</code>的过程中发现的好站+好贴，感谢作者。Spring版本：<strong>Spring 5.0.6.RELEASE</strong></p></blockquote><hr><h2 id="constructor-arg-子元素"><a href="#constructor-arg-子元素" class="headerlink" title="constructor-arg 子元素"></a>constructor-arg 子元素</h2><p>举个小栗子：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> BookService bookService;</span><br><span class="line"></span><br><span class="line">    StudentService(String name, Integer age, BookService bookService)&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.bookService = bookService;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.core.service.BookService&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;studentService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.core.service.StudentService&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;0&quot;</span> <span class="attr">value</span>=<span class="string">&quot;chenssy&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span> <span class="attr">value</span>=<span class="string">&quot;100&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;bookService&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;bookService&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>StudentService</code> 定义一个构造函数，配置文件中使用 <code>constructor-arg</code> 元素对其配置，该元素可以实现对 <code>StudentService</code> 自动寻找对应的构造函数，并在初始化的时候将值当做参数进行设置。<code>parseConstructorArgElements()</code> 方法完成 <code>constructor-arg</code> 子元素的解析。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parseConstructorArgElements</span><span class="params">(Element beanEle, BeanDefinition bd)</span> </span>&#123;</span><br><span class="line">  NodeList nl = beanEle.getChildNodes();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nl.getLength(); i++) &#123;</span><br><span class="line">    Node node = nl.item(i);</span><br><span class="line">    <span class="keyword">if</span> (isCandidateElement(node) &amp;&amp; nodeNameEquals(node, CONSTRUCTOR_ARG_ELEMENT)) &#123;</span><br><span class="line">      parseConstructorArgElement((Element) node, bd);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>遍历所有子元素，如果为 <code>constructor-arg</code> 则调用 <code>parseConstructorArgElement()</code> 进行解析。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parseConstructorArgElement</span><span class="params">(Element ele, BeanDefinition bd)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 提取 index、type、name 属性值</span></span><br><span class="line">  String indexAttr = ele.getAttribute(INDEX_ATTRIBUTE);</span><br><span class="line">  String typeAttr = ele.getAttribute(TYPE_ATTRIBUTE);</span><br><span class="line">  String nameAttr = ele.getAttribute(NAME_ATTRIBUTE);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果有index</span></span><br><span class="line">  <span class="keyword">if</span> (StringUtils.hasLength(indexAttr)) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">int</span> index = Integer.parseInt(indexAttr);</span><br><span class="line">      <span class="keyword">if</span> (index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        error(<span class="string">&quot;&#x27;index&#x27; cannot be lower than 0&quot;</span>, ele);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">// 构造一个 ConstructorArgumentEntry 并将其加入到 ParseState 中</span></span><br><span class="line">          <span class="keyword">this</span>.parseState.push(<span class="keyword">new</span> ConstructorArgumentEntry(index));</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 解析 ele 对应属性元素</span></span><br><span class="line">          Object value = parsePropertyValue(ele, bd, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 根据解析的属性元素构造一个 valueHolder 对象</span></span><br><span class="line">          ConstructorArgumentValues.ValueHolder valueHolder = </span><br><span class="line">            <span class="keyword">new</span> ConstructorArgumentValues.ValueHolder(value);</span><br><span class="line">          <span class="keyword">if</span> (StringUtils.hasLength(typeAttr)) &#123;</span><br><span class="line">            valueHolder.setType(typeAttr);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (StringUtils.hasLength(nameAttr)) &#123;</span><br><span class="line">            valueHolder.setName(nameAttr);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">//</span></span><br><span class="line">          valueHolder.setSource(extractSource(ele));</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 不允许重复指定相同参数</span></span><br><span class="line">          <span class="keyword">if</span> (bd.getConstructorArgumentValues()</span><br><span class="line">              .hasIndexedArgumentValue(index)) &#123;</span><br><span class="line">            error(<span class="string">&quot;Ambiguous constructor-arg entries for index &quot;</span> + index, ele);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 加入到 indexedArgumentValues 中国</span></span><br><span class="line">            bd.getConstructorArgumentValues()</span><br><span class="line">              .addIndexedArgumentValue(index, valueHolder);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">          <span class="keyword">this</span>.parseState.pop();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (NumberFormatException ex) &#123;</span><br><span class="line">      error(<span class="string">&quot;Attribute &#x27;index&#x27; of tag &#x27;constructor-arg&#x27; must be an integer&quot;</span>, ele);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.parseState.push(<span class="keyword">new</span> ConstructorArgumentEntry());</span><br><span class="line">      Object value = parsePropertyValue(ele, bd, <span class="keyword">null</span>);</span><br><span class="line">      ConstructorArgumentValues.ValueHolder valueHolder = </span><br><span class="line">        <span class="keyword">new</span> ConstructorArgumentValues.ValueHolder(value);</span><br><span class="line">      <span class="keyword">if</span> (StringUtils.hasLength(typeAttr)) &#123;</span><br><span class="line">        valueHolder.setType(typeAttr);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (StringUtils.hasLength(nameAttr)) &#123;</span><br><span class="line">        valueHolder.setName(nameAttr);</span><br><span class="line">      &#125;</span><br><span class="line">      valueHolder.setSource(extractSource(ele));</span><br><span class="line">      bd.getConstructorArgumentValues().addGenericArgumentValue(valueHolder);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.parseState.pop();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先获取 <code>index</code>、<code>type</code>、<code>name</code> 三个属性值，然后根据是否存在 <code>index</code> 来区分。</p><p>其实两者逻辑都差不多，总共分为如下几个步骤（以有 <code>index</code> 为例）：</p><ol><li><p>构造 <code>ConstructorArgumentEntry</code> 对象并将其加入到 <code>ParseState</code> 队列中。</p><blockquote><p><code>ConstructorArgumentEntry</code> 表示构造函数的参数。</p></blockquote></li><li><p>调用 <code>parsePropertyValue()</code> 解析 <code>constructor-arg</code> 子元素，返回结果值</p></li><li><p>根据解析的结果值构造 <code>ConstructorArgumentValues.ValueHolder</code> 实例对象</p></li><li><p>将 <code>type</code>、<code>name</code> 封装到 <code>ConstructorArgumentValues.ValueHolder</code> 中，然后将 <code>ValueHolder</code> 实例对象添加到 <code>indexedArgumentValues</code> 中。</p></li></ol><p>无 <code>index</code> 的处理逻辑差不多，只有几点不同：</p><ul><li>构造 ConstructorArgumentEntry 对象时是调用无参构造函数；</li><li>最后是将 ValueHolder 实例添加到 genericArgumentValues 中。</li><li> <code>parsePropertyValue()</code> 对子元素进一步解析。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">parsePropertyValue</span><span class="params">(Element ele, BeanDefinition bd, <span class="meta">@Nullable</span> String propertyName)</span> </span>&#123;</span><br><span class="line">  String elementName = (propertyName != <span class="keyword">null</span>) ?</span><br><span class="line">    <span class="string">&quot;&lt;property&gt; element for property &#x27;&quot;</span> + propertyName + <span class="string">&quot;&#x27;&quot;</span> :</span><br><span class="line">  <span class="string">&quot;&lt;constructor-arg&gt; element&quot;</span>;</span><br><span class="line"></span><br><span class="line">  NodeList nl = ele.getChildNodes();</span><br><span class="line">  Element subElement = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nl.getLength(); i++) &#123;</span><br><span class="line">    Node node = nl.item(i);</span><br><span class="line">    <span class="comment">// meta 、description 不处理</span></span><br><span class="line">    <span class="keyword">if</span> (node <span class="keyword">instanceof</span> Element &amp;&amp; !nodeNameEquals(node, DESCRIPTION_ELEMENT) &amp;&amp;</span><br><span class="line">        !nodeNameEquals(node, META_ELEMENT)) &#123;</span><br><span class="line">      <span class="comment">// Child element is what we&#x27;re looking for.</span></span><br><span class="line">      <span class="keyword">if</span> (subElement != <span class="keyword">null</span>) &#123;</span><br><span class="line">        error(elementName + <span class="string">&quot; must not contain more than one sub-element&quot;</span>, ele);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        subElement = (Element) node;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 解析 ref 元素</span></span><br><span class="line">  <span class="keyword">boolean</span> hasRefAttribute = ele.hasAttribute(REF_ATTRIBUTE);</span><br><span class="line">  <span class="comment">// 解析 value 元素</span></span><br><span class="line">  <span class="keyword">boolean</span> hasValueAttribute = ele.hasAttribute(VALUE_ATTRIBUTE);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// constructor-arg 子元素有两种情况不存在</span></span><br><span class="line">  <span class="comment">// 1. 即存在 ref 又存在 value</span></span><br><span class="line">  <span class="comment">// 2. 存在 ref 或者 value，但是又有子元素</span></span><br><span class="line">  <span class="keyword">if</span> ((hasRefAttribute &amp;&amp; hasValueAttribute) ||</span><br><span class="line">      ((hasRefAttribute || hasValueAttribute) &amp;&amp; subElement != <span class="keyword">null</span>)) &#123;</span><br><span class="line">    error(elementName </span><br><span class="line">          +</span><br><span class="line">          <span class="string">&quot; is only allowed to contain either &#x27;ref&#x27; attribute OR &quot;</span> </span><br><span class="line">          + <span class="string">&quot; &#x27;value&#x27; attribute OR sub-element&quot;</span>, </span><br><span class="line">          ele);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (hasRefAttribute) &#123;</span><br><span class="line">    <span class="comment">// 获取 ref 属性值</span></span><br><span class="line">    String refName = ele.getAttribute(REF_ATTRIBUTE);</span><br><span class="line">    <span class="keyword">if</span> (!StringUtils.hasText(refName)) &#123;</span><br><span class="line">      error(elementName + <span class="string">&quot; contains empty &#x27;ref&#x27; attribute&quot;</span>, ele);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将 ref 属性值构造为 RuntimeBeanReference 实例对象</span></span><br><span class="line">    RuntimeBeanReference ref = <span class="keyword">new</span> RuntimeBeanReference(refName);</span><br><span class="line">    ref.setSource(extractSource(ele));</span><br><span class="line">    <span class="keyword">return</span> ref;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (hasValueAttribute) &#123;</span><br><span class="line">    <span class="comment">// 解析 value 属性值，构造 TypedStringValue 实例对象</span></span><br><span class="line">    TypedStringValue valueHolder = <span class="keyword">new</span> TypedStringValue(</span><br><span class="line">      ele.getAttribute(VALUE_ATTRIBUTE));</span><br><span class="line">    valueHolder.setSource(extractSource(ele));</span><br><span class="line">    <span class="keyword">return</span> valueHolder;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (subElement != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 解析子元素</span></span><br><span class="line">    <span class="keyword">return</span> parsePropertySubElement(subElement, bd);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Neither child element nor &quot;ref&quot; or &quot;value&quot; attribute found.</span></span><br><span class="line">    error(elementName + <span class="string">&quot; must specify a ref or value&quot;</span>, ele);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>提取 <code>constructor-arg</code> 子元素的 <code>ref</code> 和 <code>value</code> 的属性值，对其进行判断，以下两种情况是不允许存在的<ul><li><code>ref</code> 和 <code>value</code> 属性同时存在</li><li>存在 <code>ref</code> 或者 <code>value</code> 且又有子元素</li></ul></li><li>若存在 <code>ref</code> 属性，则获取其值并将其封装进 <code>RuntimeBeanReference</code> 实例对象中</li><li>若存在 <code>value</code> 属性，则获取其值并将其封装进 <code>TypedStringValue</code> 实例对象中</li><li>如果子元素不为空，则调用 <code>parsePropertySubElement()</code> 进行子元素进一步处理</li></ol><p>对于 <code>constructor-arg</code> 子元素的嵌套子元素，需要调用 <code>parsePropertySubElement()</code> 进一步处理。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">parsePropertySubElement</span><span class="params">(Element ele, <span class="meta">@Nullable</span> BeanDefinition bd)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> parsePropertySubElement(ele, bd, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">parsePropertySubElement</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  Element ele, <span class="meta">@Nullable</span> BeanDefinition bd, <span class="meta">@Nullable</span> String defaultValueType)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!isDefaultNamespace(ele)) &#123;</span><br><span class="line">    <span class="keyword">return</span> parseNestedCustomElement(ele, bd);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (nodeNameEquals(ele, BEAN_ELEMENT)) &#123;</span><br><span class="line">    BeanDefinitionHolder nestedBd = parseBeanDefinitionElement(ele, bd);</span><br><span class="line">    <span class="keyword">if</span> (nestedBd != <span class="keyword">null</span>) &#123;</span><br><span class="line">      nestedBd = decorateBeanDefinitionIfRequired(ele, nestedBd, bd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nestedBd;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (nodeNameEquals(ele, REF_ELEMENT)) &#123;</span><br><span class="line">    <span class="comment">// A generic reference to any name of any bean.</span></span><br><span class="line">    String refName = ele.getAttribute(BEAN_REF_ATTRIBUTE);</span><br><span class="line">    <span class="keyword">boolean</span> toParent = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (!StringUtils.hasLength(refName)) &#123;</span><br><span class="line">      <span class="comment">// A reference to the id of another bean in a parent context.</span></span><br><span class="line">      refName = ele.getAttribute(PARENT_REF_ATTRIBUTE);</span><br><span class="line">      toParent = <span class="keyword">true</span>;</span><br><span class="line">      <span class="keyword">if</span> (!StringUtils.hasLength(refName)) &#123;</span><br><span class="line">        error(<span class="string">&quot;&#x27;bean&#x27; or &#x27;parent&#x27; is required for &lt;ref&gt; element&quot;</span>, ele);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!StringUtils.hasText(refName)) &#123;</span><br><span class="line">      error(<span class="string">&quot;&lt;ref&gt; element contains empty target attribute&quot;</span>, ele);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    RuntimeBeanReference ref = <span class="keyword">new</span> RuntimeBeanReference(refName, toParent);</span><br><span class="line">    ref.setSource(extractSource(ele));</span><br><span class="line">    <span class="keyword">return</span> ref;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (nodeNameEquals(ele, IDREF_ELEMENT)) &#123;</span><br><span class="line">    <span class="keyword">return</span> parseIdRefElement(ele);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (nodeNameEquals(ele, VALUE_ELEMENT)) &#123;</span><br><span class="line">    <span class="keyword">return</span> parseValueElement(ele, defaultValueType);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (nodeNameEquals(ele, NULL_ELEMENT)) &#123;</span><br><span class="line">    <span class="comment">// It&#x27;s a distinguished null value. Let&#x27;s wrap it in a TypedStringValue</span></span><br><span class="line">    <span class="comment">// object in order to preserve the source location.</span></span><br><span class="line">    TypedStringValue nullHolder = <span class="keyword">new</span> TypedStringValue(<span class="keyword">null</span>);</span><br><span class="line">    nullHolder.setSource(extractSource(ele));</span><br><span class="line">    <span class="keyword">return</span> nullHolder;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (nodeNameEquals(ele, ARRAY_ELEMENT)) &#123;</span><br><span class="line">    <span class="keyword">return</span> parseArrayElement(ele, bd);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (nodeNameEquals(ele, LIST_ELEMENT)) &#123;</span><br><span class="line">    <span class="keyword">return</span> parseListElement(ele, bd);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (nodeNameEquals(ele, SET_ELEMENT)) &#123;</span><br><span class="line">    <span class="keyword">return</span> parseSetElement(ele, bd);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (nodeNameEquals(ele, MAP_ELEMENT)) &#123;</span><br><span class="line">    <span class="keyword">return</span> parseMapElement(ele, bd);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (nodeNameEquals(ele, PROPS_ELEMENT)) &#123;</span><br><span class="line">    <span class="keyword">return</span> parsePropsElement(ele);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    error(<span class="string">&quot;Unknown property sub-element: [&quot;</span> + ele.getNodeName() + <span class="string">&quot;]&quot;</span>, ele);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面对各个子类进行分类处理，详细情况如果各位有兴趣可以移步源码进行深一步的探究。</p><h2 id="property-子元素"><a href="#property-子元素" class="headerlink" title="property 子元素"></a>property 子元素</h2><p>我们一般使用如下方式来使用 property 子元素。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;studentService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.core.service.StudentService&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;chenssy&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span> <span class="attr">value</span>=<span class="string">&quot;18&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>对于 <code>property</code> 子元素的解析，<code>Spring</code> 调用 <code>parsePropertyElements()</code>。如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parsePropertyElements</span><span class="params">(Element beanEle, BeanDefinition bd)</span> </span>&#123;</span><br><span class="line">  NodeList nl = beanEle.getChildNodes();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nl.getLength(); i++) &#123;</span><br><span class="line">    Node node = nl.item(i);</span><br><span class="line">    <span class="keyword">if</span> (isCandidateElement(node) &amp;&amp; nodeNameEquals(node, PROPERTY_ELEMENT)) &#123;</span><br><span class="line">      parsePropertyElement((Element) node, bd);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和 <code>constructor-arg</code> 子元素差不多，同样是提取所有的 <code>property</code> 的子元素，然后调用 <code>parsePropertyElement()</code> 进行分析。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parsePropertyElement</span><span class="params">(Element ele, BeanDefinition bd)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 获取 name 属性</span></span><br><span class="line">  String propertyName = ele.getAttribute(NAME_ATTRIBUTE);</span><br><span class="line">  <span class="keyword">if</span> (!StringUtils.hasLength(propertyName)) &#123;</span><br><span class="line">    error(<span class="string">&quot;Tag &#x27;property&#x27; must have a &#x27;name&#x27; attribute&quot;</span>, ele);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.parseState.push(<span class="keyword">new</span> PropertyEntry(propertyName));</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 如果存在相同的 name</span></span><br><span class="line">    <span class="keyword">if</span> (bd.getPropertyValues().contains(propertyName)) &#123;</span><br><span class="line">      error(<span class="string">&quot;Multiple &#x27;property&#x27; definitions for property &#x27;&quot;</span> </span><br><span class="line">            + propertyName + <span class="string">&quot;&#x27;&quot;</span>, ele);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析属性值</span></span><br><span class="line">    Object val = parsePropertyValue(ele, bd, propertyName);</span><br><span class="line">    <span class="comment">// 根据解析的属性值构造 PropertyValue 实例对象</span></span><br><span class="line">    PropertyValue pv = <span class="keyword">new</span> PropertyValue(propertyName, val);</span><br><span class="line">    parseMetaElements(ele, pv);</span><br><span class="line">    pv.setSource(extractSource(ele));</span><br><span class="line">    <span class="comment">// 添加到 MutablePropertyValues 中</span></span><br><span class="line">    bd.getPropertyValues().addPropertyValue(pv);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.parseState.pop();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与解析 <code>constructor-arg</code> 子元素步骤差不多。调用 <code>parsePropertyValue()</code> 解析子元素属性值，然后根据该值构造 <code>PropertyValue</code> 实例对象并将其添加到 <code>BeanDefinition</code> 中的 <code>MutablePropertyValues</code> 中。</p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
          <category> 《Spring源码分析》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> 死磕Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IoC之解析bean标签：meta、lookup-method、replace-method</title>
      <link href="/blog/2020/01/10/fa973ffe.html"/>
      <url>/blog/2020/01/10/fa973ffe.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文作者：chenssy</p><p>出处：<a href="http://cmsblogs.com/?p=2736">http://cmsblogs.com/?p=2736</a></p><p>在学习<code>Spring源码</code>的过程中发现的好站+好贴，感谢作者。Spring版本：<strong>Spring 5.0.6.RELEASE</strong></p></blockquote><hr><p>在<a href="/2020/01/09/af1473fe.html"> IOC 之解析 Bean 标签：BeanDefinition</a>中已经完成了对 <code>Bean</code> 标签属性的解析工作，这篇博文开始分析子元素的解析。</p><p>完成 <code>Bean</code> 标签基本属性解析后，会依次调用 <code>parseMetaElements()</code>、<code>parseLookupOverrideSubElements()</code>、<code>parseReplacedMethodSubElements()</code> 对子元素 meta、lookup-method、replace-method 完成解析。三个子元素的作用如下：</p><ul><li><p><code>meta</code>：元数据。</p></li><li><p><code>lookup-method</code>：<code>Spring</code> 动态改变 <code>bean</code> 里方法的实现。</p><blockquote><p>方法执行返回的对象，使用 <code>Spring</code> 内原有的这类对象替换，通过改变方法返回值来动态改变方法。内部实现为使用 <code>cglib</code> 方法，重新生成子类，重写配置的方法和返回对象，达到动态改变的效果。</p></blockquote></li><li><p><code>replace-method</code>：<code>Spring</code> 动态改变 <code>bean</code> 里方法的实现。</p><blockquote><p>需要改变的方法，使用 Spring 内原有其他类（需要继承接口<code>org.springframework.beans.factory.support.MethodReplacer</code>）的逻辑，替换这个方法。通过改变方法执行逻辑来动态改变方法。</p></blockquote></li></ul><h2 id="meta-子元素"><a href="#meta-子元素" class="headerlink" title="meta 子元素"></a>meta 子元素</h2><blockquote><p> <strong>meta</strong> ：元数据。当需要使用里面的信息时可以通过key获取</p></blockquote><p><code>meta</code> 所声明的 <code>key</code> 并不会在 <code>Bean</code> 中体现，只是一个额外的声明，当我们需要使用里面的信息时，通过 <code>BeanDefinition</code> 的 <code>getAttribute()</code> 获取。该子元素的解析过程如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parseMetaElements</span><span class="params">(Element ele, </span></span></span><br><span class="line"><span class="function"><span class="params">                              BeanMetadataAttributeAccessor attributeAccessor)</span> </span>&#123;</span><br><span class="line">  NodeList nl = ele.getChildNodes();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nl.getLength(); i++) &#123;</span><br><span class="line">    Node node = nl.item(i);</span><br><span class="line">    <span class="keyword">if</span> (isCandidateElement(node) &amp;&amp; nodeNameEquals(node, META_ELEMENT)) &#123;</span><br><span class="line">      Element metaElement = (Element) node;</span><br><span class="line">      String key = metaElement.getAttribute(KEY_ATTRIBUTE);</span><br><span class="line">      String value = metaElement.getAttribute(VALUE_ATTRIBUTE);</span><br><span class="line">      BeanMetadataAttribute attribute = <span class="keyword">new</span> BeanMetadataAttribute(key, value);</span><br><span class="line">      attribute.setSource(extractSource(metaElement));</span><br><span class="line">      attributeAccessor.addMetadataAttribute(attribute);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解析过程较为简单，获取相应的 <code>key - value</code> 构建 <code>BeanMetadataAttribute</code> 对象，然后通过 <code>addMetadataAttribute()</code> 加入到 <code>AbstractBeanDefinition</code> 中。 代码 如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addMetadataAttribute</span><span class="params">(BeanMetadataAttribute attribute)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">super</span>.setAttribute(attribute.getName(), attribute);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>委托 <code>AttributeAccessorSupport</code> 实现，如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAttribute</span><span class="params">(String name, <span class="meta">@Nullable</span> Object value)</span> </span>&#123;</span><br><span class="line">  Assert.notNull(name, <span class="string">&quot;Name must not be null&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (value != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.attributes.put(name, value);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    removeAttribute(name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>AttributeAccessorSupport</code> 是接口 <code>AttributeAccessor</code> 的实现者。 <code>AttributeAccessor</code> 接口定义了与其他对象的元数据进行连接和访问的约定，可以通过该接口对属性进行获取、设置、删除操作。 设置元数据后，则可以通过 <code>getAttribute()</code> 获取,如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getAttribute</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">  BeanMetadataAttribute attribute = (BeanMetadataAttribute) <span class="keyword">super</span>.getAttribute(name);</span><br><span class="line">  <span class="keyword">return</span> (attribute != <span class="keyword">null</span> ? attribute.getValue() : <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="lookup-method-子元素"><a href="#lookup-method-子元素" class="headerlink" title="lookup-method 子元素"></a>lookup-method 子元素</h2><blockquote><p> <strong>lookup-method</strong> ：获取器注入，是把一个方法声明为返回某种类型的 bean 但实际要返回的 bean 是在配置文件里面配置的。该方法可以用于设计一些可插拔的功能上，解除程序依赖。</p></blockquote><p>直接上例子：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bmw</span> <span class="keyword">implements</span> <span class="title">Car</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是 BMW&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hongqi</span> <span class="keyword">implements</span> <span class="title">Car</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是 hongqi&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Display</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>&#123;</span><br><span class="line">        getCar().display();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Car <span class="title">getCar</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ApplicationContext context = </span><br><span class="line">          <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;classpath:spring.xml&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Display display = (Display) context.getBean(<span class="string">&quot;display&quot;</span>);</span><br><span class="line">        display.display();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置内容如下：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;display&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.core.test1.Display&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">lookup-method</span> <span class="attr">name</span>=<span class="string">&quot;getCar&quot;</span> <span class="attr">bean</span>=<span class="string">&quot;hongqi&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>运行结果为：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">我是 hongqi</span><br></pre></td></tr></table></figure><p>如果将 <code>bean=&quot;hognqi&quot;</code> 替换为 <code>bean=&quot;bmw&quot;</code>，则运行结果变成：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">我是 BMW</span><br></pre></td></tr></table></figure><p>看了这个示例，我们初步了解了 <code>looku-method</code> 子元素提供的功能了，其解析过程如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parseLookupOverrideSubElements</span><span class="params">(Element beanEle, </span></span></span><br><span class="line"><span class="function"><span class="params">                                           MethodOverrides overrides)</span> </span>&#123;</span><br><span class="line">  NodeList nl = beanEle.getChildNodes();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nl.getLength(); i++) &#123;</span><br><span class="line">    Node node = nl.item(i);</span><br><span class="line">    <span class="keyword">if</span> (isCandidateElement(node) &amp;&amp; nodeNameEquals(node, LOOKUP_METHOD_ELEMENT)) &#123;</span><br><span class="line">      Element ele = (Element) node;</span><br><span class="line">      String methodName = ele.getAttribute(NAME_ATTRIBUTE);</span><br><span class="line">      String beanRef = ele.getAttribute(BEAN_ELEMENT);</span><br><span class="line">      LookupOverride override = <span class="keyword">new</span> LookupOverride(methodName, beanRef);</span><br><span class="line">      override.setSource(extractSource(ele));</span><br><span class="line">      overrides.addOverride(override);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解析过程和 <code>meta</code> 子元素没有多大区别，同样是解析 <code>methodName</code>、<code>beanRef</code> 构造一个 <code>LookupOverride</code> 对象，然后覆盖即可。在实例化 <code>Bean</code> 的时候，再详细阐述具体的实现过程，这里仅仅只是一个标记作用。</p><h2 id="replace-method-子元素"><a href="#replace-method-子元素" class="headerlink" title="replace-method 子元素"></a>replace-method 子元素</h2><blockquote><p> <strong>replaced-method</strong> ：可以在运行时调用新的方法替换现有的方法，还能动态的更新原有方法的逻辑</p></blockquote><p>该标签使用方法和 <code>lookup-method</code> 标签差不多，只不过替代方法的类需要实现 <code>MethodReplacer</code> 接口。如下:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Method</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是原始方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodReplace</span> <span class="keyword">implements</span> <span class="title">MethodReplacer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">reimplement</span><span class="params">(Object obj, Method method, Object[] args)</span> </span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是替换方法&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  ApplicationContext context = </span><br><span class="line">    <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;classpath:spring.xml&quot;</span>);</span><br><span class="line"></span><br><span class="line">  Method method = (Method) context.getBean(<span class="string">&quot;method&quot;</span>);</span><br><span class="line">  method.display();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果 spring.xml 文件如下：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;methodReplace&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.core.test1.MethodReplace&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;method&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.core.test1.Method&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>则运行结果为：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">我是原始方法</span><br></pre></td></tr></table></figure><p>增加 <code>replaced-method</code> 子元素：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;methodReplace&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.core.test1.MethodReplace&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;method&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.core.test1.Method&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">replaced-method</span> <span class="attr">name</span>=<span class="string">&quot;display&quot;</span> <span class="attr">replacer</span>=<span class="string">&quot;methodReplace&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>运行结果为：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">我是替换方法</span><br></pre></td></tr></table></figure><p>上面代码演示了 <code>replaced-method</code> 子元素的用法，下面再看看该子元素的解析过程。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parseReplacedMethodSubElements</span><span class="params">(Element beanEle, </span></span></span><br><span class="line"><span class="function"><span class="params">                                           MethodOverrides overrides)</span> </span>&#123;</span><br><span class="line">  NodeList nl = beanEle.getChildNodes();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nl.getLength(); i++) &#123;</span><br><span class="line">    Node node = nl.item(i);</span><br><span class="line">    <span class="keyword">if</span> (isCandidateElement(node) &amp;&amp; nodeNameEquals(node, REPLACED_METHOD_ELEMENT)) &#123;</span><br><span class="line">      Element replacedMethodEle = (Element) node;</span><br><span class="line">      String name = replacedMethodEle.getAttribute(NAME_ATTRIBUTE);</span><br><span class="line">      String callback = replacedMethodEle.getAttribute(REPLACER_ATTRIBUTE);</span><br><span class="line">      ReplaceOverride replaceOverride = <span class="keyword">new</span> ReplaceOverride(name, callback);</span><br><span class="line">      <span class="comment">// Look for arg-type match elements.</span></span><br><span class="line">      List&lt;Element&gt; argTypeEles = DomUtils</span><br><span class="line">        .getChildElementsByTagName(replacedMethodEle, ARG_TYPE_ELEMENT);</span><br><span class="line">      <span class="keyword">for</span> (Element argTypeEle : argTypeEles) &#123;</span><br><span class="line">        String match = argTypeEle.getAttribute(ARG_TYPE_MATCH_ATTRIBUTE);</span><br><span class="line">        match = (StringUtils.hasText(match) ? match : DomUtils.getTextValue(argTypeEle));</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.hasText(match)) &#123;</span><br><span class="line">          replaceOverride.addTypeIdentifier(match);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      replaceOverride.setSource(extractSource(replacedMethodEle));</span><br><span class="line">      overrides.addOverride(replaceOverride);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该子元素和 <code>lookup-method</code> 资源的解析过程差不多，同样是提取 <code>name</code> 和 <code>replacer</code> 属性构建 <code>ReplaceOverride</code> 对象，然后记录到 <code>AbstractBeanDefinition</code> 中的 <code>methodOverrides</code> 属性中。 </p><p>对于 <code>lookup-method</code> 和 <code>replaced-method</code> 两个子元素是如何使用以完成他们所提供的功能，在后续实例化 <code>Bean</code> 的时候会做详细说明。</p><blockquote><p>这两个标签很少使用</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
          <category> 《Spring源码分析》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> 死磕Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IOC之解析bean标签：BeanDefinition</title>
      <link href="/blog/2020/01/09/af1473fe.html"/>
      <url>/blog/2020/01/09/af1473fe.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文作者：chenssy</p><p>出处：<a href="http://cmsblogs.com/?p=2736">http://cmsblogs.com/?p=2736</a></p><p>在学习<code>Spring源码</code>的过程中发现的好站+好贴，感谢作者。Spring版本：<strong>Spring 5.0.6.RELEASE</strong></p></blockquote><hr><h2 id="BeanDefinition"><a href="#BeanDefinition" class="headerlink" title="BeanDefinition"></a>BeanDefinition</h2><p><code>BeanDefinition</code> 是一个接口，它描述了一个 <code>Bean</code> 实例，包括属性值、构造方法值和继承自它的类的更多信息。</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanDefinition</span> <span class="keyword">extends</span> <span class="title">AttributeAccessor</span>, <span class="title">BeanMetadataElement</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">String SCOPE_SINGLETON = ConfigurableBeanFactory.SCOPE_SINGLETON;</span><br><span class="line"></span><br><span class="line">String SCOPE_PROTOTYPE = ConfigurableBeanFactory.SCOPE_PROTOTYPE;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ROLE_APPLICATION = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ROLE_SUPPORT = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ROLE_INFRASTRUCTURE = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Modifiable attributes</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setParentName</span><span class="params">(<span class="meta">@Nullable</span> String parentName)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function">String <span class="title">getParentName</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setBeanClassName</span><span class="params">(<span class="meta">@Nullable</span> String beanClassName)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function">String <span class="title">getBeanClassName</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setScope</span><span class="params">(<span class="meta">@Nullable</span> String scope)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function">String <span class="title">getScope</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setLazyInit</span><span class="params">(<span class="keyword">boolean</span> lazyInit)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isLazyInit</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setDependsOn</span><span class="params">(<span class="meta">@Nullable</span> String... dependsOn)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line">String[] getDependsOn();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setAutowireCandidate</span><span class="params">(<span class="keyword">boolean</span> autowireCandidate)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isAutowireCandidate</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setPrimary</span><span class="params">(<span class="keyword">boolean</span> primary)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isPrimary</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setFactoryBeanName</span><span class="params">(<span class="meta">@Nullable</span> String factoryBeanName)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function">String <span class="title">getFactoryBeanName</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setFactoryMethodName</span><span class="params">(<span class="meta">@Nullable</span> String factoryMethodName)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function">String <span class="title">getFactoryMethodName</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">ConstructorArgumentValues <span class="title">getConstructorArgumentValues</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">default</span> <span class="keyword">boolean</span> <span class="title">hasConstructorArgumentValues</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> !getConstructorArgumentValues().isEmpty();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">MutablePropertyValues <span class="title">getPropertyValues</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">default</span> <span class="keyword">boolean</span> <span class="title">hasPropertyValues</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> !getPropertyValues().isEmpty();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Read-only attributes</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isSingleton</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isPrototype</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isAbstract</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getRole</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function">String <span class="title">getDescription</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function">String <span class="title">getResourceDescription</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function">BeanDefinition <span class="title">getOriginatingBeanDefinition</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="父类"><a href="#父类" class="headerlink" title="父类"></a>父类</h3><p><code>BeanDefinition</code>继承 <code>AttributeAccessor</code> 和 <code>BeanMetadataElement</code> 接口。两个接口定义如下：</p><ul><li><p><code>AttributeAccessor</code> ：定义了与其它对象的（元数据）进行连接和访问的约定，即对属性的修改，包括获取、设置、删除。</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AttributeAccessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setAttribute</span><span class="params">(String name, <span class="meta">@Nullable</span> Object value)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function">Object <span class="title">getAttribute</span><span class="params">(String name)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function">Object <span class="title">removeAttribute</span><span class="params">(String name)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">hasAttribute</span><span class="params">(String name)</span></span>;</span><br><span class="line"></span><br><span class="line">String[] attributeNames();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>BeanMetadataElement</code>：<code>Bean</code> 元对象持有的配置元素可以通过<code>getSource()</code> 方法来获取。 </p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanMetadataElement</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function">Object <span class="title">getSource</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="子类"><a href="#子类" class="headerlink" title="子类"></a>子类</h3><p><code>BeanDefinition</code> 整个结构如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/cayzlh/git-img-repository@master/uPic/SIcYke.jpg" alt="SIcYke"></p><p>我们常用的三个实现类有：<code>ChildBeanDefinition</code>、<code>GenericBeanDefinition</code>、<code>RootBeanDefinition</code>，三者都继承 <code>AbstractBeanDefinition</code>。如果配置文件中定义了<code>父</code>  和 <code>子</code>  ，则父  用 <code>RootBeanDefinition</code>表示，子  用 <code>ChildBeanDefinition</code> 表示，而没有父的就使用<code>RootBeanDefinition</code> 表示。<code>GenericBeanDefinition</code> 为一站式服务类。<code>AbstractBeanDefinition</code>对三个子类共同的类信息进行抽象。</p><h2 id="解析-Bean-标签"><a href="#解析-Bean-标签" class="headerlink" title="解析 Bean 标签"></a>解析 Bean 标签</h2><p>在 <code>BeanDefinitionParserDelegate.parseBeanDefinitionElement()</code> 中完成 <code>Bean</code> 的解析，返回的是一个已经完成对  标签解析的 <code>BeanDefinition</code> 实例。</p><h3 id="createBeanDefinition"><a href="#createBeanDefinition" class="headerlink" title="createBeanDefinition"></a>createBeanDefinition</h3><p>在该方法内部，首先调用 <code>createBeanDefinition()</code> 方法创建一个用于承载属性的 <code>GenericBeanDefinition</code> 实例，如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> AbstractBeanDefinition <span class="title">createBeanDefinition</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="meta">@Nullable</span> String className, <span class="meta">@Nullable</span> String parentName)</span></span></span><br><span class="line"><span class="function">  <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> BeanDefinitionReaderUtils.createBeanDefinition(</span><br><span class="line">    parentName, className, <span class="keyword">this</span>.readerContext.getBeanClassLoader());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>委托 <code>BeanDefinitionReaderUtils</code> 创建，如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> AbstractBeanDefinition <span class="title">createBeanDefinition</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="meta">@Nullable</span> String parentName, </span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="meta">@Nullable</span> String className, <span class="meta">@Nullable</span> ClassLoader classLoader)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line"></span><br><span class="line">  GenericBeanDefinition bd = <span class="keyword">new</span> GenericBeanDefinition();</span><br><span class="line">  bd.setParentName(parentName);</span><br><span class="line">  <span class="keyword">if</span> (className != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (classLoader != <span class="keyword">null</span>) &#123;</span><br><span class="line">      bd.setBeanClass(ClassUtils.forName(className, classLoader));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      bd.setBeanClassName(className);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> bd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法主要是设置 <code>parentName</code> 、<code>className</code>、<code>classLoader</code>。</p><h3 id="parseBeanDefinitionAttributes"><a href="#parseBeanDefinitionAttributes" class="headerlink" title="parseBeanDefinitionAttributes"></a>parseBeanDefinitionAttributes</h3><p>创建完 <code>GenericBeanDefinition</code> 实例后，再调用 <code>parseBeanDefinitionAttributes()</code> ，该方法将创建好的 <code>GenericBeanDefinition</code> 实例当做参数，对 <code>Bean</code> 标签的所有属性进行解析，如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> AbstractBeanDefinition <span class="title">parseBeanDefinitionAttributes</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  Element ele, String beanName,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="meta">@Nullable</span> BeanDefinition containingBean,</span></span></span><br><span class="line"><span class="function"><span class="params">  AbstractBeanDefinition bd)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 解析 scope 标签</span></span><br><span class="line">  <span class="keyword">if</span> (ele.hasAttribute(SINGLETON_ATTRIBUTE)) &#123;</span><br><span class="line">    error(<span class="string">&quot;Old 1.x &#x27;singleton&#x27; attribute in use - upgrade to &#x27;scope&#x27; declaration&quot;</span>, ele);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (ele.hasAttribute(SCOPE_ATTRIBUTE)) &#123;</span><br><span class="line">    bd.setScope(ele.getAttribute(SCOPE_ATTRIBUTE));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (containingBean != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// Take default from containing bean in case of an inner bean definition.</span></span><br><span class="line">    bd.setScope(containingBean.getScope());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 解析 abstract 标签</span></span><br><span class="line">  <span class="keyword">if</span> (ele.hasAttribute(ABSTRACT_ATTRIBUTE)) &#123;</span><br><span class="line">    bd.setAbstract(TRUE_VALUE.equals(ele.getAttribute(ABSTRACT_ATTRIBUTE)));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 解析 lazy-init 标签</span></span><br><span class="line">  String lazyInit = ele.getAttribute(LAZY_INIT_ATTRIBUTE);</span><br><span class="line">  <span class="keyword">if</span> (DEFAULT_VALUE.equals(lazyInit)) &#123;</span><br><span class="line">    lazyInit = <span class="keyword">this</span>.defaults.getLazyInit();</span><br><span class="line">  &#125;</span><br><span class="line">  bd.setLazyInit(TRUE_VALUE.equals(lazyInit));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 解析 autowire 标签</span></span><br><span class="line">  String autowire = ele.getAttribute(AUTOWIRE_ATTRIBUTE);</span><br><span class="line">  bd.setAutowireMode(getAutowireMode(autowire));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 解析 depends-on 标签</span></span><br><span class="line">  <span class="keyword">if</span> (ele.hasAttribute(DEPENDS_ON_ATTRIBUTE)) &#123;</span><br><span class="line">    String dependsOn = ele.getAttribute(DEPENDS_ON_ATTRIBUTE);</span><br><span class="line">    bd.setDependsOn(StringUtils.tokenizeToStringArray(dependsOn, MULTI_VALUE_ATTRIBUTE_DELIMITERS));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 解析 autowire-candidate 标签</span></span><br><span class="line">  String autowireCandidate = ele.getAttribute(AUTOWIRE_CANDIDATE_ATTRIBUTE);</span><br><span class="line">  <span class="keyword">if</span> (<span class="string">&quot;&quot;</span>.equals(autowireCandidate) || DEFAULT_VALUE.equals(autowireCandidate)) &#123;</span><br><span class="line">    String candidatePattern = <span class="keyword">this</span>.defaults.getAutowireCandidates();</span><br><span class="line">    <span class="keyword">if</span> (candidatePattern != <span class="keyword">null</span>) &#123;</span><br><span class="line">      String[] patterns = StringUtils.commaDelimitedListToStringArray(candidatePattern);</span><br><span class="line">      bd.setAutowireCandidate(PatternMatchUtils.simpleMatch(patterns, beanName));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    bd.setAutowireCandidate(TRUE_VALUE.equals(autowireCandidate));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 解析 primay 标签</span></span><br><span class="line">  <span class="keyword">if</span> (ele.hasAttribute(PRIMARY_ATTRIBUTE)) &#123;</span><br><span class="line">    bd.setPrimary(TRUE_VALUE.equals(ele.getAttribute(PRIMARY_ATTRIBUTE)));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 解析 init-method 标签</span></span><br><span class="line">  <span class="keyword">if</span> (ele.hasAttribute(INIT_METHOD_ATTRIBUTE)) &#123;</span><br><span class="line">    String initMethodName = ele.getAttribute(INIT_METHOD_ATTRIBUTE);</span><br><span class="line">    bd.setInitMethodName(initMethodName);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.defaults.getInitMethod() != <span class="keyword">null</span>) &#123;</span><br><span class="line">    bd.setInitMethodName(<span class="keyword">this</span>.defaults.getInitMethod());</span><br><span class="line">    bd.setEnforceInitMethod(<span class="keyword">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 解析 destroy-mothod 标签</span></span><br><span class="line">  <span class="keyword">if</span> (ele.hasAttribute(DESTROY_METHOD_ATTRIBUTE)) &#123;</span><br><span class="line">    String destroyMethodName = ele.getAttribute(DESTROY_METHOD_ATTRIBUTE);</span><br><span class="line">    bd.setDestroyMethodName(destroyMethodName);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.defaults.getDestroyMethod() != <span class="keyword">null</span>) &#123;</span><br><span class="line">    bd.setDestroyMethodName(<span class="keyword">this</span>.defaults.getDestroyMethod());</span><br><span class="line">    bd.setEnforceDestroyMethod(<span class="keyword">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 解析 factory-method 标签</span></span><br><span class="line">  <span class="keyword">if</span> (ele.hasAttribute(FACTORY_METHOD_ATTRIBUTE)) &#123;</span><br><span class="line">    bd.setFactoryMethodName(ele.getAttribute(FACTORY_METHOD_ATTRIBUTE));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (ele.hasAttribute(FACTORY_BEAN_ATTRIBUTE)) &#123;</span><br><span class="line">    bd.setFactoryBeanName(ele.getAttribute(FACTORY_BEAN_ATTRIBUTE));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> bd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面代码我们可以清晰地看到对 <code>Bean</code> 标签属性的解析，这些属性我们在工作中都或多或少用到过。 完成 Bean 标签基本属性解析后，会依次调用 <code>parseMetaElements()</code>、<code>parseLookupOverrideSubElements()</code>、<code>parseReplacedMethodSubElements()</code> 对子元素 <code>meta</code>、<code>lookup-method</code>、<code>replace-method</code> 完成解析。下篇博文将会对这三个子元素进行详细说明。</p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
          <category> 《Spring源码分析》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> 死磕Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IOC之解析bean标签：开启解析进程</title>
      <link href="/blog/2020/01/08/fb623179.html"/>
      <url>/blog/2020/01/08/fb623179.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文作者：chenssy</p><p>出处：<a href="http://cmsblogs.com/?p=2731">http://cmsblogs.com/?p=2731</a></p><p>在学习<code>Spring源码</code>的过程中发现的好站+好贴，感谢作者。Spring版本：<strong>Spring 5.0.6.RELEASE</strong></p></blockquote><hr><p><code>import</code> 标签解析完毕了，再看 <code>Spring</code> 中最复杂也是最重要的标签 <code>bean</code> 标签的解析过程。 在方法 <code>parseDefaultElement()</code> 中，如果遇到标签 为 <code>bean</code> 则调用 <code>processBeanDefinition()</code> 方法进行 bean 标签解析，如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">processBeanDefinition</span><span class="params">(Element ele, </span></span></span><br><span class="line"><span class="function"><span class="params">                                     BeanDefinitionParserDelegate delegate)</span> </span>&#123;</span><br><span class="line">  BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);</span><br><span class="line">  <span class="keyword">if</span> (bdHolder != <span class="keyword">null</span>) &#123;</span><br><span class="line">    bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// Register the final decorated instance.</span></span><br><span class="line">      BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, </span><br><span class="line">                                                       getReaderContext().getRegistry());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (BeanDefinitionStoreException ex) &#123;</span><br><span class="line">      getReaderContext().error(<span class="string">&quot;Failed to register bean definition with name &#x27;&quot;</span> </span><br><span class="line">                               +</span><br><span class="line">                               bdHolder.getBeanName() + <span class="string">&quot;&#x27;&quot;</span>, ele, ex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Send registration event.</span></span><br><span class="line">    getReaderContext().fireComponentRegistered(<span class="keyword">new</span> BeanComponentDefinition(bdHolder));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整个过程分为四个步骤</p><ol><li>调用 <code>BeanDefinitionParserDelegate.parseBeanDefinitionElement()</code> 进行元素解析，解析过程中如果失败，返回 <strong>null</strong>，错误由 <code>ProblemReporter</code> 处理。如果解析成功则返回 <code>BeanDefinitionHolder</code> 实例 <code>bdHolder</code>。<code>BeanDefinitionHolder</code> 为持有 <code>name</code> 和 <code>alias</code> 的 <code>BeanDefinition</code>。</li><li>若实例 <code>bdHolder</code> 不为空，则调用 <code>BeanDefinitionParserDelegate.decorateBeanDefinitionIfRequired()</code> 进行自定义标签处理</li><li>解析完成后，则调用 <code>BeanDefinitionReaderUtils.registerBeanDefinition()</code> 对 <code>bdHolder</code> 进行注册</li><li>发出响应事件，通知相关的监听器，完成 <code>Bean</code> 标签解析</li></ol><p>先看方法 <code>parseBeanDefinitionElement()</code>，如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> BeanDefinitionHolder <span class="title">parseBeanDefinitionElement</span><span class="params">(Element ele, </span></span></span><br><span class="line"><span class="function"><span class="params">                                                       <span class="meta">@Nullable</span> BeanDefinition containingBean)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 解析 ID 属性</span></span><br><span class="line">  String id = ele.getAttribute(ID_ATTRIBUTE);</span><br><span class="line">  <span class="comment">// 解析 name 属性</span></span><br><span class="line">  String nameAttr = ele.getAttribute(NAME_ATTRIBUTE);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 分割 name 属性</span></span><br><span class="line">  List&lt;String&gt; aliases = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  <span class="keyword">if</span> (StringUtils.hasLength(nameAttr)) &#123;</span><br><span class="line">    String[] nameArr = StringUtils.tokenizeToStringArray(nameAttr, MULTI_VALUE_ATTRIBUTE_DELIMITERS);</span><br><span class="line">    aliases.addAll(Arrays.asList(nameArr));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  String beanName = id;</span><br><span class="line">  <span class="keyword">if</span> (!StringUtils.hasText(beanName) &amp;&amp; !aliases.isEmpty()) &#123;</span><br><span class="line">    beanName = aliases.remove(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">      logger.debug(<span class="string">&quot;No XML &#x27;id&#x27; specified - using &#x27;&quot;</span> + beanName +</span><br><span class="line">                   <span class="string">&quot;&#x27; as bean name and &quot;</span> + aliases + <span class="string">&quot; as aliases&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 检查 name 的唯一性</span></span><br><span class="line">  <span class="keyword">if</span> (containingBean == <span class="keyword">null</span>) &#123;</span><br><span class="line">    checkNameUniqueness(beanName, aliases, ele);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 解析 属性，构造 AbstractBeanDefinition</span></span><br><span class="line">  AbstractBeanDefinition beanDefinition = parseBeanDefinitionElement(ele, beanName, containingBean);</span><br><span class="line">  <span class="keyword">if</span> (beanDefinition != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果 beanName 不存在，则根据条件构造一个 beanName</span></span><br><span class="line">    <span class="keyword">if</span> (!StringUtils.hasText(beanName)) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (containingBean != <span class="keyword">null</span>) &#123;</span><br><span class="line">          beanName = BeanDefinitionReaderUtils.generateBeanName(</span><br><span class="line">            beanDefinition, <span class="keyword">this</span>.readerContext.getRegistry(), <span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">          beanName = <span class="keyword">this</span>.readerContext.generateBeanName(beanDefinition);</span><br><span class="line">          String beanClassName = beanDefinition.getBeanClassName();</span><br><span class="line">          <span class="keyword">if</span> (beanClassName != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">              beanName.startsWith(beanClassName) &amp;&amp; beanName.length() </span><br><span class="line">              &gt; beanClassName.length() &amp;&amp;</span><br><span class="line">              !<span class="keyword">this</span>.readerContext.getRegistry().isBeanNameInUse(beanClassName)) &#123;</span><br><span class="line">            aliases.add(beanClassName);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">          logger.debug(<span class="string">&quot;Neither XML &#x27;id&#x27; nor &#x27;name&#x27; specified - &quot;</span> +</span><br><span class="line">                       <span class="string">&quot;using generated bean name [&quot;</span> + beanName + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">        error(ex.getMessage(), ele);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    String[] aliasesArray = StringUtils.toStringArray(aliases);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 封装 BeanDefinitionHolder</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> BeanDefinitionHolder(beanDefinition, beanName, aliasesArray);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法还没有对 <code>Bean</code> 标签进行解析，只是在解析动作之前做了一些功能架构，主要的工作有：</p><ul><li>解析 <code>id</code>、<code>name</code> 属性，确定 <code>alias</code> 集合，检测 <code>beanName</code> 是否唯一</li><li>调用方法 <code>parseBeanDefinitionElement()</code> 对属性进行解析并封装成 <code>GenericBeanDefinition</code> 实例 <code>beanDefinition</code></li><li>根据所获取的信息（<code>beanName</code>、<code>aliases</code>、<code>beanDefinition</code>）构造 <code>BeanDefinitionHolder</code> 实例对象并返回。</li></ul><p>这里有必要说下 <code>beanName</code> 的命名规则：如果 <code>id</code> 不为空，则 <code>beanName = id</code>；如果 <code>id</code> 为空，但是 <code>alias</code> 不空，则 <code>beanName</code> 为 <code>alias</code> 的第一个元素，如果两者都为空，则根据默认规则来设置 <code>beanName</code>。 上面三个步骤第二个步骤为核心方法，它主要承担解析 Bean 标签中所有的属性值。如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> AbstractBeanDefinition <span class="title">parseBeanDefinitionElement</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  Element ele, String beanName, <span class="meta">@Nullable</span> BeanDefinition containingBean)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.parseState.push(<span class="keyword">new</span> BeanEntry(beanName));</span><br><span class="line"></span><br><span class="line">  String className = <span class="keyword">null</span>;</span><br><span class="line">  <span class="comment">// 解析 class 属性</span></span><br><span class="line">  <span class="keyword">if</span> (ele.hasAttribute(CLASS_ATTRIBUTE)) &#123;</span><br><span class="line">    className = ele.getAttribute(CLASS_ATTRIBUTE).trim();</span><br><span class="line">  &#125;</span><br><span class="line">  String parent = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 解析 parent 属性</span></span><br><span class="line">  <span class="keyword">if</span> (ele.hasAttribute(PARENT_ATTRIBUTE)) &#123;</span><br><span class="line">    parent = ele.getAttribute(PARENT_ATTRIBUTE);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建用于承载属性的 GenericBeanDefinition 实例</span></span><br><span class="line">    AbstractBeanDefinition bd = createBeanDefinition(className, parent);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析默认 bean 的各种属性</span></span><br><span class="line">    parseBeanDefinitionAttributes(ele, beanName, containingBean, bd);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提取 description</span></span><br><span class="line">    bd.setDescription(DomUtils.getChildElementValueByTagName(ele, </span><br><span class="line">                                                             DESCRIPTION_ELEMENT));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析元数据</span></span><br><span class="line">    parseMetaElements(ele, bd);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析 lookup-method 属性</span></span><br><span class="line">    parseLookupOverrideSubElements(ele, bd.getMethodOverrides());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析 replaced-method 属性</span></span><br><span class="line">    parseReplacedMethodSubElements(ele, bd.getMethodOverrides());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析构造函数参数</span></span><br><span class="line">    parseConstructorArgElements(ele, bd);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析 property 子元素</span></span><br><span class="line">    parsePropertyElements(ele, bd);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析 qualifier 子元素</span></span><br><span class="line">    parseQualifierElements(ele, bd);</span><br><span class="line"></span><br><span class="line">    bd.setResource(<span class="keyword">this</span>.readerContext.getResource());</span><br><span class="line">    bd.setSource(extractSource(ele));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> bd;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">    error(<span class="string">&quot;Bean class [&quot;</span> + className + <span class="string">&quot;] not found&quot;</span>, ele, ex);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (NoClassDefFoundError err) &#123;</span><br><span class="line">    error(<span class="string">&quot;Class that bean class [&quot;</span> + className </span><br><span class="line">          + <span class="string">&quot;] depends on not found&quot;</span>, ele, err);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">    error(<span class="string">&quot;Unexpected failure during bean definition parsing&quot;</span>,</span><br><span class="line">          ele, ex);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.parseState.pop();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里，<code>Bean</code> 标签的所有属性我们都可以看到其解析的过程，也就说到这里我们已经解析一个基本可用的 <code>BeanDefinition</code>。 由于解析过程较为漫长，篇幅较大，为了更好的观看体验，将这篇博文进行拆分。下篇博客主要介绍 <code>BeanDefinition</code>，以及解析默认 <code>Bean</code> 的过程（<code>parseBeanDefinitionAttributes()</code>） – - <a href="/2020/01/07/3f8e0ea3.html">IOC 之解析Bean：解析 import 标签</a></p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
          <category> 《Spring源码分析》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> 死磕Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IoC之解析Bean：解析import标签</title>
      <link href="/blog/2020/01/07/3f8e0ea3.html"/>
      <url>/blog/2020/01/07/3f8e0ea3.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文作者：chenssy</p><p>出处：<a href="http://cmsblogs.com/?p=2724">http://cmsblogs.com/?p=2724</a></p><p>在学习<code>Spring源码</code>的过程中发现的好站+好贴，感谢作者。Spring版本：<strong>Spring 5.0.6.RELEASE</strong></p></blockquote><hr><p>在<a href="/2020/01/06/9de498cf.html">IOC 之 注册 BeanDefinition</a>中分析到，<code>Spring</code> 中有两种解析 <code>Bean</code> 的方式。如果根节点或者子节点采用默认命名空间的话，则调用 <code>parseDefaultElement()</code> 进行默认标签解析，否则调用 <code>delegate.parseCustomElement()</code> 方法进行自定义解析。所以，以下博客就这两个方法进行详细分析说明，先从默认标签解析过程开始，源码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parseDefaultElement</span><span class="params">(Element ele, </span></span></span><br><span class="line"><span class="function"><span class="params">                                 BeanDefinitionParserDelegate delegate)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 对 import 标签的解析</span></span><br><span class="line">  <span class="keyword">if</span> (delegate.nodeNameEquals(ele, IMPORT_ELEMENT)) &#123;</span><br><span class="line">    importBeanDefinitionResource(ele);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 对 alias 标签的解析</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (delegate.nodeNameEquals(ele, ALIAS_ELEMENT)) &#123;</span><br><span class="line">    processAliasRegistration(ele);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 对 bean 标签的解析</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (delegate.nodeNameEquals(ele, BEAN_ELEMENT)) &#123;</span><br><span class="line">    processBeanDefinition(ele, delegate);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 对 beans 标签的解析</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (delegate.nodeNameEquals(ele, NESTED_BEANS_ELEMENT)) &#123;</span><br><span class="line">  <span class="comment">// recurse</span></span><br><span class="line">    doRegisterBeanDefinitions(ele);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法的功能一目了然，分别是对四种不同的标签进行解析，分别是 <code>import</code>、<code>alias</code>、<code>bean</code>、<code>beans</code>。咱门从第一个标签 <code>import</code> 开始。</p><h2 id="import-标签的处理"><a href="#import-标签的处理" class="headerlink" title="import 标签的处理"></a>import 标签的处理</h2><p>经历过 <code>Spring</code> 配置文件的小伙伴都知道，如果工程比较大，配置文件的维护会让人觉得恐怖，文件太多了，想象将所有的配置都放在一个 <code>spring.xml</code> 配置文件中，哪种后怕感是不是很明显？所有针对这种情况 <code>Spring</code> 提供了一个分模块的思路，利用 <code>import</code> 标签，例如我们可以构造一个这样的 <code>spring.xml</code>。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">import</span> <span class="attr">resource</span>=<span class="string">&quot;spring-student.xml&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">import</span> <span class="attr">resource</span>=<span class="string">&quot;spring-student-dtd.xml&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>spring.xml</code> 配置文件中使用 <code>import</code> 标签的方式导入其他模块的配置文件。</p><ul><li>如果有配置需要修改直接修改相应配置文件即可。</li><li>若有新的模块需要引入直接增加 <code>import</code> 即可。</li></ul><p>这样大大简化了配置后期维护的复杂度，同时也易于管理。 </p><h2 id="importBeanDefinitionResource"><a href="#importBeanDefinitionResource" class="headerlink" title="importBeanDefinitionResource"></a>importBeanDefinitionResource</h2><p><code>Spring</code> 利用 <code>importBeanDefinitionResource()</code> 方法完成对 <code>import</code> 标签的解析。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">importBeanDefinitionResource</span><span class="params">(Element ele)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 获取 resource 的属性值 </span></span><br><span class="line">  String location = ele.getAttribute(RESOURCE_ATTRIBUTE);</span><br><span class="line">  <span class="comment">// 为空，直接退出</span></span><br><span class="line">  <span class="keyword">if</span> (!StringUtils.hasText(location)) &#123;</span><br><span class="line">    getReaderContext().error(<span class="string">&quot;Resource location must not be empty&quot;</span>, ele);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 解析系统属性，格式如 ：&quot;$&#123;user.dir&#125;&quot;</span></span><br><span class="line">  location = getReaderContext().getEnvironment().resolveRequiredPlaceholders(location);</span><br><span class="line"></span><br><span class="line">  Set&lt;Resource&gt; actualResources = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断 location 是相对路径还是绝对路径</span></span><br><span class="line">  <span class="keyword">boolean</span> absoluteLocation = <span class="keyword">false</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    absoluteLocation = ResourcePatternUtils.isUrl(location) || ResourceUtils.toURI(location).isAbsolute();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (URISyntaxException ex) &#123;</span><br><span class="line">    <span class="comment">// cannot convert to an URI, considering the location relative</span></span><br><span class="line">    <span class="comment">// unless it is the well-known Spring prefix &quot;classpath*:&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 绝对路径</span></span><br><span class="line">  <span class="keyword">if</span> (absoluteLocation) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 直接根据地质加载相应的配置文件</span></span><br><span class="line">      <span class="keyword">int</span> importCount = getReaderContext()</span><br><span class="line">        .getReader().loadBeanDefinitions(location, actualResources);</span><br><span class="line">      <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">        logger.debug(<span class="string">&quot;Imported &quot;</span> </span><br><span class="line">                     + importCount </span><br><span class="line">                     + <span class="string">&quot; bean definitions from URL location [&quot;</span> </span><br><span class="line">                     + location + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (BeanDefinitionStoreException ex) &#123;</span><br><span class="line">      getReaderContext().error(</span><br><span class="line">        <span class="string">&quot;Failed to import bean definitions from URL location [&quot;</span> </span><br><span class="line">        + location + <span class="string">&quot;]&quot;</span>, ele, ex);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 相对路径则根据相应的地质计算出绝对路径地址</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">int</span> importCount;</span><br><span class="line">      Resource relativeResource = getReaderContext()</span><br><span class="line">        .getResource().createRelative(location);</span><br><span class="line">      <span class="keyword">if</span> (relativeResource.exists()) &#123;</span><br><span class="line">        importCount = getReaderContext()</span><br><span class="line">          .getReader().loadBeanDefinitions(relativeResource);</span><br><span class="line">        actualResources.add(relativeResource);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        String baseLocation = getReaderContext()</span><br><span class="line">          .getResource().getURL().toString();</span><br><span class="line">        importCount = getReaderContext().getReader()</span><br><span class="line">          .loadBeanDefinitions(</span><br><span class="line">          StringUtils.applyRelativePath(baseLocation, location), </span><br><span class="line">          actualResources);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">        logger.debug(<span class="string">&quot;Imported &quot;</span> + importCount </span><br><span class="line">                     + <span class="string">&quot; bean definitions from relative location [&quot;</span> </span><br><span class="line">                     + location + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">      getReaderContext().error(<span class="string">&quot;Failed to resolve current resource location&quot;</span>, ele, ex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (BeanDefinitionStoreException ex) &#123;</span><br><span class="line">      getReaderContext()</span><br><span class="line">        .error(<span class="string">&quot;Failed to import bean definitions from relative location [&quot;</span> </span><br><span class="line">               + location + <span class="string">&quot;]&quot;</span>,</span><br><span class="line">                               ele, ex);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 解析成功后，进行监听器激活处理</span></span><br><span class="line">  Resource[] actResArray = actualResources.toArray(<span class="keyword">new</span> Resource[<span class="number">0</span>]);</span><br><span class="line">  getReaderContext().fireImportProcessed(location, actResArray, extractSource(ele));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解析 import 过程较为清晰，整个过程如下：</strong></p><ol><li>获取 <code>source</code> 属性的值，该值表示资源的路径</li><li>解析路径中的系统属性，如”<code>$&#123;user.dir&#125;</code>“</li><li>判断资源路径 <code>location</code> 是绝对路径还是相对路径</li><li>如果是绝对路径，则调递归调用 <code>Bean</code> 的解析过程，进行另一次的解析</li><li>如果是相对路径，则先计算出绝对路径得到 <code>Resource</code>，然后进行解析</li><li>通知监听器，完成解析</li></ol><p><strong>判断路径</strong> 方法通过以下方法来判断 <code>location</code> 是为相对路径还是绝对路径：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">absoluteLocation = ResourcePatternUtils.isUrl(location) || </span><br><span class="line">ResourceUtils.toURI(location).isAbsolute();</span><br></pre></td></tr></table></figure><p>判断绝对路径的规则如下：</p><ul><li>以 <strong>classpath*:</strong> 或者 <strong>classpath:</strong> 开头为绝对路径</li><li>能够通过该 <code>location</code> 构建出 <code>java.net.URL</code>为绝对路径</li><li>根据 <code>location</code> 构造 <code>java.net.URI</code> 判断调用 <code>isAbsolute()</code> 判断是否为绝对路径</li></ul><p><strong>绝对路径</strong> 如果 <code>location</code> 为绝对路径则调用 <code>loadBeanDefinitions()</code>，该方法在 <code>AbstractBeanDefinitionReader</code> 中定义。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">loadBeanDefinitions</span><span class="params">(String location, <span class="meta">@Nullable</span> Set&lt;Resource&gt; actualResources)</span> </span></span><br><span class="line"><span class="function">  <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line">  ResourceLoader resourceLoader = getResourceLoader();</span><br><span class="line">  <span class="keyword">if</span> (resourceLoader == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(</span><br><span class="line">      <span class="string">&quot;Cannot import bean definitions from location [&quot;</span> </span><br><span class="line">      + location + <span class="string">&quot;]: no ResourceLoader available&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (resourceLoader <span class="keyword">instanceof</span> ResourcePatternResolver) &#123;</span><br><span class="line">    <span class="comment">// Resource pattern matching available.</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      Resource[] resources = ((ResourcePatternResolver) resourceLoader)</span><br><span class="line">        .getResources(location);</span><br><span class="line">      <span class="keyword">int</span> loadCount = loadBeanDefinitions(resources);</span><br><span class="line">      <span class="keyword">if</span> (actualResources != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Resource resource : resources) &#123;</span><br><span class="line">          actualResources.add(resource);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">        logger.debug(<span class="string">&quot;Loaded &quot;</span> + loadCount </span><br><span class="line">                     + <span class="string">&quot; bean definitions from location pattern [&quot;</span> </span><br><span class="line">                     + location + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> loadCount;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(</span><br><span class="line">        <span class="string">&quot;Could not resolve bean definition resource pattern [&quot;</span> </span><br><span class="line">        + location + <span class="string">&quot;]&quot;</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Can only load single resources by absolute URL.</span></span><br><span class="line">    Resource resource = resourceLoader.getResource(location);</span><br><span class="line">    <span class="keyword">int</span> loadCount = loadBeanDefinitions(resource);</span><br><span class="line">    <span class="keyword">if</span> (actualResources != <span class="keyword">null</span>) &#123;</span><br><span class="line">      actualResources.add(resource);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">      logger.debug(<span class="string">&quot;Loaded &quot;</span> </span><br><span class="line">                   + loadCount </span><br><span class="line">                   + <span class="string">&quot; bean definitions from location [&quot;</span> </span><br><span class="line">                   + location + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> loadCount;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整个逻辑比较简单：</p><ol><li>首先获取 ResourceLoader</li><li>然后根据不同的 ResourceLoader 执行不同的逻辑，主要是可能存在多个 Resource</li><li>最终都会回归到 <code>XmlBeanDefinitionReader.loadBeanDefinitions()</code> ，所以这是一个递归的过程。 </li><li>获得到的 Resource 的对象或数组，都会添加到 <code>actualResources</code> 中。</li></ol><h3 id="相对路径"><a href="#相对路径" class="headerlink" title="相对路径"></a>相对路径</h3><p>如果是相对路径则会根据相应的 <code>Resource</code> 计算出相应的绝对路径，然后</p><ol><li>根据该路径构造一个 <code>Resource</code>，若该 <code>Resource</code> 存在，则调用 <code>XmlBeanDefinitionReader.loadBeanDefinitions()</code> 进行 BeanDefinition 加载</li><li>否则构造一个绝对 <code>location</code> ，调用 <code>AbstractBeanDefinitionReader.loadBeanDefinitions()</code> 方法，与绝对路径过程一样。 </li></ol><p>至此，<code>import</code> 标签解析完毕，整个过程比较清晰明了：<strong>获取 source 属性值，得到正确的资源路径，然后调用 <code>loadBeanDefinitions()</code> 方法进行递归的 BeanDefinition 加载</strong></p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
          <category> 《Spring源码分析》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> 死磕Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IoC之注册BeanDefinitions</title>
      <link href="/blog/2020/01/06/9de498cf.html"/>
      <url>/blog/2020/01/06/9de498cf.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文作者：chenssy</p><p>出处：<a href="http://cmsblogs.com/?p=2697">http://cmsblogs.com/?p=2697</a></p><p>在学习<code>Spring源码</code>的过程中发现的好站+好贴，感谢作者。Spring版本：<strong>Spring 5.0.6.RELEASE</strong></p></blockquote><hr><p>获取 <code>Document</code> 对象后，会根据该对象和 <code>Resource</code> 资源对象调用 <code>registerBeanDefinitions()</code> 方法，开始注册 <code>BeanDefinitions</code> 之旅。如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">registerBeanDefinitions</span><span class="params">(Document doc, Resource resource)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line">  BeanDefinitionDocumentReader documentReader = createBeanDefinitionDocumentReader();</span><br><span class="line">  <span class="keyword">int</span> countBefore = getRegistry().getBeanDefinitionCount();</span><br><span class="line">  documentReader.registerBeanDefinitions(doc, createReaderContext(resource));</span><br><span class="line">  <span class="keyword">return</span> getRegistry().getBeanDefinitionCount() - countBefore;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先调用 <code>createBeanDefinitionDocumentReader()</code> 方法实例化 <code>BeanDefinitionDocumentReader</code> 对象，然后获取统计前 <code>BeanDefinition</code> 的个数，最后调用 <code>registerBeanDefinitions()</code> 注册 <code>BeanDefinition</code>。 实例化 <code>BeanDefinitionDocumentReader</code> 对象方法如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> BeanDefinitionDocumentReader <span class="title">createBeanDefinitionDocumentReader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> BeanDefinitionDocumentReader.class.cast(BeanUtils</span><br><span class="line">                                  .instantiateClass(<span class="keyword">this</span>.documentReaderClass));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注册 <code>BeanDefinition</code> 的方法 <code>registerBeanDefinitions()</code> 是在接口 <code>BeanDefinitionDocumentReader</code> 中定义，如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(Document doc, XmlReaderContext readerContext)</span></span></span><br><span class="line"><span class="function">  <span class="keyword">throws</span> BeanDefinitionStoreException</span>;</span><br></pre></td></tr></table></figure><blockquote><p><strong>从给定的 Document 对象中解析定义的 BeanDefinition 并将他们注册到注册表中</strong>。</p></blockquote><p>方法接收两个参数，待解析的 <code>Document</code> 对象，以及解析器的当前上下文，包括目标注册表和被解析的资源。其中 <code>readerContext</code> 是根据 <code>Resource</code> 来创建的，如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> XmlReaderContext <span class="title">createReaderContext</span><span class="params">(Resource resource)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> XmlReaderContext(resource, <span class="keyword">this</span>.problemReporter, <span class="keyword">this</span>.eventListener,</span><br><span class="line">                              <span class="keyword">this</span>.sourceExtractor, <span class="keyword">this</span>, getNamespaceHandlerResolver());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>DefaultBeanDefinitionDocumentReader</code> 对该方法提供了实现：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(Document doc, XmlReaderContext readerContext)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.readerContext = readerContext;</span><br><span class="line">  logger.debug(<span class="string">&quot;Loading bean definitions&quot;</span>);</span><br><span class="line">  Element root = doc.getDocumentElement();</span><br><span class="line">  doRegisterBeanDefinitions(root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用 <code>doRegisterBeanDefinitions()</code> 开启注册 <code>BeanDefinition</code> 之旅。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doRegisterBeanDefinitions</span><span class="params">(Element root)</span> </span>&#123;</span><br><span class="line">  BeanDefinitionParserDelegate parent = <span class="keyword">this</span>.delegate;</span><br><span class="line">  <span class="keyword">this</span>.delegate = createDelegate(getReaderContext(), root, parent);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.delegate.isDefaultNamespace(root)) &#123;</span><br><span class="line">    <span class="comment">// 处理 profile</span></span><br><span class="line">    String profileSpec = root.getAttribute(PROFILE_ATTRIBUTE);</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.hasText(profileSpec)) &#123;</span><br><span class="line">      String[] specifiedProfiles = StringUtils.tokenizeToStringArray(</span><br><span class="line">        profileSpec, BeanDefinitionParserDelegate.MULTI_VALUE_ATTRIBUTE_DELIMITERS);</span><br><span class="line">      <span class="keyword">if</span> (!getReaderContext().getEnvironment().acceptsProfiles(specifiedProfiles)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">          logger.info(</span><br><span class="line">            <span class="string">&quot;Skipped XML bean definition file due to specified profiles [&quot;</span> </span><br><span class="line">            + profileSpec +</span><br><span class="line">                      <span class="string">&quot;] not matching: &quot;</span> + getReaderContext().getResource());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 解析前处理</span></span><br><span class="line">  preProcessXml(root);</span><br><span class="line">  <span class="comment">// 解析</span></span><br><span class="line">  parseBeanDefinitions(root, <span class="keyword">this</span>.delegate);</span><br><span class="line">  <span class="comment">// 解析后处理</span></span><br><span class="line">  postProcessXml(root);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.delegate = parent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序首先处理 <code>profile</code>属性，<code>profile</code>主要用于我们切换环境，比如切换开发、测试、生产环境，非常方便。然后调用 <code>parseBeanDefinitions()</code> 进行解析动作，不过在该方法之前之后分别调用 <code>preProcessXml()</code> 和 <code>postProcessXml()</code> 方法来进行前、后处理，目前这两个方法都是空实现，交由子类来实现。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">preProcessXml</span><span class="params">(Element root)</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">postProcessXml</span><span class="params">(Element root)</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>parseBeanDefinitions()</code> 定义如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">parseBeanDefinitions</span><span class="params">(Element root, BeanDefinitionParserDelegate delegate)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (delegate.isDefaultNamespace(root)) &#123;</span><br><span class="line">    NodeList nl = root.getChildNodes();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nl.getLength(); i++) &#123;</span><br><span class="line">      Node node = nl.item(i);</span><br><span class="line">      <span class="keyword">if</span> (node <span class="keyword">instanceof</span> Element) &#123;</span><br><span class="line">        Element ele = (Element) node;</span><br><span class="line">        <span class="keyword">if</span> (delegate.isDefaultNamespace(ele)) &#123;</span><br><span class="line">          parseDefaultElement(ele, delegate);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">          delegate.parseCustomElement(ele);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    delegate.parseCustomElement(root);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终解析动作落地在两个方法处：<code>parseDefaultElement(ele, delegate)</code> 和 <code>delegate.parseCustomElement(root)</code>。我们知道在 Spring 有两种 Bean 声明方式：</p><ul><li>配置文件式声明：<code>&lt;bean id=&quot;studentService&quot; class=&quot;org.springframework.core.StudentService&quot;/&gt;</code></li><li>自定义注解方式：<code>&lt;tx:annotation-driven&gt;</code></li></ul><p>两种方式的读取和解析都存在较大的差异，所以采用不同的解析方法，如果根节点或者子节点采用默认命名空间的话，则调用 <code>parseDefaultElement()</code> 进行解析，否则调用 <code>delegate.parseCustomElement()</code> 方法进行自定义解析。 至此，<code>doLoadBeanDefinitions()</code> 中做的三件事情已经全部分析完毕，下面将对 <code>Bean</code> 的解析过程做详细分析说明。</p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
          <category> 《Spring源码分析》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> 死磕Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IOC之获取Document对象</title>
      <link href="/blog/2020/01/05/13336b20.html"/>
      <url>/blog/2020/01/05/13336b20.html</url>
      
        <content type="html"><![CDATA[<p>在 <code>XmlBeanDefinitionReader.doLoadDocument()</code> 方法中做了两件事情，一是调用 <code>getValidationModeForResource()</code> 获取 <code>XML</code> 的验证模式，二是调用 <code>DocumentLoader.loadDocument()</code> 获取 <code>Document</code> 对象。上篇博客已经分析了获取 <code>XML</code> 验证模式（<a href="/2020/01/04/4e0696ee.html">IOC 之 获取验证模型</a>），这篇我们分析获取 <code>Document</code> 对象。 </p><h2 id="DocumentLoader"><a href="#DocumentLoader" class="headerlink" title="DocumentLoader"></a>DocumentLoader</h2><p>获取 <code>Document</code> 的策略由接口 <code>DocumentLoader</code> 定义，如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DocumentLoader</span> </span>&#123;</span><br><span class="line">    <span class="function">Document <span class="title">loadDocument</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            InputSource inputSource, EntityResolver entityResolver,</span></span></span><br><span class="line"><span class="function"><span class="params">            ErrorHandler errorHandler, <span class="keyword">int</span> validationMode, <span class="keyword">boolean</span> namespaceAware)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>DocumentLoader</code> 中只有一个方法</p><p><code>loadDocument()</code> ，该方法接收五个参数： </p><ol><li><strong>inputSource</strong>：加载 Document 的 Resource 源 </li><li><strong>entityResolver</strong>：解析文件的解析器 </li><li><strong>errorHandler</strong>：处理加载 Document 对象的过程的错误 </li><li><strong>validationMode</strong>：验证模式 </li><li><strong>namespaceAware</strong>：命名空间支持。</li></ol><p>如果要提供对 <code>XML</code> 名称空间的支持，则为<code>true</code> 该方法由 <code>DocumentLoader</code> 的默认实现类 <code>DefaultDocumentLoader</code> 实现，如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Document <span class="title">loadDocument</span><span class="params">(InputSource inputSource, </span></span></span><br><span class="line"><span class="function"><span class="params">                             EntityResolver entityResolver,</span></span></span><br><span class="line"><span class="function"><span class="params">                             ErrorHandler errorHandler, </span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="keyword">int</span> validationMode, </span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="keyword">boolean</span> namespaceAware)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">  DocumentBuilderFactory factory = </span><br><span class="line">    createDocumentBuilderFactory(validationMode, namespaceAware);</span><br><span class="line">  <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">    logger.debug(<span class="string">&quot;Using JAXP provider [&quot;</span> </span><br><span class="line">                 + factory.getClass().getName() + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  DocumentBuilder builder = </span><br><span class="line">    createDocumentBuilder(factory, entityResolver, errorHandler);</span><br><span class="line">  <span class="keyword">return</span> builder.parse(inputSource);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先调用</p><p><code>createDocumentBuilderFactory()</code> 创建 <code>DocumentBuilderFactory</code> ，再通过该 <code>factory</code> 创建 <code>DocumentBuilder</code>，最后解析 <code>InputSource</code> 返回 <code>Document</code> 对象。</p><h2 id="EntityResolver"><a href="#EntityResolver" class="headerlink" title="EntityResolver"></a>EntityResolver</h2><p><code>loadDocument()</code> 获取 <code>Document</code> 对象时，有一个参数 <code>entityResolver</code> ，该参数是通过 <code>getEntityResolver()</code> 获取的。</p><blockquote><p><code>getEntityResolver()</code> 返回指定的解析器，如果没有指定，则构造一个未指定的默认解析器。</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> EntityResolver <span class="title">getEntityResolver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.entityResolver == <span class="keyword">null</span>) &#123;</span><br><span class="line">    ResourceLoader resourceLoader = getResourceLoader();</span><br><span class="line">    <span class="keyword">if</span> (resourceLoader != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.entityResolver = <span class="keyword">new</span> ResourceEntityResolver(resourceLoader);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.entityResolver = <span class="keyword">new</span> DelegatingEntityResolver(getBeanClassLoader());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.entityResolver;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果 ResourceLoader 不为 <strong>null</strong>，则根据指定的 ResourceLoader 创建一个 ResourceEntityResolver。</li><li>如果 ResourceLoader 为<strong>null</strong>，则创建 一个 DelegatingEntityResolver，该 Resolver 委托给默认的 BeansDtdResolver 和 PluggableSchemaResolver 。</li></ul><h3 id="涉及子类"><a href="#涉及子类" class="headerlink" title="涉及子类"></a>涉及子类</h3><ul><li>ResourceEntityResolver：继承自 EntityResolver ，通过 ResourceLoader 来解析实体的引用。</li><li>DelegatingEntityResolver：EntityResolver 的实现，分别代理了 dtd 的 BeansDtdResolver 和 xml schemas 的 PluggableSchemaResolver。</li><li>BeansDtdResolver ： spring bean dtd 解析器。EntityResolver 的实现，用来从 classpath 或者 jar 文件加载 dtd。</li><li>PluggableSchemaResolver：使用一系列 Map 文件将 schema url 解析到本地 classpath 资源</li></ul><p><code>getEntityResolver()</code> 返回 EntityResolver ，那这个 EntityResolver 到底是什么呢？</p><blockquote><p>If a SAX application needs to implement customized handling for external entities, it must implement this interface and register an instance with the SAX driver using the setEntityResolver method.<br>就是说：如果 SAX 应用程序需要实现自定义处理外部实体，则必须实现此接口并使用 <code>setEntityResolver()</code> 向 SAX 驱动器注册一个实例。 如下：</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyResolver</span> <span class="keyword">implements</span> <span class="title">EntityResolver</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> InputSource <span class="title">resolveEntity</span> <span class="params">(String publicId, String systemId)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (systemId.equals(<span class="string">&quot;http://www.myhost.com/today&quot;</span>))&#123;</span><br><span class="line">      MyReader reader = <span class="keyword">new</span> MyReader();</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> InputSource(reader);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// use the default behaviour</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们首先将</p><p><code>spring-student.xml</code> 文件中的 XSD 声明的地址改掉，如下：</p><p> <img src="https://cdn.jsdelivr.net/gh/cayzlh/git-img-repository@master/uPic/MdkyLc.jpg" alt="MdkyLc"></p><p>如果我们再次运行，则会报如下错误：</p><p><img src="https://cdn.jsdelivr.net/gh/cayzlh/git-img-repository@master/uPic/xpMUPz.jpg" alt="xpMUPz"></p><p>从上面的错误可以看到，是在进行文档验证时，无法根据声明找到 XSD 验证文件而导致无法进行 XML 文件验证。在(<a href="/archives/4e0696ee.html">IOC 之 获取验证模型</a>)中讲到，如果要解析一个 XML 文件，SAX 首先会读取该 XML 文档上的声明，然后根据声明去寻找相应的 DTD 定义，以便对文档进行验证。默认的加载规则是通过网络方式下载验证文件，而在实际生产环境中我们会遇到网络中断或者不可用状态，那么就应用就会因为无法下载验证文件而报错。</p><blockquote><p>EntityResolver 的作用就是应用本身可以提供一个如何寻找验证文件的方法，即自定义实现。 接口声明如下：</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">EntityResolver</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> InputSource <span class="title">resolveEntity</span> <span class="params">(String publicId,String systemId)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> SAXException, IOException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接口方法接收两个参数 publicId 和 systemId，并返回 InputSource 对象。两个参数声明如下：</p><ul><li><p>publicId：被引用的外部实体的公共标识符，如果没有提供，则返回null</p></li><li><p>systemId：被引用的外部实体的系统标识符 这两个参数的实际内容和具体的验证模式有关系。如下</p></li><li><p>XSD 验证模式</p><ul><li>publicId：null</li><li>systemId：<a href="http://www.springframework.org/schema/beans/spring-beans.xsd">http://www.springframework.org/schema/beans/spring-beans.xsd</a></li></ul></li><li><p>DTD 验证模式 </p><ul><li>publicId：-//SPRING//DTD BEAN 2.0//EN</li></ul></li><li><p>systemId：<a href="http://www.springframework.org/dtd/spring-beans.dtd">http://www.springframework.org/dtd/spring-beans.dtd</a> 如下： </p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/cayzlh/git-img-repository@master/uPic/7nooAW.jpg" alt="7nooAW"><a href="https://gitee.com/chenssy/blog-home/raw/master/image/201811/spring-201806071003.png"><img src="https://gitee.com/chenssy/blog-home/raw/master/image/201811/spring-201806071003.png" alt="spring-201806071003"></a>我们知道在 Spring 中使用 DelegatingEntityResolver 为 EntityResolver 的实现类，<code>resolveEntity()</code> 实现如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> InputSource <span class="title">resolveEntity</span><span class="params">(String publicId, </span></span></span><br><span class="line"><span class="function"><span class="params">                                 <span class="meta">@Nullable</span> String systemId)</span> </span></span><br><span class="line"><span class="function">  <span class="keyword">throws</span> SAXException, IOException </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (systemId != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (systemId.endsWith(DTD_SUFFIX)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.dtdResolver.resolveEntity(publicId, systemId);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (systemId.endsWith(XSD_SUFFIX)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.schemaResolver.resolveEntity(publicId, systemId);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不同的验证模式使用不同的解析器解析，如果是 DTD 验证模式则使用 BeansDtdResolver 来进行解析，如果是 XSD 则使用 PluggableSchemaResolver 来进行解析。 BeansDtdResolver 的解析过程如下:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> InputSource <span class="title">resolveEntity</span><span class="params">(String publicId,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 <span class="meta">@Nullable</span> String systemId)</span> </span></span><br><span class="line"><span class="function">  <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">    logger.trace(<span class="string">&quot;Trying to resolve XML entity with public ID [&quot;</span> </span><br><span class="line">                 + publicId +</span><br><span class="line">                 <span class="string">&quot;] and system ID [&quot;</span> </span><br><span class="line">                 + systemId + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (systemId != <span class="keyword">null</span> &amp;&amp; systemId.endsWith(DTD_EXTENSION)) &#123;</span><br><span class="line">    <span class="keyword">int</span> lastPathSeparator = systemId.lastIndexOf(<span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">    <span class="keyword">int</span> dtdNameStart = systemId.indexOf(DTD_NAME, lastPathSeparator);</span><br><span class="line">    <span class="keyword">if</span> (dtdNameStart != -<span class="number">1</span>) &#123;</span><br><span class="line">      String dtdFile = DTD_NAME + DTD_EXTENSION;</span><br><span class="line">      <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">        logger.trace(<span class="string">&quot;Trying to locate [&quot;</span> + dtdFile + <span class="string">&quot;] in Spring jar on classpath&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        Resource resource = <span class="keyword">new</span> ClassPathResource(dtdFile, getClass());</span><br><span class="line">        InputSource source = <span class="keyword">new</span> InputSource(resource.getInputStream());</span><br><span class="line">        source.setPublicId(publicId);</span><br><span class="line">        source.setSystemId(systemId);</span><br><span class="line">        <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">          logger.debug(<span class="string">&quot;Found beans DTD [&quot;</span> + systemId + <span class="string">&quot;] in classpath: &quot;</span> + dtdFile);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> source;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">        <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">          logger.debug(<span class="string">&quot;Could not resolve beans DTD [&quot;</span> </span><br><span class="line">                       + systemId + <span class="string">&quot;]: not found in classpath&quot;</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  or wherever.</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的代码中我们可以看到加载 DTD 类型的</p><p><code>BeansDtdResolver.resolveEntity()</code> 只是对 systemId 进行了简单的校验（从最后一个 / 开始，内容中是否包含 <code>spring-beans</code>），然后构造一个 InputSource 并设置 publicId、systemId，然后返回。 PluggableSchemaResolver 的解析过程如下:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> InputSource <span class="title">resolveEntity</span><span class="params">(String publicId, </span></span></span><br><span class="line"><span class="function"><span class="params">                                 <span class="meta">@Nullable</span> String systemId)</span> </span></span><br><span class="line"><span class="function">  <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">    logger.trace(<span class="string">&quot;Trying to resolve XML entity with public id [&quot;</span> </span><br><span class="line">                 + publicId +</span><br><span class="line">                 <span class="string">&quot;] and system id [&quot;</span> </span><br><span class="line">                 + systemId + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (systemId != <span class="keyword">null</span>) &#123;</span><br><span class="line">    String resourceLocation = getSchemaMappings().get(systemId);</span><br><span class="line">    <span class="keyword">if</span> (resourceLocation != <span class="keyword">null</span>) &#123;</span><br><span class="line">      Resource resource = <span class="keyword">new</span> ClassPathResource(resourceLocation, </span><br><span class="line">                                                <span class="keyword">this</span>.classLoader);</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        InputSource source = <span class="keyword">new</span> InputSource(resource.getInputStream());</span><br><span class="line">        source.setPublicId(publicId);</span><br><span class="line">        source.setSystemId(systemId);</span><br><span class="line">        <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">          logger.debug(<span class="string">&quot;Found XML schema [&quot;</span> </span><br><span class="line">                       + systemId + <span class="string">&quot;] in classpath: &quot;</span> </span><br><span class="line">                       + resourceLocation);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> source;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (FileNotFoundException ex) &#123;</span><br><span class="line">        <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">          logger.debug(<span class="string">&quot;Couldn&#x27;t find XML schema [&quot;</span></span><br><span class="line">                       + systemId + <span class="string">&quot;]: &quot;</span> + resource, ex);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先调用 getSchemaMappings() 获取一个映射表(systemId 与其在本地的对照关系)，然后根据传入的 systemId 获取该 systemId 在本地的路径 resourceLocation，最后根据 resourceLocation 构造 InputSource 对象。 映射表如下（部分）:</p><p><img src="https://cdn.jsdelivr.net/gh/cayzlh/git-img-repository@master/uPic/c1mMOc.jpg" alt="c1mMOc"></p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
          <category> 《Spring源码分析》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> 死磕Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IOC之获取验证模型</title>
      <link href="/blog/2020/01/04/4e0696ee.html"/>
      <url>/blog/2020/01/04/4e0696ee.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文作者：chenssy</p><p>出处：<a href="http://cmsblogs.com/?p=2658">http://cmsblogs.com/?p=2658</a></p><p>在学习<code>Spring源码</code>的过程中发现的好站+好贴，感谢作者。Spring版本：<strong>Spring 5.0.6.RELEASE</strong></p></blockquote><hr><p>在上篇博客<a href="/2020/01/03/a6d994a0.html">IOC 之 加载 BeanDefinition</a> 中提到，在核心逻辑方法 <code>doLoadBeanDefinitions()</code>中主要是做三件事情。</p><ol><li>调用 <code>getValidationModeForResource()</code> 获取 xml 文件的验证模式</li><li>调用 <code>loadDocument()</code> 根据 xml 文件获取相应的 Document 实例。</li><li>调用 <code>registerBeanDefinitions()</code> 注册 Bean 实例。</li></ol><p>这篇博客主要分析获取 <code>xml</code> 文件的验证模式。</p><blockquote><p>XML 文件的验证模式保证了 XML 文件的正确性</p></blockquote><h2 id="DTD-与-XSD-的区别"><a href="#DTD-与-XSD-的区别" class="headerlink" title="DTD 与 XSD 的区别"></a>DTD 与 XSD 的区别</h2><p><strong>DTD</strong>(<em>Document Type Definition</em>)，即文档类型定义，为 <code>XML</code> 文件的验证机制，属于 <code>XML</code> 文件中组成的一部分。<code>DTD</code> 是一种保证 <code>XML</code> 文档格式正确的有效验证方式，它定义了相关 <code>XML</code> 文档的元素、属性、排列方式、元素的内容类型以及元素的层次结构。其实 <code>DTD</code> 就相当于 <code>XML</code> 中的 “词汇”和“语法”，我们可以通过比较 <code>XML</code> 文件和 <code>DTD</code> 文件 来看文档是否符合规范，元素和标签使用是否正确。 要在 <code>Spring</code> 中使用 <code>DTD</code>，需要在 <code>Spring XML</code> 文件头部声明：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">beans</span> <span class="meta-keyword">PUBLIC</span>  <span class="meta-string">&quot;-//SPRING//DTD BEAN//EN&quot;</span> <span class="meta-string">&quot;http://www.springframework.org/dtd/spring-beans.dtd&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>DTD</code> 在一定的阶段推动了 <code>XML</code> 的发展，但是它本身存在着一些缺陷：</p><ol><li>它没有使用 <code>XML</code> 格式，而是自己定义了一套格式，相对解析器的重用性较差；而且 <code>DTD</code> 的构建和访问没有标准的编程接口，因而解析器很难简单的解析 <code>DTD</code> 文档。</li><li><code>DTD</code> 对元素的类型限制较少；同时其他的约束力也叫弱。</li><li><code>DTD</code> 扩展能力较差。</li><li>基于正则表达式的 <code>DTD</code> 文档的描述能力有限。</li></ol><p>针对 DTD 的缺陷，W3C 在 2001 年推出 XSD。XSD（XML Schemas Definition）即 XML Schema 语言。XML Schema 本身就是一个 XML文档，使用的是 XML 语法，因此可以很方便的解析 XSD 文档。</p><p><strong>相对于 DTD，XSD 具有如下优势：</strong></p><ul><li>XML Schema基于XML,没有专门的语法</li><li>XML Schema可以象其他XML文件一样解析和处理</li><li>XML Schema比DTD提供了更丰富的数据类型.</li><li>XML Schema提供可扩充的数据模型。</li><li>XML Schema支持综合命名空间</li><li>XML Schema支持属性组。</li></ul><h2 id="getValidationModeForResource-分析"><a href="#getValidationModeForResource-分析" class="headerlink" title="getValidationModeForResource() 分析"></a>getValidationModeForResource() 分析</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">getValidationModeForResource</span><span class="params">(Resource resource)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 获取指定的验证模式</span></span><br><span class="line">  <span class="keyword">int</span> validationModeToUse = getValidationMode();</span><br><span class="line">  <span class="comment">// 如果手动指定，则直接返回</span></span><br><span class="line">  <span class="keyword">if</span> (validationModeToUse != VALIDATION_AUTO) &#123;</span><br><span class="line">    <span class="keyword">return</span> validationModeToUse;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 通过程序检测</span></span><br><span class="line">  <span class="keyword">int</span> detectedMode = detectValidationMode(resource);</span><br><span class="line">  <span class="keyword">if</span> (detectedMode != VALIDATION_AUTO) &#123;</span><br><span class="line">    <span class="keyword">return</span> detectedMode;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 出现异常，返回 XSD</span></span><br><span class="line">  <span class="keyword">return</span> VALIDATION_XSD;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果指定了 XML 文件的的验证模式（调用<code>XmlBeanDefinitionReader.setValidating(boolean validating)</code>）则直接返回指定的验证模式，否则调用 <code>detectValidationMode()</code> 获取相应的验证模式，如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">detectValidationMode</span><span class="params">(Resource resource)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (resource.isOpen()) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(</span><br><span class="line">      <span class="string">&quot;Passed-in Resource [&quot;</span> + resource + <span class="string">&quot;] contains an open stream: &quot;</span> </span><br><span class="line">      +</span><br><span class="line">      <span class="string">&quot;cannot determine validation mode automatically. Either pass in a Resource &quot;</span> </span><br><span class="line">      +</span><br><span class="line">      <span class="string">&quot;that is able to create fresh streams, or explicitly specify the validationMode &quot;</span> </span><br><span class="line">      +</span><br><span class="line">      <span class="string">&quot;on your XmlBeanDefinitionReader instance.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  InputStream inputStream;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    inputStream = resource.getInputStream();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(</span><br><span class="line">      <span class="string">&quot;Unable to determine validation mode for [&quot;</span> </span><br><span class="line">      + resource </span><br><span class="line">      + <span class="string">&quot;]: cannot open InputStream. &quot;</span> </span><br><span class="line">      +</span><br><span class="line">      <span class="string">&quot;Did you attempt to load directly from a SAX InputSource without specifying the &quot;</span> </span><br><span class="line">      +</span><br><span class="line">      <span class="string">&quot;validationMode on your XmlBeanDefinitionReader instance?&quot;</span>, ex);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 核心方法</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.validationModeDetector.detectValidationMode(inputStream);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(</span><br><span class="line">      <span class="string">&quot;Unable to determine validation mode for [&quot;</span> </span><br><span class="line">      + resource </span><br><span class="line">      + <span class="string">&quot;]: an error occurred whilst reading from the InputStream.&quot;</span>, ex);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前面一大堆的代码，核心在于 <code>this.validationModeDetector.detectValidationMode(inputStream)</code>，<code>validationModeDetector</code> 定义为 <code>XmlValidationModeDetector</code>,所以验证模式的获取委托给 <code>XmlValidationModeDetector</code> 的 <code>detectValidationMode()</code> 方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">detectValidationMode</span><span class="params">(InputStream inputStream)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  BufferedReader reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(inputStream));</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">boolean</span> isDtdValidated = <span class="keyword">false</span>;</span><br><span class="line">    String content;</span><br><span class="line">    <span class="comment">// 一行一行读取 xml 文件的内容</span></span><br><span class="line">    <span class="keyword">while</span> ((content = reader.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">      content = consumeCommentTokens(content);</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.inComment || !StringUtils.hasText(content)) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 包含 DOCTYPE 为 DTD 模式</span></span><br><span class="line">      <span class="keyword">if</span> (hasDoctype(content)) &#123;</span><br><span class="line">        isDtdValidated = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 读取 &lt; 开始符号，验证模式一定会在 &lt; 符号之前</span></span><br><span class="line">      <span class="keyword">if</span> (hasOpeningTag(content)) &#123;</span><br><span class="line">        <span class="comment">// End of meaningful data...</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 为 true 返回 DTD，否则返回 XSD</span></span><br><span class="line">    <span class="keyword">return</span> (isDtdValidated ? VALIDATION_DTD : VALIDATION_XSD);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (CharConversionException ex) &#123;</span><br><span class="line">    <span class="comment">// 出现异常，为 XSD</span></span><br><span class="line">    <span class="keyword">return</span> VALIDATION_AUTO;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">finally</span> &#123;</span><br><span class="line">    reader.close();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码中看，主要是通过读取 <code>XML</code> 文件的内容，判断内容中是否包含有 <code>DOCTYPE</code> ，如果是 则为 <code>DTD</code>，否则为 <code>XSD</code>，当然只会读取到 第一个 “<code>&lt;</code>“ 处，因为 验证模式一定会在第一个 “<code>&lt;</code>” 之前。如果当中出现了 <code>CharConversionException</code> 异常，则为 <code>XSD</code>模式。 好了，<code>XML</code> 文件的验证模式分析完毕，下篇分析 <code>doLoadBeanDefinitions()</code> 的第二个步骤：获取 <code>Document</code> 实例。</p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
          <category> 《Spring源码分析》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> 死磕Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IoC之加载BeanDefinition</title>
      <link href="/blog/2020/01/03/a6d994a0.html"/>
      <url>/blog/2020/01/03/a6d994a0.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文作者：chenssy</p><p>出处：<a href="http://cmsblogs.com/?p=2658">http://cmsblogs.com/?p=2658</a></p><p>在学习<code>Spring源码</code>的过程中发现的好站+好贴，感谢作者。Spring版本：<strong>Spring 5.0.6.RELEASE</strong></p></blockquote><hr><p>开局先看一段代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ClassPathResource resource = <span class="keyword">new</span> ClassPathResource(<span class="string">&quot;bean.xml&quot;</span>);</span><br><span class="line">DefaultListableBeanFactory factory = <span class="keyword">new</span> DefaultListableBeanFactory();</span><br><span class="line">XmlBeanDefinitionReader reader = <span class="keyword">new</span> XmlBeanDefinitionReader(factory);</span><br><span class="line">reader.loadBeanDefinitions(resource);</span><br></pre></td></tr></table></figure><p>这段代码是 <code>Spring</code> 中编程式使用 <code>IOC</code> 容器，通过这四段简单的代码，我们可以初步判断 <code>IOC</code> 容器的使用过程。</p><ul><li><p>获取资源</p></li><li><p>获取 <code>BeanFactory</code></p></li><li><p>根据新建的 <code>BeanFactory</code> 创建一个<code>BeanDefinitionReader</code>对象，该<code>Reader</code> 对象为资源的解析器</p></li><li><p>装载资源 整个过程就分为三个步骤：资源定位、装载、注册，如下：</p><p><img src="https://cdn.jsdelivr.net/gh/cayzlh/git-img-repository@master/uPic/H2Cvub.jpg" alt="H2Cvub"></p></li></ul><ul><li><p><strong>资源定位</strong>。我们一般用外部资源来描述 <code>Bean</code> 对象，所以在初始化 <code>IOC</code> 容器的第一步就是需要定位这个外部资源。在（<a href="/2020/01/02/8f7aa5ac.html"> IOC 之 Spring 统一资源加载策略</a>）已经详细说明了资源加载的过程。 </p></li><li><p><strong>装载</strong>。装载就是 <code>BeanDefinition</code> 的载入。<code>BeanDefinitionReader</code> 读取、解析 <code>Resource</code> 资源，也就是将用户定义的 <code>Bean</code> 表示成 <code>IOC</code> 容器的内部数据结构：<code>BeanDefinition</code>。在 <code>IOC</code> 容器内部维护着一个 <code>BeanDefinition Map</code> 的数据结构，在配置文件中每一个 都对应着一个<code>BeanDefinition</code>对象。</p></li><li><p><strong>注册</strong>。向<code>IOC</code>容器注册在第二步解析好的 <code>BeanDefinition</code>，这个过程是通过 <code>BeanDefinitionRegistry</code> 接口来实现的。在 <code>IOC</code> 容器内部其实是将第二个过程解析得到的 <code>BeanDefinition</code> 注入到一个 <code>HashMap</code> 容器中，<code>IOC</code> 容器就是通过这个 <code>HashMap</code> 来维护这些 <code>BeanDefinition</code> 的。在这里需要注意的一点是这个过程并没有完成依赖注入，依赖注册是发生在应用第一次调用 <code>getBean()</code> 向容器索要 <code>Bean</code> 时。当然我们可以通过设置预处理，即对某个 <code>Bean</code> 设置 <code>lazyinit</code> 属性，那么这个 <code>Bean</code> 的依赖注入就会在容器初始化的时候完成。 </p></li></ul><blockquote><p>XML Resource =&gt; XML Document =&gt; Bean Definition 。</p></blockquote><p>资源定位在前面已经分析了，下面我们直接分析加载，上面提过<code>reader.loadBeanDefinitions(resource)</code> 才是加载资源的真正实现，所以我们直接从该方法入手。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">loadBeanDefinitions</span><span class="params">(Resource resource)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> loadBeanDefinitions(<span class="keyword">new</span> EncodedResource(resource));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从指定的 <code>xml</code> 文件加载 <code>BeanDefinition</code>，这里会先对 <code>Resource</code> 资源封装成 <code>EncodedResource</code>。这里为什么需要将 <code>Resource</code> 封装成 <code>EncodedResource</code>呢？主要是为了对 <code>Resource</code> 进行编码，保证内容读取的正确性。封装成 <code>EncodedResource</code> 后，调用<code>loadBeanDefinitions()</code>，这个方法才是真正的逻辑实现。如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">loadBeanDefinitions</span><span class="params">(EncodedResource encodedResource)</span> </span></span><br><span class="line"><span class="function">  <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line">  Assert.notNull(encodedResource, <span class="string">&quot;EncodedResource must not be null&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">    logger.info(<span class="string">&quot;Loading XML bean definitions from &quot;</span> </span><br><span class="line">                + encodedResource.getResource());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取已经加载过的资源</span></span><br><span class="line">  Set&lt;EncodedResource&gt; currentResources = </span><br><span class="line">    <span class="keyword">this</span>.resourcesCurrentlyBeingLoaded.get();</span><br><span class="line">  <span class="keyword">if</span> (currentResources == <span class="keyword">null</span>) &#123;</span><br><span class="line">    currentResources = <span class="keyword">new</span> HashSet&lt;&gt;(<span class="number">4</span>);</span><br><span class="line">    <span class="keyword">this</span>.resourcesCurrentlyBeingLoaded.set(currentResources);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将当前资源加入记录中</span></span><br><span class="line">  <span class="keyword">if</span> (!currentResources.add(encodedResource)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(</span><br><span class="line">      <span class="string">&quot;Detected cyclic loading of &quot;</span> </span><br><span class="line">      + encodedResource + <span class="string">&quot; - check your import definitions!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 从 EncodedResource 获取封装的 Resource 并从 Resource 中获取其中的 InputStream</span></span><br><span class="line">    InputStream inputStream = encodedResource.getResource().getInputStream();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      InputSource inputSource = <span class="keyword">new</span> InputSource(inputStream);</span><br><span class="line">      <span class="comment">// 设置编码</span></span><br><span class="line">      <span class="keyword">if</span> (encodedResource.getEncoding() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        inputSource.setEncoding(encodedResource.getEncoding());</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 核心逻辑部分</span></span><br><span class="line">      <span class="keyword">return</span> doLoadBeanDefinitions(inputSource, </span><br><span class="line">                                   encodedResource.getResource());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">      inputStream.close();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(</span><br><span class="line">      <span class="string">&quot;IOException parsing XML document from &quot;</span> </span><br><span class="line">      + encodedResource.getResource(), ex);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 从缓存中剔除该资源</span></span><br><span class="line">    currentResources.remove(encodedResource);</span><br><span class="line">    <span class="keyword">if</span> (currentResources.isEmpty()) &#123;</span><br><span class="line">      <span class="keyword">this</span>.resourcesCurrentlyBeingLoaded.remove();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先通过</p><p><code>resourcesCurrentlyBeingLoaded.get()</code> 来获取已经加载过的资源，然后将 <code>encodedResource</code> 加入其中，如果 <code>resourcesCurrentlyBeingLoaded</code> 中已经存在该资源，则抛出 <code>BeanDefinitionStoreException</code> 异常。完成后从 <code>encodedResource</code> 获取封装的 <code>Resource</code> 资源并从 <code>Resource</code> 中获取相应的 <code>InputStream</code> ，最后将 <code>InputStream</code> 封装为 <code>InputSource</code> 调用 <code>doLoadBeanDefinitions()</code>。</p><p>方法 <code>doLoadBeanDefinitions()</code> 为从 <code>xml</code> 文件中加载 <code>BeanDefinition</code> 的真正逻辑，如下:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">doLoadBeanDefinitions</span><span class="params">(InputSource inputSource, Resource resource)</span> </span></span><br><span class="line"><span class="function">  <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 获取 Document 实例</span></span><br><span class="line">    Document doc = doLoadDocument(inputSource, resource);</span><br><span class="line">    <span class="comment">// 根据 Document 实例****注册 Bean信息</span></span><br><span class="line">    <span class="keyword">return</span> registerBeanDefinitions(doc, resource);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (BeanDefinitionStoreException ex) &#123;</span><br><span class="line">    <span class="keyword">throw</span> ex;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (SAXParseException ex) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> XmlBeanDefinitionStoreException(resource.getDescription(),</span><br><span class="line">                                              <span class="string">&quot;Line &quot;</span> + ex.getLineNumber() </span><br><span class="line">                                              + <span class="string">&quot; in XML document from &quot;</span> </span><br><span class="line">                                              + resource + <span class="string">&quot; is invalid&quot;</span>, ex);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (SAXException ex) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> XmlBeanDefinitionStoreException(resource.getDescription(),</span><br><span class="line">                                    <span class="string">&quot;XML document from &quot;</span> </span><br><span class="line">                                              + resource + <span class="string">&quot; is invalid&quot;</span>, ex);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (ParserConfigurationException ex) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(resource.getDescription(),</span><br><span class="line">                                   <span class="string">&quot;Parser configuration exception parsing XML from &quot;</span> </span><br><span class="line">                                           + resource, ex);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(resource.getDescription(),</span><br><span class="line">                                           <span class="string">&quot;IOException parsing XML document from &quot;</span> </span><br><span class="line">                                           + resource, ex);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(resource.getDescription(),</span><br><span class="line">                               <span class="string">&quot;Unexpected exception parsing XML document from &quot;</span> </span><br><span class="line">                                           + resource, ex);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>核心部分就是 <code>try</code> 块的两行代码。</p><ol><li>调用 <code>doLoadDocument()</code> 方法，根据 <code>xml</code> 文件获取 <code>Document</code> 实例。</li><li>根据获取的 <code>Document</code> 实例注册 <code>Bean</code> 信息。 其实在 </li></ol><p><code>doLoadDocument()</code>方法内部还获取了 <code>xml</code> 文件的验证模式。如下:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Document <span class="title">doLoadDocument</span><span class="params">(InputSource inputSource, Resource resource)</span> </span></span><br><span class="line"><span class="function">  <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.documentLoader.loadDocument(inputSource,</span><br><span class="line">                                          getEntityResolver(), <span class="keyword">this</span>.errorHandler,</span><br><span class="line">                                          getValidationModeForResource(resource), </span><br><span class="line">                                          isNamespaceAware());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用<code>getValidationModeForResource()</code> 获取指定资源（<code>xml</code>）的验证模式。</p><p><strong>所以 <code>doLoadBeanDefinitions()</code>主要就是做了三件事情。</strong> </p><ol><li>调用 <code>getValidationModeForResource()</code> 获取 <code>xml</code> 文件的验证模式 </li><li>调用 <code>loadDocument()</code> 根据 <code>xml</code> 文件获取相应的 <code>Document</code> 实例。 </li><li>调用 <code>registerBeanDefinitions()</code> 注册 <code>Bean</code> 实例。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
          <category> 《Spring源码分析》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> 死磕Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IOC之Spring统一资源加载策略</title>
      <link href="/blog/2020/01/02/8f7aa5ac.html"/>
      <url>/blog/2020/01/02/8f7aa5ac.html</url>
      
        <content type="html"><![CDATA[<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><blockquote><p>本文作者：chenssy</p><p>出处：<a href="http://cmsblogs.com/?p=2656">http://cmsblogs.com/?p=2656</a></p><p>在学习<code>Spring源码</code>的过程中发现的好站+好贴，感谢作者。Spring版本：<strong>Spring 5.0.6.RELEASE</strong></p></blockquote><p>资源加载策略需要满足如下要求：</p><ol><li>职能划分清楚。资源的定义和资源的加载应该要有一个清晰的界限；</li><li>统一的抽象。统一的资源定义和资源加载策略。资源加载后要返回统一的抽象给客户端，客户端要对资源进行怎样的处理，应该由抽象资源接口来界定。</li></ol><h2 id="统一资源：Resource"><a href="#统一资源：Resource" class="headerlink" title="统一资源：Resource"></a>统一资源：Resource</h2><p><code>org.springframework.core.io.Resource</code> 为 Spring 框架所有资源的抽象和访问接口，它继承 <code>org.springframework.core.io.InputStreamSource</code>接口。作为所有资源的统一抽象，Source 定义了一些通用的方法，由子类 <code>AbstractResource</code> 提供统一的默认实现。定义如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Resource</span> <span class="keyword">extends</span> <span class="title">InputStreamSource</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 资源是否存在</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">exists</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 资源是否可读</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">boolean</span> <span class="title">isReadable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 资源所代表的句柄是否被一个stream打开了</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">boolean</span> <span class="title">isOpen</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否为 File</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">boolean</span> <span class="title">isFile</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回资源的URL的句柄</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">URL <span class="title">getURL</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回资源的URI的句柄</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">URI <span class="title">getURI</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回资源的File的句柄</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">File <span class="title">getFile</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回 ReadableByteChannel</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> ReadableByteChannel <span class="title">readableChannel</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Channels.newChannel(getInputStream());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 资源内容的长度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">contentLength</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 资源最后的修改时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">lastModified</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据资源的相对路径创建新资源</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Resource <span class="title">createRelative</span><span class="params">(String relativePath)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 资源的文件名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function">String <span class="title">getFilename</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 资源的描述</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">String <span class="title">getDescription</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类结构图如下：</p><p><img src="https://cdn.jsdelivr.net/gh/cayzlh/git-img-repository@master/uPic/aN4Hdx.jpg" alt="aN4Hdx"></p><p>从上图可以看到，<code>Resource</code> 根据资源的不同类型提供不同的具体实现，如下：</p><ul><li><strong>FileSystemResource</strong>：对 <code>java.io.File</code> 类型资源的封装，只要是跟 File 打交道的，基本上与 <code>FileSystemResource</code> 也可以打交道。支持文件和 <code>URL</code> 的形式，实现 <code>WritableResource</code> 接口，且从 <em><code>Spring Framework 5.0</code> 开始，<code>FileSystemResource</code> 使用<code>NIO.2 API</code>进行读/写交互</em></li><li><strong>ByteArrayResource</strong>：对字节数组提供的数据的封装。如果通过 <code>InputStream</code> 形式访问该类型的资源，该实现会根据字节数组的数据构造一个相应的 <code>ByteArrayInputStream</code>。</li><li><strong>UrlResource</strong>：对 <code>java.net.URL</code>类型资源的封装。内部委派 URL 进行具体的资源操作。</li><li><strong>ClassPathResource</strong>：<code>class path</code> 类型资源的实现。使用给定的 <code>ClassLoader</code> 或者给定的 <code>Class</code> 来加载资源。</li><li><strong>InputStreamResource</strong>：将给定的 <code>InputStream</code> 作为一种资源的 <code>Resource</code> 的实现类。</li></ul><p><code>AbstractResource</code> 为 <code>Resource</code> 接口的默认实现，它实现了 Resource 接口的大部分的公共实现，作为 <code>Resource</code> 接口中的重中之重，其定义如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractResource</span> <span class="keyword">implements</span> <span class="title">Resource</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断文件是否存在，若判断过程产生异常（因为会调用SecurityManager来判断），就关闭对应的流</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">exists</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> getFile().exists();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">            <span class="comment">// Fall back to stream existence: can we open the stream?</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                InputStream is = getInputStream();</span><br><span class="line">                is.close();</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (Throwable isEx) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 直接返回true，表示可读</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isReadable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 直接返回 false，表示未被打开</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isOpen</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  直接返回false，表示不为 File</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFile</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 抛出 FileNotFoundException 异常，交给子类实现</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> URL <span class="title">getURL</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> FileNotFoundException(getDescription() + <span class="string">&quot; cannot be resolved to URL&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 基于 getURL() 返回的 URL 构建 URI</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> URI <span class="title">getURI</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        URL url = getURL();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> ResourceUtils.toURI(url);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (URISyntaxException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NestedIOException(<span class="string">&quot;Invalid URI [&quot;</span> + url + <span class="string">&quot;]&quot;</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 抛出 FileNotFoundException 异常，交给子类实现</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> File <span class="title">getFile</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> FileNotFoundException(getDescription() </span><br><span class="line">                                        + <span class="string">&quot; cannot be resolved to absolute file path&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据 getInputStream() 的返回结果构建 ReadableByteChannel</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ReadableByteChannel <span class="title">readableChannel</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Channels.newChannel(getInputStream());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取资源的长度</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 这个资源内容长度实际就是资源的字节长度，通过全部读取一遍来判断</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">contentLength</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        InputStream is = getInputStream();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">long</span> size = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">255</span>];</span><br><span class="line">            <span class="keyword">int</span> read;</span><br><span class="line">            <span class="keyword">while</span> ((read = is.read(buf)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                size += read;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> size;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                is.close();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回资源最后的修改时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">lastModified</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> lastModified = getFileForLastModifiedCheck().lastModified();</span><br><span class="line">        <span class="keyword">if</span> (lastModified == <span class="number">0L</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> FileNotFoundException(</span><br><span class="line">              getDescription()</span><br><span class="line">              +</span><br><span class="line">              <span class="string">&quot; cannot be resolved in the file system for resolving its last-modified timestamp&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lastModified;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> File <span class="title">getFileForLastModifiedCheck</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getFile();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 交给子类实现</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Resource <span class="title">createRelative</span><span class="params">(String relativePath)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> FileNotFoundException(</span><br><span class="line">          <span class="string">&quot;Cannot create a relative resource for &quot;</span> </span><br><span class="line">          + getDescription());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取资源名称，默认返回 null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getFilename</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回资源的描述</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getDescription();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (obj == <span class="keyword">this</span> ||</span><br><span class="line">            (obj <span class="keyword">instanceof</span> Resource &amp;&amp; ((Resource) obj)</span><br><span class="line">             .getDescription().equals(getDescription())));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getDescription().hashCode();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们想要实现自定义的 <code>Resource</code>，记住不要实现 <code>Resource</code> 接口，而应该继承 <code>AbstractResource</code> 抽象类，然后根据当前的具体资源特性覆盖相应的方法即可。</p><h2 id="统一资源定位-ResourceLoader"><a href="#统一资源定位-ResourceLoader" class="headerlink" title="统一资源定位(ResourceLoader)"></a>统一资源定位(ResourceLoader)</h2><p>一开始就说了 <code>Spring</code> 将资源的定义和资源的加载区分开了，<code>Resource</code> 定义了统一的资源，那资源的加载则由 <code>ResourceLoader</code> 来统一定义。</p><p><code>org.springframework.core.io.ResourceLoader</code> 为 <code>Spring</code> 资源加载的统一抽象，具体的资源加载则由相应的实现类来完成，所以我们可以将 <code>ResourceLoader</code> 称作为统一资源定位器。其定义如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ResourceLoader</span> </span>&#123;</span><br><span class="line">    String CLASSPATH_URL_PREFIX = ResourceUtils.CLASSPATH_URL_PREFIX;</span><br><span class="line"></span><br><span class="line">    <span class="function">Resource <span class="title">getResource</span><span class="params">(String location)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">ClassLoader <span class="title">getClassLoader</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ResourceLoader</code> 接口提供两个方法：<code>getResource()</code>、<code>getClassLoader()</code>。</p><p><code>getResource()</code>根据所提供资源的路径 <code>location</code> 返回 <code>Resource</code> 实例，但是它不确保该 <code>Resource</code> 一定存在，需要调用 <code>Resource.exist()</code>方法判断。该方法支持以下模式的资源加载：</p><ul><li>URL位置资源，如”file:C:/test.dat”</li><li>ClassPath位置资源，如”classpath:test.dat”</li><li>相对路径资源，如”WEB-INF/test.dat”，此时返回的Resource实例根据实现不同而不同</li></ul><p>该方法的主要实现是在其子类 <code>DefaultResourceLoader</code> 中实现，具体过程我们在分析 <code>DefaultResourceLoader</code> 时做详细说明。</p><p><code>getClassLoader()</code> 返回 <code>ClassLoader</code> 实例，对于想要获取 <code>ResourceLoader</code> 使用的 <code>ClassLoader</code> 用户来说，可以直接调用该方法来获取，</p><p>在分析 <code>Resource</code> 时，提到了一个类 <code>ClassPathResource</code> ，这个类是可以根据指定的 <code>ClassLoader</code> 来加载资源的。</p><p>作为 <code>Spring</code> 统一的资源加载器，它提供了统一的抽象，具体的实现则由相应的子类来负责实现，其类的类结构图如下：</p><p><img src="https://cdn.jsdelivr.net/gh/cayzlh/git-img-repository@master/uPic/R8Oaa0.jpg" alt="R8Oaa0"></p><h3 id="DefaultResourceLoader"><a href="#DefaultResourceLoader" class="headerlink" title="DefaultResourceLoader"></a>DefaultResourceLoader</h3><p><code>DefaultResourceLoader</code> 是 <code>ResourceLoader</code> 的默认实现，它接收 <code>ClassLoader</code> 作为构造函数的参数或者使用不带参数的构造函数，在使用不带参数的构造函数时，使用的 <code>ClassLoader</code> 为默认的 <code>ClassLoader</code>（一般为<code>Thread.currentThread().getContextClassLoader()</code>），可以通过 <code>ClassUtils.getDefaultClassLoader()</code>获取。当然也可以调用 <code>setClassLoader()</code>方法进行后续设置。如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DefaultResourceLoader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.classLoader = ClassUtils.getDefaultClassLoader();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DefaultResourceLoader</span><span class="params">(<span class="meta">@Nullable</span> ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.classLoader = classLoader;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setClassLoader</span><span class="params">(<span class="meta">@Nullable</span> ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.classLoader = classLoader;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ClassLoader <span class="title">getClassLoader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">this</span>.classLoader != <span class="keyword">null</span> ? <span class="keyword">this</span>.classLoader : </span><br><span class="line">          ClassUtils.getDefaultClassLoader());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ResourceLoader</code> 中最核心的方法为 <code>getResource()</code>,它根据提供的 <code>location</code> 返回相应的 <code>Resource</code>，而 <code>DefaultResourceLoader</code> 对该方法提供了核心实现(它的两个子类都没有提供覆盖该方法，所以可以断定<code>ResourceLoader</code> 的资源加载策略就封装 <code>DefaultResourceLoader</code>中)，如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Resource <span class="title">getResource</span><span class="params">(String location)</span> </span>&#123;</span><br><span class="line">  Assert.notNull(location, <span class="string">&quot;Location must not be null&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (ProtocolResolver protocolResolver : <span class="keyword">this</span>.protocolResolvers) &#123;</span><br><span class="line">    Resource resource = protocolResolver.resolve(location, <span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">if</span> (resource != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> resource;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (location.startsWith(<span class="string">&quot;/&quot;</span>)) &#123;</span><br><span class="line">    <span class="keyword">return</span> getResourceByPath(location);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (location.startsWith(CLASSPATH_URL_PREFIX)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ClassPathResource(location.substring(</span><br><span class="line">      CLASSPATH_URL_PREFIX.length()), getClassLoader());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// Try to parse the location as a URL...</span></span><br><span class="line">      URL url = <span class="keyword">new</span> URL(location);</span><br><span class="line">      <span class="keyword">return</span> (ResourceUtils.isFileURL(url) ? </span><br><span class="line">              <span class="keyword">new</span> FileUrlResource(url) : <span class="keyword">new</span> UrlResource(url));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (MalformedURLException ex) &#123;</span><br><span class="line">      <span class="comment">// No URL -&gt; resolve as resource path.</span></span><br><span class="line">      <span class="keyword">return</span> getResourceByPath(location);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先通过 <code>ProtocolResolver</code> 来加载资源，成功返回 <code>Resource</code>，否则调用如下逻辑：</p><ul><li>若 <code>location</code> 以 / 开头，则调用 <code>getResourceByPath()</code>构造 <code>ClassPathContextResource</code> 类型资源并返回。</li><li>若 <code>location</code> 以 <code>classpath</code>: 开头，则构造 <code>ClassPathResource</code> 类型资源并返回，在构造该资源时，通过 <code>getClassLoader()</code>获取当前的 <code>ClassLoader</code>。</li><li>构造 <code>URL</code> ，尝试通过它进行资源定位，若没有抛出 <code>MalformedURLException</code> 异常，则判断是否为 <code>FileURL</code> , 如果是则构造 <code>FileUrlResource</code> 类型资源，否则构造 <code>UrlResource</code>。若在加载过程中抛出 <code>MalformedURLException</code> 异常，则委派 <code>getResourceByPath()</code> 实现资源定位加载。</li></ul><p><code>ProtocolResolver</code> ，用户自定义协议资源解决策略，作为 <code>DefaultResourceLoader</code> 的 <strong>SPI</strong>，它允许用户自定义资源加载协议，而不需要继承 <code>ResourceLoader</code> 的子类。在介绍 <code>Resource</code> 时，提到如果要实现自定义 <code>Resource</code>，我们只需要继承 <code>DefaultResource</code> 即可，但是有了 <code>ProtocolResolver</code> 后，我们不需要直接继承 <code>DefaultResourceLoader</code>，改为实现 <code>ProtocolResolver</code> 接口也可以实现自定义的 <code>ResourceLoader</code>。 <code>ProtocolResolver</code> 接口，仅有一个方法 <code>Resource resolve(String location, ResourceLoader resourceLoader)</code>，该方法接收两个参数：资源路径<code>location</code>，指定的加载器 <code>ResourceLoader</code>，返回为相应的 <code>Resource</code> 。在 <code>Spring</code> 中你会发现该接口并没有实现类，它需要用户自定义，自定义的 <code>Resolver</code> 如何加入 Spring 体系呢？调用 <code>DefaultResourceLoader.addProtocolResolver()</code> 即可，如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addProtocolResolver</span><span class="params">(ProtocolResolver resolver)</span> </span>&#123;</span><br><span class="line">  Assert.notNull(resolver, <span class="string">&quot;ProtocolResolver must not be null&quot;</span>);</span><br><span class="line">  <span class="keyword">this</span>.protocolResolvers.add(resolver);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面示例是演示 <code>DefaultResourceLoader</code> 加载资源的具体策略，代码如下（<em>该示例参考《Spring 解密》 P89</em>）：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ResourceLoader resourceLoader = <span class="keyword">new</span> DefaultResourceLoader();</span><br><span class="line"></span><br><span class="line">Resource fileResource1 = resourceLoader.getResource(<span class="string">&quot;D:/Users/chenming673/Documents/spark.txt&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;fileResource1 is FileSystemResource:&quot;</span> </span><br><span class="line">                   + (fileResource1 <span class="keyword">instanceof</span> FileSystemResource));</span><br><span class="line"></span><br><span class="line">Resource fileResource2 = resourceLoader.getResource(<span class="string">&quot;/Users/chenming673/Documents/spark.txt&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;fileResource2 is ClassPathResource:&quot;</span> </span><br><span class="line">                   + (fileResource2 <span class="keyword">instanceof</span> ClassPathResource));</span><br><span class="line"></span><br><span class="line">Resource urlResource1 = resourceLoader.getResource(<span class="string">&quot;file:/Users/chenming673/Documents/spark.txt&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;urlResource1 is UrlResource:&quot;</span> </span><br><span class="line">                   + (urlResource1 <span class="keyword">instanceof</span> UrlResource));</span><br><span class="line"></span><br><span class="line">Resource urlResource2 = resourceLoader.getResource(<span class="string">&quot;http://www.baidu.com&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;urlResource1 is urlResource:&quot;</span> </span><br><span class="line">                   + (urlResource2 <span class="keyword">instanceof</span>  UrlResource));</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">fileResource1 is FileSystemResource:<span class="keyword">false</span></span><br><span class="line">fileResource2 is ClassPathResource:<span class="keyword">true</span></span><br><span class="line">urlResource1 is UrlResource:<span class="keyword">true</span></span><br><span class="line">urlResource1 is urlResource:<span class="keyword">true</span></span><br></pre></td></tr></table></figure><p>其实对于 fileResource1 我们更加希望是 FileSystemResource 资源类型，但是事与愿违，它是 ClassPathResource 类型。在<code>getResource()</code>资源加载策略中，我们知道 <code>D:/Users/chenming673/Documents/spark.txt</code>资源其实在该方法中没有相应的资源类型，那么它就会在抛出 <code>MalformedURLException</code> 异常时通过 <code>getResourceByPath()</code> 构造一个 <code>ClassPathResource</code> 类型的资源。而指定有协议前缀的资源路径，则通过 <code>URL</code> 就可以定义，所以返回的都是<code>UrlResource</code>类型。</p><h3 id="FileSystemResourceLoader"><a href="#FileSystemResourceLoader" class="headerlink" title="FileSystemResourceLoader"></a>FileSystemResourceLoader</h3><p>从上面的示例我们看到，其实 <code>DefaultResourceLoader</code> 对<code>getResourceByPath(String)</code>方法处理其实不是很恰当，这个时候我们可以使用 <code>FileSystemResourceLoader</code> ，它继承 <code>DefaultResourceLoader</code> 且覆写了 <code>getResourceByPath(String)</code>，使之从文件系统加载资源并以 <code>FileSystemResource</code> 类型返回，这样我们就可以得到想要的资源类型，如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Resource <span class="title">getResourceByPath</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (path.startsWith(<span class="string">&quot;/&quot;</span>)) &#123;</span><br><span class="line">    path = path.substring(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> FileSystemContextResource(path);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>FileSystemContextResource</code> 为 <code>FileSystemResourceLoader</code> 的内部类，它继承 <code>FileSystemResource</code>。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">FileSystemContextResource</span> <span class="keyword">extends</span> <span class="title">FileSystemResource</span> </span></span><br><span class="line"><span class="class">  <span class="keyword">implements</span> <span class="title">ContextResource</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">FileSystemContextResource</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(path);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getPathWithinContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getPath();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在构造器中也是调用 <code>FileSystemResource</code> 的构造方法来构造 <code>FileSystemContextResource</code> 的。</p><p>如果将上面的示例将 <code>DefaultResourceLoader</code> 改为 <code>FileSystemContextResource</code> ，则 <code>fileResource1</code> 则为 <code>FileSystemResource</code>。</p><h3 id="ResourcePatternResolver"><a href="#ResourcePatternResolver" class="headerlink" title="ResourcePatternResolver"></a>ResourcePatternResolver</h3><p><code>ResourceLoader</code> 的 <code>Resource getResource(String location)</code> 每次只能根据 <code>location</code> 返回一个 Resource，当需要加载多个资源时，我们除了多次调用 <code>getResource()</code> 外别无他法。<code>ResourcePatternResolver</code> 是 <code>ResourceLoader</code> 的扩展，它支持根据指定的资源路径匹配模式每次返回多个 <code>Resource</code> 实例，其定义如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ResourcePatternResolver</span> <span class="keyword">extends</span> <span class="title">ResourceLoader</span> </span>&#123;</span><br><span class="line">    String CLASSPATH_ALL_URL_PREFIX = <span class="string">&quot;classpath*:&quot;</span>;</span><br><span class="line"></span><br><span class="line">    Resource[] getResources(String locationPattern) <span class="keyword">throws</span> IOException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ResourcePatternResolver</code> 在 <code>ResourceLoader</code> 的基础上增加了 <code>getResources(String locationPattern)</code>，以支持根据路径匹配模式返回多个 <code>Resource</code> 实例，同时也新增了一种新的协议前缀 <code>classpath*:</code>，该协议前缀由其子类负责实现。</p><p><code>PathMatchingResourcePatternResolver</code> 为 <code>ResourcePatternResolver</code> 最常用的子类，它除了支持 <code>ResourceLoader</code> 和 <code>ResourcePatternResolver</code> 新增的 <em><em>classpath</em>:</em>* 前缀外，还支持 <code>Ant</code> 风格的路径匹配模式（类似于 <code>**/*.xml</code>）。</p><p><code>PathMatchingResourcePatternResolver</code> 提供了三个构造方法，如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PathMatchingResourcePatternResolver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.resourceLoader = <span class="keyword">new</span> DefaultResourceLoader();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PathMatchingResourcePatternResolver</span><span class="params">(ResourceLoader resourceLoader)</span> </span>&#123;</span><br><span class="line">  Assert.notNull(resourceLoader, <span class="string">&quot;ResourceLoader must not be null&quot;</span>);</span><br><span class="line">  <span class="keyword">this</span>.resourceLoader = resourceLoader;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PathMatchingResourcePatternResolver</span><span class="params">(<span class="meta">@Nullable</span> ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.resourceLoader = <span class="keyword">new</span> DefaultResourceLoader(classLoader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>PathMatchingResourcePatternResolver</code> 在实例化的时候，可以指定一个 <code>ResourceLoader</code>，如果不指定的话，它会在内部构造一个 <code>DefaultResourceLoader</code>。</p><h4 id="Resource-getResource-String-location"><a href="#Resource-getResource-String-location" class="headerlink" title="Resource getResource(String location)"></a>Resource getResource(String location)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Resource <span class="title">getResource</span><span class="params">(String location)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> getResourceLoader().getResource(location);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>getResource()</code> 方法直接委托给相应的 <code>ResourceLoader</code> 来实现，所以如果我们在实例化的 <code>PathMatchingResourcePatternResolver</code> 的时候，如果不知道 <code>ResourceLoader</code> ，那么在加载资源时，其实就是 <code>DefaultResourceLoader</code> 的过程。其实在下面介绍的 <code>Resource[] getResources(String locationPattern)</code> 也相同，只不过返回的资源时多个而已。</p><h4 id="Resource-getResources-String-locationPattern"><a href="#Resource-getResources-String-locationPattern" class="headerlink" title="Resource[] getResources(String locationPattern)"></a>Resource[] getResources(String locationPattern)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Resource[] getResources(String locationPattern) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">  Assert.notNull(locationPattern, <span class="string">&quot;Location pattern must not be null&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 以 classpath*: 开头</span></span><br><span class="line">  <span class="keyword">if</span> (locationPattern.startsWith(CLASSPATH_ALL_URL_PREFIX)) &#123;</span><br><span class="line">    <span class="comment">// 路径包含通配符</span></span><br><span class="line">    <span class="keyword">if</span> (getPathMatcher()</span><br><span class="line">        .isPattern(locationPattern.substring(CLASSPATH_ALL_URL_PREFIX.length()))) &#123;</span><br><span class="line">      <span class="keyword">return</span> findPathMatchingResources(locationPattern);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 路径不包含通配符</span></span><br><span class="line">      <span class="keyword">return</span> findAllClassPathResources(</span><br><span class="line">        locationPattern.substring(CLASSPATH_ALL_URL_PREFIX.length()));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">int</span> prefixEnd = (</span><br><span class="line">      locationPattern.startsWith(<span class="string">&quot;war:&quot;</span>) ? locationPattern.indexOf(<span class="string">&quot;*/&quot;</span>) + <span class="number">1</span> :</span><br><span class="line">                     locationPattern.indexOf(<span class="string">&#x27;:&#x27;</span>) + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 路径包含通配符</span></span><br><span class="line">    <span class="keyword">if</span> (getPathMatcher().isPattern(locationPattern.substring(prefixEnd))) &#123;</span><br><span class="line">      <span class="keyword">return</span> findPathMatchingResources(locationPattern);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Resource[] &#123;getResourceLoader().getResource(locationPattern)&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>处理逻辑如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/cayzlh/git-img-repository@master/uPic/UnSrsV.jpg" alt="UnSrsV"></p><p>下面就 <code>findAllClassPathResources()</code>做详细分析。</p><h4 id="findAllClassPathResources"><a href="#findAllClassPathResources" class="headerlink" title="findAllClassPathResources()"></a>findAllClassPathResources()</h4><p>当 <code>locationPattern</code> 以 <em><em>classpath</em>:</em>* 开头但是不包含通配符，则调用<code>findAllClassPathResources()</code> 方法加载资源。该方法返回 <code>classes</code> 路径下和所有 <code>jar</code> 包中的所有相匹配的资源。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Resource[] findAllClassPathResources(String location) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">  String path = location;</span><br><span class="line">  <span class="keyword">if</span> (path.startsWith(<span class="string">&quot;/&quot;</span>)) &#123;</span><br><span class="line">    path = path.substring(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  Set&lt;Resource&gt; result = doFindAllClassPathResources(path);</span><br><span class="line">  <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">    logger.debug(<span class="string">&quot;Resolved classpath location [&quot;</span> </span><br><span class="line">                 + location + <span class="string">&quot;] to resources &quot;</span> + result);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result.toArray(<span class="keyword">new</span> Resource[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>真正执行加载的是在 <code>doFindAllClassPathResources()</code>方法，如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Set&lt;Resource&gt; <span class="title">doFindAllClassPathResources</span><span class="params">(String path)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  Set&lt;Resource&gt; result = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(<span class="number">16</span>);</span><br><span class="line">  ClassLoader cl = getClassLoader();</span><br><span class="line">  Enumeration&lt;URL&gt; resourceUrls = (cl != <span class="keyword">null</span> ? cl.getResources(path) : </span><br><span class="line">                                   ClassLoader.getSystemResources(path));</span><br><span class="line">  <span class="keyword">while</span> (resourceUrls.hasMoreElements()) &#123;</span><br><span class="line">    URL url = resourceUrls.nextElement();</span><br><span class="line">    result.add(convertClassLoaderURL(url));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="string">&quot;&quot;</span>.equals(path)) &#123;</span><br><span class="line">    addAllClassLoaderJarRoots(cl, result);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>doFindAllClassPathResources()</code> 根据 <code>ClassLoader</code> 加载路径下的所有资源。在加载资源过程中如果，在构造 <code>PathMatchingResourcePatternResolver</code> 实例的时候如果传入了 <code>ClassLoader</code>，则调用其 <code>getResources()</code>，否则调用<code>ClassLoader.getSystemResources(path)</code>。 <code>ClassLoader.getResources()</code>如下:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Enumeration&lt;URL&gt; <span class="title">getResources</span><span class="params">(String name)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">  Enumeration&lt;URL&gt;[] tmp = (Enumeration&lt;URL&gt;[]) <span class="keyword">new</span> Enumeration&lt;?&gt;[<span class="number">2</span>];</span><br><span class="line">  <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">    tmp[<span class="number">0</span>] = parent.getResources(name);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    tmp[<span class="number">0</span>] = getBootstrapResources(name);</span><br><span class="line">  &#125;</span><br><span class="line">  tmp[<span class="number">1</span>] = findResources(name);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> CompoundEnumeration&lt;&gt;(tmp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看到这里是不是就已经一目了然了？如果当前父类加载器不为 null，则通过父类向上迭代获取资源，否则调用 <code>getBootstrapResources()</code>。这里是不是特别熟悉，(<em>^▽^</em>)。</p><p>若 path 为 空（“”）时，则调用 <code>addAllClassLoaderJarRoots()</code>方法。该方法主要是加载路径下得所有 jar 包，方法较长也没有什么实际意义就不贴出来了。</p><p>通过上面的分析，我们知道 <code>findAllClassPathResources()</code> 其实就是利用 ClassLoader 来加载指定路径下的资源，不管它是在 class 路径下还是在 jar 包中。如果我们传入的路径为空或者 <code>/</code>，则会调用 <code>addAllClassLoaderJarRoots()</code> 方法加载所有的 jar 包。</p><h4 id="findAllClassPathResources-1"><a href="#findAllClassPathResources-1" class="headerlink" title="findAllClassPathResources()"></a>findAllClassPathResources()</h4><p>当 <code>locationPattern</code> 以 <em><em>classpath</em>:</em>* 开头且当中包含了通配符，则调用该方法进行资源加载。如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Resource[] findPathMatchingResources(String locationPattern) </span><br><span class="line">  <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">  <span class="comment">// 确定跟路径</span></span><br><span class="line">  String rootDirPath = determineRootDir(locationPattern);</span><br><span class="line">  String subPattern = locationPattern.substring(rootDirPath.length());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取根据路径下得资源</span></span><br><span class="line">  Resource[] rootDirResources = getResources(rootDirPath);</span><br><span class="line"></span><br><span class="line">  Set&lt;Resource&gt; result = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(<span class="number">16</span>);</span><br><span class="line">  <span class="keyword">for</span> (Resource rootDirResource : rootDirResources) &#123;</span><br><span class="line">    rootDirResource = resolveRootDirResource(rootDirResource);</span><br><span class="line">    URL rootDirUrl = rootDirResource.getURL();</span><br><span class="line">    <span class="comment">// bundle 资源类型</span></span><br><span class="line">    <span class="keyword">if</span> (equinoxResolveMethod != <span class="keyword">null</span> </span><br><span class="line">        &amp;&amp; rootDirUrl.getProtocol().startsWith(<span class="string">&quot;bundle&quot;</span>)) &#123;</span><br><span class="line">      URL resolvedUrl = (URL) ReflectionUtils</span><br><span class="line">        .invokeMethod(equinoxResolveMethod, <span class="keyword">null</span>, rootDirUrl);</span><br><span class="line">      <span class="keyword">if</span> (resolvedUrl != <span class="keyword">null</span>) &#123;</span><br><span class="line">        rootDirUrl = resolvedUrl;</span><br><span class="line">      &#125;</span><br><span class="line">      rootDirResource = <span class="keyword">new</span> UrlResource(rootDirUrl);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// VFS 资源</span></span><br><span class="line">    <span class="keyword">if</span> (rootDirUrl.getProtocol().startsWith(ResourceUtils.URL_PROTOCOL_VFS)) &#123;</span><br><span class="line">      result.addAll(VfsResourceMatchingDelegate</span><br><span class="line">                    .findMatchingResources(rootDirUrl,</span><br><span class="line">                                           subPattern, getPathMatcher()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Jar</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (ResourceUtils.isJarURL(rootDirUrl) </span><br><span class="line">             || isJarResource(rootDirResource)) &#123;</span><br><span class="line">      result</span><br><span class="line">        .addAll(doFindPathMatchingJarResources</span><br><span class="line">                (rootDirResource, rootDirUrl, subPattern));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      result</span><br><span class="line">        .addAll(doFindPathMatchingFileResources(</span><br><span class="line">          rootDirResource, subPattern));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">    logger.debug(<span class="string">&quot;Resolved location pattern [&quot;</span> </span><br><span class="line">                 + locationPattern + <span class="string">&quot;] to resources &quot;</span> </span><br><span class="line">                 + result);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result.toArray(<span class="keyword">new</span> Resource[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法有点儿长，但是思路还是很清晰的，主要分两步：</p><ol><li>确定目录，获取该目录下得所有资源</li><li>在所获得的所有资源中进行迭代匹配获取我们想要的资源。</li></ol><p>在这个方法里面我们要关注两个方法，一个是 <code>determineRootDir()</code>,一个是 <code>doFindPathMatchingFileResources()</code>。</p><p><code>determineRootDir()</code>主要是用于确定根路径，如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> String <span class="title">determineRootDir</span><span class="params">(String location)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> prefixEnd = location.indexOf(<span class="string">&#x27;:&#x27;</span>) + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">int</span> rootDirEnd = location.length();</span><br><span class="line">  <span class="keyword">while</span> (rootDirEnd &gt; prefixEnd &amp;&amp; getPathMatcher()</span><br><span class="line">         .isPattern(location.substring(prefixEnd, rootDirEnd))) &#123;</span><br><span class="line">    rootDirEnd = location.lastIndexOf(<span class="string">&#x27;/&#x27;</span>, rootDirEnd - <span class="number">2</span>) + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (rootDirEnd == <span class="number">0</span>) &#123;</span><br><span class="line">    rootDirEnd = prefixEnd;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> location.substring(<span class="number">0</span>, rootDirEnd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法一定要给出一个确定的根目录。该根目录用于确定文件的匹配的起始点，将根目录位置的资源解析为 <code>java.io.File</code> 并将其传递到 <code>retrieveMatchingFiles()</code>，其余为知用于模式匹配，找出我们所需要的资源。</p><p>确定根路径如下:</p><table><thead><tr><th align="center">原路径</th><th align="center">确定根路径</th></tr></thead><tbody><tr><td align="center"><code>classpath*:test/cc*/spring-*.xml</code></td><td align="center"><code>classpath*:test/</code></td></tr><tr><td align="center"><code>classpath*:test/aa/spring-*.xml</code></td><td align="center"><code>classpath*:test/aa/</code></td></tr></tbody></table><p>确定根路径后，则调用 <code>getResources()</code> 方法获取该路径下得所有资源，然后迭代资源获取符合条件的资源。</p><p>至此 <code>Spring</code> 整个资源记载过程已经分析完毕。下面简要总结下：</p><ul><li><code>Spring</code> 提供了 <code>Resource</code> 和 <code>ResourceLoader</code> 来统一抽象整个资源及其定位。使得资源与资源的定位有了一个更加清晰的界限，并且提供了合适的 <code>Default</code> 类，使得自定义实现更加方便和清晰。</li><li><code>AbstractResource</code> 为 <code>Resource</code> 的默认实现，它对 <code>Resource</code> 接口做了一个统一的实现，子类继承该类后只需要覆盖相应的方法即可，同时对于自定义的 <code>Resource</code> 我们也是继承该类。</li><li><code>DefaultResourceLoader</code> 同样也是 <code>ResourceLoader</code> 的默认实现，在自定 <code>ResourceLoader</code> 的时候我们除了可以继承该类外还可以实现 <code>ProtocolResolver</code> 接口来实现自定资源加载协议。</li><li><code>DefaultResourceLoader</code> 每次只能返回单一的资源，所以 <code>Spring</code> 针对这个提供了另外一个接口 <code>ResourcePatternResolver</code> ，该接口提供了根据指定的 <code>locationPattern</code> 返回多个资源的策略。其子类 <code>PathMatchingResourcePatternResolver</code> 是一个集大成者的 <code>ResourceLoader</code> ，因为它即实现了 <code>Resource getResource(String location)</code> 也实现了 <code>Resource[] getResources(String locationPattern)</code>。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
          <category> 《Spring源码分析》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> 死磕Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IOC之深入理解SpringIoC</title>
      <link href="/blog/2020/01/01/a426e6ea.html"/>
      <url>/blog/2020/01/01/a426e6ea.html</url>
      
        <content type="html"><![CDATA[<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><blockquote><p>本文作者：chenssy</p><p>出处：<a href="http://cmsblogs.com/?p=2652">http://cmsblogs.com/?p=2652</a></p><p>在学习<code>Spring源码</code>的过程中发现的好站+好贴，感谢作者。Spring版本：<strong>Spring 5.0.6.RELEASE</strong></p></blockquote><h2 id="IOC-理论"><a href="#IOC-理论" class="headerlink" title="IOC 理论"></a>IOC 理论</h2><p>IoC 全称为 <code>Inversion of Control</code>，翻译为 “控制反转”，它还有一个别名为 DI（<code>Dependency Injection</code>）,即依赖注入。</p><p>如何理解“控制反转”好呢？理解好它的关键在于我们需要回答如下四个问题：</p><ol><li><strong>谁控制谁</strong></li><li><strong>控制什么</strong></li><li><strong>为何是反转</strong></li><li><strong>哪些方面反转了</strong></li></ol><p>在回答这四个问题之前，我们先看 IOC 的定义：</p><blockquote><p><strong>所谓 IOC ，就是由 Spring IOC 容器来负责对象的生命周期和对象之间的关系</strong></p></blockquote><p>上面这句话是整个 IoC 理论的核心。如何来理解这句话？我们引用一个例子来走阐述（看完该例子上面四个问题也就不是问题了）。</p><p>以找女朋友为例（对于程序猿来说这个值得探究的问题）。一般情况下我们是如何来找女朋友的呢？首先我们需要根据自己的需求（漂亮、身材好、性格好）找一个妹子，然后到处打听她的兴趣爱好、微信、电话号码，然后各种投其所好送其所要，最后追到手。如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 年轻小伙子</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">YoungMan</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> BeautifulGirl beautifulGirl;</span><br><span class="line"></span><br><span class="line">    YoungMan()&#123;</span><br><span class="line">        <span class="comment">// 可能你比较牛逼，指腹为婚</span></span><br><span class="line">        <span class="comment">// beautifulGirl = new BeautifulGirl();</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBeautifulGirl</span><span class="params">(BeautifulGirl beautifulGirl)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.beautifulGirl = beautifulGirl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        YoungMan you = <span class="keyword">new</span> YoungMan();</span><br><span class="line">        BeautifulGirl beautifulGirl = <span class="keyword">new</span> BeautifulGirl(<span class="string">&quot;你的各种条件&quot;</span>);</span><br><span class="line">        beautifulGirl.setxxx(<span class="string">&quot;各种投其所好&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 然后你有女票了</span></span><br><span class="line">        you.setBeautifulGirl(beautifulGirl);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就是我们通常做事的方式，如果我们需要某个对象，一般都是采用这种直接创建的方式(<code>new BeautifulGirl()</code>)，这个过程复杂而又繁琐，而且我们必须要面对每个环节，同时使用完成之后我们还要负责销毁它，在这种情况下我们的对象与它所依赖的对象耦合在一起。</p><p>其实我们需要思考一个问题？我们每次用到自己依赖的对象真的需要自己去创建吗？我们知道，我们依赖对象其实并不是依赖该对象本身，而是依赖它所提供的服务，只要在我们需要它的时候，它能够及时提供服务即可，至于它是我们主动去创建的还是别人送给我们的，其实并不是那么重要。再说了，相比于自己千辛万苦去创建它还要管理、善后而言，直接有人送过来是不是显得更加好呢？</p><p>这个给我们送东西的“人” 就是 IoC，在上面的例子中，它就相当于一个婚介公司，作为一个婚介公司它管理着很多男男女女的资料，当我们需要一个女朋友的时候，直接跟婚介公司提出我们的需求，婚介公司则会根据我们的需求提供一个妹子给我们，我们只需要负责谈恋爱，生猴子就行了。你看，这样是不是很简单明了。</p><p>诚然，作为婚介公司的 IoC 帮我们省略了找女朋友的繁杂过程，将原来的主动寻找变成了现在的被动接受（符合我们的要求），更加简洁轻便。你想啊，原来你还得鞍马前后，各种巴结，什么东西都需要自己去亲力亲为，现在好了，直接有人把现成的送过来，多么美妙的事情啊。所以，简单点说，IoC 的理念就是<strong>让别人为你服务</strong>，如下图（<strong>摘自Spring揭秘</strong>）：</p><p><img src="https://cdn.jsdelivr.net/gh/cayzlh/git-img-repository@master/uPic/kJbaSJ.jpg" alt="kJbaSJ"></p><p>在没有引入 IoC 的时候，被注入的对象直接依赖于被依赖的对象，有了 IoC 后，两者及其他们的关系都是通过 Ioc Service Provider 来统一管理维护的。被注入的对象需要什么，直接跟 IoC Service Provider 打声招呼，后者就会把相应的被依赖对象注入到被注入的对象中，从而达到 IOC Service Provider 为被注入对象服务的目的。<strong>所以 IoC 就是这么简单！原来是需要什么东西自己去拿，现在是需要什么东西让别人（IOC Service Provider）送过来</strong></p><p>现在在看上面那四个问题，答案就显得非常明显了:</p><ol><li><strong>谁控制谁</strong>：在传统的开发模式下，我们都是采用直接 new 一个对象的方式来创建对象，也就是说你依赖的对象直接由你自己控制，但是有了 IOC 容器后，则直接由 IoC 容器来控制。所以“谁控制谁”，当然是 IoC 容器控制对象。</li><li><strong>控制什么</strong>：控制对象。</li><li><strong>为何是反转</strong>：没有 IoC 的时候我们都是在自己对象中主动去创建被依赖的对象，这是正转。但是有了 IoC 后，所依赖的对象直接由 IoC 容器创建后注入到被注入的对象中，依赖的对象由原来的主动获取变成被动接受，所以是反转。</li><li><strong>哪些方面反转了</strong>：所依赖对象的获取被反转了。</li></ol><p>妹子有了，但是如何拥有妹子呢？这也是一门学问。</p><ol><li>可能你比较牛逼，刚刚出生的时候就指腹为婚了。</li><li>大多数情况我们还是会考虑自己想要什么样的妹子，所以还是需要向婚介公司打招呼的。</li><li>还有一种情况就是，你根本就不知道自己想要什么样的妹子，直接跟婚介公司说，我就要一个这样的妹子。</li></ol><p>所以，<code>IOC Service Provider</code> 为被注入对象提供被依赖对象也有如下几种方式：<code>构造方法注入</code>、<code>setter方法注入</code>、<code>接口注入</code>。</p><h3 id="构造器注入"><a href="#构造器注入" class="headerlink" title="构造器注入"></a>构造器注入</h3><p>构造器注入，顾名思义就是被注入的对象通过在其构造方法中声明依赖对象的参数列表，让外部知道它需要哪些依赖对象。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">YoungMan(BeautifulGirl beautifulGirl)&#123;</span><br><span class="line">        <span class="keyword">this</span>.beautifulGirl = beautifulGirl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造器注入方式比较直观，对象构造完毕后就可以直接使用，这就好比你出生你家里就给你指定了你媳妇。</p><h3 id="setter-方法注入"><a href="#setter-方法注入" class="headerlink" title="setter 方法注入"></a>setter 方法注入</h3><p>对于 JavaBean 对象而言，我们一般都是通过 getter 和 setter 方法来访问和设置对象的属性。所以，当前对象只需要为其所依赖的对象提供相对应的 setter 方法，就可以通过该方法将相应的依赖对象设置到被注入对象中。如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">YoungMan</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> BeautifulGirl beautifulGirl;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBeautifulGirl</span><span class="params">(BeautifulGirl beautifulGirl)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.beautifulGirl = beautifulGirl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相比于构造器注入，setter 方式注入会显得比较宽松灵活些，它可以在任何时候进行注入（当然是在使用依赖对象之前），这就好比你可以先把自己想要的妹子想好了，然后再跟婚介公司打招呼，你可以要林志玲款式的，赵丽颖款式的，甚至凤姐哪款的，随意性较强。</p><h3 id="接口方式注入"><a href="#接口方式注入" class="headerlink" title="接口方式注入"></a>接口方式注入</h3><p>接口方式注入显得比较霸道，因为它需要被依赖的对象实现不必要的接口，带有侵入性。一般都不推荐这种方式。</p><hr><p>关于 IOC 理论部分，笔者不在阐述，这里推荐几篇博客阅读：</p><ul><li><a href="http://www.cnblogs.com/xdp-gacl/p/4249939.html">谈谈对Spring IOC的理解</a>：<a href="http://www.cnblogs.com/xdp-gacl/p/4249939.html">http://www.cnblogs.com/xdp-gacl/p/4249939.html</a></li><li>[Spring的IOC原理<a href="https://blog.csdn.net/m13666368773/article/details/7802126">通俗解释一下]</a>：<a href="https://blog.csdn.net/m13666368773/article/details/7802126">https://blog.csdn.net/m13666368773/article/details/7802126</a></li><li><a href="https://blog.csdn.net/it_man/article/details/4402245">spring ioc原理（看完后大家可以自己写一个spring）</a>：<a href="https://blog.csdn.net/it_man/article/details/4402245">https://blog.csdn.net/it_man/article/details/4402245</a></li></ul><h2 id="各个组件"><a href="#各个组件" class="headerlink" title="各个组件"></a>各个组件</h2><p>先看下图（摘自:<a href="http://singleant.iteye.com/blog/1177358%EF%BC%89">http://singleant.iteye.com/blog/1177358）</a></p><p><img src="https://cdn.jsdelivr.net/gh/cayzlh/git-img-repository@master/uPic/KyiN5i.jpg" alt="KyiN5i"></p><p>该图为 <code>ClassPathXmlApplicationContext</code> 的类继承体系结构，虽然只有一部分，但是它基本上包含了 IOC 体系中大部分的核心类和接口。</p><p>下面我们就针对这个图进行简单的拆分和补充说明。</p><h3 id="Resource体系"><a href="#Resource体系" class="headerlink" title="Resource体系"></a>Resource体系</h3><p><code>Resource</code>，对资源的抽象，它的每一个实现类都代表了一种资源的访问策略，如<code>ClasspathResource</code> 、 <code>URLResource</code> ，<code>FileSystemResource</code> 等。</p><p>[<img src="https://cdn.jsdelivr.net/gh/cayzlh/git-img-repository@master/uPic/gUeoM5.jpg" alt="gUeoM5"></p><p>有了资源，就应该有资源加载，<code>Spring</code> 利用 <code>ResourceLoader</code> 来进行统一资源加载，类图如下：</p><p><img src="https://cdn.jsdelivr.net/gh/cayzlh/git-img-repository@master/uPic/FKcAl6.jpg" alt="FKcAl6"></p><h3 id="BeanFactory-体系"><a href="#BeanFactory-体系" class="headerlink" title="BeanFactory 体系"></a>BeanFactory 体系</h3><p><code>BeanFactory</code> 是一个非常纯粹的 <code>bean</code> 容器，它是 <code>IOC</code> 必备的数据结构，其中 <code>BeanDefinition</code> 是她的基本结构，它内部维护着一个 <code>BeanDefinition map</code> ，并可根据 <code>BeanDefinition</code> 的描述进行 <code>bean</code> 的创建和管理。</p><p><img src="https://cdn.jsdelivr.net/gh/cayzlh/git-img-repository@master/uPic/EXiivT.jpg" alt="EXiivT"></p><p><code>BeanFacoty</code> 有三个直接子类 <code>ListableBeanFactory</code>、<code>HierarchicalBeanFactory</code> 和 <code>AutowireCapableBeanFactory</code>，<code>DefaultListableBeanFactory</code> 为最终默认实现，它实现了所有接口。</p><h3 id="Beandefinition-体系"><a href="#Beandefinition-体系" class="headerlink" title="Beandefinition 体系"></a>Beandefinition 体系</h3><p><code>BeanDefinition</code> 用来描述 <code>Spring</code> 中的 <code>Bean</code> 对象。</p><p><img src="https://cdn.jsdelivr.net/gh/cayzlh/git-img-repository@master/uPic/ROyten.jpg" alt="ROyten"></p><h3 id="BeandefinitionReader体系"><a href="#BeandefinitionReader体系" class="headerlink" title="BeandefinitionReader体系"></a>BeandefinitionReader体系</h3><p><code>BeanDefinitionReader</code> 的作用是读取 <code>Spring</code> 的配置文件的内容，并将其转换成 <code>Ioc</code> 容器内部的数据结构：<code>BeanDefinition</code>。</p><p>[<img src="https://cdn.jsdelivr.net/gh/cayzlh/git-img-repository@master/uPic/le62Sh.jpg" alt="le62Sh"></p><h3 id="ApplicationContext体系"><a href="#ApplicationContext体系" class="headerlink" title="ApplicationContext体系"></a>ApplicationContext体系</h3><p>这个就是大名鼎鼎的 <code>Spring</code> 容器，它叫做应用上下文，与我们应用息息相关，她继承 <code>BeanFactory</code>，所以它是 <code>BeanFactory</code> 的扩展升级版，如果<code>BeanFactory</code> 是屌丝的话，那么 <code>ApplicationContext</code> 则是名副其实的高富帅。由于 <code>ApplicationContext</code> 的结构就决定了它与 <code>BeanFactory</code> 的不同，其主要区别有：</p><ol><li>继承 <code>MessageSource</code>，提供国际化的标准访问策略。</li><li>继承 <code>ApplicationEventPublisher</code> ，提供强大的事件机制。</li><li>扩展 <code>ResourceLoader</code>，可以用来加载多个 <code>Resource</code>，可以灵活访问不同的资源。</li><li>对 <code>Web</code> 应用的支持。</li></ol><p>下图来源：<a href="https://blog.csdn.net/yujin753/article/details/47043143">https://blog.csdn.net/yujin753/article/details/47043143</a></p><p><img src="https://cdn.jsdelivr.net/gh/cayzlh/git-img-repository@master/uPic/NFNQp8.jpg" alt="NFNQp8"></p><p>上面五个体系可以说是<code>Spring IoC</code>中最核心的部分，后面博文也是针对这五个部分进行源码分析。其实 <code>IoC</code> 咋一看还是挺简单的，无非就是将配置文件（暂且认为是 <code>xml</code> 文件）进行解析（分析 <code>xml</code> 谁不会啊），然后放到一个 <code>Map</code> 里面就差不多了，初看有道理，其实要面临的问题还是有很多的，下面就劳烦各位看客跟着 LZ 博客来一步一步揭开 <code>Spring IoC</code> 的神秘面纱。</p><blockquote><p><strong>此系列博文为 LZ 学习、研究 Spring 机制和源码的学习笔记，会涉及参考别人的博文和书籍内容，如有雷同，纯属借鉴，当然 LZ 会标明参考来源。同时由于知识面和能力的问题，文章中难免会出现错误之处，如有，望各位大佬指出，不胜感激</strong>。 <strong>LZ 写此系列博客时，Spring 最新版本为 5.0.6.RELEASE ，所以此系列博客所有源码来源均为 5.0.6.RELEASE</strong>。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
          <category> 《Spring源码分析》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> 死磕Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基础支持层——缓存模块</title>
      <link href="/blog/2019/10/31/fce458a9.html"/>
      <url>/blog/2019/10/31/fce458a9.html</url>
      
        <content type="html"><![CDATA[<p>MyBatis基础支持层位于 Mybatis 整体架构的最底层，支撑着 Mybatis 的核心处理层，是整个框架的基石。基础支持层中封装了多个较为通用的、独立的模块，不仅仅为 Mybatis 提供基础支撑，也可以在合适的场景中直接复用。</p><p><img src="https://gitee.com/cayzlh/img-repo/raw/master/2020/06/09/2_c5SKkm_zgJEGC.png" alt="整体架构"></p><blockquote><p>这篇文章介绍MyBatis的<strong>缓存模块</strong></p></blockquote><p><code>MyBatis</code>作为 一个 强大的持久层 框 架，缓 存是其必不可少的功能之一。MyBatis中的缓 存 是两 层 结 构 的，分为 <strong>一级 缓 存</strong>、<strong>二级 缓 存</strong>，但在本质 上是相同的，它 们 使用的都是<code>Cache</code>接 口的实 现 。</p><p>在 MyBatis缓 存模块 中涉及了装 饰 器模式的相关 知识 。</p><h2 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h2><p>在实践生产中，新需求在软件的整个生命过程中总是不断出现的。当有新需求出现时，就需要为某些组件添加新的功能来满足这些需求。</p><p>添加新功能的方式有很多，我们可以直接修改己有组件的代码并添加相应的新功能，这显然会破坏己有组件的稳定性，修改完成后，整个组件需要重新进行测试，才能上线使用。这种方式显然违反了“<strong>开放-封闭</strong>”原则。</p><p><u>另一种方式是使用继承方式，我们可以创建子类并在子类中添加新功能实现扩展。</u>*这种方法是静态的，用户不能控制增加行为的方式和时机。而且有些情况下继承是不可行的。</p><ul><li><p>例如己有组件是被<code>final</code>关键字修饰的类。</p></li><li><p>另外，如果待添加的新功能存在多种组合，使用继承方式可能会导致大量子类的出现。</p><p>例如，有4个待添加的新功能，系统需要动态使用任意多个功能的组合，则需要添加15个子类才能满足全部需求。</p></li></ul><p>装饰器模式能够帮助我们解决上述问题，装饰器可以动态地为对象添加功能，它是基于组合的方式实现该功能的。</p><p><strong>在实践中，我们应该尽量使用组合的方式来扩展系统的功能，而非使用继承的方式。</strong><u>设计模式中常见的一句话:组合优于继承。</u></p><p>装饰器模式的类图，以及其中的核心角色：</p><p><img src="https://gitee.com/cayzlh/img-repo/raw/master/2020/06/11/image-20200611103644916_Rw2GMv.png" alt="image-20200611103644916"></p><ul><li><p><strong>Component（组件）</strong></p><p>组件接口定义了全部组件实现类以及所有装饰器实现的行为。</p></li><li><p><strong>ConcreteComponent (具体 组 件实 现 类 )</strong></p><p>具体组件实现类实现了<code>Component</code>接口。</p><p>通常情况下，具体组件实现类就是被装饰器装饰的原始对象，该类提供了<code>Component</code>接口中定义的最基本的功能，其他高级功能或后续添加的新功能，都是通过装饰器的方式添加到该类的对象之上的。</p></li><li><p><strong>Decorator(装饰器)</strong></p><p>所有装饰器的父类，它是一个实现了<code>Component</code>接口的抽象类，并在其中封装了一个<code>Component</code>对象，也就是被装饰的对象。</p><p>而这个被装饰的对象只要是<code>Component</code>类型即可，这就实现了装饰器的组合和复用。</p><p>如下图，装饰器**C(ConcreteDecoratorl类型)<strong>修饰了装饰器</strong>B(ConcreteDecorator2类型)**并为其添加功能<code>W</code>，而装饰器<code>B(ConcreteDecorator2类型)</code>又修饰了组件<code>A(ConcreteComponent类型)</code>并为其添加功能<code>V</code>。</p><p>其中，组件对象A提供的是最基本的功能，装饰器B和装饰器C会为组件对象A添加新的功能。</p><p><img src="https://gitee.com/cayzlh/img-repo/raw/master/2020/06/11/image-20200611105658387_IJSXLa.png" alt="image-20200611105658387"></p></li><li><p><strong>ConcreteDecorator</strong></p><p>具体的装饰器实现类，该实现类要向被装饰对象添加某些功能。如上图，装饰器B、C就是该角色，被装饰的对象只要是<code>Component</code>类型即可。<br>在<code>JavaIO</code>包中，大量应用了装饰器模式，我们在使用<code>JavaIO</code>包读取文件时，经常会看到如下代码:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BufferedlnputStream bis = </span><br><span class="line">  <span class="keyword">new</span> BufferedlnputStream( <span class="keyword">new</span> FilelnputStream(<span class="keyword">new</span> File(<span class="string">&quot;D:/test.txt&quot;</span>)));</span><br></pre></td></tr></table></figure></li></ul><p><code>FilelnputStream</code>并没有缓冲功能，每次调用其<code>read()</code>方法时都会向操作系统发起相应的系统调用，当读取大量数据时，就会导致操作系统在用户态和内核态之间频繁切换，性能较低。</p><p><code>BufferedlnputStream</code>是提供了缓冲功能的装饰器，每次调用其<code>read()</code>方法时，会预先从文件中获取一部分数据并缓存到<code>BufferedlnputStream</code>的缓冲区中，后面连续的几次读取可以直接从缓冲区中获取数据，直到缓冲区数据耗尽才会重新从文件中读取数据，这样就可以减少用户态和内核态的切换，提高了读取的性能。</p><p>在<code>MyBatis</code>的缓存模块中，使用了装饰器模式的变体，其中将<code>Decorator</code>接口和<code>Component</code>接口合并为一个<code>Component</code>接口</p><p><img src="https://gitee.com/cayzlh/img-repo/raw/master/2020/06/11/image-20200611114247838_a3jRci.png" alt="image-20200611114247838"></p><p>使用装饰器模式的优点：</p><ul><li>相较于继承来说，装饰器模式的灵活性更强，可扩展性也强。正如前面所说，继承方式会导致大量子类的情况。<strong>而装饰者模式可以将复杂的功能切分成一个个独立的装饰器，通过多个独立装饰器的动态组合，创建不同功能的组件，从而满足多种不同需求。</strong></li><li>当有新功能需要添加时，只需要添加新的装饰器实现类，然后通过组合方式添加这个新装饰器即可，无须修改己有类的代码，符合“<strong>开放-封闭</strong>”原则。</li></ul><p>但是，随着添加的新需求越来越多，可能会创建出嵌套多层装饰器的对象，这增加了系统的复杂性，也增加了理解的难度和定位错误的难度。</p><h2 id="Cache接口及其实现"><a href="#Cache接口及其实现" class="headerlink" title="Cache接口及其实现"></a>Cache接口及其实现</h2><p><code>MyBatis</code>的缓存模块在<code>org.apache.ibatis.cache</code>包下，其中<code>Cache</code>接口是缓存模块的中最核心的接口，它定义了所有缓存的基本行为。</p><p><strong>Cache</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Cache</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 返回该缓存对应的id</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> The identifier of this cache</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function">String <span class="title">getId</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 向缓存中添加数据，一般情况下Key是CacheKey，value是查询结果</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> key Can be any object but usually it is a &#123;<span class="doctag">@link</span> CacheKey&#125;</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> value The result of a select.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">putObject</span><span class="params">(Object key, Object value)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 从缓存中获取数据</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> key The key</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> The object stored in the cache.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function">Object <span class="title">getObject</span><span class="params">(Object key)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 删除Key对应的缓存</span></span><br><span class="line"><span class="comment">   * As of 3.3.0 this method is only called during a rollback </span></span><br><span class="line"><span class="comment">   * for any previous value that was missing in the cache.</span></span><br><span class="line"><span class="comment">   * This lets any blocking cache to release the lock that </span></span><br><span class="line"><span class="comment">   * may have previously put on the key.</span></span><br><span class="line"><span class="comment">   * A blocking cache puts a lock when a value is null </span></span><br><span class="line"><span class="comment">   * and releases it when the value is back again.</span></span><br><span class="line"><span class="comment">   * This way other threads will wait for the value to be </span></span><br><span class="line"><span class="comment">   * available instead of hitting the database.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * </span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> key The key</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> Not used</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function">Object <span class="title">removeObject</span><span class="params">(Object key)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 清空缓存</span></span><br><span class="line"><span class="comment">   * Clears this cache instance</span></span><br><span class="line"><span class="comment">   */</span>  </span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 缓存项的个数，不会被MyBatis核心代码调用</span></span><br><span class="line"><span class="comment">   * Optional. This method is not called by the core.</span></span><br><span class="line"><span class="comment">   * </span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> The number of elements stored in the cache (not its capacity).</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** </span></span><br><span class="line"><span class="comment">   * 获取读写锁，不会被MyBatis核心代码调用</span></span><br><span class="line"><span class="comment">   * Optional. As of 3.2.6 this method is no longer called by the core.</span></span><br><span class="line"><span class="comment">   *  </span></span><br><span class="line"><span class="comment">   * Any locking needed by the cache must be provided internally by the cache provider.</span></span><br><span class="line"><span class="comment">   * </span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> A ReadWriteLock </span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function">ReadWriteLock <span class="title">getReadWriteLock</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Cache</code>接口的实现类有多个，大部分都是装饰器，只有<code>PerpetualCache</code>提供了Cache接口的基本实现。</p><p><img src="https://gitee.com/cayzlh/img-repo/raw/master/2020/06/11/image-20200611120028350_RNaWIP.png" alt="image-20200611120028350"></p><h3 id="PerpetualCache"><a href="#PerpetualCache" class="headerlink" title="PerpetualCache"></a>PerpetualCache</h3><p><code>**PerpetualCache</code>在缓存模块中扮演着<code>ConcreteComponent</code>的角色**，其实现比较简单，底层使用<code>HashMap</code>记录缓存项，也是通过该<code>HashMap</code>对象的方法实现的<code>Cache</code>接口中定义的相应方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PerpetualCache</span> <span class="keyword">implements</span> <span class="title">Cache</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> String id;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Map&lt;Object, Object&gt; cache = <span class="keyword">new</span> HashMap&lt;Object, Object&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">PerpetualCache</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.id = id;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> id;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> cache.size();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putObject</span><span class="params">(Object key, Object value)</span> </span>&#123;</span><br><span class="line">    cache.put(key, value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> cache.get(key);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">removeObject</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> cache.remove(key);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cache.clear();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> ReadWriteLock <span class="title">getReadWriteLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (getId() == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> CacheException(<span class="string">&quot;Cache instances require an ID.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == o) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Cache)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Cache otherCache = (Cache) o;</span><br><span class="line">    <span class="keyword">return</span> getId().equals(otherCache.getId());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (getId() == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> CacheException(<span class="string">&quot;Cache instances require an ID.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> getId().hashCode();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面来介绍<code>org.apache.ibatis.cache.decorators</code>包下提供的装饰器，它们都直接实现了<code>Cache</code>接口，扮演着<code>ConcreteDecorator</code>的角色。</p><p>这些装饰器会在<code>PerpetualCache</code>的基础上提供一些额外的功能，通过多个组合后满足一个特定的需求，后面介绍二级缓存时，会见到这些装饰器是如何完成动态组合的。</p><h3 id="BlockingCache"><a href="#BlockingCache" class="headerlink" title="BlockingCache"></a>BlockingCache</h3><p><code>BlockingCache</code>是阻塞版本的缓存装饰器，它会保证只有一个线程到数据库中查找指定<code>key</code>对应的数据。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 阻塞超时时间</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> timeout;</span><br><span class="line"><span class="comment">// 被装饰的底层Cache对象</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Cache delegate;</span><br><span class="line"><span class="comment">// 每个Key都有对应的ReentrantLock对象</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ConcurrentHashMap&lt;Object, ReentrantLock&gt; locks;</span><br></pre></td></tr></table></figure><p>假设<code>线程A</code>在<code>BlockingCache</code>中未查找到<code>keyA</code>对应的缓存项时，<code>线程A</code>会获取<code>keyA</code>对应的锁，这样后续线程在查找<code>keyA</code>时会发生阻塞</p><p><img src="https://gitee.com/cayzlh/img-repo/raw/master/2020/06/16/image-20200616092820328_4agKqU.png" alt="image-20200616092820328"></p><p><strong>BlockingCache.getObject(Object key)</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 获取key对应的锁</span></span><br><span class="line">  acquireLock(key);</span><br><span class="line">  Object value = delegate.getObject(key);</span><br><span class="line">  <span class="keyword">if</span> (value != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果缓存有key对应的缓存项，则释放锁</span></span><br><span class="line">    releaseLock(key);</span><br><span class="line">  &#125;        </span><br><span class="line">  <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>acquireLock(Object key)</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">acquireLock</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 获取ReentrantLock对象</span></span><br><span class="line">  Lock lock = getLockForKey(key);</span><br><span class="line">  <span class="keyword">if</span> (timeout &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 获取锁，带超时时间的那种</span></span><br><span class="line">      <span class="keyword">boolean</span> acquired = lock.tryLock(timeout, TimeUnit.MILLISECONDS);</span><br><span class="line">      <span class="keyword">if</span> (!acquired) &#123;</span><br><span class="line">        <span class="comment">// 如果超时，则抛出异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> CacheException(<span class="string">&quot;...&quot;</span>);  </span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> CacheException(<span class="string">&quot;...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再来看一下<code>getLockForKey</code>方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> ReentrantLock <span class="title">getLockForKey</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">  ReentrantLock lock = <span class="keyword">new</span> ReentrantLock(); <span class="comment">// 创建ReentrantLock对象</span></span><br><span class="line">  <span class="comment">// 试添加到locks集合中，如果locks集合中已经有了相应的ReentrantLock对象，则使用locks集合</span></span><br><span class="line">  <span class="comment">// 中的ReentrantLock对象</span></span><br><span class="line">  ReentrantLock previous = locks.putIfAbsent(key, lock);</span><br><span class="line">  <span class="keyword">return</span> previous == <span class="keyword">null</span> ? lock : previous;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设线程A从数据库中查找到keyA对应的结果对象后，将结果对象放入到<code>BlockingCache</code>中，此时线程A会释放keyA对应的锁，唤醒阻塞在该锁上的线程。</p><p>其他线程即可从<code>BlockingCache</code>中获取keyA对应的数据，而不是再次访问数据库。</p><p><img src="https://gitee.com/cayzlh/img-repo/raw/master/2020/06/18/image-20200618093048912_N2ifEV.png" alt="image-20200618093048912"></p><p><strong>BlockingCache.putObject()</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putObject</span><span class="params">(Object key, Object value)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 向缓存中添加缓存项</span></span><br><span class="line">    delegate.putObject(key, value);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    releaseLock(key);<span class="comment">// 释放锁</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>BlockingCache.releaseLock(Object key)</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">releaseLock</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">  ReentrantLock lock = locks.get(key);</span><br><span class="line">  <span class="keyword">if</span> (lock.isHeldByCurrentThread()) &#123; <span class="comment">// 判断锁是否被当前线程持有</span></span><br><span class="line">    <span class="comment">// 释放锁</span></span><br><span class="line">    lock.unlock();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="FifoCache-amp-LruCache"><a href="#FifoCache-amp-LruCache" class="headerlink" title="FifoCache&amp;LruCache"></a>FifoCache&amp;LruCache</h3><p>在很多场景中，为了控制缓存的大小，系统需要按照一定的规则清理缓存。</p><p><code>FifoCache</code>是先入先出版本的装饰器，**<u>当向缓存添加数据时，如果缓存项的个数己经达到上限，则会将缓存中最老(即最早进入缓存)的缓存项删除。</u>**</p><p><code>FifoCache</code>中字段的含义：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 被装饰的底层Cache对象</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Cache delegate;</span><br><span class="line"><span class="comment">// 用于记录key进入缓存的先后顺序，使用的是LinkedList&lt;Object&gt;类型的几个对象</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Deque&lt;Object&gt; keyList;</span><br><span class="line"><span class="comment">// 记录缓存项的上限，如果超过，则清理最老的缓存</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> size;</span><br></pre></td></tr></table></figure><p><u><code>FifoCache.getObject()</code>和<code>removeObject()</code>方法的实现都是直接调用底层<code>Cache</code>对象的对应方法。</u></p><p>在<code>FifoCache.putObject()</code>方法中会完成缓存项个数的检测以及缓存的清理操作。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putObject</span><span class="params">(Object key, Object value)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 检测并清理缓存</span></span><br><span class="line">  cycleKeyList(key);</span><br><span class="line">  <span class="comment">// 添加缓存项</span></span><br><span class="line">  delegate.putObject(key, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">cycleKeyList</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 记录key</span></span><br><span class="line">  keyList.addLast(key);</span><br><span class="line">  <span class="keyword">if</span> (keyList.size() &gt; size) &#123; <span class="comment">// 如果达到缓存上限，则清理最老的缓存项</span></span><br><span class="line">    Object oldestKey = keyList.removeFirst();</span><br><span class="line">    delegate.removeObject(oldestKey);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>LruCache</code>是按照近期最少使用算法**(LeastRecentlyUsed，LRU)**进行缓存清理的装饰器，在需要清理缓存时,它会清除最近最少使用的缓存项。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 被装饰的底层Cache对象</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Cache delegate;</span><br><span class="line"><span class="comment">// LinkedHashMap&lt;Object,Object&gt;类型对象，它是一个有序的HashMap，用于记录key最近的使用情况</span></span><br><span class="line"><span class="keyword">private</span> Map&lt;Object, Object&gt; keyMap;</span><br><span class="line"><span class="comment">// 记录最少被使用的缓存项的key</span></span><br><span class="line"><span class="keyword">private</span> Object eldestKey;</span><br></pre></td></tr></table></figure><p><code>LruCache</code>的构造函数中默认设置的缓存大小是<strong>1024</strong>,我们可以通过其<code>setSize()</code>方法重新设置缓存大小</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSize</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 重新设置缓存大小的时候， 会充值keyMap字段</span></span><br><span class="line">  <span class="comment">// LinkedHashMap构造函数的第三个参数，true表示该LinkedHashMap记录的顺序是</span></span><br><span class="line">  <span class="comment">// access-order,也就是说LinkedHashMap.get()方法会改变其记录的顺序</span></span><br><span class="line">  keyMap = <span class="keyword">new</span> LinkedHashMap&lt;Object, Object&gt;(size, <span class="number">.75F</span>, <span class="keyword">true</span>) &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">4267176411845948333L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当调用LinkedHashMap.put()方法时，会调用该方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Map.Entry&lt;Object, Object&gt; eldest)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">boolean</span> tooBig = size() &gt; size;</span><br><span class="line">      <span class="keyword">if</span> (tooBig) &#123;</span><br><span class="line">        <span class="comment">// 如果已到达缓存上限，则更新eldestKey字段，后面会删除该项</span></span><br><span class="line">        eldestKey = eldest.getKey();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> tooBig;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>LruCache.getObject()</code>方法除了返回缓存项，还会调用<code>keyMap.get()</code>方法修改<code>key</code>的顺序，表示指定的key最近被使用。</p><p><code>LruCache.putObject()</code>方法除了添加缓存项，还会将<code>eldestKey</code>字段指定的缓存项清除掉。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putObject</span><span class="params">(Object key, Object value)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 修改LinkedHashMap中记录的顺序</span></span><br><span class="line">  delegate.putObject(key, value);</span><br><span class="line">  cycleKeyList(key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">  keyMap.get(key); <span class="comment">//touch</span></span><br><span class="line">  <span class="comment">// 删除最久未使用的缓存项</span></span><br><span class="line">  <span class="keyword">return</span> delegate.getObject(key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">cycleKeyList</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">  keyMap.put(key, key);</span><br><span class="line">  <span class="keyword">if</span> (eldestKey != <span class="keyword">null</span>) &#123; <span class="comment">// eldestKey不为空，即缓存已达到上限</span></span><br><span class="line">    <span class="comment">// 删除最久未使用的缓存</span></span><br><span class="line">    delegate.removeObject(eldestKey);</span><br><span class="line">    eldestKey = <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="SoftCache-amp-WeakCache"><a href="#SoftCache-amp-WeakCache" class="headerlink" title="SoftCache&amp;WeakCache"></a>SoftCache&amp;WeakCache</h3><p>先了解一下<a href="/2020/06/18/ae9388fa.html">Java提供的4种引用类型</a>。</p><p><code>SoftCache</code>中各个字段的含义：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ReferenceQueue，引用队列，用于记录已经被GC回收的缓存项所对应的SoftEntry对象</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Deque&lt;Object&gt; hardLinksToAvoidGarbageCollection;</span><br><span class="line"><span class="comment">// 在SoftCache中，最近使用的一部分缓存项不会被GC回收，这就是通过将其value添加到</span></span><br><span class="line"><span class="comment">// hardLinksToAvoidGarbageCollection集合中实现的(即有强引用指向其value)</span></span><br><span class="line"><span class="comment">// hardLinksToAvoidGarbageCollection集合是LinkedList&lt;Object&gt;类型</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReferenceQueue&lt;Object&gt; queueOfGarbageCollectedEntries;</span><br><span class="line"><span class="comment">// 底层被装饰的底层Cache对象</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Cache delegate;</span><br><span class="line"><span class="comment">// 强连接的个数，默认值是256</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> numberOfHardLinks;</span><br></pre></td></tr></table></figure><p><code>SoftCache</code>中缓存项的<code>value</code>是<code>SoftEntry</code>对象，<code>SoftEntry</code>继承了<code>SoftReference</code>，其中指向<code>key</code>的引用是强引用，而指向<code>value</code>的引用是软引用。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SoftEntry</span> <span class="keyword">extends</span> <span class="title">SoftReference</span>&lt;<span class="title">Object</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Object key;</span><br><span class="line"></span><br><span class="line">  SoftEntry(Object key, Object value, ReferenceQueue&lt;Object&gt; garbageCollectionQueue) &#123;</span><br><span class="line">    <span class="keyword">super</span>(value, garbageCollectionQueue); <span class="comment">// 指向value的引用是软引用，且关联了引用队列</span></span><br><span class="line">    <span class="keyword">this</span>.key = key; <span class="comment">// 强引用</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>SoftCache.putObject()</code>方法除了向缓存中添加缓存项，还会清除己经被<code>GC</code>回收的缓存项,其具体实现如下:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putObject</span><span class="params">(Object key, Object value)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 清除已被GC回收的缓存项</span></span><br><span class="line">  removeGarbageCollectedItems();</span><br><span class="line">  <span class="comment">// 向缓存中添加缓存项</span></span><br><span class="line">  delegate.putObject(key, <span class="keyword">new</span> SoftEntry(key, value, queueOfGarbageCollectedEntries));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">removeGarbageCollectedItems</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  SoftEntry sv;</span><br><span class="line">  <span class="comment">// 遍历queueOfGarbageCollectedEntries集合</span></span><br><span class="line">  <span class="keyword">while</span> ((sv = (SoftEntry) queueOfGarbageCollectedEntries.poll()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 将已经被GC回收的value对象对应的缓存项清除</span></span><br><span class="line">    delegate.removeObject(sv.key);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>SoftCache.getObject()</code>方法除了从缓存中查找对应的<code>value</code>,处理被<code>GC</code>回收的<code>value</code>对应的缓存项，还会更新<code>hardLinksToAvoidGarbageCollection</code>集合</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">  Object result = <span class="keyword">null</span>;</span><br><span class="line">  <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span> <span class="comment">// assumed delegate cache is totally managed by this cache</span></span><br><span class="line">  <span class="comment">// 从缓存中查找对应的缓存项</span></span><br><span class="line">  SoftReference&lt;Object&gt; softReference = (SoftReference&lt;Object&gt;) delegate.getObject(key);</span><br><span class="line">  <span class="keyword">if</span> (softReference != <span class="keyword">null</span>) &#123; <span class="comment">// 检测缓存中是否有对应的缓存项</span></span><br><span class="line">    result = softReference.get(); <span class="comment">// 获取SoftReference引用的value</span></span><br><span class="line">    <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;<span class="comment">// 已经被GC回收</span></span><br><span class="line">      delegate.removeObject(key); <span class="comment">// 从缓存中清除对应的缓存项</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 未被GC回收</span></span><br><span class="line">      <span class="comment">// See #586 (and #335) modifications need more than a read lock </span></span><br><span class="line">      <span class="keyword">synchronized</span> (hardLinksToAvoidGarbageCollection) &#123;</span><br><span class="line">        <span class="comment">// 缓存项的value添加到hardLinksToAvoidGarbageCollection集合中保存</span></span><br><span class="line">        hardLinksToAvoidGarbageCollection.addFirst(result);</span><br><span class="line">        <span class="keyword">if</span> (hardLinksToAvoidGarbageCollection.size() &gt; numberOfHardLinks) &#123;</span><br><span class="line">          <span class="comment">// 超过numberOfHardLinks，则将最老的缓存项从hardLinksToAvoidGarbageCollection集合中清除，有点类似于先进先出队列</span></span><br><span class="line">          hardLinksToAvoidGarbageCollection.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><u><code>SoftCache.removeObject()</code>方法在清除缓存项之前，也会调用<code>removeGarbageCollectedItems()</code>方法清理被<code>GC</code>回收的缓存项。</u></p><p><code>SoftCache.clear()</code>方法首先清理<code>hardLinksToAvoidGarbageCollection</code>集合，然后清理被<code>GC</code>回收的缓存项，最后清理底层<code>delegate</code>缓存中的缓存项。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">synchronized</span> (hardLinksToAvoidGarbageCollection) &#123;</span><br><span class="line">    hardLinksToAvoidGarbageCollection.clear(); <span class="comment">// 清理强引用集合</span></span><br><span class="line">  &#125;</span><br><span class="line">  removeGarbageCollectedItems(); <span class="comment">// 清理被GC回收的缓存项</span></span><br><span class="line">  delegate.clear(); <span class="comment">// 清理底层delegate缓存中的缓存项</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>WeakCache</code>的实现与<code>SoftCache</code>基本类似，唯一的区别在于其中使用<code>WeakEntry</code>(继承自<code>WeakReference</code>)封装真正的<code>value</code>对象，其他实现完全一样。</p></blockquote><h3 id="others"><a href="#others" class="headerlink" title="others"></a>others</h3><p><code>ScheduledCache</code>是周期性清理缓存的装饰器，它的<code>clearlnterval</code>字段记录了两次缓存清理之间的时间间隔，默认是一小时，<code>lastClear</code>字段记录了最近一次清理的时间戳。</p><p><code>ScheduledCache</code>的<code>getObject()</code>、<code>putObject()</code>、<code>removeObject()</code>等核心方法在执行时，都会根据这两个字段检测是否需要进行清理操作，清理操作会清空缓存中所有缓存项。</p><p><code>LoggingCache</code>在<code>Cache</code>的基础上提供了日志功能，它通过<code>hit</code>字段和<code>request</code>字段记录了<code>Cache</code>的命中次数和访问次数。</p><p>在<code>LoggingCache.getObject()</code>方法中会统计命中次数和访问次数这两个指标，并按照指定的日志输出方式输出命中率。</p><p><code>SynchronizedCache</code>通过在每个方法上添加<code>synchronized</code>关键字，为<code>Cache</code>添加了同步功能，有点类似于<code>JDK</code>中<code>Collections</code>中的<code>SynchronizedCollection</code>内部类的实现。</p><p><code>SerializedCache</code>提供了将<code>value</code>对象序列化的功能。</p><p><code>SerializedCache</code>在添加缓存项时，会将<code>value</code>对应的<code>Java</code>对象进行序列化，并将序列化后的<code>byte[]</code>数组作为<code>value</code>存入缓存。</p><p><code>SerializedCache</code>在获取缓存项时，会将缓存项中的<code>byte[]</code>数组反序列化成<code>Java</code>对象。</p><p>使用前面介绍的<code>Cache</code>装饰器实现进行装饰之后，每次从缓存中获取同一<code>key</code>对应的对象时，得到的都是同一对象，任意一个线程修改该对象都会影响到其他线程以及缓存中的对象；而<code>SerializedCache</code>每次从缓存中获取数据时，都会通过反序列化得到一个全新的对象。**<code>SerializedCache</code>使用的序列化方式是<code>Java</code>原生序列化。**</p><h2 id="CacheKey"><a href="#CacheKey" class="headerlink" title="CacheKey"></a>CacheKey</h2><p>在<code>Cache</code>中唯一确定一个缓存项需要使用缓存项的<code>key</code>,<code>MyBatis</code>中因为涉及动态<code>SQL</code>等多方面因素，其缓存项的<code>key</code>不能仅仅通过一个<code>String</code>表示，所以<code>MyBatis</code>提供了<code>CacheKey</code>类来表示缓存项的<code>key</code>，在一个<code>CacheKey</code>对象中可以封装多个影响缓存项的因素。</p><p><code>CacheKey</code>中可以添加多个对象，由这些对象共同确定两个<code>CacheKey</code>对象是否相同。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 参与计算hashcode，默认值37</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> multiplier;</span><br><span class="line"><span class="comment">// CacheKey的hashcode，初始值是37</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> hashcode;</span><br><span class="line"><span class="comment">// 校验和</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> checksum;</span><br><span class="line"><span class="comment">// updateList集合的个数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line"><span class="comment">// 由该集合中的所有对象共同决定两个CacheKey是否相同</span></span><br><span class="line"><span class="keyword">private</span> List&lt;Object&gt; updateList;</span><br></pre></td></tr></table></figure><p>在向<code>CacheKey.updateList</code>集合中添加对 象时 ，使用的是<code>CacheKey.update()</code>方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Object object)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> baseHashCode = object == <span class="keyword">null</span> ? <span class="number">1</span> : ArrayUtil.hashCode(object); </span><br><span class="line">  <span class="comment">// 重新计算count、checksum和hashcode的值</span></span><br><span class="line">  count++;</span><br><span class="line">  checksum += baseHashCode;</span><br><span class="line">  baseHashCode *= count;</span><br><span class="line"></span><br><span class="line">  hashcode = multiplier * hashcode + baseHashCode;</span><br><span class="line"><span class="comment">// 将object添加到updateList集合中</span></span><br><span class="line">  updateList.add(object);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><p><strong>《MyBatis技术内幕》</strong></p></li><li><p>部分图片来源——<strong>《MyBatis技术内幕》</strong></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 书籍 </category>
          
          <category> 《MyBatis技术内幕》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MyBatis </tag>
            
            <tag> 《MyBatis技术内幕》 </tag>
            
            <tag> 基础支持层 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基础支持层——binding模块</title>
      <link href="/blog/2019/10/30/e275ec7f.html"/>
      <url>/blog/2019/10/30/e275ec7f.html</url>
      
        <content type="html"><![CDATA[<p>MyBatis基础支持层位于 Mybatis 整体架构的最底层，支撑着 Mybatis 的核心处理层，是整个框架的基石。基础支持层中封装了多个较为通用的、独立的模块，不仅仅为 Mybatis 提供基础支撑，也可以在合适的场景中直接复用。</p><p><img src="https://gitee.com/cayzlh/img-repo/raw/master/2020/06/09/2_c5SKkm_zgJEGC.png" alt="整体架构"></p><blockquote><p>这篇文章介绍MyBatis的binding模块</p></blockquote><p>在 <code>iBatis</code> (MyBatis 的前身)中，查 询 一个 <code>Blog</code> 对 象时 需要调 用 <code>SqlSession.queryForObject (&quot;selectBlog&quot;, blogld)</code>方法。</p><p>其中，<code>SqlSession.queryForObject()</code>方法会 执 行指定的 <code>SQL</code> 语 句进 行 查 询 并 返回一个 结 果对 象，第一个 参 数 <code>selectBlog</code>指明了具体 执 行的<code>SQL</code>语 句的<code>id</code>,该 <code>SQL</code> 语 句定义 在相应 的映射配置文件中。</p><p>如果我们 错 将 <code>selectBlog</code>写 成了 <code>selectBlogl</code>，在初始 化过 程中，<code>MyBatis</code>是无法提示该 错 误 的，而在实 际 调 用<code>queryForObject(selectBlog1，blogld)</code> 方法时才会抛出异常，开发人员才能知道该错误。</p><p><code>MyBatis</code>提供了 <code>binding</code>模块 用于解决 上述问 题 ，我们 可以定义 一个  <code>Mapper</code>接口，该 示例中为 <code>BlogMapper</code>接口，具体 代码 如下所示。</p><p><em>这 里的 <code>BlogMapper</code>接口并 不需要继 承任何其他接口，而且开 发 人员 不需要提供该 接口的实 现 。</em></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BlogMapper</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 在映射文件中存在一个&lt;select&gt;接口，id为 selectById</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Blog <span class="title">selectById</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该 <code>Mapper</code>接口中定义 了 <code>SQL</code>语 句对 应 的方法，这 些方法在<code>MyBatis</code>初始化过 程中会 与 映 射配置文件中定义 的<code>SQL</code>语 句相关 联 。如果存在无法关 联 的<code>SQL</code>语 句，在 <code>MyBatis</code>的初始化 节 点就会 抛出异 常。</p><p>我们可以调 用<code>Mapper</code>接口中的方法执 行相应 的<code>SQL</code>语 句，这样编译器就可以帮助我们提早发现上述问题 。</p><p>查询blog：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">blogMapper mapp = session.getMapper(BlogMapper.class);</span><br><span class="line">Blog blog = mapp.selectById(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p><strong>binding模块核心组件</strong></p><p><img src="https://gitee.com/cayzlh/img-repo/raw/master/2020/06/10/image-20200610142911476_529HtN.png" alt="image-20200610142911476"></p><h2 id="MapperRegistry-amp-MapperProxyFactory"><a href="#MapperRegistry-amp-MapperProxyFactory" class="headerlink" title="MapperRegistry&amp;MapperProxyFactory"></a>MapperRegistry&amp;MapperProxyFactory</h2><h3 id="MapperRegistry"><a href="#MapperRegistry" class="headerlink" title="MapperRegistry"></a>MapperRegistry</h3><p><u><code>MapperRegistry</code>是 <code>Mapper</code>接口及其对 应 的代理对 象工厂 的注册 中心。</u><code>Configuration</code>是 <code>MyBatis</code>全局性的配置对 象，在 <code>MyBatis</code>初始化的过 程中，所有配置信息会 被解析成相应 的对 象并 记 录 到<code>Configuration</code>对 象中。这 里 关 注 <code>Configuration.mapperRegistry</code>字 段 ， 它 记 录 当 前 使 用 的 <code>MapperRegistry</code>对 象 。</p><p><strong>MapperRegistry中字段及含义</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Configuration对象，MyBatis中全局唯一的配置对象，其中包含了所有配置信息</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Configuration config;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 记录Mapper接口与对应MapperRegistry之间的关系</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Class&lt;?&gt;, MapperProxyFactory&lt;?&gt;&gt; knownMappers </span><br><span class="line">  = <span class="keyword">new</span> HashMap&lt;Class&lt;?&gt;, MapperProxyFactory&lt;?&gt;&gt;();</span><br></pre></td></tr></table></figure><p>在 <code>MyBatis</code>初始化过程中读取<strong>映射配置文件</strong>以及<code>Mapper</code>接口中的注解信息，并 调 用 <code>MapperRegistry.addMapper()</code>方 法 填 充 <code>MapperRegistry.knownMappers</code> 集 合 ， 该 集 合 的 key 是 <code>Mapper</code>接口对 应 的<code>Class</code>对 象，<code>value</code>为 <code>MapperProxyFactory</code>工厂 对 象，可以为 <code>Mapper</code>接口创 建代理对 象。<code>MapperRegistry.addMapper()</code>方法的 部分实 现 如下:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">addMapper</span><span class="params">(Class&lt;T&gt; type)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (type.isInterface()) &#123;<span class="comment">// 检测type是否为接口</span></span><br><span class="line">    <span class="keyword">if</span> (hasMapper(type)) &#123;</span><br><span class="line">      <span class="comment">// 如果已经添加果该接口，则直接抛出异常</span></span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(<span class="string">&quot;...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">boolean</span> loadCompleted = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// Mapper接口对应的Class对象和MapperProxyFactory对象添加到knownMappers集合</span></span><br><span class="line">      knownMappers.put(type, <span class="keyword">new</span> MapperProxyFactory&lt;T&gt;(type));</span><br><span class="line">      <span class="comment">// It&#x27;s important that the type is added before the parser is run</span></span><br><span class="line">      <span class="comment">// otherwise the binding may automatically be attempted by the</span></span><br><span class="line">      <span class="comment">// mapper parser. If the type is already known, it won&#x27;t try.</span></span><br><span class="line">      <span class="comment">// XML解析和注解处理</span></span><br><span class="line">      MapperAnnotationBuilder parser = <span class="keyword">new</span> MapperAnnotationBuilder(config, type);</span><br><span class="line">      parser.parse();</span><br><span class="line">      loadCompleted = <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (!loadCompleted) &#123;</span><br><span class="line">        knownMappers.remove(type);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在需要执 行某<code>SQL</code>语 句时 ，<strong>会 先调 用<code>MapperRegistry.getMapper()</code>方法获 取实 现 了 <code>Mapper</code> 接口的代理对 象</strong>，例如本节 开 始的示例中，<code>session.getMapper(BlogMapper.class)</code>方法得到的实 际 上 是 <code>MyBatis</code>通 过 <strong>JDK动 态 代 理</strong> 为 <code>BlogMapper</code>接 口 生 成 的 代 理 对 象 。<code>MapperRegistry.getMapper()</code> 方法的代码 如下。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getMapper</span><span class="params">(Class&lt;T&gt; type, SqlSession sqlSession)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 查找指定type的MapperProxyFactory对象</span></span><br><span class="line">  <span class="keyword">final</span> MapperProxyFactory&lt;T&gt; mapperProxyFactory </span><br><span class="line">    = (MapperProxyFactory&lt;T&gt;) knownMappers.get(type);</span><br><span class="line">  <span class="keyword">if</span> (mapperProxyFactory == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(<span class="string">&quot;...&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 创建实现了type接口的代理对象</span></span><br><span class="line">    <span class="keyword">return</span> mapperProxyFactory.newInstance(sqlSession);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(<span class="string">&quot;Error getting mapper instance. Cause: &quot;</span> + e, e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="MapperProxyFactory"><a href="#MapperProxyFactory" class="headerlink" title="MapperProxyFactory"></a>MapperProxyFactory</h3><p><code>MapperProxyFactory</code>主要负 责 创 建代理对 象，其中核心字段的含义 和功能如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 当前MapperProxyFactory对象可以创建实现了mapperlnterface接口的代理对象</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Class&lt;T&gt; mapperInterface;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 缓存，key是mapperlnterface接口中某方法对应的Method对象，value是对应的MapperMethod对象</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Method, MapperMethod&gt; methodCache </span><br><span class="line">  = <span class="keyword">new</span> ConcurrentHashMap&lt;Method, MapperMethod&gt;();</span><br></pre></td></tr></table></figure><p><code>MapperProxyFactory.newInstance()</code>方法实现了创建实现了<code>mapperlnterface</code> 接口的代理对象的功能，具体代码如下:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> T <span class="title">newInstance</span><span class="params">(MapperProxy&lt;T&gt; mapperProxy)</span> </span>&#123;</span><br><span class="line"><span class="comment">//  创建代理对象</span></span><br><span class="line">  <span class="keyword">return</span> (T) Proxy.newProxyInstance(mapperInterface.getClassLoader(), <span class="keyword">new</span> Class[] &#123; mapperInterface &#125;, mapperProxy);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">newInstance</span><span class="params">(SqlSession sqlSession)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 创建MapperProxy对象，每次调用都会创建新的MapperProxy对象</span></span><br><span class="line">  <span class="keyword">final</span> MapperProxy&lt;T&gt; mapperProxy </span><br><span class="line">    = <span class="keyword">new</span> MapperProxy&lt;T&gt;(sqlSession, mapperInterface, methodCache);</span><br><span class="line">  <span class="keyword">return</span> newInstance(mapperProxy);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="MapperProxy"><a href="#MapperProxy" class="headerlink" title="MapperProxy"></a>MapperProxy</h2><p><code>MapperProxy</code>实现了<code>InvocationHandler</code>接口，<code>InvocationHandler</code>是实现<code>JDK</code>代理对象的核心逻辑。</p><p><code>MappProxy</code>中核心字段含义和功能：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 记录了关联的SqlSession对象</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> SqlSession sqlSession;</span><br><span class="line"></span><br><span class="line"><span class="comment">// mapper接口对应的class对象</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Class&lt;T&gt; mapperInterface;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于缓存MapperMethod对象，其中key是Mapper接口中方法对应的Method对象，value是对应的MapperMethod对象</span></span><br><span class="line"><span class="comment">// MapperMethod对象会完成参数转换以及SQL语句的执行功能</span></span><br><span class="line"><span class="comment">// MapperMethod中并不记录任何状态相关的信息，所以可以在多个代理对象之间共享</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Method, MapperMethod&gt; methodCache;</span><br></pre></td></tr></table></figure><p><code>MapperProxy.invoke()</code>方法是代理对象执行的主要逻辑，实现如下:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 如果目标方法继承自Object，则直接调用目标方法</span></span><br><span class="line">    <span class="keyword">if</span> (Object.class.equals(method.getDeclaringClass())) &#123;</span><br><span class="line">      <span class="keyword">return</span> method.invoke(<span class="keyword">this</span>, args);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isDefaultMethod(method)) &#123;</span><br><span class="line">      <span class="comment">// 这里是针对java7以上版本动态类型语言的支持</span></span><br><span class="line">      <span class="keyword">return</span> invokeDefaultMethod(proxy, method, args);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">    <span class="keyword">throw</span> ExceptionUtil.unwrapThrowable(t);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 从缓存中获取MapperMethod对象，如果缓存中没有，则创建新的MapperMethod对象并添加到缓存中</span></span><br><span class="line">  <span class="keyword">final</span> MapperMethod mapperMethod = cachedMapperMethod(method);</span><br><span class="line">  <span class="comment">// 执行SQL语句</span></span><br><span class="line">  <span class="keyword">return</span> mapperMethod.execute(sqlSession, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>MapperProxy.cachedMapperMethod()</code>方法主要负责维护<code>methodCache</code>这个缓存集合：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> MapperMethod <span class="title">cachedMapperMethod</span><span class="params">(Method method)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 先从缓存中获取MapperMethod对象</span></span><br><span class="line">  MapperMethod mapperMethod = methodCache.get(method);</span><br><span class="line">  <span class="keyword">if</span> (mapperMethod == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 缓存就爱你mapperMethod对象并放到缓存中</span></span><br><span class="line">    mapperMethod = <span class="keyword">new</span> MapperMethod(mapperInterface, method, sqlSession.getConfiguration());</span><br><span class="line">    methodCache.put(method, mapperMethod);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> mapperMethod;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="MapperMethod"><a href="#MapperMethod" class="headerlink" title="MapperMethod"></a>MapperMethod</h2><p><code>MapperMethod</code>中封装了 <code>Mapper</code>接口中对应方法的信息，以及对应 <code>SQL</code>语句的信息。</p><p> <strong>可以将 <code>MapperMethod</code>看作连接 <code>Mapper</code>接口以及映射配置文件中定义的<code>SQL</code>语句的桥梁。</strong> </p><p><code>MapperMethod</code>中各个字段的信息如下:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 记录SQL语句和类型</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> SqlCommand command;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Mapper接口对应方法的信息</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> MethodSignature method;</span><br></pre></td></tr></table></figure><h3 id="SqlCommand"><a href="#SqlCommand" class="headerlink" title="SqlCommand"></a>SqlCommand</h3><p><code>SqlCommand</code>是 <code>MapperMethod</code>中定义 的内 部类 ,它 使用<code>name</code>字段记 录 了 <code>SQL</code>语 句的名称 , 使用<code>type</code>字 段 (<code>SqlCommandType</code>类 型)记 录 了 <code>SQL</code>语 句的类 型。</p><p><strong><code>SqlCommandType</code>是枚举类型 ，有效取值为<code>UNKNOWN</code>、<code>INSERT</code>、<code>UPDATE</code>、<code>DELETE</code>、<code>SELECT</code>、<code>FLUSH</code>。</strong></p><p><code>SqlCommand</code>的构造方法会初始化<code>name</code>字段和<code>type</code>字段，代码如下:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SqlCommand</span><span class="params">(Configuration configuration, Class&lt;?&gt; mapperInterface, Method method)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> String methodName = method.getName();</span><br><span class="line">  <span class="keyword">final</span> Class&lt;?&gt; declaringClass = method.getDeclaringClass();</span><br><span class="line">  MappedStatement ms </span><br><span class="line">    = resolveMappedStatement(mapperInterface, methodName, declaringClass,</span><br><span class="line">                                              configuration);</span><br><span class="line">  <span class="keyword">if</span> (ms == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (method.getAnnotation(Flush.class) != <span class="keyword">null</span>) &#123; <span class="comment">// @Flush处理</span></span><br><span class="line">      name = <span class="keyword">null</span>;</span><br><span class="line">      type = SqlCommandType.FLUSH;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(<span class="string">&quot;...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    name = ms.getId();</span><br><span class="line">    type = ms.getSqlCommandType();</span><br><span class="line">    <span class="keyword">if</span> (type == SqlCommandType.UNKNOWN) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(<span class="string">&quot;Unknown execution method for: &quot;</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> MappedStatement <span class="title">resolveMappedStatement</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  Class&lt;?&gt; mapperInterface, String methodName,</span></span></span><br><span class="line"><span class="function"><span class="params">  Class&lt;?&gt; declaringClass, Configuration configuration)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// SQL语句的名称是由Mapper接口的名称与对应的方法名称组成的</span></span><br><span class="line">  String statementId = mapperInterface.getName() + <span class="string">&quot;.&quot;</span> + methodName;</span><br><span class="line">  <span class="keyword">if</span> (configuration.hasStatement(statementId)) &#123; <span class="comment">// 检测是否有该名称的SQL语句</span></span><br><span class="line">    <span class="comment">// 从Configuration.mappedStatements集合中查找对应的MappedStatement对象，</span></span><br><span class="line">    <span class="comment">// MappedStatement对象中封装了SQL语句相关的信息，在MyBatis初始化时创建，后面详细描述</span></span><br><span class="line">    <span class="keyword">return</span> configuration.getMappedStatement(statementId);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mapperInterface.equals(declaringClass)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (Class&lt;?&gt; superInterface : mapperInterface.getInterfaces()) &#123;</span><br><span class="line">    <span class="comment">// 如果指定方法是在父接口中定义的，则在此进行继承结构的处理</span></span><br><span class="line">      <span class="keyword">if</span> (declaringClass.isAssignableFrom(superInterface)) &#123;</span><br><span class="line">        <span class="comment">// 递归处理</span></span><br><span class="line">        MappedStatement ms = </span><br><span class="line">          resolveMappedStatement(superInterface,methodName,declaringClass, configuration);</span><br><span class="line">        <span class="keyword">if</span> (ms != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> ms;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ParamNameResolver"><a href="#ParamNameResolver" class="headerlink" title="ParamNameResolver"></a>ParamNameResolver</h3><p>在 <code>MethodSignature</code>中 ，会 使 用 <code>ParamNameResolver</code>处 理 <code>Mapper</code>接 口 中 定 义 的 方 法 的 参 数 列 表 。</p><p><code>ParamNameResolver</code> 使用 <code>name</code> 字 段 (<code>SortedMap&lt;Integer, String&gt;</code>类 型 )记 录 了 参 数 在 参<br> 数 列表中的位置索引与 参 数 名称 之间 的对 应 关 系，其中<code>key</code>表示参 数 在参 数 列表中的索引位置， <code>value</code>表示参 数 名称 ，参 数 名称 可以通过 <code>@Param</code>注解指定，如果没 有指定<code>@Param</code>注解，则 使 用参 数 索引作为 其名称 。</p><p>如果参 数 列表中包含<code>RowBounds</code>类 型 或 <code>ResultHandler</code>类 型的参 数 ， 则 这 两 种 类 型的参 数 并 不会 被记 录 到<code>name</code>集合中，这 就会 导 致参 数 的索引与 名称 不一致。</p><p><img src="https://gitee.com/cayzlh/img-repo/raw/master/2020/06/10/image-20200610153922096_DqRtVF.png" alt="image-20200610153922096"></p><p><code>ParamNameResolver</code>的 <code>hasParamAnnotation</code>字 段 (<code>boolean</code>类 型 )记 录 对 应 方 法 的 参 数 列 表 中是否使用了 <code>@Param</code>注 解 。</p><p>在 <code>ParamNameResolver</code>的构 造方法中，会 通过 反射的方式读 取<code>Mapper</code>接口中对 应 方法的信息，并初始化以上字段：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ParamNameResolver</span><span class="params">(Configuration config, Method method)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 获取参数列表中每个参数的类型</span></span><br><span class="line">  <span class="keyword">final</span> Class&lt;?&gt;[] paramTypes = method.getParameterTypes();</span><br><span class="line">  <span class="comment">// 获取参数列表上的注解</span></span><br><span class="line">  <span class="keyword">final</span> Annotation[][] paramAnnotations = method.getParameterAnnotations();</span><br><span class="line">  <span class="comment">// 记录参数索引与参数名称的对应关系</span></span><br><span class="line">  <span class="keyword">final</span> SortedMap&lt;Integer, String&gt; map = <span class="keyword">new</span> TreeMap&lt;Integer, String&gt;();</span><br><span class="line">  <span class="keyword">int</span> paramCount = paramAnnotations.length;</span><br><span class="line">  <span class="comment">// get names from @Param annotations</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> paramIndex = <span class="number">0</span>; paramIndex &lt; paramCount; paramIndex++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (isSpecialParameter(paramTypes[paramIndex])) &#123;</span><br><span class="line">      <span class="comment">// skip special parameters</span></span><br><span class="line">      <span class="comment">// 如果参数是RowBounds类型或ResultHandler类型，则跳过对该参数的分析</span></span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    String name = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 遍历参数对应的注解集合</span></span><br><span class="line">    <span class="keyword">for</span> (Annotation annotation : paramAnnotations[paramIndex]) &#123;</span><br><span class="line">      <span class="keyword">if</span> (annotation <span class="keyword">instanceof</span> Param) &#123;</span><br><span class="line">        <span class="comment">// 如果出现过@Param就把hasParamAnnotation初始化为true</span></span><br><span class="line">        hasParamAnnotation = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">// 获取@Param注解指定的参数名称</span></span><br><span class="line">        name = ((Param) annotation).value();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (name == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// @Param was not specified.</span></span><br><span class="line">      <span class="keyword">if</span> (config.isUseActualParamName()) &#123;</span><br><span class="line">        name = getActualParamName(method, paramIndex);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (name == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// use the parameter index as the name (&quot;0&quot;, &quot;1&quot;, ...)</span></span><br><span class="line">        <span class="comment">// gcode issue #71</span></span><br><span class="line">        name = String.valueOf(map.size());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    map.put(paramIndex, name);</span><br><span class="line">  &#125;</span><br><span class="line">  names = Collections.unmodifiableSortedMap(map);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>names</code>集合主要在<code>ParamNameResolver.getNamedParams()</code>方法中使用，该 方法接收的参 数 是 用户传入的实参列表，并将实参与其对应名称进行关联，具体代码如下:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getNamedParams</span><span class="params">(Object[] args)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">int</span> paramCount = names.size();</span><br><span class="line">  <span class="keyword">if</span> (args == <span class="keyword">null</span> || paramCount == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!hasParamAnnotation &amp;&amp; paramCount == <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> args[names.firstKey()];</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> Map&lt;String, Object&gt; param = <span class="keyword">new</span> ParamMap&lt;Object&gt;();</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;Integer, String&gt; entry : names.entrySet()) &#123;</span><br><span class="line">      param.put(entry.getValue(), args[entry.getKey()]);</span><br><span class="line">      <span class="comment">// add generic param names (param1, param2, ...)</span></span><br><span class="line">      <span class="keyword">final</span> String genericParamName = GENERIC_NAME_PREFIX + String.valueOf(i + <span class="number">1</span>);</span><br><span class="line">      <span class="comment">// ensure not to overwrite parameter named with @Param</span></span><br><span class="line">      <span class="keyword">if</span> (!names.containsValue(genericParamName)) &#123;</span><br><span class="line">        param.put(genericParamName, args[entry.getKey()]);</span><br><span class="line">      &#125;</span><br><span class="line">      i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> param;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="MethodSignature"><a href="#MethodSignature" class="headerlink" title="MethodSignature"></a>MethodSignature</h3><p><code>MethodSignature</code> 也 是 <code>MapperMethod</code>中定义 的内 部类 ，其中封装 了 <code>Mapper</code>接口中定义 的方法的相关 信息， <code>MethodSignature</code>中核心字段的含义 如下:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回值类型是否为 Collection类型或是数组类型</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> returnsMany;</span><br><span class="line"><span class="comment">// 返回值类型是否为Map类型</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> returnsMap;</span><br><span class="line"><span class="comment">// 返回值类型是否为Void类型</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> returnsVoid;</span><br><span class="line"><span class="comment">// 返回类型是否为Cursor类型</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> returnsCursor;</span><br><span class="line"><span class="comment">// 返回值类型</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Class&lt;?&gt; returnType;</span><br><span class="line"><span class="comment">// 如果返回值类型是Map，则该字段记录了作为key的列名</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String mapKey;</span><br><span class="line"><span class="comment">// 用来标记该方法参数列表中ResultHandler类型参数的位置</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Integer resultHandlerIndex;</span><br><span class="line"><span class="comment">// 用来标记该方法参数列表中RowBounds类型参数的位置</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Integer rowBoundsIndex;</span><br><span class="line"><span class="comment">//  方法对应的ParamNameResolver对象</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ParamNameResolver paramNameResolver;</span><br></pre></td></tr></table></figure><p>在 <code>MethodSignature</code>的构 造函数 中会 解析相应 的<code>Method</code>对 象，并 初始化上述字段，具体 代 码 如下:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> MethodSignature</span><br><span class="line">  (Configuration configuration, Class&lt;?&gt; mapperInterface, Method method) &#123;</span><br><span class="line">  Type resolvedReturnType = TypeParameterResolver.resolveReturnType(method, mapperInterface);</span><br><span class="line">  <span class="keyword">if</span> (resolvedReturnType <span class="keyword">instanceof</span> Class&lt;?&gt;) &#123;</span><br><span class="line">    <span class="keyword">this</span>.returnType = (Class&lt;?&gt;) resolvedReturnType;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (resolvedReturnType <span class="keyword">instanceof</span> ParameterizedType) &#123;</span><br><span class="line">    <span class="keyword">this</span>.returnType = (Class&lt;?&gt;) ((ParameterizedType) resolvedReturnType).getRawType();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.returnType = method.getReturnType();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.returnsVoid = <span class="keyword">void</span>.class.equals(<span class="keyword">this</span>.returnType);</span><br><span class="line">  <span class="keyword">this</span>.returnsMany = </span><br><span class="line">    configuration.getObjectFactory().isCollection(<span class="keyword">this</span>.returnType) </span><br><span class="line">    || <span class="keyword">this</span>.returnType.isArray();</span><br><span class="line">  <span class="keyword">this</span>.returnsCursor = Cursor.class.equals(<span class="keyword">this</span>.returnType);</span><br><span class="line">  <span class="comment">// 若MethodSignature对 应 方法的返回值 是Map且指定了@MapKey注解，则 使用getMapKey()方法处 理</span></span><br><span class="line">  <span class="keyword">this</span>.mapKey = getMapKey(method);</span><br><span class="line">  <span class="keyword">this</span>.returnsMap = <span class="keyword">this</span>.mapKey != <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">this</span>.rowBoundsIndex = getUniqueParamIndex(method, RowBounds.class);</span><br><span class="line">  <span class="keyword">this</span>.resultHandlerIndex = getUniqueParamIndex(method, ResultHandler.class);</span><br><span class="line">  <span class="keyword">this</span>.paramNameResolver = <span class="keyword">new</span> ParamNameResolver(configuration, method);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>getUniqueParamIndex()</code>方法的主要功能是查找指定类型的参数在参数列表中的位置。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Integer <span class="title">getUniqueParamIndex</span><span class="params">(Method method, Class&lt;?&gt; paramType)</span> </span>&#123;</span><br><span class="line">  Integer index = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">final</span> Class&lt;?&gt;[] argTypes = method.getParameterTypes();</span><br><span class="line">  <span class="comment">// 遍历MethodSignature对应方法的参数列表</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; argTypes.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (paramType.isAssignableFrom(argTypes[i])) &#123;</span><br><span class="line">      <span class="keyword">if</span> (index == <span class="keyword">null</span>) &#123; <span class="comment">// 记录paramType类型参数在参数列表中的位置索引</span></span><br><span class="line">        index = i;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// RowBounds和ResultHandler类型的参数只能有一个，不能重复出现</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(<span class="string">&quot;...&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>convertArgsToSqlCommandParam()</code>辅助方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 负责将args[]数组(用户传入的实参列表)转换成SQL语句对应的参数列表，它是通过上面介绍的</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">convertArgsToSqlCommandParam</span><span class="params">(Object[] args)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> paramNameResolver.getNamedParams(args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="MapperMethod-execute"><a href="#MapperMethod-execute" class="headerlink" title="MapperMethod.execute()"></a>MapperMethod.execute()</h3><p><code>MapperMethod</code>中 最核心的方法是<code>execute()</code>方法，它 会 根据<code>SQL</code>语 句的类 型调 用<code>SqlSession</code>对 应 的方法完成数 据 库 操作：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">execute</span><span class="params">(SqlSession sqlSession, Object[] args)</span> </span>&#123;</span><br><span class="line">  Object result;</span><br><span class="line">  <span class="keyword">switch</span> (command.getType()) &#123;<span class="comment">// 根据SQL语句的类型调用SqlSession对应的方法</span></span><br><span class="line">    <span class="keyword">case</span> INSERT: &#123;</span><br><span class="line">      <span class="comment">// 使用ParamNameResolver处理args[]数组(用户传入的实参列表)，将用户传入的实参与</span></span><br><span class="line">      <span class="comment">// 指定参数名称关联起来</span></span><br><span class="line">      Object param = method.convertArgsToSqlCommandParam(args);</span><br><span class="line"><span class="comment">//  用SqlSession.insert()方法，rowCountResult()方法会根据method字段中记录的方法的</span></span><br><span class="line">      result = rowCountResult(sqlSession.insert(command.getName(), param));</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> UPDATE: &#123;</span><br><span class="line">      Object param = method.convertArgsToSqlCommandParam(args);</span><br><span class="line">      result = rowCountResult(sqlSession.update(command.getName(), param));</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> DELETE: &#123;</span><br><span class="line">      Object param = method.convertArgsToSqlCommandParam(args);</span><br><span class="line">      result = rowCountResult(sqlSession.delete(command.getName(), param));</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> SELECT:</span><br><span class="line">      <span class="comment">// 处理返回值为Void且ResultSet通过ResultHandler处理的方法</span></span><br><span class="line">      <span class="keyword">if</span> (method.returnsVoid() &amp;&amp; method.hasResultHandler()) &#123;</span><br><span class="line">        executeWithResultHandler(sqlSession, args);</span><br><span class="line">        result = <span class="keyword">null</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.returnsMany()) &#123; <span class="comment">// 处理返回值为集合或数组的类型</span></span><br><span class="line">        result = executeForMany(sqlSession, args);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.returnsMap()) &#123;<span class="comment">// 处理返回值为Map的方法</span></span><br><span class="line">        result = executeForMap(sqlSession, args);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.returnsCursor()) &#123; <span class="comment">// ...</span></span><br><span class="line">        result = executeForCursor(sqlSession, args);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123; <span class="comment">// 处理返回值为单一对象的方法</span></span><br><span class="line">        Object param = method.convertArgsToSqlCommandParam(args);</span><br><span class="line">        result = sqlSession.selectOne(command.getName(), param);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> FLUSH:</span><br><span class="line">      result = sqlSession.flushStatements();</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(<span class="string">&quot;Unknown execution method for: &quot;</span> + command.getName());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (result == <span class="keyword">null</span> &amp;&amp; method.getReturnType().isPrimitive() &amp;&amp; !method.returnsVoid()) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(<span class="string">&quot;...&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 执 行 <code>INSERT</code>、<code>UPDATE</code>、<code>DELETE</code>类 型 的 <code>SQL</code>语 句时 ，其执 行结 果都需要经 过<code>MapperMethod.rowCountResult()</code>方 法 处 理 。 </p><p><code>SqlSession</code> 中 的 <code>insert()</code>等 方 法 返 回 的 是 <code>int</code> 值 ， <code>rowCountResult()</code>方法会 将 该 <code>int</code>值 转 换 成<code>Mapper</code>接口中对 应 方法的返回值 ，具体 实 现 如下:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">rowCountResult</span><span class="params">(<span class="keyword">int</span> rowCount)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> Object result;</span><br><span class="line">  <span class="keyword">if</span> (method.returnsVoid()) &#123;</span><br><span class="line">    result = <span class="keyword">null</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Integer.class.equals(method.getReturnType()) </span><br><span class="line">             || Integer.TYPE.equals(method.getReturnType())) &#123;</span><br><span class="line">    result = rowCount;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Long.class.equals(method.getReturnType()) </span><br><span class="line">             || Long.TYPE.equals(method.getReturnType())) &#123;</span><br><span class="line">    result = (<span class="keyword">long</span>)rowCount;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Boolean.class.equals(method.getReturnType()) </span><br><span class="line">             || Boolean.TYPE.equals(method.getReturnType())) &#123;</span><br><span class="line">    result = rowCount &gt; <span class="number">0</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(<span class="string">&quot;...&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如 果 <code>Mapper</code>接口中定义 的方法准备 使用<code>ResultHandler</code>处 理查 询 结 果集，则 通过 <code>MapperMethod.executeWithResultHandler()</code>方法处 理，具体 实 现 如下:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">executeWithResultHandler</span><span class="params">(SqlSession sqlSession, Object[] args)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 获 取SQL语 句对 应 的MappedStatement对象</span></span><br><span class="line">  MappedStatement ms = sqlSession.getConfiguration().getMappedStatement(command.getName());</span><br><span class="line">  <span class="keyword">if</span> (!StatementType.CALLABLE.equals(ms.getStatementType())</span><br><span class="line">      &amp;&amp; <span class="keyword">void</span>.class.equals(ms.getResultMaps().get(<span class="number">0</span>).getType())) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(<span class="string">&quot;...&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  Object param = method.convertArgsToSqlCommandParam(args);</span><br><span class="line">  <span class="keyword">if</span> (method.hasRowBounds()) &#123;</span><br><span class="line">    RowBounds rowBounds = method.extractRowBounds(args);</span><br><span class="line">    sqlSession.select(command.getName(), param, rowBounds, method.extractResultHandler(args));</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 调用SqlSession.select()方法，执行查询 ，并由指定的ResultHandler处理结果对象</span></span><br><span class="line">    sqlSession.select(command.getName(), param, method.extractResultHandler(args));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如 果 <code>Mapper</code>接口中对 应 方法的返回值 为 数 组 或是<code>Collection</code>接口实 现 类 ，则 通过 <code>MapperMethod.executeForMany()</code>方 法 处 理 ，具 体 实 现 如 下 :</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;E&gt; <span class="function">Object <span class="title">executeForMany</span><span class="params">(SqlSession sqlSession, Object[] args)</span> </span>&#123;</span><br><span class="line">  List&lt;E&gt; result;</span><br><span class="line">  Object param = method.convertArgsToSqlCommandParam(args);</span><br><span class="line">  <span class="keyword">if</span> (method.hasRowBounds()) &#123;</span><br><span class="line">    RowBounds rowBounds = method.extractRowBounds(args);</span><br><span class="line">    <span class="comment">// 调用SqlSession.selectList()方法完成查询</span></span><br><span class="line">    result = sqlSession.&lt;E&gt;selectList(command.getName(), param, rowBounds);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    result = sqlSession.&lt;E&gt;selectList(command.getName(), param);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// issue #510 Collections &amp; arrays support</span></span><br><span class="line">  <span class="keyword">if</span> (!method.getReturnType().isAssignableFrom(result.getClass())) &#123;</span><br><span class="line">    <span class="keyword">if</span> (method.getReturnType().isArray()) &#123;</span><br><span class="line">      <span class="keyword">return</span> convertToArray(result);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> convertToDeclaredCollection(sqlSession.getConfiguration(), result);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>convertToDeclaredCollection()</code>方 法 和 <code>convertToArray()</code>方 法 的 功 能 类 似 ，主 要 负 责 将 结 果 对 象转 换 成<code>Collection</code>集合对 象和数 组 对 象，具体 实 现 如下:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;E&gt; <span class="function">Object <span class="title">convertToDeclaredCollection</span><span class="params">(Configuration config, List&lt;E&gt; list)</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 通过反射创建集合对象</span></span><br><span class="line">  Object collection = config.getObjectFactory().create(method.getReturnType());</span><br><span class="line">  <span class="comment">// 创建MetaObject对象</span></span><br><span class="line">  MetaObject metaObject = config.newMetaObject(collection);</span><br><span class="line">  metaObject.addAll(list);</span><br><span class="line">  <span class="keyword">return</span> collection;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="keyword">private</span> &lt;E&gt; <span class="function">Object <span class="title">convertToArray</span><span class="params">(List&lt;E&gt; list)</span> </span>&#123;</span><br><span class="line">  Class&lt;?&gt; arrayComponentType = method.getReturnType().getComponentType();</span><br><span class="line">  Object array = Array.newInstance(arrayComponentType, list.size());</span><br><span class="line">  <span class="keyword">if</span> (arrayComponentType.isPrimitive()) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">      Array.set(array, i, list.get(i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> list.toArray((E[])array);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果<code>Mapper</code>接口中对 应 方法的返回值 为 <code>Map</code>类 型,则 通过 <code>MapperMethod.executeForMap()</code> 方法处理，具体实现如下:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;K, V&gt; <span class="function">Map&lt;K, V&gt; <span class="title">executeForMap</span><span class="params">(SqlSession sqlSession, Object[] args)</span> </span>&#123;</span><br><span class="line">  Map&lt;K, V&gt; result;</span><br><span class="line">  Object param = method.convertArgsToSqlCommandParam(args);</span><br><span class="line">  <span class="keyword">if</span> (method.hasRowBounds()) &#123;</span><br><span class="line">    RowBounds rowBounds = method.extractRowBounds(args);</span><br><span class="line">    result = sqlSession.&lt;K, V&gt;selectMap(</span><br><span class="line">      command.getName(), param, method.getMapKey(), rowBounds);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    result = sqlSession.&lt;K, V&gt;selectMap(command.getName(), param, method.getMapKey());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>executeForCursor()</code>方法与 <code>executeForMap()</code>方法类似，唯一区别就是调 <code>selectCursor()</code>方法。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><p><strong>《MyBatis技术内幕》</strong></p></li><li><p>部分图片来源——<strong>《MyBatis技术内幕》</strong></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 书籍 </category>
          
          <category> 《MyBatis技术内幕》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MyBatis </tag>
            
            <tag> 《MyBatis技术内幕》 </tag>
            
            <tag> 基础支持层 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基础支持层——Transaction</title>
      <link href="/blog/2019/10/29/e275ec7f.html"/>
      <url>/blog/2019/10/29/e275ec7f.html</url>
      
        <content type="html"><![CDATA[<p>MyBatis基础支持层位于 Mybatis 整体架构的最底层，支撑着 Mybatis 的核心处理层，是整个框架的基石。基础支持层中封装了多个较为通用的、独立的模块，不仅仅为 Mybatis 提供基础支撑，也可以在合适的场景中直接复用。</p><p><img src="https://gitee.com/cayzlh/img-repo/raw/master/2020/06/09/2_c5SKkm_zgJEGC.png" alt="整体架构"></p><blockquote><p>这篇文章介绍MyBatis的Transaction模块</p></blockquote><p>在实 践 开 发 中，控制数 据库 事务 是一件非常重要的工作，<code>MyBatis</code>使 用 <code>Transaction</code>接口对数据库事务进 行了抽象，<code>Transaction</code>接口的定义 如下:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Transaction</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 获取对应的数据库连接</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function">Connection <span class="title">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 提交事务</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">commit</span><span class="params">()</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 回滚事务</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">rollback</span><span class="params">()</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 关闭数据库连接</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 获取事务超时时间</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function">Integer <span class="title">getTimeout</span><span class="params">()</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Transaction</code> 接 口 有 <code>JdbcTransaction</code>、 <code>ManagedTransaction</code> 两 个 实 现 ， 其 对 象 分 别 由</p><p><code>JdbcTransactionFactory</code>和 <code>ManagedTransactionFactory</code>负 责 创 建。<strong>这 里也使用 工厂 方法模式。</strong></p><p><img src="https://gitee.com/cayzlh/img-repo/raw/master/2020/06/09/image-20200609173458476_DrG0nO.png" alt="image-20200609173458476"></p><h3 id="JdbcTransaction"><a href="#JdbcTransaction" class="headerlink" title="JdbcTransaction"></a>JdbcTransaction</h3><p><code>JdbcTransaction</code>依赖于 <code>JDBC Connection</code>控制事务的提交和回 滚 。<code>JdbcTransaction</code>中 字 段 的 含义 如下:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 事务对应的数据库连接</span></span><br><span class="line"><span class="keyword">protected</span> Connection connection;</span><br><span class="line"><span class="comment">// 数据库连接所属的DataSource</span></span><br><span class="line"><span class="keyword">protected</span> DataSource dataSource;</span><br><span class="line"><span class="comment">// 事务隔离级别</span></span><br><span class="line"><span class="keyword">protected</span> TransactionIsolationLevel level;</span><br><span class="line"><span class="comment">// 是否自动提交</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">boolean</span> autoCommmit;</span><br></pre></td></tr></table></figure><p>在 <code>JdbcTransaction</code>的构 造函数 中会 初始化除<code>connection</code>字段之外的其他三个 字段，而 <code>connection</code>字段会 延迟 初始化，它 会 在调 用<code>getConnection()</code>方法时 通过 <code>dataSource.getConnection()</code> 方法初始化，并 且同时 设 置<code>autoCommit</code>和事务 隔离 级 别 。</p><blockquote><p>JdbcTransaction的 commit()方法和 rollback()方法都会 调 用Connection对 应 方法实 现 的。</p></blockquote><h3 id="ManagedTransaction"><a href="#ManagedTransaction" class="headerlink" title="ManagedTransaction"></a>ManagedTransaction</h3><p><code>ManagedTransaction</code>的实 现 更加简 单 ，它 同样 依赖 其中的<code>dataSource</code>字段获 取连 接，但其 <code>commit()</code>、<code>rollback()</code>方法都是空实 现 ，事务 的提交和回滚 都是依靠 容器管理的。</p><blockquote><p><code>ManagedTransaction</code>中通过 <code>closeConnection</code>字段的值 控制数 据库 连 接的关 闭 行为 。</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.closeConnection &amp;&amp; <span class="keyword">this</span>.connection != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">      log.debug(<span class="string">&quot;Closing JDBC Connection [&quot;</span> + <span class="keyword">this</span>.connection + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.connection.close();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="TransactionFactory"><a href="#TransactionFactory" class="headerlink" title="TransactionFactory"></a>TransactionFactory</h3><p><code>TransactionFactory</code>接 口 定 义 了 配 置 新 建 <code>TransactionFactory</code>对 象 的 方 法 ， 以 及 创 建 <code>Transaction</code>对 象的方法，代码 如下:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TransactionFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 配置TransactionFactory对 象，一般紧 跟 在创 建完成之后，完成对 TransactionFactory的自定义 配置</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">setProperties</span><span class="params">(Properties props)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 在指定的连 接上创 建Transaction对 象</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function">Transaction <span class="title">newTransaction</span><span class="params">(Connection conn)</span></span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 从 指定数 据源中获 取数 据库 连 接，并 在此连 接之上创 建Transaction对 象</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function">Transaction <span class="title">newTransaction</span><span class="params">(DataSource dataSource, </span></span></span><br><span class="line"><span class="function"><span class="params">                             TransactionIsolationLevel level, <span class="keyword">boolean</span> autoCommit)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>JdbcTransactionFactory</code> 和 <code>ManagedTransactionFactory</code> 负 责 创 建 <code>JdbcTransaction</code> 和 <code>ManagedTransaction</code>，这 一部分的代码 比较 简 单 。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><p><strong>《MyBatis技术内幕》</strong></p></li><li><p>部分图片来源——<strong>《MyBatis技术内幕》</strong></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 书籍 </category>
          
          <category> 《MyBatis技术内幕》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MyBatis </tag>
            
            <tag> 《MyBatis技术内幕》 </tag>
            
            <tag> 基础支持层 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基础支持层——DataSource</title>
      <link href="/blog/2019/10/28/899df03d.html"/>
      <url>/blog/2019/10/28/899df03d.html</url>
      
        <content type="html"><![CDATA[<p>MyBatis基础支持层位于 Mybatis 整体架构的最底层，支撑着 Mybatis 的核心处理层，是整个框架的基石。基础支持层中封装了多个较为通用的、独立的模块，不仅仅为 Mybatis 提供基础支撑，也可以在合适的场景中直接复用。</p><p><img src="https://gitee.com/cayzlh/img-repo/raw/master/2020/06/09/2_c5SKkm_zgJEGC.png" alt="整体架构"></p><blockquote><p>这篇文章介绍MyBatis的DataSource模块</p></blockquote><p>在数 据持久层 中，数 据源是一个 非常重要的组 件，其性能直接关 系到整个 数 据持久层 的性能。</p><p>在实 践 中比较 常见 的第三方数 据源组 件有<code>ApacheCommonDBCP</code>、<code>C3P0</code>、<code>Proxool</code>等，MyBatis不仅 可以集成第三方数 据源组 件，还 提供了自己的数 据源实 现 。</p><p>常见 的数 据源组 件都实 现 了 <code>javax.sql.DataSource</code>接口，MyBatis自身实 现 的数 据源实 现 也 不 例 外 。</p><p>MyBatis 提 供 了 两 个 <code>javax.sql.DataSource</code> 接 口 实 现 ， 分 别 是 <code>PooledDataSource</code> 和 <code>UnpooledDataSource</code>。 </p><p>Mybatis使 用 不 同 的 DataSourceFactory接 口 实 现 创 建 不 同 类 型 的 DataSource,如图所示，这 是工厂 方法模式的一个 典型应 用。</p><p><img src="https://gitee.com/cayzlh/img-repo/raw/master/2020/06/08/image-20200608220639013_wB5yIb.png" alt="image-20200608220639013"></p><h3 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h3><blockquote><p>在工厂 方法模式中，定义 了一个 用于创 建对 象的工厂 接口，并 根据工厂 接口的具体 实 现 类 决定具体实例化哪一个具体产品类。首先来看工厂方法模式的UML图，从整体上了解该模式 的结 构 。</p></blockquote><p><img src="https://gitee.com/cayzlh/img-repo/raw/master/2020/06/08/image-20200608221034019_4Qx2xe.png" alt="image-20200608221034019"></p><p>工厂方法有四个角色构成：</p><ul><li><p>工厂接口（Factory）</p><p>工厂 接口是工厂 方法模式的核心接口，调 用者会 直接与 工厂 接 口交互用于获取具体的产品实现类</p></li><li><p>具体工厂类（ConcreteFactory）</p><p>具体 工厂 类 是工厂 接口的实 现 类 ，用于实 例化产 品 对象，不同的具体工厂类会根据需求实例化不同的产品实现类。</p></li><li><p>产品接口（Product）</p><p> 品接口用于定义 产 品类 的功能，具体 工厂 类 产 生的所有产 品对象都必须实现该接口。调用者一般会面向产品接口进行编程，所以产品接口会与调用者直接交互，也是调 用者最为 关 心的接口。</p></li><li><p>具体 产 品类 （ConcreteProduct）</p><p> 现 产 品接口的实 现 类 ，具体 产 品类 中定义 了具体的业务逻辑</p></li></ul><p>如果需要产 生新的产 品，例如对 于MyBatis的数 据源模块 来 说 ，就是添加新的第三方数 据 源组 件，只需要添加对 应 的工厂 实 现 类 ，新数 据源就可以被MyBatis使用，而不必修改己有的 代码 。显 然，工厂 方法模式符合“开 放-封闭 ”原则 。除此之外，工厂 方法会 向调 用者隐 藏具体 产 品类 的实 例化细 节 ，调 用者只需要了解工厂 接口和产 品接口，面向这 两 个 接口编 程即 可。</p><blockquote><p>工厂 方法模式也是存在缺点的。在增加新产 品实 现 类 时 ，还 要提供一个 与 之对 应 的工厂 实 现 类 ，所以实 际 新增的类 是成对 出现 的，这 增加了系统 的复 杂 度。另 外，工厂 方法模式引入了 工厂 接口和产 品接口这 一层 抽象，调 用者面向该 抽象层 编 程,增加了程序的抽象性和理解难 度。</p></blockquote><h3 id="DataSourceFactory"><a href="#DataSourceFactory" class="headerlink" title="DataSourceFactory"></a>DataSourceFactory</h3><p>在数 据源模块 中，<code>DataSourceFactory</code>接口扮演工厂 接口的角色。</p><p><code>UnpooledDataSourceFactory</code> 和 <code>PooledDataSourceFactory</code>则 扮演着具体 工厂 类 的角色。</p><p>我们 从 <code>DataSourceFactory</code>接口开 始分 析，其定义 如下:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DataSourceFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置DataSource的相关属性，一般紧跟在初始化完成之后</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">setProperties</span><span class="params">(Properties props)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取DataSource对象</span></span><br><span class="line">  <span class="function">DataSource <span class="title">getDataSource</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>UnpooledDataSourceFactory</code>的 构 造 函 数 中 会 直 接 创 建 <code>UnpooledDataSource</code>对 象 ，并 初始 化 <code>UnpooledDataSourceFactory.dataSource</code> 字 段 。<code>UnpooledDataSourceFactory.setProperties()</code>方法会 完成对 <code>UnpooledDataSource</code>对 象的配置，代码 如下:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setProperties</span><span class="params">(Properties properties)</span> </span>&#123;</span><br><span class="line">  Properties driverProperties = <span class="keyword">new</span> Properties();</span><br><span class="line">  <span class="comment">// 创建DataSource对应的MetaObject</span></span><br><span class="line">  MetaObject metaDataSource = SystemMetaObject.forObject(dataSource);</span><br><span class="line">  <span class="comment">// 遍历properties集合，该集合中配置了数据源需要的信息</span></span><br><span class="line">  <span class="keyword">for</span> (Object key : properties.keySet()) &#123;</span><br><span class="line">    String propertyName = (String) key;</span><br><span class="line">    <span class="comment">// 以&quot;driver.&quot;开头的配置项是对DateSource的配置，记录到driverProperties中保存</span></span><br><span class="line">    <span class="keyword">if</span> (propertyName.startsWith(DRIVER_PROPERTY_PREFIX)) &#123;</span><br><span class="line">      String value = properties.getProperty(propertyName);</span><br><span class="line">      driverProperties.setProperty(</span><br><span class="line">        propertyName.substring(DRIVER_PROPERTY_PREFIX_LENGTH), value);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (metaDataSource.hasSetter(propertyName)) &#123;</span><br><span class="line">      String value = (String) properties.get(propertyName);</span><br><span class="line">      Object convertedValue = convertValue(metaDataSource, propertyName, value);</span><br><span class="line">      metaDataSource.setValue(propertyName, convertedValue);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> DataSourceException(<span class="string">&quot;...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (driverProperties.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    metaDataSource.setValue(<span class="string">&quot;driverProperties&quot;</span>, driverProperties);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>UnpooledDataSourceFactory.getDataSource()</code>方法实 现 比较 简 单 ，它 直接返回 <code>dataSource</code>字段 记 录 的 <code>UnpooledDataSource</code> 对 象 。</p><p><code>PooledDataSourceFactory</code> 继 承 了 <code>UnpooledDataSourceFactory</code>, 但 并 没 有 覆 盖 <code>setProperties()</code> 方法和<code>getDataSource()</code>方法。两 者唯一的区 别 是<code>PooledDataSourceFactory</code>的构 造函数 会 将 其 <code>dataSource</code> 字 段 初 始 化 为 <code>PooledDataSource</code> 对 象 。</p><p><code>JndiDataSourceFactory</code>是依赖 JNDI服务 从 容器中获 取用户 配置的<code>DataSource</code>，其逻 辑 并 不 复 杂 。</p><h3 id="UnpooledDataSource"><a href="#UnpooledDataSource" class="headerlink" title="UnpooledDataSource"></a>UnpooledDataSource</h3><p><code>javax.sql.DataSource</code>接口在数 据源模块 中扮演了产 品接口的角色，<code>MyBatis</code>提供了两 个 <code>DataSource</code>接 口 的 实 现 类 ，分 别 是 <code>UnpooledDataSource</code>和 <code>PooledDataSource</code>，它 们 扮 演 着 具 体 产 品类 的角色。</p><p><code>UnpooledDataSource</code> 实 现 了 <code>javax.sql.DataSource</code> 接 口 中 定 义 的 <code>getConnection()</code>方 法 及 其 重 载方法，用于获 取数 据库 连 接。</p><p>每次通过 <code>UnpooledDataSource.getConnection()</code>方法获 取数 据库 连 接 时 都会 创 建一个 新连 接。</p><p><code>UnpooledDataSource</code>中的字段如下，每个 字段都有对 应 的getter/setter 方法:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnpooledDataSource</span> <span class="keyword">implements</span> <span class="title">DataSource</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> ClassLoader driverClassLoader;</span><br><span class="line">  <span class="keyword">private</span> Properties driverProperties;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, Driver&gt; registeredDrivers = <span class="keyword">new</span> ConcurrentHashMap&lt;String, Driver&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> String driver;</span><br><span class="line">  <span class="keyword">private</span> String url;</span><br><span class="line">  <span class="keyword">private</span> String username;</span><br><span class="line">  <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Boolean autoCommit;</span><br><span class="line">  <span class="keyword">private</span> Integer defaultTransactionIsolationLevel;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> &#123;</span><br><span class="line">    Enumeration&lt;Driver&gt; drivers = DriverManager.getDrivers();</span><br><span class="line">    <span class="keyword">while</span> (drivers.hasMoreElements()) &#123;</span><br><span class="line">      Driver driver = drivers.nextElement();</span><br><span class="line">      registeredDrivers.put(driver.getClass().getName(), driver);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Pooled-DataSource"><a href="#Pooled-DataSource" class="headerlink" title="Pooled DataSource"></a>Pooled DataSource</h3><p>了解JDBC编 程的读 者知道，数 据库 连 接的创 建过 程是非常耗时 的，数 据库 能够 建立的连 接数 也非常有限，所以在绝 大多数 系统 中，数 据库 连 接是非常珍贵 的资 源，使用数 据库 连 接池就显得尤为必要。</p><p>使用数据库连接池会带来很多好处，例如，<strong>可以实现数据库连接的重用、提高响 应 速度、防止数 据库 连 接过 多造成数 据库 假死、避免数 据库 连 接泄露等。</strong></p><blockquote><p>数据库连接池在初始化时，一般会创建一定数量的数据库连接并添加到连接池中备用。</p><p>当 程序需要使用数 据库 连 接时 ，从 池中请 求连 接;当 程序不再使用该 连 接时 ，会 将 其返回到池中 缓 存，等待下次使用，而不是直接关 闭 。</p><p>当 然，数 据库 连 接池会 控制连 接总 数 的上限以及空闲 连 接数 的上限，如果连 接池创 建的总 连 接数 己达 到上限，且都已被占用，则 后续 请 求连 接的线 程会 进 入阻塞队 列等待，直到有线 程释 放出可用的连 接。</p><p>如果连 接池中空闲 连 接数 较 多，达 到 其上限，则 后续 返回的空闲 连 接不会 放入池中，而是直接关 闭 ，这 样 可以减 少系统 维 护 多余数 据库连接的开销。</p></blockquote><ul><li>如果将总连接数的上限设置得过大，可能因连接数过多而导致数据库僵死，系统整体性能 下降;</li><li>如果总连接数上限过小，则无法完全发挥数据库的性能，浪费数据库资源。如果将空闲 连接的上限设置得过大，则会浪费系统资源来维护这些空闲连接;</li><li>如果空闲连接上限过小，当 出现 瞬间 的峰值 请 求时 ，系统 的快速响 应 能力就比较 弱。</li></ul><p><em>所以在设 置数 据库 连 接池的这 两 个 值 时，需要进行性能测试、权衡以及一些经验。</em></p><p><code>PooledDataSource</code>实 现 了简 易数 据库 连 接池的功能，它 依赖 的组 件如图 所示，其中需 要注意的是，<code>PooledDataSource</code>创 建新数 据库 连 接的功能是依赖 其中封装 的<code>UnpooledDataSource</code> 对象实现的。</p><p><img src="https://gitee.com/cayzlh/img-repo/raw/master/2020/06/09/image-20200609115725188_8mgoXg.png" alt="image-20200609115725188"></p><h4 id="PooledConnection"><a href="#PooledConnection" class="headerlink" title="PooledConnection"></a>PooledConnection</h4><p><code>PooledDataSource</code>并 不会 直接管理<code>java.sql.Connection</code>对 象，而是管理 <code>PooledConnection</code>对 象。</p><p>在 <code>PooledConnection</code>中封装 了真 正的数 据库 连 接对 象(<code>java.sql.Connection</code>) 以及其代理对 象，这 里的代理对 象是通过 JDK动 态 代理产 生的。<code>PooledConnection</code>继 承了 <code>InvocationHandler</code> 接口。</p><p>核心字段：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 记录当前PooledConnection对 象所在的 PooledDataSource对 象。</span></span><br><span class="line"><span class="comment">// 该 PooledConnection是从该 PooledDataSource中获 取的;</span></span><br><span class="line"><span class="comment">// 当 调 用close() 方法时 会 将 PooledConnection放回该PooledDataSource 中</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> PooledDataSource dataSource;</span><br><span class="line"><span class="comment">// 真正的数据库连接</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Connection realConnection;</span><br><span class="line"><span class="comment">// 数据库连接代理对象</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Connection proxyConnection;</span><br><span class="line"><span class="comment">// 从连接池中取出该连接的时间戳</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> checkoutTimestamp;</span><br><span class="line"><span class="comment">// 创建该连接的时间戳</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> createdTimestamp;</span><br><span class="line"><span class="comment">// 最后一次使用的时间戳</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> lastUsedTimestamp;</span><br><span class="line"><span class="comment">// 由数据库URL、用户名和密码计算出来的hash值，可用于标识该连接所在的连接池</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> connectionTypeCode;</span><br><span class="line"><span class="comment">// 检测当前PooledConnection是否有效，主要是为了防止程序通过close()方法将连接还给连接池之后</span></span><br><span class="line"><span class="comment">// 依然通过该连接操作数据库</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> valid;</span><br></pre></td></tr></table></figure><p><code>PooledConnection.invoke()</code>方法的实 现 ，该 方法是<code>proxyConnection</code>这 个 连 接代理对 象的真 正代理 逻 辑 ，它 会 对 <code>close()</code>方法的调 用进 行代理，并 且在调 用真 正数 据库 连 接的方法之前进 行检 测 ， 代码 如下:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> </span></span><br><span class="line"><span class="function">  <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">  String methodName = method.getName();</span><br><span class="line">  <span class="comment">// 如果调用close()方法，则将其重新放入连接池，而不是真正关闭数据库连接</span></span><br><span class="line">  <span class="keyword">if</span> (CLOSE.hashCode() == methodName.hashCode() &amp;&amp; CLOSE.equals(methodName)) &#123;</span><br><span class="line">    dataSource.pushConnection(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (!Object.class.equals(method.getDeclaringClass())) &#123;</span><br><span class="line">        <span class="comment">// issue #579 toString() should never fail</span></span><br><span class="line">        <span class="comment">// throw an SQLException instead of a Runtime</span></span><br><span class="line">        <span class="comment">// 通过valid字段检测连接是否有效</span></span><br><span class="line">        checkConnection();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 调用真正数据库连接对象对应的方法</span></span><br><span class="line">      <span class="keyword">return</span> method.invoke(realConnection, args);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">      <span class="keyword">throw</span> ExceptionUtil.unwrapThrowable(t);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="PoolState"><a href="#PoolState" class="headerlink" title="PoolState"></a>PoolState</h4><p><code>PoolState</code>是 用 于 管 理 <code>PooledConnection</code>对 象 状 态 的 组 件 ，它 通 过 两 个 <code>ArrayList &lt;PooledConnection&gt;</code>集合分别 管理空闲 状 态 的连 接和活跃 状 态 的连 接，定义 如下:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 空闲的PooledConnection对象集合</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> List&lt;PooledConnection&gt; idleConnections = </span><br><span class="line">  <span class="keyword">new</span> ArrayList&lt;PooledConnection&gt;();</span><br><span class="line"><span class="comment">// 活跃的PooledConnection集合</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> List&lt;PooledConnection&gt; activeConnections = </span><br><span class="line">  <span class="keyword">new</span> ArrayList&lt;PooledConnection&gt;();</span><br><span class="line"><span class="comment">// 请求数据库连接的次数</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">long</span> requestCount = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 获取连接的累积时间</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">long</span> accumulatedRequestTime = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// checkoutTime表示应用从连接池中取出连接，到归还的这段时长</span></span><br><span class="line"><span class="comment">// accumulatedCheckoutTime记录了所有连接累积的checkoutTime时长</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">long</span> accumulatedCheckoutTime = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 当连接长时间未归还给连接池的时候，会被认该连接超时</span></span><br><span class="line"><span class="comment">// claimedOverdueConnectionCount记录了超时连接个数</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">long</span> claimedOverdueConnectionCount = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 累积超时时间</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">long</span> accumulatedCheckoutTimeOfOverdueConnections = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 累积等待时间</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">long</span> accumulatedWaitTime = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 累积等待次数</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">long</span> hadToWaitCount = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 无效的连接数</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">long</span> badConnectionCount = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><h4 id="PooledDataSource"><a href="#PooledDataSource" class="headerlink" title="PooledDataSource"></a>PooledDataSource</h4><p><code>PooledDataSource</code>中 管 理 的 真 正 的 数 据 库 连 接 对 象 是 由 <code>PooledDataSource</code>中封装 的<code>UnpooledDataSource</code>对 象 创 建 的 ，并 由 <code>PoolState</code>管 理 所 有 连 接 的 状 态 。</p><p><code>PooledDataSource</code>中核心字段的含义 和功能如下:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过 PoolState管理连接池的状态并记录统计信息</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> PoolState state = <span class="keyword">new</span> PoolState(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 记录UnpooledDataSource对象，用于生成真实的数据库连接对象，构造函数中会初始化该字段</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> UnpooledDataSource dataSource;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最大活跃连接数</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">int</span> poolMaximumActiveConnections = <span class="number">10</span>;</span><br><span class="line"><span class="comment">// 最大空闲连接数</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">int</span> poolMaximumIdleConnections = <span class="number">5</span>;</span><br><span class="line"><span class="comment">// 最大checkout时长</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">int</span> poolMaximumCheckoutTime = <span class="number">20000</span>;</span><br><span class="line"><span class="comment">// 最大等待时间</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">int</span> poolTimeToWait = <span class="number">20000</span>;</span><br><span class="line"><span class="comment">// 最大无效连接数量</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">int</span> poolMaximumLocalBadConnectionTolerance = <span class="number">3</span>;</span><br><span class="line"><span class="comment">// 在检测一个数据库连接是否可用的时候，会给数据库发送一个测试SQL语句</span></span><br><span class="line"><span class="keyword">protected</span> String poolPingQuery = <span class="string">&quot;NO PING QUERY SET&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">boolean</span> poolPingEnabled;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当连接超过 poolPingConnectionsNotUsedFor毫秒未使用时 ，会发送一次测试SQL语句，检测连接是否正常</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">int</span> poolPingConnectionsNotUsedFor;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据数据库的URL、用户名和密码生成的一个hash值，该哈希值用于标志着当前的连接池，在构造函数中初始化</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> expectedConnectionTypeCode;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>PooledDataSource.getConnection()</code>方 法 首 先 会 调 用 <code>PooledDataSource.popConnection()</code>方 法 获 取 <code>PooledConnection</code> 对 象，然后通过 <code>PooledConnection.getProxyConnection()</code>方法获 取数 据库 连 接的代理对 象。<code>popConnection()</code>方法是<code>PooledDataSource</code>的核心逻 辑 之一，其具体 逻 辑 如图。</p><p><img src="https://gitee.com/cayzlh/img-repo/raw/master/2020/06/09/image-20200609150810073_QLmTH2.png" alt="image-20200609150810073"></p><p><code>PooledDataSource.popConnection()</code>方法的具体实现：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> PooledConnection <span class="title">popConnection</span><span class="params">(String username, String password)</span> </span></span><br><span class="line"><span class="function">  <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  <span class="keyword">boolean</span> countedWait = <span class="keyword">false</span>;</span><br><span class="line">  PooledConnection conn = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">long</span> t = System.currentTimeMillis();</span><br><span class="line">  <span class="keyword">int</span> localBadConnectionCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (conn == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (state) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!state.idleConnections.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// Pool has available connection</span></span><br><span class="line">        conn = state.idleConnections.remove(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">          log.debug(<span class="string">&quot;...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Pool does not have available connection</span></span><br><span class="line">        <span class="keyword">if</span> (state.activeConnections.size() &lt; poolMaximumActiveConnections) &#123;</span><br><span class="line">          <span class="comment">// Can create new connection</span></span><br><span class="line">          conn = <span class="keyword">new</span> PooledConnection(dataSource.getConnection(), <span class="keyword">this</span>);</span><br><span class="line">          <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;...&quot;</span>);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// Cannot create new connection</span></span><br><span class="line">          PooledConnection oldestActiveConnection = state.activeConnections.get(<span class="number">0</span>);</span><br><span class="line">          <span class="keyword">long</span> longestCheckoutTime = oldestActiveConnection.getCheckoutTime();</span><br><span class="line">          <span class="keyword">if</span> (longestCheckoutTime &gt; poolMaximumCheckoutTime) &#123;</span><br><span class="line">            <span class="comment">// Can claim overdue connection</span></span><br><span class="line">            state.claimedOverdueConnectionCount++;</span><br><span class="line">            state.accumulatedCheckoutTimeOfOverdueConnections += longestCheckoutTime;</span><br><span class="line">            state.accumulatedCheckoutTime += longestCheckoutTime;</span><br><span class="line">            state.activeConnections.remove(oldestActiveConnection);</span><br><span class="line">            <span class="keyword">if</span> (!oldestActiveConnection.getRealConnection().getAutoCommit()) &#123;</span><br><span class="line">              <span class="keyword">try</span> &#123;</span><br><span class="line">                oldestActiveConnection.getRealConnection().rollback();</span><br><span class="line">              &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;Bad connection. Could not roll back&quot;</span>);</span><br><span class="line">              &#125;  </span><br><span class="line">            &#125;</span><br><span class="line">            conn = <span class="keyword">new</span> PooledConnection(oldestActiveConnection.getRealConnection(), <span class="keyword">this</span>);</span><br><span class="line">            conn.setCreatedTimestamp(oldestActiveConnection.getCreatedTimestamp());</span><br><span class="line">            conn.setLastUsedTimestamp(oldestActiveConnection.getLastUsedTimestamp());</span><br><span class="line">            oldestActiveConnection.invalidate();</span><br><span class="line">            <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">              log.debug(<span class="string">&quot;....&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Must wait</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="keyword">if</span> (!countedWait) &#123;</span><br><span class="line">                state.hadToWaitCount++;</span><br><span class="line">                countedWait = <span class="keyword">true</span>;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;...&quot;</span>);</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">long</span> wt = System.currentTimeMillis();</span><br><span class="line">              state.wait(poolTimeToWait);</span><br><span class="line">              state.accumulatedWaitTime += System.currentTimeMillis() - wt;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (conn != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// ping to server and check the connection is valid or not</span></span><br><span class="line">        <span class="keyword">if</span> (conn.isValid()) &#123;</span><br><span class="line">          <span class="keyword">if</span> (!conn.getRealConnection().getAutoCommit()) &#123;</span><br><span class="line">            conn.getRealConnection().rollback();</span><br><span class="line">          &#125;</span><br><span class="line">          conn.setConnectionTypeCode(assembleConnectionTypeCode(dataSource.getUrl(), username, password));</span><br><span class="line">          conn.setCheckoutTimestamp(System.currentTimeMillis());</span><br><span class="line">          conn.setLastUsedTimestamp(System.currentTimeMillis());</span><br><span class="line">          state.activeConnections.add(conn);</span><br><span class="line">          state.requestCount++;</span><br><span class="line">          state.accumulatedRequestTime += System.currentTimeMillis() - t;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;...&quot;</span>);</span><br><span class="line">          &#125;</span><br><span class="line">          state.badConnectionCount++;</span><br><span class="line">          localBadConnectionCount++;</span><br><span class="line">          conn = <span class="keyword">null</span>;</span><br><span class="line">          <span class="keyword">if</span> (localBadConnectionCount &gt; (poolMaximumIdleConnections + poolMaximumLocalBadConnectionTolerance)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">              log.debug(<span class="string">&quot;...&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SQLException(<span class="string">&quot;...&quot;</span>);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (conn == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">      log.debug(<span class="string">&quot;...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> SQLException(<span class="string">&quot;...&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> conn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通 过 前 面 对 <code>PooledConnection.invoke()</code>方法的分析我们 知道，当 调 用连 接的代理对 象的 <code>close()</code>方 法 时 ，并未关闭真正的数据连接 ，而是调用<code>PooledDataSource.pushConnection()</code>方法将 <code>PooledConnection</code>对 象归 还 给 连 接池，供之后重用。</p><p><code>PooledDataSource.pushConnection()</code>方法也是 <code>PooledDataSource</code>的核心逻 辑 之一，其逻 辑 如图 </p><p><img src="https://gitee.com/cayzlh/img-repo/raw/master/2020/06/09/image-20200609151224380_AWh8ao.png" alt="image-20200609151224380"></p><p><code>PooledDataSource.pushConnection()</code>代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">pushConnection</span><span class="params">(PooledConnection conn)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">synchronized</span> (state) &#123;</span><br><span class="line">    state.activeConnections.remove(conn);</span><br><span class="line">    <span class="keyword">if</span> (conn.isValid()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (state.idleConnections.size() &lt; poolMaximumIdleConnections </span><br><span class="line">          &amp;&amp; conn.getConnectionTypeCode() == expectedConnectionTypeCode) &#123;</span><br><span class="line">        state.accumulatedCheckoutTime += conn.getCheckoutTime();</span><br><span class="line">        <span class="keyword">if</span> (!conn.getRealConnection().getAutoCommit()) &#123;</span><br><span class="line">          <span class="comment">// 回滚未提交的事务</span></span><br><span class="line">          conn.getRealConnection().rollback();</span><br><span class="line">        &#125;</span><br><span class="line">        PooledConnection newConn = <span class="keyword">new</span> PooledConnection(conn.getRealConnection(), <span class="keyword">this</span>);</span><br><span class="line">        state.idleConnections.add(newConn);</span><br><span class="line">        newConn.setCreatedTimestamp(conn.getCreatedTimestamp());</span><br><span class="line">        newConn.setLastUsedTimestamp(conn.getLastUsedTimestamp());</span><br><span class="line">        conn.invalidate();</span><br><span class="line">        <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">          log.debug(<span class="string">&quot;...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        state.notifyAll();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123; <span class="comment">// 空闲连接数已达到上限或PooledConnection对象并不属于该连接池</span></span><br><span class="line">        state.accumulatedCheckoutTime += conn.getCheckoutTime();</span><br><span class="line">        <span class="keyword">if</span> (!conn.getRealConnection().getAutoCommit()) &#123;</span><br><span class="line">          conn.getRealConnection().rollback();</span><br><span class="line">        &#125;</span><br><span class="line">        conn.getRealConnection().close();</span><br><span class="line">        <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">          log.debug(<span class="string">&quot;...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        conn.invalidate();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;...&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 统计无效PooledConnection对象个数</span></span><br><span class="line">      state.badConnectionCount++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里需要注意的是，<code>PooledDataSource.pushConnection()</code>方法和<code>popConnection()</code>方法中都调 用了 <code>PooledConnection.isValid()</code>方 法 来 检 测 <code>PooledConnection</code>的 有 效 性 ， 该 方 法 除 了 检 测 <code>PooledConnection.valid</code> 字段的值 ，还 会 调 用 <code>PooledDataSource.pingConnection()</code>方法尝 试 让 数 据 库 执 行<code>podPingQuery</code>字段中记 录 的测 试 SQL语 句，从 而检 测 真 正的数 据库 连 接对 象是否依然 可以正常使用。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> valid &amp;&amp; realConnection != <span class="keyword">null</span> &amp;&amp; dataSource.pingConnection(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">pingConnection</span><span class="params">(PooledConnection conn)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">boolean</span> result = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    result = !conn.getRealConnection().isClosed();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">    <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">      log.debug(<span class="string">&quot;...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    result = <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (result) &#123;</span><br><span class="line">    <span class="keyword">if</span> (poolPingEnabled) &#123;</span><br><span class="line">      <span class="comment">// 检测poolPingEnabled设置，是否运行执行测试SQL语 句</span></span><br><span class="line">      <span class="comment">// 长时间(超过 poolPingConnectionsNotUsedFor指定的时长)未使用的连接，才需要ping</span></span><br><span class="line">      <span class="comment">// 操作来检测数据库连接是否正常</span></span><br><span class="line">      <span class="keyword">if</span> (poolPingConnectionsNotUsedFor &gt;= <span class="number">0</span> </span><br><span class="line">          &amp;&amp; conn.getTimeElapsedSinceLastUse() &gt; poolPingConnectionsNotUsedFor) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;...&quot;</span>);</span><br><span class="line">          &#125;</span><br><span class="line">          Connection realConn = conn.getRealConnection();</span><br><span class="line">          Statement statement = realConn.createStatement();</span><br><span class="line">          ResultSet rs = statement.executeQuery(poolPingQuery);</span><br><span class="line">          rs.close();</span><br><span class="line">          statement.close();</span><br><span class="line">          <span class="keyword">if</span> (!realConn.getAutoCommit()) &#123;</span><br><span class="line">            realConn.rollback();</span><br><span class="line">          &#125;</span><br><span class="line">          result = <span class="keyword">true</span>;</span><br><span class="line">          <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;...&quot;</span>);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">          log.warn(<span class="string">&quot;...&quot;</span>);</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            conn.getRealConnection().close();</span><br><span class="line">          &#125; <span class="keyword">catch</span> (Exception e2) &#123;</span><br><span class="line">            <span class="comment">//ignore</span></span><br><span class="line">          &#125;</span><br><span class="line">          result = <span class="keyword">false</span>;</span><br><span class="line">          <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;...&quot;</span>);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后需要注意的是<code>PooledDataSource.forceCloseAll()</code>方法，当 修改<code>PooledDataSource</code>的字段 时 ，例如数 <strong>据库 URL</strong>、<strong>用户名</strong>、<strong>密码</strong> 、<strong>autoCommit配置</strong>等，都会 调 用<code>forceCloseAll()</code>方法将 所 有数 据库 连 接关 闭 ，同时 也会 将 所有相应 的<code>PooledConnectiori</code>对 象都设 置为 无效，清 空 <code>activeConnections</code> 集 合 和 <code>idleConnections</code> 集 合 。</p><p>应用系统之后通过<code>PooledDataSource.getConnection()</code>获取连接时，会按照新的配置重新配置新的数据库连接以及相应的<code>PooledConnection</code>对象。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forceCloseAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">synchronized</span> (state) &#123;</span><br><span class="line">    expectedConnectionTypeCode = assembleConnectionTypeCode(</span><br><span class="line">      dataSource.getUrl(), dataSource.getUsername(), dataSource.getPassword());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = state.activeConnections.size(); i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        PooledConnection conn = state.activeConnections.remove(i - <span class="number">1</span>);</span><br><span class="line">        conn.invalidate();</span><br><span class="line"></span><br><span class="line">        Connection realConn = conn.getRealConnection();</span><br><span class="line">        <span class="keyword">if</span> (!realConn.getAutoCommit()) &#123;</span><br><span class="line">          realConn.rollback();</span><br><span class="line">        &#125;</span><br><span class="line">        realConn.close();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="comment">// ignore</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = state.idleConnections.size(); i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        PooledConnection conn = state.idleConnections.remove(i - <span class="number">1</span>);</span><br><span class="line">        conn.invalidate();</span><br><span class="line"></span><br><span class="line">        Connection realConn = conn.getRealConnection();</span><br><span class="line">        <span class="keyword">if</span> (!realConn.getAutoCommit()) &#123;</span><br><span class="line">          realConn.rollback();</span><br><span class="line">        &#125;</span><br><span class="line">        realConn.close();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="comment">// ignore</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">    log.debug(<span class="string">&quot;PooledDataSource forcefully closed/removed all connections.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><p><strong>《MyBatis技术内幕》</strong></p></li><li><p>部分图片来源——<strong>《MyBatis技术内幕》</strong></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 书籍 </category>
          
          <category> 《MyBatis技术内幕》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MyBatis </tag>
            
            <tag> 《MyBatis技术内幕》 </tag>
            
            <tag> 基础支持层 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基础支持层——资源加载</title>
      <link href="/blog/2019/10/27/899df03d.html"/>
      <url>/blog/2019/10/27/899df03d.html</url>
      
        <content type="html"><![CDATA[<p>MyBatis基础支持层位于 Mybatis 整体架构的最底层，支撑着 Mybatis 的核心处理层，是整个框架的基石。基础支持层中封装了多个较为通用的、独立的模块，不仅仅为 Mybatis 提供基础支撑，也可以在合适的场景中直接复用。</p><p><img src="https://cdn.jsdelivr.net/gh/cayzlh/git-img-repository@master/2020/05/21/2_c5SKkm.png" alt="整体架构"></p><blockquote><p>这篇文章介绍MyBatis的资源加载模块</p></blockquote><h3 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3><p>Java虚 拟 机中的类 加载 器(ClassLoader)负 责 加载 来 自文件系统 、网 络 或其他来 源的类 文 件。Java虚 拟 机中的类 加载 器默认 使用的是<strong>双 亲 委派模式</strong>，如图所示，其中有三种 默认 使 用 的 类 加 载 器 ，分 别 是 <code>Bootstrap ClassLoader</code>、<code>Extension ClassLoader</code> 和 <code>System ClassLoader</code> (也 被称 为 <code>ApplicationClassLoader</code>)，每种 类 加载 器都己经 确 定从 哪 个 位置加载 类 文件。</p><p><code>BootstrapClassLoader</code>负 责 加载 JDK自带 的<code>rt.jar</code>包中的类 文件，它 是所有类 加载 器的父加载 器，<code>Bootstrap ClassLoader</code>没 有任何父类 加载 器。<code>Extension ClassLoader</code>负 责 加 载 Java的扩 展类 库 ，也就是从 <code>jre/lib/ext</code>目录 下或者<code>java.ext.dirs</code>系统 属 性指定的目录 下加载 类 。</p><p><code>SystemClassLoader</code>负 责 从 <code>classpath</code>环 境变 量中加载 类 文件，<code>classpath</code>环 境变 量通常由<code>-classpath</code>或 <code>-cp</code>命令行选 项 来 定义 ，或 是 由 JAR中 Manifest文 件 的 classpath属 性指定。<code>System ClassLoader</code>是<code>ExtensionClassLoader</code>的子加载 器。</p><p><img src="https://gitee.com/cayzlh/img-repo/raw/master/2020/06/08/image-20200608173325045_78JEcv.png" alt="image-20200608173325045"></p><p>根据双亲委派模式，在加载类文件时，子加载器首先会将加载请求委托给它的父加载器。</p><p>父加载器会检测自己是否已经加载过该类，如果己加载则加载过程结束;如果未加载则请求继 续 向上传 递 ，直到BootstrapClassLoader。</p><p>如果在请 求向上委托的过 程中，始终 未检 测 到该 类 己 加载 ，则 从 BootstrapClassLoader开 始尝 试 从 其对 应 路径 中加载 该 类 文件，如果加载 失败 则 由 子加载器继续尝试加载，直至发起加载请求的子加载器位为止。</p><blockquote><p>双 亲 委派模式可以保证 两 点:</p><p>一是子加载 器可以使用父加载 器己加载 的类 ，而父加载 器无 法使用子加载 器已加载 的类 ;</p><p>二是父加载 器已加载 过 的类 无法被子加载 器再次加载 。</p><p>这 样 就可以保证 JVM的安全性和稳 定性。</p></blockquote><h3 id="ClassLoaderWrapper"><a href="#ClassLoaderWrapper" class="headerlink" title="ClassLoaderWrapper"></a>ClassLoaderWrapper</h3><p>上上一小节中了解了类 加载 器的常见 使用方式。在 MyBatis的 <code>IO</code> 包中封装 了 ClassLoader以及读 取资 源文件的相关 API。</p><p>在 <code>IO</code>包 中 提 供 的 <code>ClassLoaderWrapper</code>是 一 个 <code>ClassLoader</code>的包装 器，其中包含了多个<code>ClassLoader</code>对 象。</p><p>通过 调 整多个 类 加载 器的使用顺 序，<code>ClassLoaderWrapper</code>可以确 保返回给 系 统 使用的是正确 的类 加载 器。</p><p>使 用 <code>ClassLoaderWrapper</code>就如同使用一个 <code>ClassLoader</code>对 象， <code>ClassLoaderWrapper</code>会 按照指定的顺 序依次检 测 其中封装 的<code>ClassLoader</code>对 象，并 从 中选 取第一 个 可用的<code>ClassLoader</code>完成相关 功能。</p><p><code>ClassLoaderWrapper</code>的 主 要 功 能 可 以 分 为 三 类 ， 分 别 是 <code>getResourceAsURL()方 法</code> 、 <code>classForName()方法</code>、<code>getResourceAsStream()方法</code>，这 三个 方法都有多个 重载 ，这 三类 方法最终 都会 调 用参 数 为 <code>String</code>和<code>ClassLoader[]</code>的重载 。</p><p><code>getResourceAsURL()</code>代码如下，其他的类似：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> URL <span class="title">getResourceAsURL</span><span class="params">(String resource, ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> getResourceAsURL(resource, getClassLoaders(classLoader));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回ClassLoader[], 该方法指明类加载器的使用顺序</span></span><br><span class="line">ClassLoader[] getClassLoaders(ClassLoader classLoader) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> ClassLoader[]&#123;</span><br><span class="line">    classLoader,</span><br><span class="line">    defaultClassLoader,</span><br><span class="line">    Thread.currentThread().getContextClassLoader(),</span><br><span class="line">    getClass().getClassLoader(),</span><br><span class="line">    systemClassLoader&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">URL <span class="title">getResourceAsURL</span><span class="params">(String resource, ClassLoader[] classLoader)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  URL url;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (ClassLoader cl : classLoader) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> != cl) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// look for the resource as passed in...</span></span><br><span class="line">      url = cl.getResource(resource);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// ...but some class loaders want this leading &quot;/&quot;, so we&#x27;ll add it</span></span><br><span class="line">      <span class="comment">// and try again if we didn&#x27;t find the resource</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">null</span> == url) &#123;</span><br><span class="line">        url = cl.getResource(<span class="string">&quot;/&quot;</span> + resource);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// &quot;It&#x27;s always in the last place I look for it!&quot;</span></span><br><span class="line">      <span class="comment">// ... because only an idiot would keep looking for it after finding it, so stop looking already.</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">null</span> != url) &#123;</span><br><span class="line">        <span class="keyword">return</span> url;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// didn&#x27;t find it anywhere.</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Resources是一个 提供了多个 静 态 方法的工具类 ，其中封装 了一个 ClassLoaderWrapper类 型 的静 态 字段，Resources提供的这 些静 态 工具都是通过 调 用该 ClassLoaderWrapper对 象的相应 方 法实 现 的。</p><h3 id="ResolverUtil"><a href="#ResolverUtil" class="headerlink" title="ResolverUtil"></a>ResolverUtil</h3><p><code>ResolverUtil</code>可以根据指定的条件查找指定包下的类 ，其中使用的条件由Test接口表示。 </p><p><code>ResolverUtil</code>中使用<code>classLoader</code>字 段 (<code>ClassLoader</code>类 型)记 录 了当 前使用的类 加载 器，默认 情 况 下，使用的是当 前线 程上下文绑 定的<code>ClassLoader</code>，我们 可以通过 <code>setClassLoader()</code>方法修改使 用类加载器。</p><p>MyBatis提供了两 个 常用的<code>Test</code>接口实 现 ，分别 是<code>IsA</code>和<code>AnnotatedWith</code>,如图 所示。 <code>IsA</code>用于检 测 类 是否继 承了指定的类 或接口，<code>AnnotatedWith</code>用于检 测 类 是否添加了指定的注解。 开 发 人员 也可以自己实 现 <code>Test</code>接口，实 现 指定条 件的检 测 。</p><p><img src="https://gitee.com/cayzlh/img-repo/raw/master/2020/06/08/image-20200608175854576_mu9XKh.png" alt="image-20200608175854576"></p><p>Test接口中定义 了 matches()方法，它 用于检 测 指定类 是否符合条 件:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Will be called repeatedly with candidate classes. Must return True if a class</span></span><br><span class="line"><span class="comment">     * is to be included in the results, false otherwise.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(Class&lt;?&gt; type)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>IsA</code>和 <code>AnnotatedWith</code>的具体 实 现 如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">IsA</span> <span class="keyword">implements</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Class&lt;?&gt; parent;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** Constructs an IsA test using the supplied Class as the parent class/interface. */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">IsA</span><span class="params">(Class&lt;?&gt; parentType)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.parent = parentType;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** Returns true if type is assignable to the parent type supplied in the constructor. */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(Class&lt;?&gt; type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> type != <span class="keyword">null</span> &amp;&amp; parent.isAssignableFrom(type);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;is assignable to &quot;</span> + parent.getSimpleName();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotatedWith</span> <span class="keyword">implements</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Class&lt;? extends Annotation&gt; annotation;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** Constructs an AnnotatedWith test for the specified annotation type. */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">AnnotatedWith</span><span class="params">(Class&lt;? extends Annotation&gt; annotation)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.annotation = annotation;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** Returns true if the type is annotated with the class provided to the constructor. */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(Class&lt;?&gt; type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> type != <span class="keyword">null</span> &amp;&amp; type.isAnnotationPresent(annotation);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;annotated with @&quot;</span> + annotation.getSimpleName();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>默认 情况 下，使用<code>Thread.currentThread().getContextClassLoader()</code>这 个 类 加载 器加载 符合条 件的类 ，我们 可以在调 用<code>find()</code>方法之前，调 用 <code>setClassLoader(ClassLoader)</code>设 置需要使用的 <code>ClassLoader</code>，这 个 <code>ClassLoader</code>可 以 从 <code>ClassLoaderWrapper</code>中 获 取 合 适 的 类 加 载 器 。</p></blockquote><p>ResolverUtil的使用案例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ResolverUtil&lt;ActionBean&gt; resolver = <span class="keyword">new</span> ResolverUtil&lt;ActionBean&gt;();</span><br><span class="line"><span class="comment">// 在pkg1和pkg2这个包下查找实现了ActionBean这个接口的类</span></span><br><span class="line">resolver.findImplementation(ActionBean.class,  pkg1, pkg2);</span><br><span class="line"><span class="comment">// 在pkg1包下查找符合CustomerTest条件的类</span></span><br><span class="line">resolver.find(<span class="keyword">new</span> CustomTest(), pkg1);</span><br><span class="line"><span class="comment">// 在pkg2包下查找符合CustomerTest条件的类</span></span><br><span class="line">resolver.find(<span class="keyword">new</span> CustomTest(), pkg2);</span><br><span class="line"><span class="comment">// 获取上面三次查找的结果</span></span><br><span class="line">Collection&lt;ActionBean&gt; beans = resolver.getClasses();</span><br></pre></td></tr></table></figure><p><code>ResolverUtil.findImplementations()</code>方法和<code>ResolverUtil.findAnnotated()</code>方法都是依赖<code>RescolverUtil.find()</code>方法实现的，<code>findImplementations()</code>方法会创建<code>IsA</code>对象作为检测条件，<code>findAnnotated()</code>方法会创建<code>AnnotatedWith</code>对象作为检测条件。</p><p><img src="https://gitee.com/cayzlh/img-repo/raw/master/2020/06/08/image-20200608214416619_RmQAqH.png" alt="image-20200608214416619"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ResolverUtil&lt;T&gt; <span class="title">find</span><span class="params">(Test test, String packageName)</span> </span>&#123;</span><br><span class="line">  String path = getPackagePath(packageName);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    List&lt;String&gt; children = VFS.getInstance().list(path);</span><br><span class="line">    <span class="keyword">for</span> (String child : children) &#123;</span><br><span class="line">      <span class="keyword">if</span> (child.endsWith(<span class="string">&quot;.class&quot;</span>)) &#123;</span><br><span class="line">        addIfMatching(test, child);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (IOException ioe) &#123;</span><br><span class="line">    log.error(<span class="string">&quot;Could not read package: &quot;</span> + packageName, ioe);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">addIfMatching</span><span class="params">(Test test, String fqn)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// fqn是类所在完全限定名，即包括其所在包的包名</span></span><br><span class="line">    String externalName = fqn.substring(<span class="number">0</span>, fqn.indexOf(<span class="string">&#x27;.&#x27;</span>)).replace(<span class="string">&#x27;/&#x27;</span>, <span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">    ClassLoader loader = getClassLoader();</span><br><span class="line">    <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">      log.debug(<span class="string">&quot;...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt; type = loader.loadClass(externalName);</span><br><span class="line">    <span class="keyword">if</span> (test.matches(type)) &#123;</span><br><span class="line">      matches.add((Class&lt;T&gt;) type);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">    log.warn(<span class="string">&quot;...&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="VFS"><a href="#VFS" class="headerlink" title="VFS"></a>VFS</h3><p>VFS表示虚 拟 文件系统 (VirtualFileSystem),它 用来 査找 指定路径 下的资 源。VFS是一个 抽象类 ，MyBatis中提供了 JBoss6VFS和 DefaultVFS两 个 VFS的实 现 ，如图所示。用户 也可以提供自定义 的VFS实 现 类 。</p><blockquote><p>VFS采用单例模式实现</p></blockquote><p><img src="https://gitee.com/cayzlh/img-repo/raw/master/2020/06/08/image-20200608220219508_W9RlCv.png" alt="image-20200608220219508"></p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><p><strong>《MyBatis技术内幕》</strong></p></li><li><p>部分图片来源——<strong>《MyBatis技术内幕》</strong></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 书籍 </category>
          
          <category> 《MyBatis技术内幕》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MyBatis </tag>
            
            <tag> 《MyBatis技术内幕》 </tag>
            
            <tag> 基础支持层 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基础支持层——日志模块</title>
      <link href="/blog/2019/10/26/899df03d.html"/>
      <url>/blog/2019/10/26/899df03d.html</url>
      
        <content type="html"><![CDATA[<p>MyBatis基础支持层位于 Mybatis 整体架构的最底层，支撑着 Mybatis 的核心处理层，是整个框架的基石。基础支持层中封装了多个较为通用的、独立的模块，不仅仅为 Mybatis 提供基础支撑，也可以在合适的场景中直接复用。</p><p><img src="https://gitee.com/cayzlh/img-repo/raw/master/2020/06/09/2_c5SKkm-20200609155948653_2YZD6l.png" alt="整体架构"></p><blockquote><p>这篇文章介绍MyBatis的日志模块</p></blockquote><p>在 Java 开 发 中常用的日志框 架有 <code>Log4j</code>、<code>Log4j2</code>、<code>Apache Commons Log</code>、<code>java.util.logging</code>、 <code>slf4j</code>等，这 些工具对 外的接口不尽 相同。</p><p>为 了统 一这 些工具的接口，MyBatis定义 了一套统 一 的日志接口供上层 使用，并 为 上述常用的日志框 架提供了相应 的适配器。</p><h3 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h3><p>先简单介绍一下设计模式中的六大原则</p><ul><li><p>单一职责原则</p><p>不要存在多于一个导致类变更的原因，简单来说，一个类只负责唯一 项职责。</p></li><li><p>里氏替换原则</p><p>如果对 每一个 类 型为 T1的对 象tl，都有类 型为 T2的对 象使得以 T1定义 的所有程序P在所有的对 象tl都代换 成t2时 ，程序P 的行为 没 有发 生变 化， 那么 类 型T2是类 型T1的子类 型。遵守里氏替换 原则 ，可以帮 助我们 设 计 出更为 合 理的继 承体 系。</p></li><li><p>依赖倒置原则</p><p>系统的高层模块不应该依赖低层模块的具体实现，二者都应该依赖其 抽象类 或接口，抽象接口不应 该 依赖 具体 实 现 类 ，而具体 实 现 类 应 该 于依赖 抽象。简 单 来 说 ，我们 要面向接口编 程。当 需求发 生变 化时 对 外接口不变 ，只要提供新的实 现 类 即 可。</p></li><li><p>接口隔离原则</p><p>一个类对另一个类的依赖应该建立在最小的接口上。简单来说，我们 在设 计 接口时 ，不要设 计 出庞 大臃 肿 的接口，因为 实 现 这 种 接口时 需要实 现 很 多不必 要的方法。我们 要尽 量设 计 出功能单 一的接口，这 样 也能保证 实 现 类 的职 责 单 一。</p></li><li><p>迪米特法则</p><p>一个对象应该对其他对象保持最少的了解。简单来说，就是要求我们减 低类 间 耦 合。</p></li><li><p>开放-封闭原则</p><p>程序要对扩展开放，对修改关闭。简单来说，当需求发生变化时，我 们 可以通过 添加新的模块 满 足新需求，而不是通过 修改原来 的实 现 代码 来 满 足新需求。</p></li></ul><p><strong>在这 六条 原则 中，开 放-封闭 原则 是最基础 的原则 ，也是其他原则 以及后文介绍 的所有设 计 模式的最终 目标 。</strong></p><p>适配器模式的主要目的是解决 由于接口不能兼容而导 致类 无 法使用的问 题 ，适配器模式会 将 需要适配的类 转 换 成调 用者能够 使用的目标 接口。这 里先介绍 适配器模式中涉及的几 个 角色，如下所述。</p><ul><li><p>目标接口</p><p> 用者能够 直接使用的接口。</p></li><li><p>需要适配的类（Adaptee）</p><p>—般情况下，Adaptee类中有真正的业务逻辑，但是其接口 不能被调 用者直接使用。</p></li><li><p>适配器（Adapter）</p><p>Adapter 实 现 了 Target 接口，并 包装 了一个 Adaptee 对 象。Adapter 在实 现 Target接口中的方法时 ，会 将 调 用委托给 Adaptee对 象的相关 方法，由Adaptee 完成具体 的业 务 。</p></li></ul><p>适配器模式类图：</p><p><img src="https://gitee.com/cayzlh/img-repo/raw/master/2020/06/08/image-20200608165414581_Ty7boQ.png" alt="image-20200608165414581"></p><blockquote><p>使用适配器模式的好处 就是复 用现 有组 件。</p><p>应 用程序需要复 用现 有的类 ，但接口不能被该 应 用程序兼容，则 无法直接使用。</p><p>这 种 场 景下就适合使用适配器模式实 现 接口的适配，从 而完 成组 件的复 用。</p><p>很 明显 ，适配器模式通过 提供Adapter的方式完成接口适配，实 现 了程序复 用 Adaptee的需求，避免了修改Adaptee实 现 接口，这 符合“开 放-封闭 ”原则 。</p><p>当 有新的Adaptee 需要被复 用时 ，只要添加新的Adapter即 可，这 也是符合“开 放-封闭 ”原则 的。</p></blockquote><p>在 MyBatis的日志模块 中，就使用了适配器模式。</p><p>MyBatis内 部调 用其日志模块 时 ，使用 了其内 部接口(也就是后面要介绍 的<code>org.apache.ibatis.loggingLog</code> 接口)。但是 <code>Log4j</code>、<code>Log4j2</code> 等第三方日志组 件对 外提供的接口各不相同，MyBatis为 了集成和复 用这 些第三方日志组 件，</p><p>在其日志模块 中提供了多种 <code>Adapter</code>, 将 这 些第三方日志组 件对 外的接口适配成了 <code>org.apache.ibatis.logging.Log</code> 接口，这 样 MyBatis 内 部就可以统 一通过 <code>org.apache.ibatis.logging.Log</code>接口调 用第三方日志组 件的功能了。</p><h3 id="日志适配器"><a href="#日志适配器" class="headerlink" title="日志适配器"></a>日志适配器</h3><p>MyBatis 统 一提供了 <code>trace</code>、<code>debug</code>、 <code>warn</code>、<code>error</code>四个 级 别 用于对应上诉的各种第三方日志组件的级别，这 基本与 主流日志框 架的曰志级 别 类 似，可以满 足绝 大多数 场 景的日志 需求。</p><p>MyBatis的日志模块 位于<code>org.apache.ibatis.logging</code>包中，该 模块 中通过 Log接口定义 了日志 模块 的功能，当 然日志适配器也会 实 现 此接口。LogFactory工厂 类 负 责 创 建对 应 的日志组 件适 配器。</p><p>在LogFactory类 加载 时 会 执 行其静 态 代码 块 ，其逻 辑 是按序加载 并 实 例化对 应 日志组 件的 适配器，然后使用<code>LogFactory. logConstructor</code>这 个 静 态 字段，记 录 当 前使用的第三方日志组 件的 适配器，具体 代码 如下所示。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Constructor&lt;? extends Log&gt; logConstructor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">  tryImplementation(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      useSlf4jLogging();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  tryImplementation(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      useCommonsLogging();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  tryImplementation(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      useLog4J2Logging();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  tryImplementation(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      useLog4JLogging();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  tryImplementation(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      useJdkLogging();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  tryImplementation(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      useNoLogging();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>LogFactory.tryImplementation()</code>方 法 首 先 会 检 测 <code>logConstructor</code>字 段 ， 若 为 空 则 调 用 <code>Runnable.run()</code>方法(注意，不是***start()***方法)，如上述代码 所示，其中会 调 用<code>use*Logging()</code>方法。 这 里以<code>useJdkLogging()</code>为 例进 行介绍 ，具体 代码 如下:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">useJdkLogging</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  setImplementation(org.apache.ibatis.logging.jdk14.Jdk14LoggingImpl.class);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setImplementation</span><span class="params">(Class&lt;? extends Log&gt; implClass)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 获取指定适配器的构造方法</span></span><br><span class="line">    Constructor&lt;? extends Log&gt; candidate = implClass.getConstructor(String.class);</span><br><span class="line">    Log log = candidate.newInstance(LogFactory.class.getName());</span><br><span class="line">    <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">      log.debug(<span class="string">&quot;Logging initialized using &#x27;&quot;</span> + implClass + <span class="string">&quot;&#x27; adapter.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 初始化logConstructor字段</span></span><br><span class="line">    logConstructor = candidate;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> LogException(<span class="string">&quot;Error setting Log implementation.  Cause: &quot;</span> + t, t);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相应的实现类都在<code>org.apache.ibatis.logging</code>的子包下。且都实 现 了 <code>org.apache.ibatis.logging.Log</code> 接口，并 封装 了 <code>java.util.logging. Logger</code> 对 象 ，<code>org.apache.ibatis.logging.Log</code> 接口 的功能全部通过 调 用 <code>java.util.logging.Logger</code> 对 象 实 现 ，这 与 前面介绍 的适配器模式完全一致。</p><p><img src="https://gitee.com/cayzlh/img-repo/raw/master/2020/06/08/image-20200608171903948_fKzybU.png" alt="image-20200608171903948"></p><h3 id="JDBC调试"><a href="#JDBC调试" class="headerlink" title="JDBC调试"></a>JDBC调试</h3><p>在MyBatis的日志模块 中有一个 Jdbc包，它 并 不是将 日志信息通过 JDBC保存到数 据库 中， 而是通过 JDK动 态 代理的方式，将 JDBC操作通过 指定的日志框 架打印出来 。这 个 功能通常在 开 发 阶 段使用，它 可以输 出SQL语 句、用户 传 入的绑 定参 数 、SQL语 句影响 行数 等等信息，对 调 试 程序来 说 是非常重要的。</p><p>BaseJdbcLogger是一个 抽象类 ，它 是Jdbc包下其他Logger类 的父类 ，继 承关 系如图所示。</p><p><img src="https://gitee.com/cayzlh/img-repo/raw/master/2020/06/08/image-20200608172259632_8cistF.png" alt="image-20200608172259632"></p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><p><strong>《MyBatis技术内幕》</strong></p></li><li><p>部分图片来源——<strong>《MyBatis技术内幕》</strong></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 书籍 </category>
          
          <category> 《MyBatis技术内幕》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MyBatis </tag>
            
            <tag> 《MyBatis技术内幕》 </tag>
            
            <tag> 基础支持层 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基础支持层——反射模块</title>
      <link href="/blog/2019/10/25/899df03d.html"/>
      <url>/blog/2019/10/25/899df03d.html</url>
      
        <content type="html"><![CDATA[<p>MyBatis基础支持层位于 Mybatis 整体架构的最底层，支撑着 Mybatis 的核心处理层，是整个框架的基石。基础支持层中封装了多个较为通用的、独立的模块，不仅仅为 Mybatis 提供基础支撑，也可以在合适的场景中直接复用。</p><p><img src="https://gitee.com/cayzlh/img-repo/raw/master/2020/06/09/2_c5SKkm-20200609160003190_wDXqrk.png" alt="整体架构"></p><blockquote><p>这篇介绍MyBatis的反射模块</p></blockquote><h3 id="反射工具箱"><a href="#反射工具箱" class="headerlink" title="反射工具箱"></a>反射工具箱</h3><p>Mybatis 在进行参数处理、结果映射等操作时，会涉及大量的反射操作。Java 中的反射虽然功能强大，但是代码编写起来比较复杂且容易出错，为了简化反射操作的相关代码，Mybatis 提供了专门的反射模块，该模块位于 <code>org.apache.ibatis.reflection</code> 包中，它对常见的反射操作做了进一步封装，提供了更加简洁方便的反射 API。</p><h4 id="Reflector-amp-ReflectorFactory"><a href="#Reflector-amp-ReflectorFactory" class="headerlink" title="Reflector &amp; ReflectorFactory"></a>Reflector &amp; ReflectorFactory</h4><p>Reflector是MyBatis中反射模块的基础，每隔Reflector对象都对应一个类，在Reflector中缓存了反射操作需要使用的累的元信息。</p><p>Reflector中各个字段的含义如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Private Class &lt;?&gt; type; <span class="comment">//对应的 C1 ass 类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//可读属性的名称集合，可读属性就是存在相应 getter 方法的属性，初始值为空数组</span></span><br><span class="line"><span class="keyword">private</span> String I readablepropertynames= EMPTY STRING ARRAY</span><br><span class="line"></span><br><span class="line"><span class="comment">//可写属性的名称集合，可写属性就是存在相应 setter 方法的属性，初始值为空数组</span></span><br><span class="line"><span class="keyword">private</span> String  [writeablepropertynames EMPTY STRING ARRAY;</span><br><span class="line"><span class="comment">//记录了属性相应的 setter 方法，key 是属性名称，value 是 Invoker 对象，它是对 setter 方法对应 </span></span><br><span class="line"><span class="comment">// Me thod 对象的封装，后面会详细介绍</span></span><br><span class="line"><span class="keyword">private</span> Map &lt;String, Invoker&gt; setmethods =<span class="keyword">new</span> Hashmap &lt;String, Invoker&gt;  ();</span><br><span class="line"></span><br><span class="line"><span class="comment">//属性相应的 getter 方法集合，key 是属性名称，value 也是 Invoker 对象</span></span><br><span class="line"><span class="keyword">private</span> Map &lt;String, Invoker&gt; getmethods =<span class="keyword">new</span> Hashmap &lt;String, Invoker&gt; ();</span><br><span class="line"></span><br><span class="line"><span class="comment">//记录了属性相应的 setter 方法的参数值类型，key 是属性名称，value 是 setter 方法的参数类型</span></span><br><span class="line"><span class="keyword">private</span> Map &lt;String, Class &lt;?&gt;&gt; settypes =<span class="keyword">new</span> Hashmap &lt;string, Class &lt;?&gt;&gt; ();</span><br><span class="line"></span><br><span class="line"><span class="comment">//记录了属性相应的 getter 方法的返回值类型，key 是属性名称，value 是 getter 方法的返回值类型 </span></span><br><span class="line"><span class="keyword">private</span> Map &lt;string, Class &lt;?&gt;&gt; gettypes=<span class="keyword">new</span> Hashmap &lt;string, Class &lt;?&gt;&gt; ();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Constructor &lt;?&gt; <span class="keyword">default</span> Constructor; <span class="comment">//记录了默认构造方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//记录了所有属性名称的集合</span></span><br><span class="line"><span class="keyword">private</span> Map &lt;string, String&gt; caseinsensitivepropertymap-<span class="keyword">new</span> Hashmap &lt;String, String&gt; ();</span><br></pre></td></tr></table></figure><blockquote><p>在Reflector的构造方法中会解析制定的Class对象，并填充上述集合。具体如下：</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Reflector</span><span class="params">(Class&lt;?&gt; clazz)</span> </span>&#123;</span><br><span class="line">  type = clazz; <span class="comment">// 初始化type字段</span></span><br><span class="line">  <span class="comment">// 查找clazz的默认构造方法，具体实现是通过反射遍历所有构造方法</span></span><br><span class="line">  addDefaultConstructor(clazz);</span><br><span class="line">  addGetMethods(clazz); <span class="comment">// 处理clazz中的getter方法，填充getMethods集合和getTypes集合</span></span><br><span class="line">  addSetMethods(clazz); <span class="comment">// 处理clazz中的setter方法，填充setMethods集合和setTypes集合</span></span><br><span class="line">  addFields(clazz); <span class="comment">// 处理没有getter/setter方法的字段</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 根据getMethods/setMethods集合，初始化可读/写属性的名称集合</span></span><br><span class="line">  readablePropertyNames = getMethods.keySet().toArray(<span class="keyword">new</span> String[<span class="number">0</span>]);</span><br><span class="line">  writablePropertyNames = setMethods.keySet().toArray(<span class="keyword">new</span> String[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 初始化caseInsensitivePropertyMap集合，其中记录了所有大写格式的属性名称</span></span><br><span class="line">  <span class="keyword">for</span> (String propName : readablePropertyNames) &#123;</span><br><span class="line">    caseInsensitivePropertyMap.put(</span><br><span class="line">      propName.toUpperCase(Locale.ENGLISH), propName);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (String propName : writablePropertyNames) &#123;</span><br><span class="line">    caseInsensitivePropertyMap.put(</span><br><span class="line">      propName.toUpperCase(Locale.ENGLISH), propName);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Reflector.Addgetmethodso()</code>方法主要负责解析类中定义的 <code>getter</code> 方法，<code>Reflector. addSetMethods()</code>方法负责解析类中定义的 <code>setter</code> 方法，两者的逻辑类似。</p><p><code>Reflector. Addgetmethods()</code> 方法有如下三个核心步骤。</p><ol><li><p>首先，调用Reflector.getClassMethods()方法获取当前类及其父类中定义的所有方法的唯一签名以及响应的Method对象。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Method[] getClassMethods(Class&lt;?&gt; clazz) &#123;</span><br><span class="line">  <span class="comment">// 用于记录制定类中定义的全部方法的唯一签名以及对应的Method对象</span></span><br><span class="line">  Map&lt;String, Method&gt; uniqueMethods = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">  Class&lt;?&gt; currentClass = clazz;</span><br><span class="line">  <span class="keyword">while</span> (currentClass != <span class="keyword">null</span> &amp;&amp; currentClass != Object.class) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录currentClass这个类中定义的全部方法</span></span><br><span class="line">    addUniqueMethods(uniqueMethods, currentClass.getDeclaredMethods());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// we also need to look for interface methods -</span></span><br><span class="line">    <span class="comment">// because the class may be abstract</span></span><br><span class="line">    <span class="comment">// 记录接口中定义的方法</span></span><br><span class="line">    Class&lt;?&gt;[] interfaces = currentClass.getInterfaces();</span><br><span class="line">    <span class="keyword">for</span> (Class&lt;?&gt; anInterface : interfaces) &#123;</span><br><span class="line">      addUniqueMethods(uniqueMethods, anInterface.getMethods());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取父类，继续while循环</span></span><br><span class="line">    currentClass = currentClass.getSuperclass();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Collection&lt;Method&gt; methods = uniqueMethods.values();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> methods.toArray(<span class="keyword">new</span> Method[<span class="number">0</span>]);<span class="comment">// 转换成Methods数组返回</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>然后，按照JavaBean的规范，从Reflector.getClassMethods()方法返回的Method数组中查找该类中定义的getter方法，将其记录到<code>conflictingGetters</code>集合中。<code>conflictingGetters</code>集合的key为属性名称，value是该属性对应的getter方法的集合。</p></li><li><p>当子类覆盖了父类的getter方法且返回值发生变化时，在步骤1中就会产生两个签名不同的方法。</p></li></ol><h4 id="TypeParameterResolver"><a href="#TypeParameterResolver" class="headerlink" title="TypeParameterResolver"></a>TypeParameterResolver</h4><p>在开 始介绍 TypeParameterResolver之前，先简 单 介绍 一下Type接口的基础 知识 。Type是所有类 型的父接口，它 有四个 子接口和一个 实 现 类 ，如图所示。</p><p><img src="https://gitee.com/cayzlh/img-repo/raw/master/2020/06/06/image-20200606160310736_88u4tj.png" alt="image-20200606160310736"></p><p>下面来 看这 些子接口和子类 所代表的类 型。</p><ul><li><p><strong>Class</strong>比较 常见 ，它 表示的是原始类 型。</p><p>Class类 的对 象表示JVM中的一个 类 或接口， 每个 Java类 在JVM里都表现 为 一个 Class对 象。</p><p>在程序中可以通过 “<strong>类名.class</strong>”、“**对象.getClass()<strong>”或是“</strong>Class.forName(“类 名”)**”等方式获 取Class对 象。</p><p>数 组 也被映射为 Class对 象，所有元素类 型相同且维 数 相同的数 组 都共享同一个 Class对 象。</p></li><li><p><strong>ParameterizedType</strong> 表示的是参 数 化类 型，例如 List<String>、 Map&lt;Integer，String&gt;、 Service<User>这 种 带 有泛型的类 型。</p><p>ParameterizedType接口中常用的方法有三个 ，分别 是:</p><ul><li><code>Type getRawType()</code>—–返回参 数 化类 型中的原始类 型，例如List<Strin>的原始类 型为 List。</li><li><code>Type[] getActualTypeArguments()</code>—–获 取参 数 化类 型的类 型变 量或是实 际 类 型列 表，例如Map&lt;Integer，String&gt;的实 际 泛型列表Integer和 String。需要注意的是， 该 列表的元素类 型都是Type,也就是说 ，可能存在多层 嵌套的情况 。</li><li><code>Type getOwnerType()</code>—–返回是类 型所属 的类 型，例如存在A<T>类 ，其中定义 了 内 部类 InnerA<I>，则 InnerA<I>属 的类 型为 A<T>，如果是顶 层 类 型则 返回null。 这 种 关 系比较 常见 的示例是Map&lt;K，V&gt;接口与 Map.Entry&lt;K，V&gt;接口，Map&lt;K，V&gt; 接 口 是Map&lt;K,V&gt;接口的所有者。</li></ul></li><li><p><code>TypeVariable</code>表示的是类 型变 量，它 用来 反映在JVM编 译 该 泛型前的信息。</p><p>例如List<T> 中的T就是类 型变 量，它 在编 译 时 需被转 换 为 一个 具体 的类 型后才能正常使用。</p><p>该 接口中常用的方法有三个 ，分别 是:</p><ul><li><p><code>Type[] getBounds()</code>—–获 取类 型变 量的上边 界，如果未明确 声 明上边 界则 默认 为 Object。 </p><p>例如 class Test<K extends Person>中 K 的上界就是 Person。</p></li><li><p> <code>D getGenericDeclaration()</code>—–获 取声 明该 类 型变 量的原始类 型，例 如 class Test<K extends Person> 中 的原始类 型是 Test。</p></li><li><p><code>String getName()</code>— 获 取在源码 中定义 时 的名字，上例中为 K。</p></li></ul></li><li><p><code>GenericArrayType</code> 表示的是数 组 类 型且组 成元素是 ParameterizedType 或 TypeVariable。 </p><p>例如 List<String>或T[]。该 接口只有 Type getGenericComponentType()—个 方法，它 返回数 组 的组 成元素。</p></li><li><p><code>WildcardType</code> 表示的是通配符泛型，例如<code>? extends Number</code> 和<code>? uper Integer</code>。</p><p>WildcardType接口有两 个 方法，分别 是:</p><ul><li><code>Type[] getUpperBounds()</code>—-返回泛型变 量的上界。 </li><li> <code>Type[] getLowerBounds()</code>—- 返回泛型变 量的下界。</li></ul></li></ul><p> 回到对 <code>TypeParameterResolve</code>，它 是一个 工具类 ，提供了一系列静 态 方法来 解析指定类 中的字段、方法返回值 或方法参 数 的类 型。TypeParameterResolver中各个 静 态 方法之间 的调 用关 系大致如下图 所示，为 保持清 晰 ，其中递 归 调 用没 有表现 出来 ，在后面 的代码 分析过 程中会 进 行强调 。</p><p><img src="https://gitee.com/cayzlh/img-repo/raw/master/2020/06/06/image-20200606162023961_yxCRz4.png" alt="image-20200606162023961"></p><p><code>TypeParameterResolver</code> 中 通 过 <code>resolveFieldType()</code>方 法 、 <code>resolveRetumType()</code>方 法 、 <code>resolveParamTypes()</code>方法分别 解析字段类 型、方法返回值 类 型和方法参 数 列表中各个 参 数 的类 型。 这 三个 方法的逻 辑 基本类 似，这 里以resolveFieldType()方法为 例进 行介绍 ，<code>TypeParameterResolver.resolveFieldType()</code>方法的具体 实 现 如下:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> The field type as &#123;<span class="doctag">@link</span> Type&#125;. If it has type parameters in the declaration,</span></span><br><span class="line"><span class="comment">   *         they will be resolved to the actual runtime &#123;<span class="doctag">@link</span> Type&#125;s.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Type <span class="title">resolveFieldType</span><span class="params">(Field field, Type srcType)</span> </span>&#123;</span><br><span class="line">  Type fieldType = field.getGenericType();</span><br><span class="line">  Class&lt;?&gt; declaringClass = field.getDeclaringClass();</span><br><span class="line">  <span class="keyword">return</span> resolveType(fieldType, srcType, declaringClass);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述三个 方法都会 调 用<code>resolveType()</code>方法，该 方法会 根据其第一个 参 数 的 类 型，即 字段、方法返回值 或方法参 数 的类 型，选 择 合适的方法进 行解析。<code>resolveType()</code>方法的 第二个 参 数 表示查 找 该 字段、返回值 或方法参 数 的起始位置。第三个 参 数 则 表示该 字段、方法 定义 所在的类 。<code>TypeParameterResolver.resolveType()</code>方法代码 如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Type <span class="title">resolveType</span><span class="params">(Type type, Type srcType, Class&lt;?&gt; declaringClass)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (type <span class="keyword">instanceof</span> TypeVariable) &#123;</span><br><span class="line">    <span class="comment">// 解析TypeVariable类型</span></span><br><span class="line">    <span class="keyword">return</span> resolveTypeVar((TypeVariable&lt;?&gt;) type, srcType, declaringClass);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type <span class="keyword">instanceof</span> ParameterizedType) &#123;</span><br><span class="line">    <span class="comment">// 解析ParameterizedType类型</span></span><br><span class="line">    <span class="keyword">return</span> resolveParameterizedType((ParameterizedType) type, srcType, declaringClass);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type <span class="keyword">instanceof</span> GenericArrayType) &#123;</span><br><span class="line">    <span class="comment">// 解析genericArrayType类型</span></span><br><span class="line">    <span class="keyword">return</span> resolveGenericArrayType((GenericArrayType) type, srcType, declaringClass);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> type; <span class="comment">// class类型</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 字段、返回值 、参 数 不可能直接定义 成WildcardType类 型，但可以嵌套在别 的类 型中</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了便于理解，通过一个示例分析<code>resolveType</code>方法， 假设有三个类 ClassA、SubClassA、TestType，代码如下：</p><p><code>ClassA</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassA</span> &lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123; </span><br><span class="line">  <span class="keyword">protected</span> Map&lt;K, V&gt; map;</span><br><span class="line"><span class="comment">// ••• map 的 getter/setter 方 法 (略 )</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>SubClassA</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubClassA</span> &lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">ClassA</span>&lt;<span class="title">T</span>,<span class="title">T</span>&gt; </span>&#123; </span><br><span class="line">  <span class="comment">// ...... </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>TestType</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestType</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  SubClassA&lt;Long&gt; sa = <span class="keyword">new</span> SubClassA();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchFieldException </span>&#123;</span><br><span class="line">    Field f = ClassA.class.getDeclaredField(<span class="string">&quot;map&quot;</span>);</span><br><span class="line">    System.out.println(f.getGenericType());</span><br><span class="line">    System.out.println(f.getGenericType() <span class="keyword">instanceof</span> ParameterizedType);</span><br><span class="line">    <span class="comment">// 输出：</span></span><br><span class="line">    <span class="comment">// java.util.Map&lt;K, V&gt;</span></span><br><span class="line">    <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析SubA&lt;Long&gt;(ParameterizedType类 型)中的map字段，注意:ParameterizedTypelmpl是</span></span><br><span class="line">    <span class="comment">// 在 sun.reflect.generics.reflectiveObjects 包下的 ParameterizedType接口实 现</span></span><br><span class="line"></span><br><span class="line">    Type type = TypeParameterResolver.resolveFieldType(</span><br><span class="line">      f, ParameterizedTypelmpl.make(SubClassA.class, </span><br><span class="line">                                    <span class="keyword">new</span> Type[]&#123;Long.class&#125;, TestType.class));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//也可以使用下面的方式生成上述ParameterizedType对 象，</span></span><br><span class="line">    <span class="comment">// 并 调 用 TypeParameterResolver.resolveFieldType ()方 法 :</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// TypeParameterResolver.resolveFieldType(f,</span></span><br><span class="line">    <span class="comment">// TestType.class.getDeclaredField(&quot;sa&quot;).getGenericType());</span></span><br><span class="line">    System.out.println(type.getClass());</span><br><span class="line">    <span class="comment">// 输 出 :class TypeParameterResolver$ParameterizedTypelmpl</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注意，TypeParameterResolver$ParameterizedTypeImpl是ParameterizedType接口的实 现 </span></span><br><span class="line">    ParameterizedType p = (ParameterizedType) type; </span><br><span class="line">    System.out.println(p.getRawType());</span><br><span class="line">    <span class="comment">// 输 出 :interface java.util.Map</span></span><br><span class="line"></span><br><span class="line">    System.out.println(p.getOwnerType());</span><br><span class="line">    <span class="comment">// 输 出:null</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Type t : p .getActualTypeArguments()) &#123;</span><br><span class="line">      System.out.println(t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//输 出:</span></span><br><span class="line">    <span class="comment">// class java.lang.Long</span></span><br><span class="line">    <span class="comment">// class java.lang.Long</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据前面的Type接口的介绍，上例中ClassA.map字段声明的类型Map&lt;K,V&gt;是ParamelerizedType类型，resolveType()方法回调用resolvParameterizedType()方法进行解析。</p><p>首先介绍resolveParameterizedType()方法的参数：</p><ul><li>第一个参数是待解析的ParameterizedType类型</li><li>第二个参数是解析操作的起始类型</li><li>第三个参数为定义该字段或方法的类的Class对象</li></ul><p>在该示例中第一个参数是Map&lt;K,V&gt;对应的ParameterizedType对象，第二个参数是TypeTest.SubA<Long>对应的ParameterizedType对象，第三个参数是ClassA（声明map字段的类）相应的Class对象。</p><p><strong>继续分析<code>scanSuperTypes()</code>方法</strong>，该方法回递归整个继承结构并完成类型变量的解析。在该示例之中，第一个参数K对应的TypeVariable对象，第二个参数是TypeText.SubA<Long>对应的ParameterizedType对象，第三个参数是ClassA（声明map字段的类）对应的Class对象，第四个参数是SubClassA对应的Class对象，第五个参数是Class&lt;T,T&gt;对应的ParameterizedType对象。</p><p><code>scanSuperTypes()</code>方法的具体实现如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Type <span class="title">scanSuperTypes</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  TypeVariable&lt;?&gt; typeVar, Type srcType, </span></span></span><br><span class="line"><span class="function"><span class="params">  Class&lt;?&gt; declaringClass, Class&lt;?&gt; clazz, Type superclass)</span> </span>&#123;</span><br><span class="line">    Type result = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (superclass <span class="keyword">instanceof</span> ParameterizedType) &#123;</span><br><span class="line">      ParameterizedType parentAsType = (ParameterizedType) superclass;</span><br><span class="line">      Class&lt;?&gt; parentAsClass = (Class&lt;?&gt;) parentAsType.getRawType();</span><br><span class="line">      <span class="keyword">if</span> (declaringClass == parentAsClass) &#123;</span><br><span class="line">        Type[] typeArgs = parentAsType.getActualTypeArguments();</span><br><span class="line">        TypeVariable&lt;?&gt;[] declaredTypeVars = </span><br><span class="line">          declaringClass.getTypeParameters();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; declaredTypeVars.length; i++) &#123;</span><br><span class="line">          <span class="keyword">if</span> (declaredTypeVars[i] == typeVar) &#123;</span><br><span class="line">            <span class="keyword">if</span> (typeArgs[i] <span class="keyword">instanceof</span> TypeVariable) &#123;</span><br><span class="line">              TypeVariable&lt;?&gt;[] typeParams = clazz.getTypeParameters();</span><br><span class="line">              <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; typeParams.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (typeParams[j] == typeArgs[i]) &#123;</span><br><span class="line">                  <span class="keyword">if</span> (srcType <span class="keyword">instanceof</span> ParameterizedType) &#123;</span><br><span class="line">                    result = ((ParameterizedType) srcType).getActualTypeArguments()[j];</span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              result = typeArgs[i];</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (declaringClass.isAssignableFrom(parentAsClass)) &#123;</span><br><span class="line">        result = resolveTypeVar(typeVar, parentAsType, declaringClass);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (superclass <span class="keyword">instanceof</span> Class) &#123;</span><br><span class="line">      <span class="keyword">if</span> (declaringClass.isAssignableFrom((Class&lt;?&gt;) superclass)) &#123;</span><br><span class="line">        result = resolveTypeVar(typeVar, superclass, declaringClass);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>下图展示了scanSuperTypes()方法解析类型变量的核心逻辑。</p><p><img src="https://gitee.com/cayzlh/img-repo/raw/master/2020/06/07/image-20200607094904927_ZT0Sxt.png" alt="image-20200607094904927"></p><h4 id="ObjectFactory"><a href="#ObjectFactory" class="headerlink" title="ObjectFactory"></a>ObjectFactory</h4><p>MyBatis中很多模块会使用到ObjectFactory接口，该接口提供了多个create()方法的重载，通过这些create()方法可以创建指定类型的对象。ObjectFactory的定义如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ObjectFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Sets configuration properties.</span></span><br><span class="line"><span class="comment">   * 设置配置信息</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> properties configuration properties</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">setProperties</span><span class="params">(Properties properties)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Creates a new object with default constructor. </span></span><br><span class="line"><span class="comment">   * 通过无参构造器创建指定类的对象</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> type Object type</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  &lt;T&gt; <span class="function">T <span class="title">create</span><span class="params">(Class&lt;T&gt; type)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Creates a new object with the specified constructor and params.</span></span><br><span class="line"><span class="comment">   * 根据参数列表，从指定类型中选择合适的构造器创建对象</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> type Object type</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> constructorArgTypes Constructor argument types</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> constructorArgs Constructor argument values</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  &lt;T&gt; <span class="function">T <span class="title">create</span><span class="params">(Class&lt;T&gt; type, List&lt;Class&lt;?&gt;&gt; constructorArgTypes, List&lt;Object&gt; constructorArgs)</span></span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Returns true if this object can have a set of other objects.</span></span><br><span class="line"><span class="comment">   * It&#x27;s main purpose is to support non-java.util.Collection objects like Scala collections.</span></span><br><span class="line"><span class="comment">   * 检测指定类型是否为集合类型，主要处理java.util.Collectiopn及其子类</span></span><br><span class="line"><span class="comment">   * </span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> type Object type</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> whether it is a collection or not</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@since</span> 3.1.0</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  &lt;T&gt; <span class="function"><span class="keyword">boolean</span> <span class="title">isCollection</span><span class="params">(Class&lt;T&gt; type)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>DefaultObjectFactory</code>是<code>MyBatis</code>提供的<code>ObjectFactory</code>接口的唯一实 现 ，它 是一个 反射工厂 ， 其 <code>create()</code>方法通过 调 用 <code>instantiateClass()</code>方法实 现 。</p><p><code>DefaultObjectFactory.instantiateClass()</code>方法会 根据传 入的参 数 列表选 择 合适的构 造函数 实 例化对 象，具体 实 现 如下:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span>  &lt;T&gt; <span class="function">T <span class="title">instantiateClass</span><span class="params">(Class&lt;T&gt; type, List&lt;Class&lt;?&gt;&gt; constructorArgTypes, List&lt;Object&gt; constructorArgs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      Constructor&lt;T&gt; constructor;</span><br><span class="line">      <span class="keyword">if</span> (constructorArgTypes == <span class="keyword">null</span> || constructorArgs == <span class="keyword">null</span>) &#123;</span><br><span class="line">        constructor = type.getDeclaredConstructor();</span><br><span class="line">        <span class="keyword">if</span> (!constructor.isAccessible()) &#123;</span><br><span class="line">          constructor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> constructor.newInstance();</span><br><span class="line">      &#125;</span><br><span class="line">      constructor = type.getDeclaredConstructor(constructorArgTypes.toArray(<span class="keyword">new</span> Class[constructorArgTypes.size()]));</span><br><span class="line">      <span class="keyword">if</span> (!constructor.isAccessible()) &#123;</span><br><span class="line">        constructor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> constructor.newInstance(constructorArgs.toArray(<span class="keyword">new</span> Object[constructorArgs.size()]));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      StringBuilder argTypes = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">      <span class="keyword">if</span> (constructorArgTypes != <span class="keyword">null</span> &amp;&amp; !constructorArgTypes.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Class&lt;?&gt; argType : constructorArgTypes) &#123;</span><br><span class="line">          argTypes.append(argType.getSimpleName());</span><br><span class="line">          argTypes.append(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        argTypes.deleteCharAt(argTypes.length() - <span class="number">1</span>); <span class="comment">// remove trailing ,</span></span><br><span class="line">      &#125;</span><br><span class="line">      StringBuilder argValues = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">      <span class="keyword">if</span> (constructorArgs != <span class="keyword">null</span> &amp;&amp; !constructorArgs.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Object argValue : constructorArgs) &#123;</span><br><span class="line">          argValues.append(String.valueOf(argValue));</span><br><span class="line">          argValues.append(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        argValues.deleteCharAt(argValues.length() - <span class="number">1</span>); <span class="comment">// remove trailing ,</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> ReflectionException(<span class="string">&quot;Error instantiating &quot;</span> + type + <span class="string">&quot; with invalid types (&quot;</span> + argTypes + <span class="string">&quot;) or values (&quot;</span> + argValues + <span class="string">&quot;). Cause: &quot;</span> + e, e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>除了使用MyBatis提供的<code>DefaultObjectFactory</code>实现，还可以在mybatis-config.xml配置文件中指定自定义的ObjectFactory接口实现累， 从而实现功能上的扩展。</p><h4 id="Property工具类"><a href="#Property工具类" class="headerlink" title="Property工具类"></a>Property工具类</h4><p><code>org.apache.ibatis.reflection.property</code> 包下，提供了 PropertyCopier、PropertyNamer、PropertyTokenizer 三个属性相关的工具类。</p><p><strong>PropertyTokenizer</strong></p><p>在使用MyBatis的过程中，经常会碰到一些属性表达式，例如，在查询用户（User）的订单（Order）的结果集如下表所示：</p><table><thead><tr><th>user_name</th><th>order</th><th>item1</th><th>item2</th><th>…</th></tr></thead><tbody><tr><td>Mary</td><td>124640</td><td>iPhone 8 plus</td><td>MacBook Pro</td><td>…</td></tr><tr><td>Lisa</td><td>46546</td><td>iPhone 11 Pro</td><td>Mac Pro</td><td>…</td></tr><tr><td>…</td><td>…</td><td>…</td><td>…</td><td>…</td></tr></tbody></table><p>对象模型如下：</p><p><img src="https://gitee.com/cayzlh/img-repo/raw/master/2020/06/07/image-20200607100948201_0zx3nS.png" alt="image-20200607100948201"></p><p>假设现在需要将结果集中的<code>item1</code>列雨用户第一个订单（Order）的第一条目（Item）的名称映射，<code>item2</code>与用户第一个订单的（Order）的第二条目（Item）的名称映射（这里仅仅是一个示例，在实际生产中很少这样的设计），我们可以得到下面的映射规则：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;rm4testProTool&quot;</span> <span class="attr">type</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;orders[0].items[0].name&quot;</span> <span class="attr">column</span>=<span class="string">&quot;iteml&quot;</span> /&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;orders[0].items[1].name&quot;</span> <span class="attr">column</span>=<span class="string">&quot;item2&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在上面的例子中，<code>orders[0].items[0].name</code>这种由<code> .</code>和<code>[]</code>组成的表达式是由<code>PropertyTokenizer</code>进行解析的。以下是此类的源码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PropertyTokenizer</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">PropertyTokenizer</span>&gt; </span>&#123;</span><br><span class="line">  <span class="comment">// 当前表达式的名称</span></span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 当前表达式的索引名</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> String indexedName;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 索引下标</span></span><br><span class="line">  <span class="keyword">private</span> String index;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 子表达式</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> String children;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">PropertyTokenizer</span><span class="params">(String fullname)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 查找 . 的位置</span></span><br><span class="line">    <span class="keyword">int</span> delim = fullname.indexOf(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (delim &gt; -<span class="number">1</span>) &#123;</span><br><span class="line">      <span class="comment">// 初始化 name</span></span><br><span class="line">      name = fullname.substring(<span class="number">0</span>, delim);</span><br><span class="line">      <span class="comment">// 初始化children</span></span><br><span class="line">      children = fullname.substring(delim + <span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      name = fullname;</span><br><span class="line">      children = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 初始化indexname</span></span><br><span class="line">    indexedName = name;</span><br><span class="line">    delim = name.indexOf(<span class="string">&#x27;[&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (delim &gt; -<span class="number">1</span>) &#123;</span><br><span class="line">      <span class="comment">// 初始化index</span></span><br><span class="line">      index = name.substring(delim + <span class="number">1</span>, name.length() - <span class="number">1</span>);</span><br><span class="line">      name = name.substring(<span class="number">0</span>, delim);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> index;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getIndexedName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> indexedName;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getChildren</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> children;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> children != <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// next方法中会创建PropertyTokenizer对象并解析children字段记录的子表达式</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> PropertyTokenizer <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> PropertyTokenizer(children);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">&quot;Remove is not supported, as it has no meaning in the context of properties.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>PropertyTokenizer</code>继承了<code>Iterator</code>接口，它可以迭代处理嵌套多层表达式。</p><p><code>next()</code>方法中会创建<code>PropertyTokenizer</code>对象并解析<code>children</code>字段记录的子表达式。</p><p>继续使用订单示例进行说明，描述解析属性表达式<code>orders[0].items[0].name</code>的迭代过程：</p><p><img src="https://gitee.com/cayzlh/img-repo/raw/master/2020/06/07/image-20200607102830771_hVgxny.png" alt="image-20200607102830771"></p><p><strong>PropertyNamer</strong></p><p><code>PropertyNamer</code>是另一个工具类，提供了下列静态方法帮助完成方法名到属性名的转换，以及多种检测操作。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">PropertyNamer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">PropertyNamer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Prevent Instantiation of Static Class</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将方法名转换成属性名</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">methodToProperty</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (name.startsWith(<span class="string">&quot;is&quot;</span>)) &#123;</span><br><span class="line">      name = name.substring(<span class="number">2</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (name.startsWith(<span class="string">&quot;get&quot;</span>) || name.startsWith(<span class="string">&quot;set&quot;</span>)) &#123;</span><br><span class="line">      name = name.substring(<span class="number">3</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> ReflectionException(<span class="string">&quot;Error parsing property name &#x27;&quot;</span> + name + <span class="string">&quot;&#x27;.  Didn&#x27;t start with &#x27;is&#x27;, &#x27;get&#x27; or &#x27;set&#x27;.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (name.length() == <span class="number">1</span> || (name.length() &gt; <span class="number">1</span> &amp;&amp; !Character.isUpperCase(name.charAt(<span class="number">1</span>)))) &#123;</span><br><span class="line">      name = name.substring(<span class="number">0</span>, <span class="number">1</span>).toLowerCase(Locale.ENGLISH) + name.substring(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isProperty</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> name.startsWith(<span class="string">&quot;get&quot;</span>) || name.startsWith(<span class="string">&quot;set&quot;</span>) || name.startsWith(<span class="string">&quot;is&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isGetter</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> name.startsWith(<span class="string">&quot;get&quot;</span>) || name.startsWith(<span class="string">&quot;is&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isSetter</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> name.startsWith(<span class="string">&quot;set&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>PropertyCopier</strong></p><p><code>PropertyCopier</code>是一个属性拷贝的工具类，核心方法是<code>copyBeanProperties()</code>方法，主要实现相同类型的两个对象之间的属性值拷贝，具体如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">PropertyCopier</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">PropertyCopier</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Prevent Instantiation of Static Class</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">copyBeanProperties</span><span class="params">(Class&lt;?&gt; type, Object sourceBean, Object destinationBean)</span> </span>&#123;</span><br><span class="line">    Class&lt;?&gt; parent = type;</span><br><span class="line">    <span class="keyword">while</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">final</span> Field[] fields = parent.getDeclaredFields();</span><br><span class="line">      <span class="keyword">for</span>(Field field : fields) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">          field.set(destinationBean, field.get(sourceBean));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">          <span class="comment">// Nothing useful to do, will only fail on final fields, which will be ignored.</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 继续拷贝父类中定义的字段</span></span><br><span class="line">      parent = parent.getSuperclass();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="MetaClass"><a href="#MetaClass" class="headerlink" title="MetaClass"></a>MetaClass</h4><p><code>org.apache.ibatis.reflection.MetaClass</code> ，类的元数据，基于 Reflector 和 PropertyTokenizer ，提供对指定类的各种骚操作。实现了对复杂的属性表达式的解析，并实现了获取指定属性描述信息的功能。</p><p>代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MetaClass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 用于缓存Reflector对象</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ReflectorFactory reflectorFactory;</span><br><span class="line">  <span class="comment">// 创建MetaClass时会指定一个类，该Reflector对象会用于记录该类相关的元信息</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Reflector reflector;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// MetaClass的构造方法是使用private修饰的</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">MetaClass</span><span class="params">(Class&lt;?&gt; type, ReflectorFactory reflectorFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.reflectorFactory = reflectorFactory;</span><br><span class="line">    <span class="comment">// 创建Reflector对象</span></span><br><span class="line">    <span class="keyword">this</span>.reflector = reflectorFactory.findForClass(type);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 使用静态方法创建MetaClass对象</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> MetaClass <span class="title">forClass</span><span class="params">(Class&lt;?&gt; type, ReflectorFactory reflectorFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MetaClass(type, reflectorFactory);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> MetaClass <span class="title">metaClassForProperty</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    Class&lt;?&gt; propType = reflector.getGetterType(name);</span><br><span class="line">    <span class="keyword">return</span> MetaClass.forClass(propType, reflectorFactory);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">findProperty</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 委托给buildProperty()方法实现</span></span><br><span class="line">    StringBuilder prop = buildProperty(name, <span class="keyword">new</span> StringBuilder());</span><br><span class="line">    <span class="keyword">return</span> prop.length() &gt; <span class="number">0</span> ? prop.toString() : <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">findProperty</span><span class="params">(String name, <span class="keyword">boolean</span> useCamelCaseMapping)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (useCamelCaseMapping) &#123;</span><br><span class="line">      name = name.replace(<span class="string">&quot;_&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> findProperty(name);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> String[] getGetterNames() &#123;</span><br><span class="line">    <span class="keyword">return</span> reflector.getGetablePropertyNames();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> String[] getSetterNames() &#123;</span><br><span class="line">    <span class="keyword">return</span> reflector.getSetablePropertyNames();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> Class&lt;?&gt; getSetterType(String name) &#123;</span><br><span class="line">    PropertyTokenizer prop = <span class="keyword">new</span> PropertyTokenizer(name);</span><br><span class="line">    <span class="keyword">if</span> (prop.hasNext()) &#123;</span><br><span class="line">      MetaClass metaProp = metaClassForProperty(prop.getName());</span><br><span class="line">      <span class="keyword">return</span> metaProp.getSetterType(prop.getChildren());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> reflector.getSetterType(prop.getName());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> Class&lt;?&gt; getGetterType(String name) &#123;</span><br><span class="line">    PropertyTokenizer prop = <span class="keyword">new</span> PropertyTokenizer(name);</span><br><span class="line">    <span class="keyword">if</span> (prop.hasNext()) &#123;</span><br><span class="line">      MetaClass metaProp = metaClassForProperty(prop);</span><br><span class="line">      <span class="keyword">return</span> metaProp.getGetterType(prop.getChildren());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// issue #506. Resolve the type inside a Collection Object</span></span><br><span class="line">    <span class="keyword">return</span> getGetterType(prop);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> MetaClass <span class="title">metaClassForProperty</span><span class="params">(PropertyTokenizer prop)</span> </span>&#123;</span><br><span class="line">    Class&lt;?&gt; propType = getGetterType(prop);</span><br><span class="line">    <span class="keyword">return</span> MetaClass.forClass(propType, reflectorFactory);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Class&lt;?&gt; getGetterType(PropertyTokenizer prop) &#123;</span><br><span class="line">    Class&lt;?&gt; type = reflector.getGetterType(prop.getName());</span><br><span class="line">    <span class="keyword">if</span> (prop.getIndex() != <span class="keyword">null</span> &amp;&amp; Collection.class.isAssignableFrom(type)) &#123;</span><br><span class="line">      Type returnType = getGenericGetterType(prop.getName());</span><br><span class="line">      <span class="keyword">if</span> (returnType <span class="keyword">instanceof</span> ParameterizedType) &#123;</span><br><span class="line">        Type[] actualTypeArguments = ((ParameterizedType) returnType).getActualTypeArguments();</span><br><span class="line">        <span class="keyword">if</span> (actualTypeArguments != <span class="keyword">null</span> &amp;&amp; actualTypeArguments.length == <span class="number">1</span>) &#123;</span><br><span class="line">          returnType = actualTypeArguments[<span class="number">0</span>];</span><br><span class="line">          <span class="keyword">if</span> (returnType <span class="keyword">instanceof</span> Class) &#123;</span><br><span class="line">            type = (Class&lt;?&gt;) returnType;</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (returnType <span class="keyword">instanceof</span> ParameterizedType) &#123;</span><br><span class="line">            type = (Class&lt;?&gt;) ((ParameterizedType) returnType).getRawType();</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> type;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> Type <span class="title">getGenericGetterType</span><span class="params">(String propertyName)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      Invoker invoker = reflector.getGetInvoker(propertyName);</span><br><span class="line">      <span class="keyword">if</span> (invoker <span class="keyword">instanceof</span> MethodInvoker) &#123;</span><br><span class="line">        Field _method = MethodInvoker.class.getDeclaredField(<span class="string">&quot;method&quot;</span>);</span><br><span class="line">        _method.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        Method method = (Method) _method.get(invoker);</span><br><span class="line">        <span class="keyword">return</span> TypeParameterResolver.resolveReturnType(method, reflector.getType());</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (invoker <span class="keyword">instanceof</span> GetFieldInvoker) &#123;</span><br><span class="line">        Field _field = GetFieldInvoker.class.getDeclaredField(<span class="string">&quot;field&quot;</span>);</span><br><span class="line">        _field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        Field field = (Field) _field.get(invoker);</span><br><span class="line">        <span class="keyword">return</span> TypeParameterResolver.resolveFieldType(field, reflector.getType());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchFieldException e) &#123;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasSetter</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    PropertyTokenizer prop = <span class="keyword">new</span> PropertyTokenizer(name);</span><br><span class="line">    <span class="keyword">if</span> (prop.hasNext()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (reflector.hasSetter(prop.getName())) &#123;</span><br><span class="line">        MetaClass metaProp = metaClassForProperty(prop.getName());</span><br><span class="line">        <span class="keyword">return</span> metaProp.hasSetter(prop.getChildren());</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> reflector.hasSetter(prop.getName());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断指定属性是否有 getting 方法</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasGetter</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    PropertyTokenizer prop = <span class="keyword">new</span> PropertyTokenizer(name);</span><br><span class="line">    <span class="keyword">if</span> (prop.hasNext()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (reflector.hasGetter(prop.getName())) &#123;</span><br><span class="line">        MetaClass metaProp = metaClassForProperty(prop);</span><br><span class="line">        <span class="keyword">return</span> metaProp.hasGetter(prop.getChildren());</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> reflector.hasGetter(prop.getName());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Invoker <span class="title">getGetInvoker</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> reflector.getGetInvoker(name);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Invoker <span class="title">getSetInvoker</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> reflector.getSetInvoker(name);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> StringBuilder <span class="title">buildProperty</span><span class="params">(String name, StringBuilder builder)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 解析属性表达式</span></span><br><span class="line">    PropertyTokenizer prop = <span class="keyword">new</span> PropertyTokenizer(name);</span><br><span class="line">    <span class="keyword">if</span> (prop.hasNext()) &#123; <span class="comment">// 是否还有子表达式</span></span><br><span class="line">      <span class="comment">// 查找Propertytokenizer.name对应的属性</span></span><br><span class="line">      String propertyName = reflector.findPropertyName(prop.getName());</span><br><span class="line">      <span class="keyword">if</span> (propertyName != <span class="keyword">null</span>) &#123;</span><br><span class="line">        builder.append(propertyName);</span><br><span class="line">        builder.append(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">        <span class="comment">// 为该属性创建对应的MetaClass对象</span></span><br><span class="line">        MetaClass metaProp = metaClassForProperty(propertyName);</span><br><span class="line">        <span class="comment">// 递归解析children字段，将解析结果添加到builder中保存</span></span><br><span class="line">        metaProp.buildProperty(prop.getChildren(), builder);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 递归出口</span></span><br><span class="line">      String propertyName = reflector.findPropertyName(name);</span><br><span class="line">      <span class="keyword">if</span> (propertyName != <span class="keyword">null</span>) &#123;</span><br><span class="line">        builder.append(propertyName);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> builder;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasDefaultConstructor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> reflector.hasDefaultConstructor();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>MetaClass中比较重要的是findProperty()，它是通过调用MetaClass.buildProperty()方法实现的， 二buildProperty()方法会通过PropertyTokenizer解析复杂的属性表达式</strong></li></ul><h4 id="ObjectWrapper"><a href="#ObjectWrapper" class="headerlink" title="ObjectWrapper"></a>ObjectWrapper</h4><p><code>MetaClass</code>是Mybatis对类级别的元信息的封装和处理，下面来看MyBatis对对象级别的元信息的处理。<code>ObjectWrapper</code>接口是对对象的包装，抽象了对象的属性信息，它定义了一系列查询对象属性信息的方法，以及更新属性的方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ObjectWrapper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果ObjectWrapper中封装的是普通的Bean对象，则调用相应属性的相应getter方法，</span></span><br><span class="line">  <span class="comment">// 如果封装的是集合类，则获取指定key或下标对应的value值</span></span><br><span class="line">  <span class="function">Object <span class="title">get</span><span class="params">(PropertyTokenizer prop)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果ObjectWrapper中封装的是普通的Bean对象，则调用相应的setter方法</span></span><br><span class="line">  <span class="comment">// 如果封装的是集合类，则设置指定key或下标对应的value值</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(PropertyTokenizer prop, Object value)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 查找属性表达式指定的属性，第二个参数表示是否忽略属性表达式中的下划线</span></span><br><span class="line">  <span class="function">String <span class="title">findProperty</span><span class="params">(String name, <span class="keyword">boolean</span> useCamelCaseMapping)</span></span>;</span><br><span class="line"></span><br><span class="line">  String[] getGetterNames();</span><br><span class="line"></span><br><span class="line">  String[] getSetterNames();</span><br><span class="line"></span><br><span class="line">  Class&lt;?&gt; getSetterType(String name);</span><br><span class="line"></span><br><span class="line">  Class&lt;?&gt; getGetterType(String name);</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">hasSetter</span><span class="params">(String name)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">hasGetter</span><span class="params">(String name)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 为属性表达式的属性创建相应的MetaObject对象</span></span><br><span class="line">  <span class="function">MetaObject <span class="title">instantiatePropertyValue</span><span class="params">(String name, PropertyTokenizer prop, ObjectFactory objectFactory)</span></span>;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">isCollection</span><span class="params">()</span></span>;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(Object element)</span></span>;</span><br><span class="line">  </span><br><span class="line">  &lt;E&gt; <span class="function"><span class="keyword">void</span> <span class="title">addAll</span><span class="params">(List&lt;E&gt; element)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ObjectWrapperFactory负责创建ObjectWrapper对象。</p><p><img src="https://gitee.com/cayzlh/img-repo/raw/master/2020/06/07/image-20200607105809062_CxBOIT.png" alt="image-20200607105809062"></p><p><code>DefaultObjectWrapperFactory</code>实 现 了 <code>ObjectWrapperFactory</code>接口，但它 实 现 的 <code>getWrapperFor()</code> 方法始终 抛出异 常，<code>hasWrapperFor()</code>方法始终 返回false，所以该 实 现 实 际 上是不可用的。但是 与 ObjectFactory 类 似，我们 可以在 mybatis-config.xml 中配置自定义 的 ObjectWrapperFactory 实 现 类 进 行扩 展，在后面介绍 MyBatis初始化时 还 会 提到该 扩 展点。</p><p><code>BaseWrapper</code>是一个实现了<code>ObjectWrapper</code>接口的抽象类，其中封装了<code>MetaObject</code>对象，并提供了三个方勇的方法提供其子类使用：</p><p><img src="https://gitee.com/cayzlh/img-repo/raw/master/2020/06/07/image-20200607110710849_oIM782.png" alt="image-20200607110710849"></p><p>BaseWrapper,resolveCollection()方法会 调 用 MetaObject.get Value()方法，它 会 解析属 性表达 式并 获 取指定的属 性。</p><p>BaseWrapper.getCollectionValue()方法和 setCollectionValue()方法会 解析属 性表达 式的索引 信息，然后获 取/设 置对 应 项 。</p><h4 id="MetaObject"><a href="#MetaObject" class="headerlink" title="MetaObject"></a>MetaObject</h4><p><code>org.apache.ibatis.reflection.MetaObject</code> ，对象元数据，提供了对象的属性值的获得和设置等等方法。 可以理解成，对 BaseWrapper 操作的进一步<strong>增强</strong>。</p><blockquote><p>ObjectWrapper提供了获取/设置对象中指定的属性值、检测getter/setter等常用功能，但是ObjectWrapper只是这些功能的最后一站，我们省略了对属性表达式解析过程的介绍，而该解析过程是在MetaObject中实现的。</p></blockquote><p><strong>MetaObject</strong>中字段的含义：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 原始JavaBean对象</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Object originalObject;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上文介绍的ObjectWrapper对象，其中封装了originalObject对象</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ObjectWrapper objectWrapper;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 负责实例化originalObject的工厂对象</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ObjectFactory objectFactory;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 负责创建ObjectWrapper的工厂对象</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ObjectWrapperFactory objectWrapperFactory;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于创建并缓存Reflector对象的工厂对象</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReflectorFactory reflectorFactory;</span><br></pre></td></tr></table></figure><p><strong>MetaObject的构造方法</strong>会根据传入的原始对象的类型以及ObjectFactory工厂的实现， 创建相应的ObjectWrapper对象：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">MetaObject</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  Object object, ObjectFactory objectFactory, ObjectWrapperFactory objectWrapperFactory, ReflectorFactory reflectorFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.originalObject = object;</span><br><span class="line">    <span class="keyword">this</span>.objectFactory = objectFactory;</span><br><span class="line">    <span class="keyword">this</span>.objectWrapperFactory = objectWrapperFactory;</span><br><span class="line">    <span class="keyword">this</span>.reflectorFactory = reflectorFactory;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (object <span class="keyword">instanceof</span> ObjectWrapper) &#123;</span><br><span class="line">      <span class="keyword">this</span>.objectWrapper = (ObjectWrapper) object;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (objectWrapperFactory.hasWrapperFor(object)) &#123;</span><br><span class="line">      <span class="keyword">this</span>.objectWrapper = objectWrapperFactory.getWrapperFor(<span class="keyword">this</span>, object);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (object <span class="keyword">instanceof</span> Map) &#123;</span><br><span class="line">      <span class="keyword">this</span>.objectWrapper = <span class="keyword">new</span> MapWrapper(<span class="keyword">this</span>, (Map) object);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (object <span class="keyword">instanceof</span> Collection) &#123;</span><br><span class="line">      <span class="keyword">this</span>.objectWrapper = <span class="keyword">new</span> CollectionWrapper(<span class="keyword">this</span>, (Collection) object);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.objectWrapper = <span class="keyword">new</span> BeanWrapper(<span class="keyword">this</span>, object);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>MetaObject和ObjectWrapper中关于类级别的方法，例如hasGetter()、hasSetter()、findProperty()等方法，都是直接调用MetaClass的对应方法实现的。</p><p>其他方法都是关于对象级别的方法，这些方法都是与ObjectWrapper配合实现，例如MetaObject.getValue()/setValue()方法。</p><p>以下是getValue()的代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getValue</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    PropertyTokenizer prop = <span class="keyword">new</span> PropertyTokenizer(name);</span><br><span class="line">    <span class="keyword">if</span> (prop.hasNext()) &#123;</span><br><span class="line">      <span class="comment">// 根据PropertyTokenizer解析后指定的属性，创建相应的MetaObject对象</span></span><br><span class="line">      MetaObject metaValue = metaObjectForProperty(prop.getIndexedName());</span><br><span class="line">      <span class="keyword">if</span> (metaValue == SystemMetaObject.NULL_META_OBJECT) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> metaValue.getValue(prop.getChildren());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> objectWrapper.get(prop);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><p>JDBC数据类型与Java语言中的数据类型并不是完全对应的，所以在PreparedStatement为SQL语句绑定参数时，需要从Java类型转换成JDBC类型，而从结果集获取数据的时候，则需要从JDBC类型转换成Java类型。</p><p>MyBatis使用类型转换处理器完车过了上述两种转换。</p><p><img src="https://gitee.com/cayzlh/img-repo/raw/master/2020/06/07/image-20200607224820211_lIdG1a.png" alt="image-20200607224820211"></p><blockquote><p>在 MyBatis中使用JdbcType这 个 枚举 类 型代表JDBC中的数 据类 型，该 枚举 类 型中定义 了 TYPE_CODE字段，记 录 了 JDBC类 型在java.sql.Types中相应 的常量 编 码 ，并 通过 一个 静 态 集合codeLookup (HashMap&lt;Integer，JdbcType&gt;类 型)维 护 了常量编 码 与JdbcType之间的对应关系。</p></blockquote><h4 id="TypeHandler"><a href="#TypeHandler" class="headerlink" title="TypeHandler"></a>TypeHandler</h4><p>MyBatis中所有的类 型转 换 器都继 承了 TypeHandler接口，在 TypeHandler接口中定义 了如 下四个 方法，这 四个 方法分为 两 类 :setParameter()方法负 责 将 数 据由JdbcType类 型转 换 成Java 类 型:<code>getResult()</code>方法及其重载 负 责 将 数 据由Java类 型转 换 成JdbcType类 型。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TypeHandler</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//在通过 PreparedStatement为 SQL语 句绑 定参 数 时 ，会 将 数 据由JdbcType类 型转 换 成Java类 型</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">setParameter</span><span class="params">(PreparedStatement ps, <span class="keyword">int</span> i, T parameter, JdbcType jdbcType)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line">  </span><br><span class="line"><span class="comment">//从 ResultSet中获 取数 据时 会 调 用此方法，会 将 数 据由Java类 型转 换 成JdbcType类 型</span></span><br><span class="line">  <span class="function">T <span class="title">getResult</span><span class="params">(ResultSet rs, String columnName)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">T <span class="title">getResult</span><span class="params">(ResultSet rs, <span class="keyword">int</span> columnIndex)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">T <span class="title">getResult</span><span class="params">(CallableStatement cs, <span class="keyword">int</span> columnIndex)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了方便用户自定义TypeHandler实现，MyBatis提供了BaseTypeHandler这个抽象类，它实现了TypeHandler接口，并继承了TypeReference抽象类，其继承结构如下：</p><p><img src="https://gitee.com/cayzlh/img-repo/raw/master/2020/06/07/image-20200607225857225_4Xvffn.png" alt="image-20200607225857225"></p><p>在BaseTypeHandler中实现了<code>TypeHandler.setParameter()</code>方法和<code>TypeHandler.getResult()</code>方法，具体实现如下。需要注意的是，这两个方法对于非空数据的处理都交给了子类实现。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseTypeHandler</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">TypeReference</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">TypeHandler</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span> Configuration configuration;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setConfiguration</span><span class="params">(Configuration c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.configuration = c;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setParameter</span><span class="params">(PreparedStatement ps, <span class="keyword">int</span> i, T parameter, JdbcType jdbcType)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (parameter == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (jdbcType == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> TypeException(<span class="string">&quot;JDBC requires that the JdbcType must be specified for all nullable parameters.&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        ps.setNull(i, jdbcType.TYPE_CODE);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> TypeException(<span class="string">&quot;Error setting null for parameter #&quot;</span> + i + <span class="string">&quot; with JdbcType &quot;</span> + jdbcType + <span class="string">&quot; . &quot;</span> +</span><br><span class="line">                <span class="string">&quot;Try setting a different JdbcType for this parameter or a different jdbcTypeForNull configuration property. &quot;</span> +</span><br><span class="line">                <span class="string">&quot;Cause: &quot;</span> + e, e);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        setNonNullParameter(ps, i, parameter, jdbcType);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> TypeException(<span class="string">&quot;Error setting non null for parameter #&quot;</span> + i + <span class="string">&quot; with JdbcType &quot;</span> + jdbcType + <span class="string">&quot; . &quot;</span> +</span><br><span class="line">                <span class="string">&quot;Try setting a different JdbcType for this parameter or a different configuration property. &quot;</span> +</span><br><span class="line">                <span class="string">&quot;Cause: &quot;</span> + e, e);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> T <span class="title">getResult</span><span class="params">(ResultSet rs, String columnName)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    T result;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      result = getNullableResult(rs, columnName);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> ResultMapException(<span class="string">&quot;Error attempting to get column &#x27;&quot;</span> + columnName + <span class="string">&quot;&#x27; from result set.  Cause: &quot;</span> + e, e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (rs.wasNull()) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> T <span class="title">getResult</span><span class="params">(ResultSet rs, <span class="keyword">int</span> columnIndex)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    T result;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      result = getNullableResult(rs, columnIndex);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> ResultMapException(<span class="string">&quot;Error attempting to get column #&quot;</span> + columnIndex+ <span class="string">&quot; from result set.  Cause: &quot;</span> + e, e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (rs.wasNull()) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> T <span class="title">getResult</span><span class="params">(CallableStatement cs, <span class="keyword">int</span> columnIndex)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    T result;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      result = getNullableResult(cs, columnIndex);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> ResultMapException(<span class="string">&quot;Error attempting to get column #&quot;</span> + columnIndex+ <span class="string">&quot; from callable statement.  Cause: &quot;</span> + e, e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (cs.wasNull()) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">setNonNullParameter</span><span class="params">(PreparedStatement ps, <span class="keyword">int</span> i, T parameter, JdbcType jdbcType)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> T <span class="title">getNullableResult</span><span class="params">(ResultSet rs, String columnName)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> T <span class="title">getNullableResult</span><span class="params">(ResultSet rs, <span class="keyword">int</span> columnIndex)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> T <span class="title">getNullableResult</span><span class="params">(CallableStatement cs, <span class="keyword">int</span> columnIndex)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一般情况下， TypeHandler用于完成单个参数以及单个列值的类型转换， 如果存在多列值转换成一个Java对象的需求，应该优先考虑在使用映射文件中定义合适的映射规则（<resultMap>）完成映射。</p><h4 id="TypeHandlerRegistry"><a href="#TypeHandlerRegistry" class="headerlink" title="TypeHandlerRegistry"></a>TypeHandlerRegistry</h4><p>介绍完TypeHandler接口及其功能之后，MyBatis如何管理众多的TypeHanlder接口实现，如何知道何时使用哪个TypeHandler接口实现完成转换呢？</p><p>这个工作是由TypeHandlerRegistry完成的，在MyBatis初始化过程中，会为所有已知的TypeHanlder创建对象，并实现注册到TypeHandlerRegistry中， 由TypeHandlerRegistry负责管理这些TypeHandler对象。</p><p><strong>TypeHandlerRegistry</strong>中核心字段的含义：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 记录JdbcType与TypeHandler之间的对应关系，其中JdbcType是一个枚举类型，它定义对应的JDBC类型</span></span><br><span class="line"><span class="comment">// 该集合主要用于从结果集读取数据时，将数据从Jdbc类型转换成Java类型</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;JdbcType, TypeHandler&lt;?&gt;&gt; JDBC_TYPE_HANDLER_MAP = </span><br><span class="line">  <span class="keyword">new</span> EnumMap&lt;JdbcType, TypeHandler&lt;?&gt;&gt;(JdbcType.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 记录了Java类型向指定JdbcType转换时，需要使用的TypeHandler对象。</span></span><br><span class="line"><span class="comment">// 例如Java类型中的String可能转换成数据库的char、varchar等多种类型，所以存在一对多关系</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Type, Map&lt;JdbcType, TypeHandler&lt;?&gt;&gt;&gt; TYPE_HANDLER_MAP = </span><br><span class="line">  <span class="keyword">new</span> ConcurrentHashMap&lt;Type, Map&lt;JdbcType, TypeHandler&lt;?&gt;&gt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 记录了全部TypeHandler的类型以及该类型相应的TypeHandler对象</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> TypeHandler&lt;Object&gt; UNKNOWN_TYPE_HANDLER = </span><br><span class="line">  <span class="keyword">new</span> UnknownTypeHandler(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 空TypeHandler集合的标识</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Class&lt;?&gt;, TypeHandler&lt;?&gt;&gt; ALL_TYPE_HANDLERS_MAP = </span><br><span class="line">  <span class="keyword">new</span> HashMap&lt;Class&lt;?&gt;, TypeHandler&lt;?&gt;&gt;();</span><br></pre></td></tr></table></figure><p><strong>1. 注册TypeHandler对象</strong></p><p>TypeHandlerRegistry.register()方法实 现 了注册 TypeHandler对 象的功能，该 注册 过 程会 向上 述四个 集合中添加TypeHandler对 象。register()方法有多个 重载 ，这 些重载 之间 的调 用关 系如图 。</p><p><img src="https://gitee.com/cayzlh/img-repo/raw/master/2020/06/07/image-20200607231443963_Zd5zVS.png" alt="image-20200607231443963"></p><p>从 上图中可以看出，多数 register()方法最终 会 调 用重载(4) 完成注册 功能，先来看该方法的实现，其三个 参 数 分别 指定了 TypeHandler能够 处 理的Java类 型、Jdbc类 型以及 TypeHandler对 象。</p><p>重载(4)</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(Type javaType, JdbcType jdbcType, TypeHandler&lt;?&gt; handler)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (javaType != <span class="keyword">null</span>) &#123;<span class="comment">// 检测是否明确指定了TypeHanlder能够处理的Java类型</span></span><br><span class="line">    <span class="comment">// 获取指定java类型在TYPE_HANDLER_MAP集合中对应TypeHanlder集合</span></span><br><span class="line">    Map&lt;JdbcType, TypeHandler&lt;?&gt;&gt; map = TYPE_HANDLER_MAP.get(javaType);</span><br><span class="line">    <span class="keyword">if</span> (map == <span class="keyword">null</span> || map == NULL_TYPE_HANDLER_MAP) &#123;</span><br><span class="line">      <span class="comment">// 创建新的TypeHandler集合，并添加到TYPE_HANDLER_MAP中</span></span><br><span class="line">      map = <span class="keyword">new</span> HashMap&lt;JdbcType, TypeHandler&lt;?&gt;&gt;();</span><br><span class="line">      TYPE_HANDLER_MAP.put(javaType, map);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将TypeHandler对象注册到并添加到TYPE_HANDLER_MAP中</span></span><br><span class="line">    map.put(jdbcType, handler);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 向ALL_TYPE_HANDLERS_MAP集合注册TypeHandler类型和对应的TypeHanlder对象</span></span><br><span class="line">  ALL_TYPE_HANDLERS_MAP.put(handler.getClass(), handler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在(1)〜(3)这 三个 <code>register()</code>方法重载 中会 尝 试 读 取<code>TypeHandler</code>类 中定义 的<code>@MappedTypes</code> 注解和<code>@MappedJdbcTypes</code>注解，<code>@MappedTypes</code>注解用于指明该 <code>TypeHandler</code>实 现 类 能够 处 理 的Java类 型的集合，<code>@MappedJdbcTypes</code>注解用于指明该 <code>TypeHandler</code>实 现 类 能够 处 理的JDBC 类 型集合。<code>register()</code>方法的重载(1)〜(3)的具体 实 现 如下:</p><p>重载(1)</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Only handler type</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(Class&lt;?&gt; typeHandlerClass)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">boolean</span> mappedTypeFound = <span class="keyword">false</span>;</span><br><span class="line">  MappedTypes mappedTypes = typeHandlerClass.getAnnotation(MappedTypes.class);</span><br><span class="line">  <span class="keyword">if</span> (mappedTypes != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (Class&lt;?&gt; javaTypeClass : mappedTypes.value()) &#123;</span><br><span class="line">      register(javaTypeClass, typeHandlerClass);</span><br><span class="line">      mappedTypeFound = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!mappedTypeFound) &#123;</span><br><span class="line">    register(getInstance(<span class="keyword">null</span>, typeHandlerClass));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重载(2)</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">register</span><span class="params">(TypeHandler&lt;T&gt; typeHandler)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">boolean</span> mappedTypeFound = <span class="keyword">false</span>;</span><br><span class="line">  MappedTypes mappedTypes = typeHandler.getClass().getAnnotation(MappedTypes.class);</span><br><span class="line">  <span class="keyword">if</span> (mappedTypes != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (Class&lt;?&gt; handledType : mappedTypes.value()) &#123;</span><br><span class="line">      register(handledType, typeHandler);</span><br><span class="line">      mappedTypeFound = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// @since 3.1.0 - try to auto-discover the mapped type</span></span><br><span class="line">  <span class="keyword">if</span> (!mappedTypeFound &amp;&amp; typeHandler <span class="keyword">instanceof</span> TypeReference) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      TypeReference&lt;T&gt; typeReference = (TypeReference&lt;T&gt;) typeHandler;</span><br><span class="line">      register(typeReference.getRawType(), typeHandler);</span><br><span class="line">      mappedTypeFound = <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">      <span class="comment">// maybe users define the TypeReference with a different type and are not assignable, so just ignore it</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!mappedTypeFound) &#123;</span><br><span class="line">    register((Class&lt;T&gt;) <span class="keyword">null</span>, typeHandler);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重载(3)</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">register</span><span class="params">(Type javaType, TypeHandler&lt;? extends T&gt; typeHandler)</span> </span>&#123;</span><br><span class="line">  MappedJdbcTypes mappedJdbcTypes = typeHandler.getClass().getAnnotation(MappedJdbcTypes.class);</span><br><span class="line">  <span class="keyword">if</span> (mappedJdbcTypes != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (JdbcType handledJdbcType : mappedJdbcTypes.value()) &#123;</span><br><span class="line">      register(javaType, handledJdbcType, typeHandler);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mappedJdbcTypes.includeNullJdbcType()) &#123;</span><br><span class="line">      register(javaType, <span class="keyword">null</span>, typeHandler);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    register(javaType, <span class="keyword">null</span>, typeHandler);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上 述 全 部 的 <code>register()</code>方 法 重 载 都 是 在 向 <code>TYPE_HANDLER_MAP</code>集 合 和 <code>ALL_TYPE_HANDLERS_MAP</code> 集合注册 <code>TypeHandler</code> 对 象，而重载(5)是向 <code>JDBC_TYPE_HANDLER_MAP</code> 集合注册 <code>TypeHandler</code>对 象，其具体 实 现 如下:</p><p>重载(5)</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(JdbcType jdbcType, TypeHandler&lt;?&gt; handler)</span> </span>&#123;</span><br><span class="line">  JDBC_TYPE_HANDLER_MAP.put(jdbcType, handler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>TypeHandlerRegistry</code>除了提供注册 单 个 <code>TypeHandler的register()</code>重载 ，还 可以扫 描整个 包下 的<code>TypeHandler</code>接口实 现 类 ，并 将 完成这 些<code>TypeHandler</code>实 现 类 的注册 。</p><p>重载(6)</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(String packageName)</span> </span>&#123;</span><br><span class="line">  ResolverUtil&lt;Class&lt;?&gt;&gt; resolverUtil = <span class="keyword">new</span> ResolverUtil&lt;Class&lt;?&gt;&gt;();</span><br><span class="line">  <span class="comment">// 查找指定包下的接口实现类</span></span><br><span class="line">  resolverUtil.find(<span class="keyword">new</span> ResolverUtil.IsA(TypeHandler.class), packageName);</span><br><span class="line">  Set&lt;Class&lt;? extends Class&lt;?&gt;&gt;&gt; handlerSet = resolverUtil.getClasses();</span><br><span class="line">  <span class="keyword">for</span> (Class&lt;?&gt; type : handlerSet) &#123;</span><br><span class="line">    <span class="comment">//Ignore inner classes and interfaces (including package-info.java) and abstract classes</span></span><br><span class="line">    <span class="keyword">if</span> (!type.isAnonymousClass() &amp;&amp; !type.isInterface() &amp;&amp; !Modifier.isAbstract(type.getModifiers())) &#123;</span><br><span class="line">      register(type);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2. 查找TypeHandler</strong></p><p><code>TypeHandlerRegistry</code>提供了查 找 <code>TypeHandler</code>对 象的功能。<code>TypeHandlerRegistry.getTypeHandler()</code>方法实 现 了从 上述四个 集合中获 取对 应 <code>TypeHandler</code>对 象的功能。TypeHandlerRegistry.getTypeHandler()方法有多个 重载 ，这 些重 载 之间 的关 系如下图所示。</p><p><img src="https://gitee.com/cayzlh/img-repo/raw/master/2020/06/08/image-20200608163219733_jqTbhc.png" alt="image-20200608163219733"></p><p>经 过 一系列类 型转 换 之后，<code>TypeHandlerRegistry.getTypeHandler()</code>方法的多个 重载 都会 调 用 <code>TypeHandlerRegistry.getTypeHandle(Type, JdbcType)</code>这 个 重载 方法，它 会 根据指定的 Java 类 型和 JdbcType类 型查 找 相应 的TypeHandler对 象。</p><h4 id="TypeAliasRegistry"><a href="#TypeAliasRegistry" class="headerlink" title="TypeAliasRegistry"></a>TypeAliasRegistry</h4><p>在编 写 SQL语 句时 ，使用别 名可以方便理解以及维 护 ，例如表名或列名很 长 时 ，我们 一般 会 为 其设 计 易懂 易维 护 的别 名。MyBatis将 SQL语 句中别 名的概 念进 行了延伸和扩 展，MyBatis 可以为 一个 类 添加一个 别 名，之后就可以通过 别 名引用该 类 。</p><p><code>MyBatis</code>通过 <code>TypeAliasRegistry</code>类 完成别 名注册 和管理的功能，<code>TypeAliasRegistry</code>的结 构 比 较 简 单 ，它 通过 <code>TYPE_ALIASES</code>字段(<code>Map&lt;String，Class&lt;?&gt;&gt;</code>类 型)管理别 名与 Java类 型之间 的对 应 关 系，通过 <code>TypeAHasRegistiy.registerAlias()</code>方法完成注册 别 名，该 方法的具体 实 现 如下:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerAlias</span><span class="params">(String alias, Class&lt;?&gt; value)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (alias == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> TypeException(<span class="string">&quot;The parameter alias cannot be null&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将别名转换成小写</span></span><br><span class="line">  String key = alias.toLowerCase(Locale.ENGLISH);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 检测别名是否存在</span></span><br><span class="line">  <span class="keyword">if</span> (TYPE_ALIASES.containsKey(key) </span><br><span class="line">      &amp;&amp; TYPE_ALIASES.get(key) != <span class="keyword">null</span> </span><br><span class="line">      &amp;&amp; !TYPE_ALIASES.get(key).equals(value)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> TypeException(<span class="string">&quot;...&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  TYPE_ALIASES.put(key, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在 <code>TypeAliasRegistry</code>的构 造方法中，默认 为 Java的基本类 型及其数 组 类 型、基本类 型的封 装 类 及其数组类型、Date、BigDecimal、Biglnteger、Map、HashMap、List、ArrayList、Collection、 Iterator、ResultSet等类 型添加了别名。</p></blockquote><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><p><strong>《MyBatis技术内幕》</strong></p></li><li><p>部分图片来源——<strong>《MyBatis技术内幕》</strong></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 书籍 </category>
          
          <category> 《MyBatis技术内幕》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MyBatis </tag>
            
            <tag> 《MyBatis技术内幕》 </tag>
            
            <tag> 基础支持层 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基础支持层——解析器模块</title>
      <link href="/blog/2019/10/24/94150c5.html"/>
      <url>/blog/2019/10/24/94150c5.html</url>
      
        <content type="html"><![CDATA[<p>MyBatis基础支持层位于 Mybatis 整体架构的最底层，支撑着 Mybatis 的核心处理层，是整个框架的基石。基础支持层中封装了多个较为通用的、独立的模块，不仅仅为 Mybatis 提供基础支撑，也可以在合适的场景中直接复用。</p><p><img src="https://cdn.jsdelivr.net/gh/cayzlh/git-img-repository@master/2020/05/21/2_c5SKkm.png" alt="整体架构"></p><blockquote><p>这篇文章介绍MyBatis的解析器模块</p></blockquote><p><code>Mybatis</code>中涉及大量的<code>XML</code>配置文件，常见的<code>XML</code>解析方式：<strong>DOM、SAX和StAX。</strong></p><h3 id="XPath简介"><a href="#XPath简介" class="headerlink" title="XPath简介"></a>XPath简介</h3><p><code>MyBatis</code>在初始化过 程中处 理<code>mybatis-config.xml</code>配置文件以及映射文件时 ，使用的是<code>DOM</code> 解析方式，并 结 合使用<code>XPath</code>解析<code>XML</code>配置文件。</p><p>正如前文所述，<code>DOM</code>会将整个 <code>XML</code>文档 加载 到内 存中并 形成树状数据结构 ，而 <code>XPath</code>是一种 为 查 询 <code>XML</code>文档 而设 计 的语 言，它 可以 与 <code>DOM</code>解析方式配合使用，实 现 对 <code>XML</code>文档 的解析。</p><blockquote><p>Xpath 之于 XML 就好比 SQL 语言之于数据库。</p></blockquote><h3 id="XPathParser"><a href="#XPathParser" class="headerlink" title="XPathParser"></a>XPathParser</h3><p><code>Mybatis</code> 提供的 <code>Xpathparser</code> 类封装了<code>Xpath</code>、<code>Document</code> 和<code> Entityresolver</code>。</p><p><img src="https://gitee.com/cayzlh/img-repo/raw/master/2020/06/06/7_2t67aF.png" alt="7"></p><p><code>Xpathparser</code> 中各个字段的含义和功能如下所示。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Document document; <span class="comment">// Document 对象 private boolean validation; //是否开启验证</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Entityresolver entityresolver; <span class="comment">//用于加载本地 DTD 文件</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Properties variables; <span class="comment">// mybatis- config. Xm1 中《propteries》标签定义的键值对集合 </span></span><br><span class="line"><span class="keyword">private</span> Xpath xpath; <span class="comment">// Xpath 对象</span></span><br></pre></td></tr></table></figure><p>默认情况下，对 <code>XML</code> 文档进行验证时，会根据 <code>XML</code> 文档开始位置指定的网址加载对应的 <code>DTD</code> 文件或 <code>XSD</code> 文件。</p><p>如果解析 <code>mybatis- config. Xml</code> 配置文件，默认联网加载 <code>http: / mybatis. Org, / dtd/mybatis-3- config. Dtd</code> 这个 <code>DTD</code> 文档，当网络比较慢时会导致验证过程缓慢。</p><p>在实践中往往会提前设置 <code>Entityresolver</code> 接口对象加载本地的 <code>DTD</code> 文件，从而避免联网加载 <code>DTD</code> 文件。</p><p><strong><code>Xmlmapperentity Resolver</code> 是 Mybatis 提供的 <code>Entity Resolver</code> 接口的实现类。</strong></p><p><img src="https://gitee.com/cayzlh/img-repo/raw/master/2020/06/06/8_sk1073.png" alt="8"></p><p><code>EntityResolver</code> 接口的核心是 <code>resolveEntity()</code>方法，<code>XMLMapperEntityResolver</code> 的实 现 如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XMLMapperEntityResolver</span> <span class="keyword">implements</span> <span class="title">EntityResolver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String IBATIS_CONFIG_SYSTEM = <span class="string">&quot;ibatis-3-config.dtd&quot;</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String IBATIS_MAPPER_SYSTEM = <span class="string">&quot;ibatis-3-mapper.dtd&quot;</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String MYBATIS_CONFIG_SYSTEM = <span class="string">&quot;mybatis-3-config.dtd&quot;</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String MYBATIS_MAPPER_SYSTEM = <span class="string">&quot;mybatis-3-mapper.dtd&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String MYBATIS_CONFIG_DTD </span><br><span class="line">    = <span class="string">&quot;org/apache/ibatis/builder/xml/mybatis-3-config.dtd&quot;</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String MYBATIS_MAPPER_DTD </span><br><span class="line">    = <span class="string">&quot;org/apache/ibatis/builder/xml/mybatis-3-mapper.dtd&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> InputSource <span class="title">resolveEntity</span><span class="params">(String publicId, String systemId)</span> <span class="keyword">throws</span> SAXException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (systemId != <span class="keyword">null</span>) &#123;</span><br><span class="line">        String lowerCaseSystemId = systemId.toLowerCase(Locale.ENGLISH);</span><br><span class="line">        <span class="keyword">if</span> (lowerCaseSystemId.contains(MYBATIS_CONFIG_SYSTEM) </span><br><span class="line">            || lowerCaseSystemId.contains(IBATIS_CONFIG_SYSTEM)) &#123;</span><br><span class="line">          <span class="keyword">return</span> getInputSource(MYBATIS_CONFIG_DTD, publicId, systemId);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (lowerCaseSystemId.contains(MYBATIS_MAPPER_SYSTEM) </span><br><span class="line">                   || lowerCaseSystemId.contains(IBATIS_MAPPER_SYSTEM)) &#123;</span><br><span class="line">          <span class="keyword">return</span> getInputSource(MYBATIS_MAPPER_DTD, publicId, systemId);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> SAXException(e.toString());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> InputSource <span class="title">getInputSource</span><span class="params">(String path, String publicId, String systemId)</span> </span>&#123;</span><br><span class="line">    InputSource source = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (path != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        InputStream in = Resources.getResourceAsStream(path);</span><br><span class="line">        source = <span class="keyword">new</span> InputSource(in);</span><br><span class="line">        source.setPublicId(publicId);</span><br><span class="line">        source.setSystemId(systemId);        </span><br><span class="line">      &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="comment">// ignore, null is ok</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> source;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>回到对 <code>XPathParser</code> 的 分 析 ，在 <code>XPathParser. createDocument()</code>方法中封装 了前面介绍 的创 建<code>Document</code>对 象的过 程并 触 发 了加载 <code>XML</code>文档 的 过 程，具体 实 现 如下:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">commonConstructor</span><span class="params">(<span class="keyword">boolean</span> validation, Properties variables, EntityResolver entityResolver)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.validation = validation;</span><br><span class="line">  <span class="keyword">this</span>.entityResolver = entityResolver;</span><br><span class="line">  <span class="keyword">this</span>.variables = variables;</span><br><span class="line">  XPathFactory factory = XPathFactory.newInstance();</span><br><span class="line">  <span class="keyword">this</span>.xpath = factory.newXPath();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Document <span class="title">createDocument</span><span class="params">(InputSource inputSource)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// important: this must only be called AFTER common constructor</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();</span><br><span class="line">    factory.setValidating(validation);</span><br><span class="line"></span><br><span class="line">    factory.setNamespaceAware(<span class="keyword">false</span>);</span><br><span class="line">    factory.setIgnoringComments(<span class="keyword">true</span>);</span><br><span class="line">    factory.setIgnoringElementContentWhitespace(<span class="keyword">false</span>);</span><br><span class="line">    factory.setCoalescing(<span class="keyword">false</span>);</span><br><span class="line">    factory.setExpandEntityReferences(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    DocumentBuilder builder = factory.newDocumentBuilder();</span><br><span class="line">    builder.setEntityResolver(entityResolver);</span><br><span class="line">    builder.setErrorHandler(<span class="keyword">new</span> ErrorHandler() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">error</span><span class="params">(SAXParseException exception)</span> <span class="keyword">throws</span> SAXException </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> exception;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fatalError</span><span class="params">(SAXParseException exception)</span> <span class="keyword">throws</span> SAXException </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> exception;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">warning</span><span class="params">(SAXParseException exception)</span> <span class="keyword">throws</span> SAXException </span>&#123;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> builder.parse(inputSource);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">&quot;Error creating document instance.  Cause: &quot;</span> + e, e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><code>Xpathparser</code> 中提供了一系列的 <code>eval*0</code> 方法用于解析 <code>boolean</code>、<code>shot</code>、<code>long</code>、<code>int</code>、<code>String</code>、<code>Node</code> 等类型的信息，它通过调用前面介绍的 <code>Xpath. Evaluate()</code> 方法查找指定路径的节点或属性，并进行相应的类型装换。具体代码比较简单，就不贴出来了。这里需要注意的是 <code>Xpathparser. Evalstring()</code> 方法，其中会调用 <code>Propertyparser. Parse()</code> 方法处理节点中相应的默认值。</p></li><li><p>在 <code>Propertyparser</code> 中指定了是否开启使用默认值的功能以及默认的分隔符</p></li><li><p><code>PropertyParser.parse()</code> 方法中会创建 <strong>Generic Tokenparser</strong> 解析器，并将默认值的处理委托给Generic <code>Tokenparser.parse()</code>方法。</p></li><li><p><strong>Generic Tokenparser</strong> 是一个通用的字占位符解析器，其字段的含义如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Private <span class="keyword">final</span> String opentoken; <span class="comment">//占位符的开始标记 </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String closetoken; <span class="comment">//占位符的结東标记</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Tokenhandler handler; <span class="comment">// Tokenhandler 接口的实现会按照一定的逻辑解析占位符</span></span><br></pre></td></tr></table></figure><p><code>GenericTokenparser.parse()</code> 方法的逻辑并不复杂，它会顺序查找 <code>openToken</code> 和 <code>closeToken</code>，解析得到占位符的字面值，并将其交给 <code>Tokenhandler</code> 处理，然后将解析结果重新拼装成字符串并返回。</p></li></ul><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><p><strong>《MyBatis技术内幕》</strong></p></li><li><p>部分图片来源——<strong>《MyBatis技术内幕》</strong></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 书籍 </category>
          
          <category> 《MyBatis技术内幕》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MyBatis </tag>
            
            <tag> 《MyBatis技术内幕》 </tag>
            
            <tag> 基础支持层 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MyBatis快速入门</title>
      <link href="/blog/2019/10/21/3f93d624.html"/>
      <url>/blog/2019/10/21/3f93d624.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>心血来潮，搞了本《MyBatis技术内幕》，整理一些核心内容</p></blockquote><p><strong>思维导图：</strong></p><p><img src="https://gitee.com/cayzlh/img-repo/raw/master/2020/06/09/1_3tUMVN.png" alt="1"></p><p><strong>整体架构：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cayzlh/git-img-repository@master/2020/05/21/2_c5SKkm.png" alt="整体架构"></p><h2 id="基础支持层"><a href="#基础支持层" class="headerlink" title="基础支持层"></a>基础支持层</h2><p>基础支持层包含整个 <code>Mybatis</code> 的基础模块，这些模块为核心处理层的功能提供了良好的支撑。</p><h3 id="反射模块"><a href="#反射模块" class="headerlink" title="反射模块"></a>反射模块</h3><p><code>Java</code> 中的反射虽然功能强大，但对大多数开发人员来说，写出高质量的反射代码还是</p><p>有一定难度的。<code>Mybatis</code>  中专门提供了反射模块，该模块对 <code>Java</code> 原生的反射进行了良好的封装，提供了更加简洁易用的 AP，方便上层使调用，并且对反射操作进行了系列优化，例如缓存了类的元数据，提高了反射操作的性能。</p><h3 id="类型转换模块"><a href="#类型转换模块" class="headerlink" title="类型转换模块"></a>类型转换模块</h3><p>正如前面示例所示，<code>Mybatis</code> 为简化配置文件提供了别名机制，该机制是类型转换模块的主要功能之一。</p><p>类型转换模块的另一个功能是实现 <code>JDBC</code> 类型与 <code>Java</code> 类型之间的转换，该功能在为 <code>SQL</code> 语句绑定实参以及映射查询结果集时都会涉及。在为 <code>SQL</code> 语句绑定实参时，会将数据由 <code>Java</code> 类型转换成 <code>JDBC</code> 类型；而在映射结果集时，会将数据由 <code>JDBC</code> 类型转换成 <code>Java</code> 类型。</p><p>###日志模块</p><p>无论在开发测试环境中，还是在线上生产环境中，日志在整个系统中的地位都是非常重要的。良好的日志功能可以帮助开发人员和测试人员快速定位 <code>Bug</code> 代码，也可以帮助运维人员快速定位性能瓶颈等问题。目前的 <code>Java</code> 世界中存在很多优秀的日志框架，例如 <code>Log4j</code>、<code>Log4j2</code>、<code>slf4</code> 等。<code>Mybatis</code> 作为一个设计优良的框架，除了提供详细的日志输出信息，还要能够集成多种日志框架，其日志模块的一个主要功能就是集成第三方日志框架。资源加载模块</p><p>资源加载模块主要是对类加载器进行封装，确定类加载器的使用顺序，并提供了加载类文件以及其他资源文件的功能。</p><h3 id="解析器模块"><a href="#解析器模块" class="headerlink" title="解析器模块"></a>解析器模块</h3><p>解析器模块的主要提供了两个功能：一个功能是对 Xpath 进行封装，为 <code>Mybatis</code> 初始化时解析 mybatis-config, xml 配置文件以及映射配置文件提供支持；另一个功能是为处理动态 SQL 语句中的占位符提供支持。数据源模块</p><p>数据源是实际开发中常用的组件之一。现在开源的数据源都提供了比较丰富的功能，例如，连接池功能、检测连接状态等，选择性能优秀的数据源组件对于提升 ORM 框架乃至整个应用的性能都是非常重要的。Mybatis 自身提供了相应的数据源实现，当然 Mybatis 也提供了与第三方数据源集成的接口，这些功能都位于数据源模块之中。</p><h3 id="事务管理"><a href="#事务管理" class="headerlink" title="事务管理"></a>事务管理</h3><p>Mybatis 对数据库中的事务进行了抽象，其自身提供了相应的事务接口和简单实现。在很多场景中，My Batis 会与 Spring 框架集成，并由 Spring 框架管理事务，在第 4 章会介绍 Mybatis 如何与 Spring 集成开发，其中就会涉及 Spring 框架管理事务相关的配置。</p><h3 id="缓存模块"><a href="#缓存模块" class="headerlink" title="缓存模块"></a>缓存模块</h3><p>在优化系统性能时，优化数据库性能是非常重要的一个环节，而添加缓存则是优化数据库时最有效的手段之一。正确、合理地使用缓存可以将一部分数据库请求拦截在缓存这一层，这就能够减少相当一部分数据库的压力。</p><p>Mybatis 中提供了一级缓存和二级缓存，而这两级缓存都是依赖于基础支持层中的缓存模块实现的。这里需要读者注意的是，Mybatis 中自带的这两级缓存与 Mybatis 以及整个应用是运行在同一个 JM 中的，共享同一块堆内存。如果这两级缓存中的数据量较大，则可能影响系统中其他功能的运行，所以当需要缓存大量数据时，优先考虑使用 Redis、Memcache 等缓存产品。</p><p><img src="https://gitee.com/cayzlh/img-repo/raw/master/2020/06/10/3_aix99F.png" alt="缓存模块"></p><h3 id="Binding-模块"><a href="#Binding-模块" class="headerlink" title="Binding 模块"></a>Binding 模块</h3><p>通过前面的示例我们知道，在调用 Sqlsession 相应方法执行数据库操作时，需要指定映射文件中定义的 SQL 节点，如果出现拼写错误，我们只能在运行时才能发现相应的异常。为了尽早发现这种错误，Mybatis 通过 Binding 模块将用户自定义的 Mapper 1 接口与映射配置文件关联起来，系统可以通过调用自定义 Mapper 接口中的方法执行相应的 SQL 语句完成数据库操作，从而避免上述问题。</p><p>值得读者注意的是，开发人员无须编写自定义 Mapper 接口的实现，My Batis 会自动为其创建动态代理对象。在有些场景中，自定义 Mapper 接口可以完全代替映射配置文件，但有的映射规则和 SQL 语句的定义还是写在映射配置文件中比较方便，例如<strong>动态 SQL 语句的定义</strong>。</p><h2 id="核心处理层"><a href="#核心处理层" class="headerlink" title="核心处理层"></a>核心处理层</h2><h3 id="配置解析"><a href="#配置解析" class="headerlink" title="配置解析"></a>配置解析</h3><p>在 Mybatis 初始化过程中，会加载 mybatis-config. Xml 配置文件、映射配置文件以及 Mapper 接口中的注解信息，解析后的配置信息会形成相应的对象并保存到 Configuration 对象中。例如，示例中定义的~  &lt;resultmap》节点（即 Resultset I 的映射规则）会被解析成 Resultmap 对象；示例中定义的《result 节点（即属性映射）会被解析成 Resultmapping 对象。之后，利用该 Configuration 对象创建 Sqlsessionfactory 对象。待 Mybatis 初始化之后，开发人员可以通过初始化得到 Sqlsessionfactory 创建 Sqlsession 对象并完成数据库操作。</p><h3 id="SQL-解析与-scripting-模块"><a href="#SQL-解析与-scripting-模块" class="headerlink" title="SQL 解析与 scripting 模块"></a>SQL 解析与 scripting 模块</h3><p>拼凑 SQL 语句是一件烦琐且易出错的过程，为了将开发人员从这项枯燥无趣的工作中解脱出来，Mybatis 实现动态 SQL 语句的功能，提供了多种动态 SQL 语句对应的节点，例如，<code>where</code>节点、<code>if</code>节点、<code>foreach</code>节点等。通过这些节点的组合使用，开发人员可以写出几乎满足所有需求的动态 SQL 语句。</p><p>Mybatis 中的 scripting 模块会根据用户传入的实参，解析映射文件中定义的动态 SQL 节点，并形成数据库可执行的 SQL 语句。之后会处理 SQL 语句中的占位符，绑定用户传入的实参。</p><h3 id="SQL-执行"><a href="#SQL-执行" class="headerlink" title="SQL 执行"></a>SQL 执行</h3><p>SQL 语句的执行涉及多个组件，其中比较重要的是 Executor、Statementhandler、Parameterhandler 和 Resultsethandler。Executor 主要负责维护一级缓存和二级缓存并提供事务管理的相关操作，它会将数据库相关操作委托给 Statementhandler 完成 Statementhandler 首先通过 Parameter Handler 完成 SQL 语句的实参绑定，然后通过 iava, sql Statement 对象执行 <code>SQL</code> 语句并得到结果集，最后通过 <code>Resultset Handler</code> 完成结果集的映射，得到结果对象并返回。</p><p><img src="https://gitee.com/cayzlh/img-repo/raw/master/2020/06/10/4_SAR13A.png" alt="Mybatis 执行一条 SQL 语句的大致过程"></p><h3 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h3><p><code>Mybatis</code> 自身的功能虽然强大，但是并不能完美切合所有的应用场景，因此 <code>Mybatis</code> 提供了插件接口，我们可以通过添加用户自定义插件的方式对 <code>Mybatis</code> 进行扩展。用户自定义插件也可以改变 <code>Mybatis</code> 的默认行为，例如，我们可以拦截 <code>SQL</code> 语句并对其进行重写。由于用户自定义插件会影响 <code>Mybatis</code> 的核心行为，在使用自定义插件之前，开发人员需要了解 <code>Mybatis</code> 内部的原理，这样才能编写出安全、高效的插件</p><h2 id="接口层"><a href="#接口层" class="headerlink" title="接口层"></a>接口层</h2><p>接口层相对简单，其核心是 <code>Sqlsession</code> 接口，该接口中定义了 <code>Mybatis</code> 暴露给应用程序调用的 <code>API</code>，也就是上层应用与 <code>MyBatis</code> 交互的桥梁。接口层在接收到调用请求时，会调用核心处理层的相应模块来完成具体的数据库操作。</p>]]></content>
      
      
      <categories>
          
          <category> 书籍 </category>
          
          <category> 《MyBatis技术内幕》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MyBatis </tag>
            
            <tag> 《MyBatis技术内幕》 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker Swarm</title>
      <link href="/blog/2019/09/28/656e6847.html"/>
      <url>/blog/2019/09/28/656e6847.html</url>
      
        <content type="html"><![CDATA[<p> 实践中会发现，生产环境中使用单个 Docker 节点是远远不够的，搭建 Docker 集群势在必行。然而，面对 Kubernetes, Mesos 以及 Swarm 等众多容器集群系统，我们该如何选择呢？它们之中，Swarm 是 Docker 原生的，同时也是最简单，最易学，最节省资源的，比较适合中小型公司使用。</p><h2 id="Docker-Swarm-介绍"><a href="#Docker-Swarm-介绍" class="headerlink" title="Docker Swarm 介绍"></a>Docker Swarm 介绍</h2><p>Swarm 在 Docker 1.12 版本之前属于一个独立的项目，在 Docker 1.12 版本发布之后，该项目合并到了 Docker 中，成为 Docker 的一个子命令。目前，Swarm 是 Docker 社区提供的唯一一个原生支持 Docker 集群管理的工具。它可以把多个 Docker 主机组成的系统转换为单一的虚拟 Docker 主机，使得容器可以组成跨主机的子网网络。</p><p>Docker Swarm 是一个为 IT 运维团队提供集群和调度能力的编排工具。用户可以把集群中所有 Docker Engine 整合进一个「虚拟 Engine」的资源池，通过执行命令与单一的主 Swarm 进行沟通，而不必分别和每个 Docker Engine 沟通。在灵活的调度策略下，IT 团队可以更好地管理可用的主机资源，保证应用容器的高效运行。</p><p><img src="https://github.com/cayzlh/git-img-repository/raw/master/blog/2019/09/22.png" alt="Docker Swarm"></p><h2 id="Docker-Swarm-优点"><a href="#Docker-Swarm-优点" class="headerlink" title="Docker Swarm 优点"></a>Docker Swarm 优点</h2><h3 id="任何规模都有高性能表现"><a href="#任何规模都有高性能表现" class="headerlink" title="任何规模都有高性能表现"></a>任何规模都有高性能表现</h3><p>对于企业级的 Docker Engine 集群和容器调度而言，可拓展性是关键。任何规模的公司——不论是拥有五个还是上千个服务器——都能在其环境下有效使用 Swarm。 经过测试，Swarm 可拓展性的极限是在 1000 个节点上运行 50000 个部署容器，每个容器的启动时间为亚秒级，同时性能无减损。</p><h3 id="灵活的容器调度"><a href="#灵活的容器调度" class="headerlink" title="灵活的容器调度"></a>灵活的容器调度</h3><p>Swarm 帮助 IT 运维团队在有限条件下将性能表现和资源利用最优化。Swarm 的内置调度器（scheduler）支持多种过滤器，包括：节点标签，亲和性和多种容器部策略如 binpack、spread、random 等等。</p><h3 id="服务的持续可用性"><a href="#服务的持续可用性" class="headerlink" title="服务的持续可用性"></a>服务的持续可用性</h3><p>Docker Swarm 由 Swarm Manager 提供高可用性，通过创建多个 Swarm master 节点和制定主 master 节点宕机时的备选策略。如果一个 master 节点宕机，那么一个 slave 节点就会被升格为 master 节点，直到原来的 master 节点恢复正常。 此外，如果某个节点无法加入集群，Swarm 会继续尝试加入，并提供错误警报和日志。在节点出错时，Swarm 现在可以尝试把容器重新调度到正常的节点上去。</p><p><strong>和 Docker API 及整合支持的兼容性</strong> Swarm 对 Docker API 完全支持，这意味着它能为使用不同 Docker 工具（如 Docker CLI，Compose，Trusted Registry，Hub 和 UCP）的用户提供无缝衔接的使用体验。</p><p><strong>Docker Swarm 为 Docker 化应用的核心功能（诸如多主机网络和存储卷管理）提供原生支持。</strong>开发的 Compose 文件能（通过 docker-compose up ）轻易地部署到测试服务器或 Swarm 集群上。Docker Swarm 还可以从 Docker Trusted Registry 或 Hub 里 pull 并 run 镜像。</p><p><strong>综上所述，Docker Swarm 提供了一套高可用 Docker 集群管理的解决方案，完全支持标准的 Docker API，方便管理调度集群 Docker 容器，合理充分利用集群主机资源</strong>。</p><blockquote><p><strong>并非所有服务都应该部署在Swarm集群内。数据库以及其它有状态服务就不适合部署在Swarm集群内。</strong></p></blockquote><h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><h3 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h3><p>运行 Docker 的主机可以主动初始化一个 Swarm 集群或者加入一个已存在的 Swarm 集群，这样这个运行 Docker 的主机就成为一个 Swarm 集群的节点 (node) 。节点分为管理 (manager) 节点和工作 (worker) 节点。</p><p>管理节点用于 Swarm 集群的管理，docker swarm 命令基本只能在管理节点执行（节点退出集群命令 docker swarm leave 可以在工作节点执行）。一个 Swarm 集群可以有多个管理节点，但只有一个管理节点可以成为 leader，leader 通过 raft 协议实现。</p><p>工作节点是任务执行节点，管理节点将服务 (service) 下发至工作节点执行。管理节点默认也作为工作节点。你也可以通过配置让服务只运行在管理节点。下图展示了集群中管理节点与工作节点的关系。</p><p><img src="https://github.com/cayzlh/git-img-repository/raw/master/blog/2019/09/23.png" alt="节点"></p><h3 id="服务和任务"><a href="#服务和任务" class="headerlink" title="服务和任务"></a>服务和任务</h3><p>任务 （Task）是 Swarm 中的最小的调度单位，目前来说就是一个单一的容器。 服务 （Services） 是指一组任务的集合，服务定义了任务的属性。服务有两种模式：</p><ul><li>replicated services 按照一定规则在各个工作节点上运行指定个数的任务。</li><li>global services 每个工作节点上运行一个任务</li></ul><p>两种模式通过 docker service create 的 –mode 参数指定。下图展示了容器、任务、服务的关系。</p><p><img src="https://github.com/cayzlh/git-img-repository/raw/master/blog/2019/09/24.png" alt="服务和任务"></p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><ul><li><p>转自：<a href="http://www.ityouknow.com/docker/2018/04/19/docker-swarm.html">Docker(六)：Docker 三剑客之 Docker Swarm</a></p></li><li><p>对这个Docker Swarm这部分不是很熟悉，主要是想了解其概念。转发这篇文章内容以免以后找不到。</p></li><li><p>实践之后再做补充</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
            <tag> 转载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java设计模式之代理模式</title>
      <link href="/blog/2019/04/02/ae152a83.html"/>
      <url>/blog/2019/04/02/ae152a83.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>以下文章内容来源：微信公众号（Java知音）文章，设计模式是什么鬼（代理）</p></blockquote><p>生活中还有很多其他实例不胜枚举，但对于做技术的我们，以网络代理举例相信是最合适不过了。</p><p><img src="https://github.com/cayzlh/git-img-repository/raw/master/blog/2019/03/01/7.png" alt="网络代理"></p><p>首先，我们上网前得去网络服务提供商（ISP）申请互联网宽带业务，于是顺理成章光纤入户，并拿到一个调制解调器，也就是我们俗称的“猫”。好，“猫”实现了互联网访问接口，看代码。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Internet</span> </span>&#123;<span class="comment">//互联网访问接口</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">access</span><span class="params">(String url)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Modem</span> <span class="keyword">implements</span> <span class="title">Internet</span> </span>&#123;<span class="comment">//调制解调器</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">access</span><span class="params">(String url)</span></span>&#123;<span class="comment">//实现互联网访问接口</span></span><br><span class="line">        System.out.println(<span class="string">&quot;正在访问：&quot;</span> + url);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>作为调制解调器，一定有上网功能了，用户的电脑只需要用网线连接这只“猫”便接入互联网了。就这么简单么？然而某天我们发现孩子学习时总是偷偷上网看电影玩游戏，于是我们决定对某些网站进行过滤，拒绝黄赌毒侵害未成年。那么，我们需要在客户终端电脑与猫之间加一层代理，用于过滤某些不良网站，最终我们决定购买一款有过滤功能的路由器。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RouterProxy</span> <span class="keyword">implements</span> <span class="title">Internet</span> </span>&#123;<span class="comment">//路由器代理类</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Internet modem;<span class="comment">//持有被代理类引用</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; blackList = Arrays.asList(<span class="string">&quot;电影&quot;</span>, <span class="string">&quot;游戏&quot;</span>, <span class="string">&quot;音乐&quot;</span>, <span class="string">&quot;小说&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RouterProxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.modem = <span class="keyword">new</span> Modem();<span class="comment">//实例化被代理类</span></span><br><span class="line">        System.out.println(<span class="string">&quot;拨号上网...连接成功！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">access</span><span class="params">(String url)</span> </span>&#123;<span class="comment">//同样实现互联网访问接口方法</span></span><br><span class="line">        <span class="keyword">for</span> (String keyword : blackList) &#123;<span class="comment">//循环黑名单</span></span><br><span class="line">            <span class="keyword">if</span> (url.contains(keyword)) &#123;<span class="comment">//是否包含黑名单字眼</span></span><br><span class="line">                System.out.println(<span class="string">&quot;禁止访问：&quot;</span> + url);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        modem.access(url);<span class="comment">//正常访问互联网</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意看，在这里路由器代理主要充当代理的角色，和之前的“猫”一样，它同样实现了互联网接口，看似也是有上网功能的，其实不然。第12行代码对于互联网访问功能的实现一开始就做了个过滤，如果地址中带有黑名单中的敏感字眼则禁止访问并直接退出，反之则于第19行调用“猫”的互联网访问方法，看到了吧，最终还是调用“猫”的上网功能。注意此处为了对“猫”进行控制，代理专为此而生，我们直接于第7行实例化它而不是需要别人把它注入进来。好了，孩子现在来上网了，迫不及待运行之。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Internet proxy = <span class="keyword">new</span> RouterProxy();<span class="comment">//实例化的是代理</span></span><br><span class="line">        proxy.access(<span class="string">&quot;http://www.电影.com&quot;</span>);</span><br><span class="line">        proxy.access(<span class="string">&quot;http://www.游戏.com&quot;</span>);</span><br><span class="line">        proxy.access(<span class="string">&quot;ftp://www.学习.com/java&quot;</span>);</span><br><span class="line">        proxy.access(<span class="string">&quot;http://www.工作.com&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 运行结果</span></span><br><span class="line"><span class="comment">            拨号上网...连接成功！</span></span><br><span class="line"><span class="comment">            禁止访问：http://www.电影.com</span></span><br><span class="line"><span class="comment">            禁止访问：http://www.游戏.com</span></span><br><span class="line"><span class="comment">            正在访问：ftp://www.学习.com/java</span></span><br><span class="line"><span class="comment">            正在访问：http://www.工作.com</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在第3行处，孩子实例化的不再是“猫”，而是被偷梁换柱的替换为路由器代理了，也就是说大家上网都连接路由器了，而不是直接去连“猫”，这样不但省去了我们拨号的麻烦（路由器帮助拨号）而且孩子再也访问不到乱七八糟的网站了。而这个代理自身其实并不具备访问互联网的能力，它只是简单的调用“猫”上网功能，其存在目的只是为了控制对”猫“的互联访问，对其进行代理而已。</p><p><strong>代理模式更强调的是对被代理对象的控制，而不是仅限于去装饰目标对象并增强其原有的功能。就像明星的例子一样，如果钱没给够，合同未达成，则不让明星随意作秀。</strong></p><p>相信大家已经理解地很通透了吧，这也是我们最常用的代理模式了。其实还有一种叫动态代理，不同之处在于其实例化过程是在运行时完成的，也就是说我们不需要专门针对某个接口去写这么一个代理类，而是根据接口动态生成。</p><p>举个例子，让我们先忘掉之前的路由器代理，当我们内网中的上网设备越来越多，路由器的Lan口已被占满不够用了，于是我们决定换成交换机，看代码。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Intranet</span> </span>&#123;<span class="comment">//局域网访问接口</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fileAccess</span><span class="params">(String path)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了保持简单，我们假设这个交换机Switch实现了局域网访问接口Intranet，请注意这里不是互联网接口Internet。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Switch</span> <span class="keyword">implements</span> <span class="title">Intranet</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fileAccess</span><span class="params">(String path)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;访问内网：&quot;</span> + path);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里进行的是局域网文件访问，比如说是拷贝另一台内网机器上的共享文件，并且我们想保证与之前一样的关键字过滤控制功能，也就是说不管是什么地址都要先通过过滤。</p><p>到这里让我们思考一下，猫实现的是互联网访问接口，交换机实现的是局域网访问接口，那我们的过滤器代理类到底该怎么写？是实现Internet接口呢还是实现Intranet接口呢？要么两个都实现？再加进来新的类接口又要不停地改实现类吗？这显然行不通，过滤器无非就是一段过滤逻辑不必来回改动，这违反了设计模式开闭原则。动态代理应时而生，我们来看代码。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KeywordFilter</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; blackList = Arrays.asList(<span class="string">&quot;电影&quot;</span>, <span class="string">&quot;游戏&quot;</span>, <span class="string">&quot;音乐&quot;</span>, <span class="string">&quot;小说&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 被代理的真实对象,猫、交换机、或是别的什么都是。</span></span><br><span class="line">    <span class="keyword">private</span> Object origin;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">KeywordFilter</span><span class="params">(Object origin)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.origin = origin;<span class="comment">//注入被代理对象</span></span><br><span class="line">        System.out.println(<span class="string">&quot;开启关键字过滤模式...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">//要被切入方法面之前的业务逻辑</span></span><br><span class="line">        String arg = args[<span class="number">0</span>].toString();</span><br><span class="line">        <span class="keyword">for</span> (String keyword : blackList) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arg.toString().contains(keyword)) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;禁止访问：&quot;</span> + arg);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//调用真实的被代理对象方法</span></span><br><span class="line">        <span class="keyword">return</span> method.invoke(origin, arg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于这个关键字过滤功能我们不再写到代理类里面了，而是另外写个类并实现JDK反射包中提供的InvocationHandler接口，于第9行注入即将被代理的对象，不管是猫还是交换机什么的它总归是个Object，然后在第14行实现这个invoke调用方法，之后生成的动态代理将来会调进来跑这块的逻辑，很显然我们这里依然保持不变的逻辑，在真实对象方法被执行之前运行了过滤逻辑加以控制。由于传入的参数是被代理对象的方法method，以及一堆参数args，所以注意这里第24行我们要用反射去调用被代理对象origin了，最后来看我们如何运行。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//访问外网（互联网）,生成猫代理。</span></span><br><span class="line">        Internet internet = (Internet) Proxy.newProxyInstance(</span><br><span class="line">                Modem.class.getClassLoader(),</span><br><span class="line">                Modem.class.getInterfaces(), </span><br><span class="line">                <span class="keyword">new</span> KeywordFilter(<span class="keyword">new</span> Modem()));</span><br><span class="line">        internet.access(<span class="string">&quot;http://www.电影.com&quot;</span>);</span><br><span class="line">        internet.access(<span class="string">&quot;http://www.游戏.com&quot;</span>);</span><br><span class="line">        internet.access(<span class="string">&quot;http://www.学习.com&quot;</span>);</span><br><span class="line">        internet.access(<span class="string">&quot;http://www.工作.com&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//访问内网（局域网），生成交换机代理。</span></span><br><span class="line">        Intranet intranet = (Intranet) Proxy.newProxyInstance(</span><br><span class="line">                Switch.class.getClassLoader(),</span><br><span class="line">                Switch.class.getInterfaces(), </span><br><span class="line">                <span class="keyword">new</span> KeywordFilter(<span class="keyword">new</span> Switch()));</span><br><span class="line">        intranet.fileAccess(<span class="string">&quot;\\\\192.68.1.2\\共享\\电影\\IronHuman.mp4&quot;</span>);</span><br><span class="line">        intranet.fileAccess(<span class="string">&quot;\\\\192.68.1.2\\共享\\游戏\\Hero.exe&quot;</span>);</span><br><span class="line">        intranet.fileAccess(<span class="string">&quot;\\\\192.68.1.4\\shared\\Java学习资料.zip&quot;</span>);</span><br><span class="line">        intranet.fileAccess(<span class="string">&quot;\\\\192.68.1.6\\Java知音\\设计模式是什么鬼.doc&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            开启关键字过滤模式...</span></span><br><span class="line"><span class="comment">            禁止访问：http://www.电影.com</span></span><br><span class="line"><span class="comment">            禁止访问：http://www.游戏.com</span></span><br><span class="line"><span class="comment">            正在访问：http://www.学习.com</span></span><br><span class="line"><span class="comment">            正在访问：http://www.工作.com</span></span><br><span class="line"><span class="comment">            开启关键字过滤模式...</span></span><br><span class="line"><span class="comment">            禁止访问：\\192.68.1.2\共享\电影\IronHuman.mp4</span></span><br><span class="line"><span class="comment">            禁止访问：\\192.68.1.2\共享\游戏\Hero.exe</span></span><br><span class="line"><span class="comment">            访问内网：\\192.68.1.4\shared\Java学习资料.zip</span></span><br><span class="line"><span class="comment">            访问内网：\\192.68.1.6\Java知音\设计模式是什么鬼.doc</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，我们不管是访问互联网还是局域网，只需要分别生成相应的代理并调用即可，相同的过滤器逻辑被执行了。如此一来，我们并不需要再写任何的代理类了，只需要实现一次InvocationHandler就一劳永逸了，在运行时去动态地生成代理，达到兼容任何接口的目的。</p><p><em>其实在很多框架中大量应用到了动态代理模式，比如Spring的面向切面AOP，我们只需要定义好一个切面类@Aspect，声明其切入点@Pointcut（被代理的哪些对象的哪些方法，也就是这里的猫和交换机的access以及accessFile），以及被切入的代码块（要增加上去的逻辑，比如这里的过滤功能代码，可分为前置执行@Before，后置执行@After，以及异常处理@AfterThrowing等），于是框架自动帮我们生成代理并切入目标执行。</em>正如给每给方法前后加入日志的例子，或者更经典的事务控制的例子，在所有业务代码之前先切入“事务开始”，执行过后再切入“事务提交”，如果抛异常被捕获则执行“事务回滚”，如此就不必要在每个业务类中去写这些重复代码了，一劳永逸，冗余代码大量减少，开发效率惊人提升。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Java设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 转载 </tag>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java设计模式之享元模式</title>
      <link href="/blog/2019/03/23/34d98dd9.html"/>
      <url>/blog/2019/03/23/34d98dd9.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>以下文章内容来源：微信公众号（Java知音）文章，设计模式是什么鬼（享元）</p></blockquote><p>首先来看一个实例，比如我们要开发一款RPG游戏，游戏地图通常非常大，而且有各种各样，有草地、沙漠、荒原，水路等等，在写代码之前，我们先思考下应该怎样去建模。</p><p><img src="https://github.com/cayzlh/git-img-repository/raw/master/blog/2019/03/01/6.png" alt="享元模式"></p><p>对于这种地图，我们加载一整张图片来做地图？如果地图太大，图片加载相当卡顿吧？而且大片地图上其实都是重复的图片素材，整图加载设计也有失灵活性。再仔细观察下，这地图无非就是很多小图片（元）拼起来的哦，这不就是类似于我们装修时贴马赛克嘛？</p><p>简单的实现方法，我们有个砖块类，持有“图片”，“位置”等属性信息，然后实例化这些砖块再调用其“绘制”方法把图片显示在地图某位置上即可。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tile</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String image;<span class="comment">//地砖所用的图片材质</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> x, y;<span class="comment">//地砖所在坐标</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Tile</span><span class="params">(String image, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.image = image;</span><br><span class="line">        System.out.print(<span class="string">&quot;从磁盘加载[&quot;</span> + image + <span class="string">&quot;]图片，耗时半秒。。。&quot;</span>);</span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">        <span class="keyword">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;在位置[&quot;</span> + x + <span class="string">&quot;:&quot;</span> + y + <span class="string">&quot;]上绘制图片：[&quot;</span> + image + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码看起来非常简单，第3行的地砖材质图片我们用String来模拟代替，第7行初始化时我们把图片加载到内存，比如说这个IO操作要耗费半秒时间，好了我们先测试绘制第一行砖块，运行一下。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//以绘制第一行为例</span></span><br><span class="line">        <span class="keyword">new</span> Tile(<span class="string">&quot;河流&quot;</span>, <span class="number">10</span>, <span class="number">10</span>).draw();</span><br><span class="line">        <span class="keyword">new</span> Tile(<span class="string">&quot;河流&quot;</span>, <span class="number">10</span>, <span class="number">20</span>).draw();</span><br><span class="line">        <span class="keyword">new</span> Tile(<span class="string">&quot;石路&quot;</span>, <span class="number">10</span>, <span class="number">30</span>).draw();</span><br><span class="line">        <span class="keyword">new</span> Tile(<span class="string">&quot;草坪&quot;</span>, <span class="number">10</span>, <span class="number">40</span>).draw();</span><br><span class="line">        <span class="keyword">new</span> Tile(<span class="string">&quot;草坪&quot;</span>, <span class="number">10</span>, <span class="number">50</span>).draw();</span><br><span class="line">        <span class="keyword">new</span> Tile(<span class="string">&quot;草坪&quot;</span>, <span class="number">10</span>, <span class="number">60</span>).draw();</span><br><span class="line">        <span class="keyword">new</span> Tile(<span class="string">&quot;草坪&quot;</span>, <span class="number">10</span>, <span class="number">70</span>).draw();</span><br><span class="line">        <span class="keyword">new</span> Tile(<span class="string">&quot;草坪&quot;</span>, <span class="number">10</span>, <span class="number">80</span>).draw();</span><br><span class="line">        <span class="comment">/* 运行结果</span></span><br><span class="line"><span class="comment">        从磁盘加载[河流]图片，耗时半秒。。。在位置[10:10]上绘制图片：[河流]</span></span><br><span class="line"><span class="comment">        从磁盘加载[河流]图片，耗时半秒。。。在位置[10:20]上绘制图片：[河流]</span></span><br><span class="line"><span class="comment">        从磁盘加载[石路]图片，耗时半秒。。。在位置[10:30]上绘制图片：[石路]</span></span><br><span class="line"><span class="comment">        从磁盘加载[草坪]图片，耗时半秒。。。在位置[10:40]上绘制图片：[草坪]</span></span><br><span class="line"><span class="comment">        从磁盘加载[草坪]图片，耗时半秒。。。在位置[10:50]上绘制图片：[草坪]</span></span><br><span class="line"><span class="comment">        从磁盘加载[草坪]图片，耗时半秒。。。在位置[10:60]上绘制图片：[草坪]</span></span><br><span class="line"><span class="comment">        从磁盘加载[草坪]图片，耗时半秒。。。在位置[10:70]上绘制图片：[草坪]</span></span><br><span class="line"><span class="comment">        从磁盘加载[草坪]图片，耗时半秒。。。在位置[10:80]上绘制图片：[草坪]</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有没有发现问题？每加载一张图都要耗费掉半秒钟，才画了8张地砖图就4秒钟流逝了，如果构建整张地图得多少时间？这就像是在慢性自杀，如此效率严重影响了游戏的用户体验，光卡顿在地图加载这给漫长的过程就已经让玩家失去兴趣了。</p><p>这个场景很容易想到用<strong>原型模式</strong>来实现，<strong>把相同的图共享出来，用克隆的方式代替物件图实例化的过程，从而加快初始化速度。</strong>共享元貌似没什么问题，速度也加快了，但对象数量貌似还是个严重问题，每一个小物件图都要对应一个对象，这么个小游戏用得着那么大的内存开销么，搞不好甚至会造成内存溢出，所以，设计模式一定还是有问题。</p><p><img src="https://github.com/cayzlh/git-img-repository/raw/master/blog/2019/02/20/1.jpg" alt="假装有图"></p><p>沿着共享的思路我们再看下到底需不需要这么多对象？这些对象不同的地方在于其坐标的不同，再就是材质的不同，也就是图的不同了，能不能从这些对象里抽取出来一些共同点呢？首先每个图的坐标都不一样，是没办法共享的，但是材质图是重复出现的，是可以共享的，同样的材质图会在不同的坐标位置上重复出现，那么这个材质图是可以做成共享元的。</p><p>既然坐标不能共享，那就不做为材质类的共享元属性，由客户端维护这些坐标并作为参数传入好了，而且这些材质都有绘制能力，那就先定义一个接口吧。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Drawable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>;<span class="comment">//绘制方法，接收地图坐标。</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以用抽象类抽出更多的属性和方法代替接口，使子类变得简单，这里为了清晰说明问题就用接口。接下来是材质类们，统统实现这个绘制接口。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Water</span> <span class="keyword">implements</span> <span class="title">Drawable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String image;<span class="comment">//河流图片材质</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Water</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.image = <span class="string">&quot;河流&quot;</span>;</span><br><span class="line">        System.out.print(<span class="string">&quot;从磁盘加载[&quot;</span> + image + <span class="string">&quot;]图片，耗时半秒。。。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;在位置[&quot;</span> + x + <span class="string">&quot;:&quot;</span> + y + <span class="string">&quot;]上绘制图片：[&quot;</span> + image + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意第6行因为是河流材质类，所以初始化我们直接加载河流图片素材，这就是类内部即将做共享的“元”数据了，也叫做“内蕴状态”，至于“外蕴状态”就是坐标了，只作为参数从外部传入不做共享。接下来是草地、石子路等等。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Grass</span> <span class="keyword">implements</span> <span class="title">Drawable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String image;<span class="comment">//草坪图片材质</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Grass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.image = <span class="string">&quot;草坪&quot;</span>;</span><br><span class="line">        System.out.print(<span class="string">&quot;从磁盘加载[&quot;</span> + image + <span class="string">&quot;]图片，耗时半秒。。。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;在位置[&quot;</span> + x + <span class="string">&quot;:&quot;</span> + y + <span class="string">&quot;]上绘制图片：[&quot;</span> + image + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Stone</span> <span class="keyword">implements</span> <span class="title">Drawable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String image;<span class="comment">//石路图片材质</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Stone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.image = <span class="string">&quot;石路&quot;</span>;</span><br><span class="line">        System.out.print(<span class="string">&quot;从磁盘加载[&quot;</span> + image + <span class="string">&quot;]图片，耗时半秒。。。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;在位置[&quot;</span> + x + <span class="string">&quot;:&quot;</span> + y + <span class="string">&quot;]上绘制图片：[&quot;</span> + image + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">House</span> <span class="keyword">implements</span> <span class="title">Drawable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String image;<span class="comment">//房子图片材质</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">House</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.image = <span class="string">&quot;房子&quot;</span>;</span><br><span class="line">        System.out.print(<span class="string">&quot;从磁盘加载[&quot;</span> + image + <span class="string">&quot;]图片，耗时一秒。。。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;将图层切到最上层。。。&quot;</span>);<span class="comment">//房子盖在地上，所以切换到顶层图层。</span></span><br><span class="line">        System.out.println(<span class="string">&quot;在位置[&quot;</span> + x + <span class="string">&quot;:&quot;</span> + y + <span class="string">&quot;]上绘制图片：[&quot;</span> + image + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意上面这个的房子类有所不同，它有自己特有的绘制行为方法，也就是在地板图层之上绘制房子，覆盖掉下面的地板，使其变得更加立体。这也就是为什么<strong>我们非要用接口或抽象类来做引用，使实现类可以有自己独特的行为方式，多态的好处立竿见影。</strong>接下来就是实现“元之共享”的关键了，我们来做一个简单工厂类，看代码。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Factory</span> </span>&#123;<span class="comment">//图件工厂</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Drawable&gt; images;<span class="comment">//图库</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Factory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        images = <span class="keyword">new</span> HashMap&lt;String, Drawable&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Drawable <span class="title">getDrawable</span><span class="params">(String image)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//缓存里如果没有图件，则实例化并放入缓存。</span></span><br><span class="line">        <span class="keyword">if</span>(!images.containsKey(image))&#123;</span><br><span class="line">            <span class="keyword">switch</span> (image) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;河流&quot;</span>:</span><br><span class="line">                images.put(image, <span class="keyword">new</span> Water());</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;草坪&quot;</span>:</span><br><span class="line">                images.put(image, <span class="keyword">new</span> Grass());</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;石路&quot;</span>:</span><br><span class="line">                images.put(image, <span class="keyword">new</span> Stone());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//缓存里必然有图，直接取得并返回。</span></span><br><span class="line">        <span class="keyword">return</span> images.get(image);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个图件工厂维护着所有元对象的图库，构造方法于第5行会初始化一个哈希图的缓存”池“，当客户端于第8行需要实例化图件的时候，我们先观察这个图库池里存在不存在已实例化过的图件，也就是看有无已做共享的图元，如果没有则实例化并加入图库共享池供下次使用，这便是”元之共享“的秘密了。巧夺天工的设计一气呵成，已经迫不及待去运行了。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//先实例化图件工厂</span></span><br><span class="line">        Factory factory = <span class="keyword">new</span> Factory();</span><br><span class="line">        <span class="comment">//以第一行为例</span></span><br><span class="line">        factory.getDrawable(<span class="string">&quot;河流&quot;</span>).draw(<span class="number">10</span>, <span class="number">10</span>);</span><br><span class="line">        factory.getDrawable(<span class="string">&quot;河流&quot;</span>).draw(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line">        factory.getDrawable(<span class="string">&quot;石路&quot;</span>).draw(<span class="number">10</span>, <span class="number">30</span>);</span><br><span class="line">        factory.getDrawable(<span class="string">&quot;草坪&quot;</span>).draw(<span class="number">10</span>, <span class="number">40</span>);</span><br><span class="line">        factory.getDrawable(<span class="string">&quot;草坪&quot;</span>).draw(<span class="number">10</span>, <span class="number">50</span>);</span><br><span class="line">        factory.getDrawable(<span class="string">&quot;草坪&quot;</span>).draw(<span class="number">10</span>, <span class="number">60</span>);</span><br><span class="line">        factory.getDrawable(<span class="string">&quot;草坪&quot;</span>).draw(<span class="number">10</span>, <span class="number">70</span>);</span><br><span class="line">        factory.getDrawable(<span class="string">&quot;草坪&quot;</span>).draw(<span class="number">10</span>, <span class="number">80</span>);</span><br><span class="line">        <span class="comment">/*运行结果</span></span><br><span class="line"><span class="comment">        从磁盘加载[河流]图片，耗时半秒。。。在位置[10:10]上绘制图片：[河流]</span></span><br><span class="line"><span class="comment">        在位置[10:20]上绘制图片：[河流]</span></span><br><span class="line"><span class="comment">        从磁盘加载[石路]图片，耗时半秒。。。在位置[10:30]上绘制图片：[石路]</span></span><br><span class="line"><span class="comment">        从磁盘加载[草坪]图片，耗时半秒。。。在位置[10:40]上绘制图片：[草坪]</span></span><br><span class="line"><span class="comment">        在位置[10:50]上绘制图片：[草坪]</span></span><br><span class="line"><span class="comment">        在位置[10:60]上绘制图片：[草坪]</span></span><br><span class="line"><span class="comment">        在位置[10:70]上绘制图片：[草坪]</span></span><br><span class="line"><span class="comment">        在位置[10:80]上绘制图片：[草坪]</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，我们抛弃了利用new关键字肆意妄为地制造对象，而是改用这个图件工厂去帮我们把元构建并共享起来。显而易见，我们看到运行结果中每次实例化对象会耗费半秒时间，再次请求对象时就不再会加载图片耗费时间了，也就是从共享图池直接拿到了，不再造次。更妙的是，如果画完整个地图只需要实例化需要用到的某些元素材而已，即使是那个大房子图件也只需要实例化一次就够了。至此，CPU速度，内存轻量化同时做到了优化，整个游戏用户体验得到了极大的提升。</p><p>享元的精髓当然重点不止于”享“，更重要的是对于元的辨识，例如那个从外部客户端传入的坐标参数，如果我们依然把坐标也当作共享对象元数据（内蕴状态）的话，那么这个结构将无元可享，大量的对象就如同世界上没有相同的两片树叶一样多不胜数，最终会导致图库池被撑爆，享元将变得毫无意义。所以，对于整个系统数据结构的分析、设计、规划显得尤为重要。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Java设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 转载 </tag>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java设计模式之中介者模式</title>
      <link href="/blog/2019/03/18/af3a654f.html"/>
      <url>/blog/2019/03/18/af3a654f.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>以下文章内容来源：微信公众号（Java知音）文章，设计模式是什么鬼（中介）</p></blockquote><p>中介，作用于多个事物之间充当交互沟通的媒介。我们的生活中有各种各样的媒介，比如一些传统媒体，书刊杂志，报纸，把信息传递给读者。再比如利用电子信息技术的互联网，作为一种新媒体，不单可以更高效地把信息传递给用户，而且可以反向地获得用户反馈评论，用户与用户之间亦可以进行沟通，这种全终端双向互通是传统媒体所不能及的。</p><p>除此之外，再如婚介所、房产中介、交换机组网、现代电子商务、C2C购物平台、手机、即时通软件等等，这些都与我们的生活息息相关，离开它们我们将举步维艰。其实不管是任何中介，其本质都是相同的，都是充当中间媒介的角色，并达成多方业务互通的目的。</p><p>首先我们以最简单的模型来解决问题，以两个人交谈为例，其实他们之间并不需要任何第三方媒介，而是一对一直接沟通，看代码。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String name;<span class="comment">//用名字来区别人。</span></span><br><span class="line">  <span class="keyword">private</span> People other;<span class="comment">//持有对方的引用。</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">People</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;<span class="comment">//初始化必须起名。</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">(People other)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.other = other;<span class="comment">//连接方法中注入对方引用。</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">talk</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">    other.listen(msg);<span class="comment">//我方说话时，对方聆听。</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listen</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//聆听来自对方的声音</span></span><br><span class="line">    System.out.println(</span><br><span class="line">        other.getName() + <span class="string">&quot; 对 &quot;</span> + <span class="keyword">this</span>.name + <span class="string">&quot; 说：&quot;</span> + msg</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一切就绪，两人开始沟通。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">    People p3 = <span class="keyword">new</span> People(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">    People p4 = <span class="keyword">new</span> People(<span class="string">&quot;李四&quot;</span>);</span><br><span class="line"></span><br><span class="line">    p3.connect(p4);</span><br><span class="line">    p4.connect(p3);</span><br><span class="line"></span><br><span class="line">    p3.talk(<span class="string">&quot;你好。&quot;</span>);</span><br><span class="line">    p4.talk(<span class="string">&quot;早上好，三哥。&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/****************************</span></span><br><span class="line"><span class="comment">  输出结果：</span></span><br><span class="line"><span class="comment">    张三 对 李四 说：你好。</span></span><br><span class="line"><span class="comment">    李四 对 张三 说：早上好，三哥。</span></span><br><span class="line"><span class="comment">  *****************************/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从People类中我们可以看到，沟通只只能在两人之间进行，而且各自都持有对方对象的引用，以便把消息传递给对方的监听方法。这种模式虽然简单，但耦合性太强，你中有我，我中有你，谁也离不开谁。试想如果再有多个人加入交谈，那每个人都要持有其他所有人的引用了，这时会陷入一种多对多的关联陷阱，对象关系变得复杂不堪，如蛛网般难以维护。</p><p><img src="https://github.com/cayzlh/git-img-repository/raw/master/blog/2019/03/01/3.png" alt="1v1"></p><p>我们就拿群聊天室举例，每当有人加入或离开，都要把每个人持有的其他人的引用关系更新一遍，发消息时更是繁琐不堪，重复工作显得非常多余。那么如何解决这个问题呢？我们开始进行思考，为何不把重复的部分抽离出来呢，也就是把对方的引用放在一个中介类里面去统一维护起来，于是设计更改如下。</p><p><img src="https://github.com/cayzlh/git-img-repository/raw/master/blog/2019/03/01/4.png" alt="nvn"></p><p>可以看到，每个用户不再所持有其他所有用户的引用了，取而代之的是聊天室的引用，这样引用关系瞬间变得明朗起来，开始我们的代码重构。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;<span class="comment">//名字</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ChatRoom chatRoom;<span class="comment">//聊天室引用</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;<span class="comment">//初始化必须起名字</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">login</span><span class="params">(ChatRoom chatRoom)</span> </span>&#123;<span class="comment">//用户登陆</span></span><br><span class="line">        chatRoom.connect(<span class="keyword">this</span>);<span class="comment">//调用聊天室连接方法</span></span><br><span class="line">        <span class="keyword">this</span>.chatRoom = chatRoom;<span class="comment">//注入聊天室引用</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">talk</span><span class="params">(String msg)</span> </span>&#123;<span class="comment">//用户发言</span></span><br><span class="line">        chatRoom.sendMsg(<span class="keyword">this</span>, msg);<span class="comment">//给聊天室发消息</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listen</span><span class="params">(User fromWhom, String msg)</span> </span>&#123;<span class="comment">//且听风吟</span></span><br><span class="line">        System.out.print(<span class="string">&quot;【&quot;</span>+<span class="keyword">this</span>.name+<span class="string">&quot;的对话框】&quot;</span>);</span><br><span class="line">        System.out.println(fromWhom.getName() + <span class="string">&quot; 说： &quot;</span> + msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到第14行，用户登陆聊天室时不再是连接对方了，而是连接通知聊天室并告知：“有人进来了请进行注册”，然后记录下来用户当前所在聊天室的引用。第19行，用户发言时也不是直接找对方了，而是把消息扔给聊天室处理。第23行，聆听方法同样也是，将来会接受来自聊天室的声音。很显然，一切沟通都与是中介聊天室进行，这样用户之间就实现了解耦的目的。接着写聊天室中介类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChatRoom</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;<span class="comment">//聊天室命名</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ChatRoom</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;<span class="comment">//初始化必须命名聊天室</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    List&lt;User&gt; users = <span class="keyword">new</span> ArrayList&lt;&gt;();<span class="comment">//聊天室里的用户们</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.users.add(user);<span class="comment">//用户进入聊天室加入列表。</span></span><br><span class="line">        System.out.print(<span class="string">&quot;欢迎【&quot;</span>);</span><br><span class="line">        System.out.print(user.getName());</span><br><span class="line">        System.out.println(<span class="string">&quot;】加入聊天室【&quot;</span> + <span class="keyword">this</span>.name + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMsg</span><span class="params">(User fromWhom, String msg)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 循环所有用户，只发消息给非发送方fromWhom。</span></span><br><span class="line">        users.stream()</span><br><span class="line">        .filter(user -&gt; !user.equals(fromWhom))<span class="comment">//过滤掉发送方fromWhom</span></span><br><span class="line">        .forEach(toWhom -&gt; toWhom.listen(fromWhom, msg));<span class="comment">//发送消息给剩下的所有人</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们新建一个聊天室作为中介类，所有参与者登陆时调用第10行的connect方法进入聊天室，并记录其引用到users列表中。第17行，当用户发消息到平台我们再转发给其他人，这里利用Java8的流和Lambda表达式进行过滤（User类的equals方法请自行加入），并循环调用所有接收方的listen方法即可。</p><p>为了说明问题，我们这里只是保持最简单的方式，如果某天情况变得复杂，有了不同的用户，或是聊天室也各不相同并加入了各自的特性，那我们就需要继续重构，抽象聊天室类，抽象用户类，读者可以灵活运用，这里就不做赘述了。</p><p>其实中介模式不止是在生活中广泛应用，<strong>在软件架构中也非常常见，当下流行的微服务分布式软件架构所用到的注册中心，例如最常用到的云组件Eureka Server，其作用就是为众多分布式服务提供注册发现服务，它正是充当像中介一样的角色。</strong></p><p>中介模式更像是网络拓扑中的<strong>星型结构</strong>，它描述了众节点与中心点的关系。</p><p><img src="https://github.com/cayzlh/git-img-repository/raw/master/blog/2019/03/01/5.png" alt="星型结构"></p><p>对像之间显式地互相引用越多，意味着依赖性越强，独立性越差，不利于代码维护与扩展，同时多方沟通的任务也应交由中间平台来完成，每个类应只具备各自该有的功能，这便是高内聚低耦合的设计标准。中介模式符合迪米特法则，它解决了对象间过度耦合、复杂频繁交互的问题，打破了你中有我，我中有你的相互依赖，第三方的介入有助于双方调停，打破如胶似漆、纠缠不休的关系，让他们之间变得松散、自由、独立。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Java设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 转载 </tag>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java设计模式之装饰器模式</title>
      <link href="/blog/2019/03/15/e4d55155.html"/>
      <url>/blog/2019/03/15/e4d55155.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>以下文章内容来源：微信公众号（Java知音）文章，设计模式是什么鬼（装饰）</p></blockquote><p>装饰，在某物件基础上加以修饰，装点，使得原本的朴素变得华丽，达到化腐朽为神奇的效果。比如我们从开发商买来的毛坯房，必然要进行室内装潢这么一项工程，什么简约风啊，北欧风啊，地中海，美式中式等等，当然萝卜青菜各有所爱，每个人装出的房子都各有差异，但不管何种风格，这都是对原本毛坯房的装饰，留给业主按照自己的喜好进行二次加工，这也是为什么有时候毛坯二手房比装修过的要好卖，有成品就一定得有半成品，这样才能把更多的选择留给用户，使得装饰成为可能。</p><p>人靠衣装马靠鞍，当然不止是装修有这么神奇的效果，对于女生化妆来说我们也是深有体会，每当女友回家卸妆后素面朝天的时候我们的内心是崩溃的，有种当初相亲被骗的感觉。</p><p>显而易见，女友每天出门之前进行的那场洗礼是多么的神圣，多么的不可或缺。诚然，化妆的过程对于男人来说充满了神秘色彩，但对于女人来说更像是一场洗礼，怀揣着信仰与敬畏感进行的一场仪式，最终会像魔法一般把自己的脸变得完美无瑕，更有甚者浓妆艳抹地连毛孔都看不到。</p><p>作为研发人员，我们一定不能放过对于这项神秘工程的拆解分析，开始我们的工作。首先每个人要展示自己那必然有一个标准行为show()，我们将它抽象出来作为接口Showable。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Showable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>;<span class="comment">//定义展示行为</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，女友会这门功夫了，所以实现了此行为并施展其“美丽的脸庞”了，但此时只是原生态的素颜。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Girl</span> <span class="keyword">implements</span> <span class="title">Showable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;女孩的素颜&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>没什么复杂的，直接调用的话会是素面朝天直面惨淡的人生，这样当然达不到美颜效果了，何以登上人生巅峰。那么接下来要进行化妆了，这里必须依靠一种神秘而又昂贵的东西，化妆品登场了，它同样实现了Showable接口。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Decorator</span> <span class="keyword">implements</span> <span class="title">Showable</span></span>&#123;<span class="comment">//化妆品粉饰器</span></span><br><span class="line"></span><br><span class="line">    Showable showable;<span class="comment">//持有某个善于展示的家伙</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Decorator</span><span class="params">(Showable showable)</span> </span>&#123;<span class="comment">//构造时注入这个家伙</span></span><br><span class="line">        <span class="keyword">this</span>.showable = showable;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;粉饰(&quot;</span>);<span class="comment">//化妆品粉饰</span></span><br><span class="line">        showable.show();<span class="comment">//这家伙素面朝天的秀</span></span><br><span class="line">        System.out.print(<span class="string">&quot;)&quot;</span>);<span class="comment">//粉饰打完收工</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以发现，在构造化妆品类的时候可以把女孩给注入进来，目的在于调用女孩的show方法，但对于其原本的具体行为装饰器一无所知，并且没有加入任何逻辑限制，它所做的无非是“画龙点睛”，“锦上添花”。接下来我们来运行一下看结果。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//用装饰器包裹女孩show出来</span></span><br><span class="line">        <span class="keyword">new</span> Decorator(<span class="keyword">new</span> Girl()).show();</span><br><span class="line">        <span class="comment">//结果：粉饰(女孩的素颜)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到，只需要新建装饰器的时候把女孩给包装进去就得到了粉饰过的美颜，是不是非常简单？然而此时有女朋友会嫌弃了，“只是打粉底这么简单吗？眼霜呢？口红呢……”。</p><p>好吧，为了满足女友的要求，我们得再多一些设计。想想看这些化妆品，不管是什么都有共同的特性，也就是说他们统统都可以装饰原生态的素颜展示方法show，那我们何不把这些特性抽象出来呢？开始行动，修改我们的装饰类。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Decorator</span> <span class="keyword">implements</span> <span class="title">Showable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Showable showable;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Decorator</span><span class="params">(Showable showable)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.showable = showable;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        showable.show();<span class="comment">//直接调用不做加任何粉饰。</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们把化妆品类给改成抽象类，重写show方法，但不做任何粉饰了，这里我们留给子类具体的某个化妆品去做装饰吧。化妆首先第一步一定要打底了，这里我们首先加入一个粉底类。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FoundationMakeup</span> <span class="keyword">extends</span> <span class="title">Decorator</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FoundationMakeup</span><span class="params">(Showable showable)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(showable);<span class="comment">//调用化妆品父类注入</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;打粉底(&quot;</span>);</span><br><span class="line">        showable.show();</span><br><span class="line">        System.out.print(<span class="string">&quot;)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到粉底类继承了化妆品类，当然这个粉底的show方法一定要加以修饰了，在原生态的前后都进行了打粉底操作。同样地，打完粉底后再画个口红吧。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Lipstick</span> <span class="keyword">extends</span> <span class="title">Decorator</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Lipstick</span><span class="params">(Showable showable)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(showable);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;涂口红(&quot;</span>);</span><br><span class="line">        showable.show();</span><br><span class="line">        System.out.print(<span class="string">&quot;)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，我们把女友、粉底、口红层层包裹起来并运行，结果如愿以偿。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//口红包裹粉底，再包裹女友。</span></span><br><span class="line">        Showable madeupGirl = <span class="keyword">new</span> Lipstick(<span class="keyword">new</span> FoundationMakeup(<span class="keyword">new</span> Girl()));</span><br><span class="line">        madeupGirl.show();</span><br><span class="line">        <span class="comment">//运行结果：涂口红(打粉底(女孩的脸庞))</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果女友对这种淡妆效果还是不满意，我们可以继续添加化妆品类，睫毛膏、眼线、眉笔、腮红等等等等，只需要层层包裹起来，最终实现女友浓妆艳抹的梦想。</p><p>我们观察这种装饰器模式结构，是不是似曾相识呢？没错，其实装饰器模式在JDK里就有很多应用，比如<strong>Java IO包里的众多流处理类。</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> FileInputStream(filePath)));</span><br></pre></td></tr></table></figure><p>当然，流处理类当然要比我们的例子复杂的多，但其基本思想和我们去繁就简的例子异途同归，这些对象就好像是俄罗斯套娃一样层层包裹，层层装饰，每套一层就会多出一些功能出来，我们更可以自由搭配，实现不同的组合功能。</p><p>所以，不管是女生化妆还是程序员写代码，我们都不可能弄出一个巨大的类然后去搞定所有事情，如此代码会越堆积越多，难于维护，功能扩展更是举步维艰。我们都需要有这种设计思想，每个化妆品部件各司其职，不做和自己不相关的事，然后把部件层层叠加，并根据需求组装成型，以达最终的装饰目的。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Java设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 转载 </tag>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java设计模式之门面模式</title>
      <link href="/blog/2019/03/12/2ce91e46.html"/>
      <url>/blog/2019/03/12/2ce91e46.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>以下文章内容来源：微信公众号（Java知音）文章，设计模式是什么鬼（门面）</p></blockquote><p>开门见山，门，建筑物的入口，面，脸也。门面（Facade），通常指店铺的门头外表部分，当然一定要临街才是好的商铺，在人流量大的地方营造更好的视觉冲击，这样会有更多等等机会暴露给潜在顾客，否则只能是靠“酒香不怕巷子深”，靠味道来吸引人了。</p><p><img src="https://github.com/cayzlh/git-img-repository/raw/master/blog/2019/03/01/2.jpeg" alt="酒神不怕巷子深"></p><p>当然除了光鲜亮丽的外表，更重要的是门店提供的服务了。就拿餐饮来举例吧，如果没有这些门店我们都怎样吃饭呢？我们自己做又不会，算了还是找女友下厨吧。很简单分三步走，首先找菜贩买菜，其次女友下厨，最后吃完洗碗，打完收工代码如下。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VegVendor</span> </span>&#123;<span class="comment">//菜贩子</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sell</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;菜贩子卖菜。。。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GirlFriend</span> </span>&#123;<span class="comment">//女友</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cook</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;女友烹饪。。。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Me</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我只会吃。。。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//找菜贩子买菜</span></span><br><span class="line">        VegVendor vv = <span class="keyword">new</span> VegVendor();</span><br><span class="line">        vv.sell();</span><br><span class="line">        <span class="comment">//找女友做饭</span></span><br><span class="line">        GirlFriend gf = <span class="keyword">new</span> GirlFriend();</span><br><span class="line">        gf.cook();</span><br><span class="line">        <span class="comment">//我只会吃</span></span><br><span class="line">        Me me = <span class="keyword">new</span> Me();</span><br><span class="line">        me.eat();</span><br><span class="line">        <span class="comment">//谁洗碗呢？一场战场一触即发……</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实我们不该找女友做饭的，而是应该雇一个专业厨师，可这下来得多大花费啊，太划不来了，也许还得我们自己洗碗……哎。其实我们也不想麻烦，还是找门店来解决吧，至于那些买菜啊，烹饪啊，洗碗收拾桌子啊我们统统都不用管了，门店可以进行资源整合与调度，这样我们吃饭就变得如此简单了，只需要付钱就行了，毕竟我们只会吃。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Facade</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> VegVendor vv;</span><br><span class="line">    <span class="keyword">private</span> Chef chef;</span><br><span class="line">    <span class="keyword">private</span> Waiter waiter;</span><br><span class="line">    <span class="keyword">private</span> Cleaner cleaner;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Facade</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.vv = <span class="keyword">new</span> VegVendor();</span><br><span class="line">        <span class="comment">//开门前就找菜贩子准备好蔬菜</span></span><br><span class="line">        vv.sell();</span><br><span class="line">        <span class="comment">//当然还得雇佣好各类饭店服务人员</span></span><br><span class="line">        <span class="keyword">this</span>.chef = <span class="keyword">new</span> Chef();</span><br><span class="line">        <span class="keyword">this</span>.waiter = <span class="keyword">new</span> Waiter();</span><br><span class="line">        <span class="keyword">this</span>.cleaner = <span class="keyword">new</span> Cleaner();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">provideService</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//接待，入座，点菜</span></span><br><span class="line">        waiter.order();</span><br><span class="line">        <span class="comment">//找厨师做饭</span></span><br><span class="line">        chef.cook();</span><br><span class="line">        <span class="comment">//上菜</span></span><br><span class="line">        waiter.serve();</span><br><span class="line">        <span class="comment">//收拾桌子，洗碗，以及其他工序……</span></span><br><span class="line">        cleaner.clean();</span><br><span class="line">        cleaner.wash();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这下可爽了，我们再也不用去花费时间去调动那么多资源，又是出门买菜，又是找女友做菜，洗碗擦桌什么的。所以我们急需一个门面来解决这些问题，如果没有门面的话，试想每家每户每顿都做饭的话，于是我们放弃我们的专业优势，整天花很长时间做饭才能不饿肚子，如此劳动分工不明确，社会生产率低下，国家经济生产不景气，最后造成GDP下滑，这就是亚当斯密的劳动分工理论。</p><hr><p><strong>总结：</strong></p><p>其实这就是门面模式的用法了，门面就是一个大系统，里面封装了很多的子部件（或子系统），部件之间也许有复杂的逻辑关系，对于我们旁观者来说，直接使用这些子部件是非常麻烦的一件事情，所以门面就充当了一个包装类的角色，并且对外暴露一个接口，达到简化客户操作的目的，同时也是对客户端与子系统之间的解耦。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Java设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 转载 </tag>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java设计模式之模板方法</title>
      <link href="/blog/2019/03/08/334a0583.html"/>
      <url>/blog/2019/03/08/334a0583.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>设计模式`相关文章，用于整理网络中对应的设计模式的一些解读。</p><p> 面向对象，是对事物属性与行为的封装，方法，指的就是行为。模板方法，显而易见是说某个方法充当了模板的作用，其充分利用了抽象类虚实结合的特性，虚部抽象预留，实部固定延续，以达到将某种固有行为延续至子类的目的。反观接口，则达不到这种目的。要搞明白模板方法，首先我们从接口与抽象类的区别切入。</p><p>以下文章内容来源：微信公众号（Java知音）文章，设计模式是什么鬼（模板方法）</p></blockquote><h2 id="模板方法"><a href="#模板方法" class="headerlink" title="模板方法"></a>模板方法</h2><p>汽车上的接口最常见的就是这几个了：<strong>点烟器，USB，AUX等等</strong>，很明显这些都是接口，它们都预留了某种标准，暴露在系统外部，并与外设对接。就拿点烟器接口来说吧，它原本是专门用于给点烟器供电的，后来由于这个接口在汽车上的通用性，于是衍生出了各种外部设备，只要是符合这个标准size的，带正负极簧片的，直流12V的，那就可以使用，比如导航、行车记录仪、吸尘器什么的，以及其他各种车载电子设备。</p><h3 id="点烟器接口"><a href="#点烟器接口" class="headerlink" title="点烟器接口"></a>点烟器接口</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CigarLighterInterface</span> </span>&#123;<span class="comment">//点烟器接口</span></span><br><span class="line">    <span class="comment">//供电方法，16V直流电</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">electrifyDC16V</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="GPS"><a href="#GPS" class="headerlink" title="GPS"></a>GPS</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GPS</span> <span class="keyword">implements</span> <span class="title">CigarLighterInterface</span> </span>&#123;</span><br><span class="line">    <span class="comment">//导航的实现</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">electrifyDC16V</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;连接卫星&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;定位。。。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="CigarLighter"><a href="#CigarLighter" class="headerlink" title="CigarLighter"></a>CigarLighter</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CigarLighter</span> <span class="keyword">implements</span> <span class="title">CigarLighterInterface</span> </span>&#123;</span><br><span class="line">    <span class="comment">//点烟器的实现</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">electrifyDC16V</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> time = <span class="number">1000</span>;</span><br><span class="line">        <span class="keyword">while</span>(--time&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;加热电炉丝&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;点烟器弹出&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于点烟器接口来说，它根本不在乎也不知道对接的外设是什么鬼，它只是定义了一种规范，一种标准，只要符合的都可以对接。再比如USB接口的应用更加广泛，外设更是应有尽有。</p><p>当然大部分情况我们使用接口会多于抽象类，因为接口灵活啊，抽象类不允许多继承啊等等，其实我们还是要看应用场景，在某种无规矩不成方圆，或者规范比较明确，的情况下抽象类的应用是有必要的，世间万物没有最好的，只有最合适的。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Java设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 转载 </tag>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java设计模式之状态模式</title>
      <link href="/blog/2019/03/01/5f8f3de5.html"/>
      <url>/blog/2019/03/01/5f8f3de5.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>设计模式`相关文章，用于整理网络中对应的设计模式的一些解读。</p></blockquote><h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><blockquote><p>以下文字来源于微信公众号（Java知音）文章，设计模式是什么鬼（状态）</p></blockquote><p>状态State，指某事物所处的状况或形态，比如水的三态，零下会变成固态冰，常温会是液态水，100℃会蒸发成气态的水蒸气。</p><p>在这个地球生态系统中，水的总量并不会增加，也不会减少，只是随着温度的变化其分子间发生了稀松紧密的变化罢了，于是便有了不同的行为，比如流动、凝固、或是蒸腾，但对于其本质H2O分子对象并没有任何变化，变化的，只是其形态。</p><p><img src="https://github.com/cayzlh/git-img-repository/raw/master/blog/2019/02/20/1.jpg" alt="图片"></p><p>当然，事物的状态都是不同的，有的多有的少。物质基本三态，人的精神状态更是非常复杂多变的，喜怒哀乐，五味杂陈。更有趣的是，对于某些患有严重的精神分裂的病人来说，其精神状态更是变化无常，有些竟可以扮演几十种角色，随时间或境遇切换，一会变成精明聪颖的律师，一会是懦弱的失败者总是要自杀，一个境遇触发又是愤怒的杀人暴徒，这人格切换速度，丧心病狂到令人发指。</p><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><blockquote><p>以下实例来源于微信公众号（Java知音）文章，设计模式是什么鬼（适配器）</p></blockquote><h3 id="开关"><a href="#开关" class="headerlink" title="开关"></a>开关</h3><p>实现一个开关类，暴露出两个UI可操作接口（对接你的手指）：开、关。</p><p><img src="https://github.com/cayzlh/git-img-repository/raw/master/blog/2019/03/01/1.png" alt="开关"></p><p>定义一个类吧，就叫它：Switcher好了，对外暴露两个方法：switchOn()以及switchOff()，以便用户调用。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Switcher</span> </span>&#123;</span><br><span class="line">    <span class="comment">//false代表关，true代表开</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> state = <span class="keyword">false</span>;<span class="comment">//初始状态是关</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">switchOn</span><span class="params">()</span></span>&#123;</span><br><span class="line">        state = !state;</span><br><span class="line">        System.out.println(<span class="string">&quot;OK...灯亮&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">switchOff</span><span class="params">()</span></span>&#123;</span><br><span class="line">        state = !state;</span><br><span class="line">        System.out.println(<span class="string">&quot;OK...灯灭&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接口设计完成，没有问题了！！当然说这个没问题是在前端UI壳子设计精妙的前提下，但这<strong>并不能代表我们的程序设计没问题。</strong>如果UI可以重复调用开或者关会出现什么情况？状态乱套了！这个设计是非常不可靠的，我们不能因为表面设计上的完美就忽略了后端代码功能的逻辑正确性，表里不一。这就是为什么我们做应用时不但要做好前端校验（<strong>用户体验</strong>），更要保证后端校验（<strong>功能正确性</strong>）不可缺失。</p><p>改一下我们之前的设计，这里一定要加入针对当前状态的条件判断，也就是说，开的状态不能再开，关的状态不能再关！</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Switcher</span> </span>&#123;</span><br><span class="line">    <span class="comment">//false代表关，true代表开</span></span><br><span class="line">    <span class="keyword">boolean</span> state = <span class="keyword">false</span>;<span class="comment">//初始状态是关</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">switchOn</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(state == <span class="keyword">false</span>)&#123;<span class="comment">//当前是关状态</span></span><br><span class="line">            state = <span class="keyword">true</span>;</span><br><span class="line">            System.out.println(<span class="string">&quot;OK...灯亮&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;<span class="comment">//当前是开状态</span></span><br><span class="line">            System.out.println(<span class="string">&quot;WARN!!!通电状态无需再开&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">switchOff</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(state == <span class="keyword">true</span>)&#123;<span class="comment">//当前是开状态</span></span><br><span class="line">            state = <span class="keyword">false</span>;</span><br><span class="line">            System.out.println(<span class="string">&quot;OK...灯灭&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;<span class="comment">//当前是关状态</span></span><br><span class="line">            System.out.println(<span class="string">&quot;WARN!!!断电状态无需再关&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里加入了逻辑判断，如果重复开或者重复关的话是会告警的，当然这里也可以抛异常出去，我们就不搞那么复杂化了。那对于这样的设计没有问题吧？很显然，逻辑上是跑的通的，写个Client类测试一下。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Switcher s = <span class="keyword">new</span> Switcher();</span><br><span class="line">        s.switchOff();<span class="comment">//WARN!!!断电状态无需再关</span></span><br><span class="line">        s.switchOn();<span class="comment">//OK...灯亮</span></span><br><span class="line">        s.switchOff();<span class="comment">//OK...灯灭</span></span><br><span class="line">        s.switchOn();<span class="comment">//OK...灯亮</span></span><br><span class="line">        s.switchOn();<span class="comment">//WARN!!!通电状态无需再开</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>So far，不管熊孩子怎么开开关关都不会有问题了。</p><h3 id="自动挡"><a href="#自动挡" class="headerlink" title="自动挡"></a>自动挡</h3><blockquote><p>这样的设计仍然是糟糕的。试想，如果状态不止一种，并且状态切换有及其复杂的逻辑，例如：汽车的自动挡。</p></blockquote><p>汽车的自动挡，按照上面的逻辑来设计，就像如下代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">    <span class="comment">//0：Park驻车档，1：Reverse倒退挡，</span></span><br><span class="line">    <span class="comment">//2：Neutral空挡，3：Drive前进档。</span></span><br><span class="line">    String state = <span class="string">&quot;P&quot;</span>;<span class="comment">//初始状态是P档</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">()</span></span>&#123;<span class="comment">//向上推档杆</span></span><br><span class="line">        <span class="keyword">switch</span> (state) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;P&quot;</span>:<span class="comment">//驻车档状态</span></span><br><span class="line">            System.out.println(<span class="string">&quot;WARN!!!到头了推不动了！&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;R&quot;</span>:<span class="comment">//倒挡状态</span></span><br><span class="line">            state = <span class="string">&quot;P&quot;</span>;</span><br><span class="line">            System.out.println(<span class="string">&quot;OK...切P档&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;N&quot;</span>:<span class="comment">//空档状态</span></span><br><span class="line">            System.out.println(<span class="string">&quot;OK...切R档&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;D&quot;</span>:<span class="comment">//前进档状态</span></span><br><span class="line">            System.out.println(<span class="string">&quot;OK...切N档&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pull</span><span class="params">()</span></span>&#123;<span class="comment">//向下拉档杆</span></span><br><span class="line">        <span class="comment">//这里省略，逻辑同上类似</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个是在<strong>作死</strong>了，那一大堆逻辑判断写在宿主类里会越来越像蜘蛛网！我们必须想方设法把这个设计给模块化，把状态模块给独立出来！可以使用<a href="/2019/02/26/2019022601/">策略模式</a>，将算法策略被抽离出来，这里举一反三，把状态也给抽离出来，好了办法有了，我们忘掉自动挡，继续用我们大道至简的开关例子。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">State</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">switchOn</span><span class="params">(Switcher switcher)</span></span>;<span class="comment">//开</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">switchOff</span><span class="params">(Switcher switcher)</span></span>;<span class="comment">//关</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上我们首先了定义一个状态State接口，两个方法开与关，注意这里与策略模式不同的是，我们为了与宿主Switcher对接所以把它作为参数传入。然后是开状态与关状态的实现。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">On</span> <span class="keyword">implements</span> <span class="title">State</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">switchOn</span><span class="params">(Switcher switcher)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;WARN!!!通电状态无需再开&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">switchOff</span><span class="params">(Switcher switcher)</span> </span>&#123;</span><br><span class="line">        switcher.setState(<span class="keyword">new</span> Off());</span><br><span class="line">        System.out.println(<span class="string">&quot;OK...灯灭&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Off</span> <span class="keyword">implements</span> <span class="title">State</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">switchOn</span><span class="params">(Switcher switcher)</span> </span>&#123;</span><br><span class="line">        switcher.setState(<span class="keyword">new</span> On());</span><br><span class="line">        System.out.println(<span class="string">&quot;OK...灯亮&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">switchOff</span><span class="params">(Switcher switcher)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;WARN!!!断电状态无需再关&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显而易见，注意看第10行代码，开状态不能做开行为，只告警并返回，关状态反之亦然。而第4行代码则是合法的行为，所以可以进行状态切换并实施相应行为，也就是说，开状态可关，关状态可开。注意这里是把宿主对象传入进来用于切换其当前状态，亦或是调用宿主的具体功能方法（这里省略用打印输出代替），比如宿主里的一盏灯提供的方法。</p><p>至此，一切看起来非常优雅，我们已经成功的将状态从宿主中抽离了，最后再来看宿主开关类是什么样子。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Switcher</span> </span>&#123;</span><br><span class="line">    <span class="comment">//开关的初始状态设置为“关”</span></span><br><span class="line">    <span class="keyword">private</span> State state = <span class="keyword">new</span> Off();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> State <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(State state)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.state = state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">switchOn</span><span class="params">()</span></span>&#123;</span><br><span class="line">        state.switchOn(<span class="keyword">this</span>);<span class="comment">//这里调用的是当前状态的开方法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">switchOff</span><span class="params">()</span></span>&#123;</span><br><span class="line">        state.switchOff(<span class="keyword">this</span>);<span class="comment">//这里调用的是当前状态的关方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>甚至我们还可以给里面加一盏灯，像之前我们提到的那样，在State状态接口实现里去调用。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Switcher</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...之上代码略...</span></span><br><span class="line">    <span class="keyword">private</span> Lamp lamp;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lampOn</span><span class="params">()</span></span>&#123;</span><br><span class="line">        lamp.on();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lampOff</span><span class="params">()</span></span>&#123;</span><br><span class="line">        lamp.off();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实它就是策略的一个变种，只不过<strong>状态模式会更好的根据当前的状态去实施不同的行为，并且自主切换到另一个正确的状态，开变关，关变开。</strong>就好似电梯（虽然是嵌入式面向过程，这里只是举例），用户根本无法随意强制更改其状态以及行为，你让它上，它不一定马上就能上，否则会造成事故。电梯内部封装了多个状态以及对应的逻辑产生不同的行为，它会根据当前状态去自我调整并实施最优方案，以达到安全、高效的目的，这才是可靠的设计。</p><p><strong>注意事项：</strong>在行为受状态约束的时候使用状态模式，而且状态不超过 5 个。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Java设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 转载 </tag>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java设计模式之策略模式</title>
      <link href="/blog/2019/02/26/a7a792e2.html"/>
      <url>/blog/2019/02/26/a7a792e2.html</url>
      
        <content type="html"><![CDATA[<blockquote><p><code>设计模式</code>相关文章，用于整理网络中对应的设计模式的一些解读。</p></blockquote><h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><p>在策略模式（Strategy Pattern）中，一个类的行为或其算法可以在运行时更改。这种类型的设计模式属于行为型模式。</p><p>在策略模式中，我们创建表示各种策略的对象和一个行为随着策略对象改变而改变的 context 对象。策略对象改变 context 对象的执行算法。</p><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><blockquote><p>以下实例来源于微信公众号（Java知音）文章，设计模式是什么鬼（策略）</p></blockquote><h3 id="计算器"><a href="#计算器" class="headerlink" title="计算器"></a>计算器</h3><p>实现一个最简单的计算器，假设只能进行加减法，代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Calculator</span> </span>&#123;<span class="comment">//违反设计模式原则的做法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;<span class="comment">//加法</span></span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sub</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;<span class="comment">//减法</span></span><br><span class="line">        <span class="keyword">return</span> a - b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样写能实现我们的加减法功能，但是往拓展方面想，如果随着我们的算法不断增加，如乘法、除法、次方、开方等等，那么这个计算器类就得不断的改啊改啊，改到最后这个类的代码将会非常庞大。。</p><h3 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h3><p>既然不能把算法给写死在这里面，那一定要把这个算法给抽象一下，<strong>把实现细节从这个类里抽离出来，独立出来成为n个策略，</strong>就当下来讲我们一共有俩个策略，一个是加法策略，一个是减法策略，他们实现的都是同一个算法接口，接收参数为操作数a，以及被操作数b。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Strategy</span> </span>&#123;<span class="comment">//算法标准</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calculate</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;<span class="comment">//操作数，被操作数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><h4 id="加法"><a href="#加法" class="headerlink" title="加法"></a>加法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Addition</span> <span class="keyword">implements</span> <span class="title">Strategy</span></span>&#123;<span class="comment">//实现算法接口</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calculate</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;<span class="comment">//加数与被加数</span></span><br><span class="line">        <span class="keyword">return</span> a + b;<span class="comment">//这里我们做加法运算</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="减法"><a href="#减法" class="headerlink" title="减法"></a>减法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Subtraction</span> <span class="keyword">implements</span> <span class="title">Strategy</span></span>&#123;<span class="comment">//实现算法接口</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calculate</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;<span class="comment">//减数与被减数</span></span><br><span class="line">        <span class="keyword">return</span> a - b;<span class="comment">//这里我们做减法运算</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="实现计算器"><a href="#实现计算器" class="headerlink" title="实现计算器"></a>实现计算器</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Calculator</span> </span>&#123;<span class="comment">//计算器类</span></span><br><span class="line">    <span class="keyword">private</span> Strategy strategy;<span class="comment">//拥有某种算法策略</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStrategy</span><span class="params">(Strategy strategy)</span> </span>&#123;<span class="comment">//接入算法策略</span></span><br><span class="line">        <span class="keyword">this</span>.strategy = strategy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getResult</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.strategy.calculate(a, b);<span class="comment">//返回具体策略的结果</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，计算器类里已经把之前的具体加减算法实现代码给剥离出去了，要用哪个算法，只需要注入进来，然后获得计算结果getResult实际上调用的是具体算法的calculate。</p><h4 id="使用计算器"><a href="#使用计算器" class="headerlink" title="使用计算器"></a>使用计算器</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Calculator calculator = <span class="keyword">new</span> Calculator();<span class="comment">//实例化计算器</span></span><br><span class="line">        calculator.setStrategy(<span class="keyword">new</span> Addition());<span class="comment">//接入加法实现</span></span><br><span class="line">        <span class="keyword">int</span> result = calculator.getResult(<span class="number">1</span>, <span class="number">1</span>);<span class="comment">//计算！</span></span><br><span class="line">        System.out.println(result);<span class="comment">//得到的是加法结果2</span></span><br><span class="line"></span><br><span class="line">        calculator.setStrategy(<span class="keyword">new</span> Subtraction());<span class="comment">//再次接入减法实现</span></span><br><span class="line">        result = calculator.getResult(<span class="number">1</span>, <span class="number">1</span>);<span class="comment">//计算！</span></span><br><span class="line">        System.out.println(result);<span class="comment">//得到的是减法结果0</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个计算器可以说是具有算法策略扩展性的，以后要有新的算法是不需要再更改任何现有代码的，只需要新写一个算法比如乘法Multiplication，并实现calculate方法，接下来要做的只是组装上去便可以使用了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>策略实现类已经成为独立于宿主之外的模块，即插即用。可以组合成为一个整体，又可以分拆独立，可以发生关联，但绝不耦合，既对立又统一，这是唯物辩证法的绝佳体现。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Java设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 转载 </tag>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java设计模式之适配器模式</title>
      <link href="/blog/2019/02/25/8ac957b9.html"/>
      <url>/blog/2019/02/25/8ac957b9.html</url>
      
        <content type="html"><![CDATA[<blockquote><p><code>设计模式</code>相关文章，用于整理网络中对应的设计模式的一些解读。</p></blockquote><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><blockquote><p>以下实例来源于微信公众号（Java知音）文章，设计模式是什么鬼（适配器）</p></blockquote><p>顾名思义，适配器，得适应当前的不同配置，解决兼容性问题。我们生活中充满了各种各样的适配器，上网用的调制解调器(modem)就是一种数模转换的适配器，俗称“猫”，不过现在都是光猫了，也就是光信号和电信号的互相转化，其实道理是一样的，还有各种变压器也属于电压转换的适配器。</p><p><img src="https://github.com/cayzlh/git-img-repository/raw/master/blog/2019/02/25/1.png" alt="适配器"></p><p>如果觉得还不够形象可以看一下家里的电器，比如你的电视是两项插头，墙上的插孔是三项插孔怎么办？哦，有人说把插头掰弯强行插入！那如果是三项插头接两项插孔呢？把零线插针拔了！呃，我只能说这是暴力破解！违反设计模式原则。言归正传，我们还是不要随便破坏现有的类，那我们需要的是一个转换器，用优雅微妙的方式化解这种不兼容情况。</p><p><img src="https://github.com/cayzlh/git-img-repository/raw/master/blog/2019/02/25/2.png" alt="适配器"></p><p>举个例子，我们开始代码部分，先写墙上的三项插孔接口，命名<code>TriplePin</code>：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TriplePin</span> </span>&#123;</span><br><span class="line">    <span class="comment">//参数分别为火线live，零线null，地线earth</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">electrify</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> n, <span class="keyword">int</span> e)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们只定义三插孔标准<code>electrify</code>（通电）方法，三个参数分别是火线、零线、地线，很简单吧，同样地接下来是两项插孔接口，只是少了地线，命名<code>DualPin</code>：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DualPin</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">electrify</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> n)</span></span>;<span class="comment">//这里没有地线</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请注意，这个并不是我们的墙上的目标接口，而是电视机的两插标准。好了继续，我们的<code>TV</code>登场了，用的是两项插头，当然它实现的是<code>DualPin</code>的标准，<code>Let&#39;s keep it simple</code>，命名<code>TV</code>：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TV</span> <span class="keyword">implements</span> <span class="title">DualPin</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span><span class="comment">//既然是两项插头，当然实现两项插标准</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">electrify</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;火线通电：&quot;</span> + l);</span><br><span class="line">        System.out.println(<span class="string">&quot;零线通电：&quot;</span> + n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么问题来了，墙上的接口是三插标准，电视实现的是两插标准，无法通电。怎么办？把电视拆了重新修改实现三插标准么？暴力份子你又来？答案显然是否定的，既然是设计模式，果断转换插头啊！好，写个<code>Adapter</code>解决他们之间不可调和的矛盾。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Adapter</span> <span class="keyword">implements</span> <span class="title">TriplePin</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> DualPin dualPinDevice; </span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建适配器地时候，需要把双插设备接入进来</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Adapter</span><span class="params">(DualPin dualPinDevice)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.dualPinDevice = dualPinDevice;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//适配器实现的是目标接口</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">electrify</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> n, <span class="keyword">int</span> e)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//实际上调用了被适配设备的双插通电，地线e被丢弃了。</span></span><br><span class="line">        dualPinDevice.electrify(l, n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意了最关键最精华的部分来了，<code>private DualPin dualPinDevice; </code>代码意味着这个适配器内部是有一个双插接口的，对于任何双插标准的设备都是可以兼容的OK吗？不明白赶紧看看你家里的适配器。<code>public Adapter(DualPin dualPinDevice) &#123;...&#125;</code>方法的代码完成的过程实际就是你把电视插头接入<code>Adapter</code>了，其实适配器并不在意是什么设备，洗衣机冰箱都可以的，只要是双插标准就可以接入（第一节讲过的多态概念）。<code>electrify()</code>通电方法实现的是三插标准，但方法体内部<code>dualPinDevice.electrify(l, n);</code>实际上是在给“某个设备”（是什么设备就看你接什么了）的双插供电，地线e那个参数是用不上的，所以就没有接通，很清晰透彻吧？</p><p>当然，除了以上的注入插头的方式（对象适配），还有另一种更简单的方式叫做“类适配器”我们来看下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassAdapter</span> <span class="keyword">extends</span> <span class="title">TV</span> <span class="keyword">implements</span> <span class="title">TriplePin</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">electrify</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> n, <span class="keyword">int</span> e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.electrify(l, n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看出来区别没有？这里并没有注入插头（对象组合），而是把电视机给继承了，这样就可以直接调用父类（TV）的双插通电而不是注入进来去调用，缺点大家也看到了，这适配器继承为TV儿子专用了，洗衣机是用不了啦，作死？其实也不是完全不好，要看具体应用场景哈。</p><p>至此，我们的<code>Adapter</code>就差不多完成了，以后再也不用破坏插头了，因为这样重写接口或者修改类的代价太大，如果其他类还有依赖的话，那统统要修改，引入了没有必要的重构，总之暴力修改是违反设计模式的基本原则的，开闭原则，指的就是对扩展开放，而对修改关闭，也就是说不要去改动原始类，而是扩展现有功能，提供另一种机制让整个系统实现想要的功能。</p><p>最后说下那些概念，归类，名字，什么“类适配器”，“对象适配器”啊，其实，理解不了就算了无所谓，真正的意义在于怎么样在实际工作中灵活运用，实现方式是无穷无尽的，道不清说不尽的，没必要太纠结它到底叫什么，归于哪一类，掌控其背后的道才是最根本的，正如李耳君所言：“道可道，非常道。名可名，非常名。”</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Java设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 转载 </tag>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java设计模式之单例模式</title>
      <link href="/blog/2019/02/20/242438ad.html"/>
      <url>/blog/2019/02/20/242438ad.html</url>
      
        <content type="html"><![CDATA[<blockquote><p><code>设计模式</code>相关文章，用于整理网络中对应的设计模式的一些解读。</p></blockquote><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>单例模式（<code>Singleton Pattern</code>）是 <code>Java</code> 中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。</p><p>这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。</p><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ul><li>1、单例类只能有一个实例。</li><li>2、单例类必须自己创建自己的唯一实例。</li><li>3、单例类必须给所有其他对象提供这一实例。</li></ul><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><strong>意图：</strong>保证一个类仅有一个实例，并提供一个访问它的全局访问点。</p><p><strong>主要解决：</strong>一个全局使用的类频繁地创建与销毁。</p><p><strong>何时使用：</strong>当您想控制实例数目，节省系统资源的时候。</p><p><strong>如何解决：</strong>判断系统是否已经有这个单例，如果有则返回，如果没有则创建。</p><p><strong>关键代码：</strong>构造函数是私有的。</p><h2 id="实例应用"><a href="#实例应用" class="headerlink" title="实例应用"></a>实例应用</h2><blockquote><p>以下实例来源于微信公众号（Java知音）文章，设计模式是什么鬼（单例）</p></blockquote><p>单例，顾名思义，整个系统其实就只有一个实例存在，不能再多，否则就不叫单例。那我们把整个宇宙看做是一个庞大的系统，这宇宙里有各种对象存在，人啊，动物啊，植物啊不胜枚举，这些都是实例，丰富多彩的世界是美好的。然而，持续几千年的战争给世界带来了巨大灾难，尤其是宗教战争最为残忍，各个信仰间存在极大的世界观价值观冲突。</p><p><img src="https://github.com/cayzlh/git-img-repository/raw/master/blog/2019/02/20/1.jpg" alt="神"></p><p>单印度一个国家就有几百个神，人们各信各的，风俗各异，各邦文化冲突不断，语言不通，办事效率极低。</p><p><img src="https://github.com/cayzlh/git-img-repository/raw/master/blog/2019/02/20/1.jpg" alt="插图"></p><p>为了让幸福美好洒满人间，那我们就定义一位神吧，独一无二的神。</p><p><img src="https://github.com/cayzlh/git-img-repository/raw/master/blog/2019/02/20/1.jpg" alt="插图"></p><p>我们先写一个God类吧，类中空空如也，世界如此清净，虚无缥缈。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">God</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先我们得保证任何人都不能去创建神的实例，否则如：<code>new God()</code>，这样世界又要陷入战争的灾难，各种造神运动，或是某天又出来个什么神棍先知告诉信徒说他们肚子里有个轮子。那就不写构造方法吧？不行，因为有默认的无参构造器！那就把构造方法改成private吧，也就是神可以自己创造自己，但别人不能。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">God</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">God</span><span class="params">()</span></span>&#123;&#125;<span class="comment">//构造方法私有化</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>God类里面封装一个God自己，对，一切都是神创造的，包括我们人类。有人开始质疑，那神是谁？神自己是谁造的？这是个哲学问题。神说“I am who I am.” 我是我所是，我就是我，自有永有，超越时空。很逆天吧？ 好吧，谁也不能造上帝，神自己造自己。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">God</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> God god = <span class="keyword">new</span> God();<span class="comment">//自有永有的神单例</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">God</span><span class="params">()</span></span>&#123;&#125;<span class="comment">//构造方法私有化</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上<code>private</code>关键字保证了上帝的私有性，不可见性，不可访问性，我想没有活人见过上帝吧？<code>static</code>关键字保证上帝的静态性，他与类同在，不依赖于类的实例化就自有永有，他将在内存中永生，<code>GC</code>垃圾回收器也回收不了他。<code>final</code>关键字则保证这位神是和常量，衡量，他是终极上帝，不能再改。</p><p>正如同静态方法<code>main()</code>，不需要实例化类就能运行的入口，同样我们需要一个静态方法<code>getInstance()</code>来请神，方法体内我们就返回这个在唯一的真神，当然方法它必须是<code>public</code>公开的，不然谁都访问不了。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">God</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> God god = <span class="keyword">new</span> God();<span class="comment">//自有永有的神单例</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">God</span><span class="params">()</span></span>&#123;&#125;<span class="comment">//构造方法私有化</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> God <span class="title">getInstance</span><span class="params">()</span></span>&#123;<span class="comment">//请神方法公开化</span></span><br><span class="line">        <span class="keyword">return</span> god;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上的神类雏形已经写好了，当然你还可以加其他的功能方法，比如说创世纪神造了光，造了世界、动物、人、亚当夏娃等等功能，我们这里就不在赘述了。那对于外部来说只要调用<code>God.getInstance();</code>就可以拿到神了，而且不管谁拿，拿几次，都是同一个神，这样就保证了整个系统中神的唯一性，不可伪造性，至于其他先知那也只是神的代理人，只能帮请神而已。</p><p>好了，其实我们已经学会了单例模式的<strong>“痴汉模式（Eager load）”</strong>，代码第一行一开始就造出了神（new God那一句），已经准备好了随时给你请神，这样就有了一个问题，如果没人请神那不是白造了？提前备货如果价格跌了不是很惨？反应在系统中的问题就是占用了内存空间。于是又有了<strong>“懒汉模式（Lazy load）”</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">God</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> God god;<span class="comment">//这里不进行实例化</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">God</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> God <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (god == <span class="keyword">null</span>) &#123;<span class="comment">//如果无神才造神</span></span><br><span class="line">            god = <span class="keyword">new</span> God();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> god;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这我们看到一开始就没有造神，只有某人第一次求神时才实例化，之后再求的就直接返回了。这样的好处是省了一段时间的内存（无求神期间），坏处是第一次请神的时候速度相较之前的痴汉模式会慢，因为要消耗<code>CPU</code>去造神。</p><p>其实这么写是在多线程模式下是有陷阱的，试想多人同时并发请神的话，依然会造成多神，好吧我们再来改良一下，把请神方法加上<code>synchronized</code>，声明为同步方法，某线程调用前必须获取同步锁，调用完后会释放锁给其他线程用，也就是请神的必须排队，大家一个一个按顺序来。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">God</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> God god;<span class="comment">//这里不进行实例化</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">God</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> God <span class="title">getInstance</span><span class="params">()</span> </span>&#123;<span class="comment">//此处加入同步</span></span><br><span class="line">        <span class="keyword">if</span> (god == <span class="keyword">null</span>) &#123;<span class="comment">//如果无神才造神</span></span><br><span class="line">            god = <span class="keyword">new</span> God();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> god;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然而，这样做是要付出代价的，还没进庙呢不管三七二十一请神的直接给加锁排队，结果队伍从北边的庙排到了南天门，人们都要来一个一个拜佛求神，这造成了巨大时间浪费，没有充分利用<code>CPU</code>资源并发优势（特别是多核情况）。好吧，那还是让人们抢好了，但依然得保证单例神的情况下。</p><p><img src="https://github.com/cayzlh/git-img-repository/raw/master/blog/2019/02/20/1.jpg" alt="插图"></p><p>这里我们去掉方法上的同步关键字，换到方法体内部做同步，整个方法开放并发大家都可以同时入庙，当然起早贪黑的虔诚信徒们要抢头香是必须要入堂排队的。一旦头香诞生，那其他抢香的都白早起，白排队了。再之后的事情我们都可以预见了，头注香被抢后堂内排队再无必要来了，大家可以在堂外同时并发拜佛求神，这就极大的利用了<code>CPU</code>资源。简而言之：只有第一批抢头香的在排队，之后大家都不必排队了，代码如下。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">God</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> God god;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">God</span><span class="params">()</span></span>&#123;&#125; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> God <span class="title">getInstance</span><span class="params">()</span> </span>&#123;<span class="comment">//庙是开放的不用排队进入</span></span><br><span class="line">        <span class="keyword">if</span> (god == <span class="keyword">null</span>) &#123;<span class="comment">//如果头柱香未产生，这批抢香人进入堂内排队。</span></span><br><span class="line">            <span class="keyword">synchronized</span>(God.class)&#123;</span><br><span class="line">                <span class="keyword">if</span> (god == <span class="keyword">null</span>) &#123;<span class="comment">//只有头香造了神，其他抢香的白排队了</span></span><br><span class="line">                    god = <span class="keyword">new</span> God();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//此处头柱香产生后不必再排队</span></span><br><span class="line">        <span class="keyword">return</span> god;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实在这之上还发展出了各种各样的单例模式变种，我们这里只讲了最基础的两种，其实他们都各有优缺，我们要做到灵活运用，各取所需。对于我个人来讲倾向于痴汉模式，现在内存成本根本不算问题，况且迟早要被实例化占用内存，加锁解锁更是一种浪费，还有同步效率低等问题，如果上帝不是很占空间那就没必要去懒汉延迟加载，越复杂问题越多，风险越大。</p><h2 id="单例模式的几种实现方式"><a href="#单例模式的几种实现方式" class="headerlink" title="单例模式的几种实现方式"></a>单例模式的几种实现方式</h2><h3 id="懒汉式，线程不安全"><a href="#懒汉式，线程不安全" class="headerlink" title="懒汉式，线程不安全"></a>懒汉式，线程不安全</h3><p><strong>是否 Lazy 初始化：</strong>是</p><p><strong>是否多线程安全：</strong>否</p><p><strong>实现难度：</strong>易</p><p><strong>描述：</strong>这种方式是最基本的实现方式，这种实现最大的问题就是不支持多线程。因为没有加锁 synchronized，所以严格意义上它并不算单例模式。<br>这种方式 <code>lazy loading</code> 很明显，不要求线程安全，在多线程不能正常工作。</p><p><strong>实例：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;  </span><br><span class="line">        instance = <span class="keyword">new</span> Singleton();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="懒汉式，线程安全"><a href="#懒汉式，线程安全" class="headerlink" title="懒汉式，线程安全"></a>懒汉式，线程安全</h3><p><strong>是否 Lazy 初始化：</strong>是</p><p><strong>是否多线程安全：</strong>是</p><p><strong>实现难度：</strong>易</p><p><strong>描述：</strong>这种方式具备很好的 <code>lazy loading</code>，能够在多线程中很好的工作，但是，效率很低，<code>99%</code> 情况下不需要同步。<br>优点：第一次调用才初始化，避免内存浪费。<br>缺点：必须加锁 <code>synchronized</code> 才能保证单例，但加锁会影响效率。<br><code>getInstance()</code> 的性能对应用程序不是很关键（该方法使用不太频繁）。</p><p><strong>实例：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;  </span><br><span class="line">        instance = <span class="keyword">new</span> Singleton();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h3><p><strong>是否 Lazy 初始化：</strong>否</p><p><strong>是否多线程安全：</strong>是</p><p><strong>实现难度：</strong>易</p><p><strong>描述：</strong>这种方式比较常用，但容易产生垃圾对象。<br>优点：没有加锁，执行效率会提高。<br>缺点：类加载时就初始化，浪费内存。<br>它基于 <code>classloader</code> 机制避免了多线程的同步问题，不过，<code>instance</code> 在类装载时就实例化，虽然导致类装载的原因有很多种，在单例模式中大多数都是调用 <code>getInstance</code> 方法， 但是也不能确定有其他的方式（或者其他的静态方法）导致类装载，这时候初始化 <code>instance</code> 显然没有达到 <code>lazy loading</code> 的效果。</p><p><strong>实例：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="双检锁-双重校验锁（DCL，即-double-checked-locking）"><a href="#双检锁-双重校验锁（DCL，即-double-checked-locking）" class="headerlink" title="双检锁/双重校验锁（DCL，即 double-checked locking）"></a>双检锁/双重校验锁（DCL，即 double-checked locking）</h3><p><strong>JDK 版本：</strong><code>JDK1.5</code> 起</p><p><strong>是否 Lazy 初始化：</strong>是</p><p><strong>是否多线程安全：</strong>是</p><p><strong>实现难度：</strong>较复杂</p><p><strong>描述：</strong>这种方式采用双锁机制，安全且在多线程情况下能保持高性能。<br><code>getInstance()</code> 的性能对应用程序很关键。</p><p><strong>实例：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton singleton;  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getSingleton</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;  </span><br><span class="line">        <span class="keyword">synchronized</span> (Singleton.class) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;  </span><br><span class="line">            singleton = <span class="keyword">new</span> Singleton();  </span><br><span class="line">        &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> singleton;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="登记式-静态内部类"><a href="#登记式-静态内部类" class="headerlink" title="登记式/静态内部类"></a>登记式/静态内部类</h3><p><strong>是否 Lazy 初始化：</strong>是</p><p><strong>是否多线程安全：</strong>是</p><p><strong>实现难度：</strong>一般</p><p><strong>描述：</strong>这种方式能达到双检锁方式一样的功效，但实现更简单。对静态域使用延迟初始化，应使用这种方式而不是双检锁方式。这种方式只适用于静态域的情况，双检锁方式可在实例域需要延迟初始化时使用。<br>这种方式同样利用了 <code>classloader</code> 机制来保证初始化 <code>instance</code> 时只有一个线程，它跟第 <code>3</code> 种方式不同的是：第 <code>3</code> 种方式只要 <code>Singleton</code> 类被装载了，那么 <code>instance</code> 就会被实例化（没有达到 <code>lazy loading</code> 效果），而这种方式是 <code>Singleton</code> 类被装载了，<code>instance</code> 不一定被初始化。因为 <code>SingletonHolder</code> 类没有被主动使用，只有通过显式调用 <code>getInstance</code> 方法时，才会显式装载 <code>SingletonHolder</code> 类，从而实例化 <code>instance</code>。想象一下，如果实例化 <code>instance</code> 很消耗资源，所以想让它延迟加载，另外一方面，又不希望在 <code>Singleton</code> 类加载时就实例化，因为不能确保 <code>Singleton</code> 类还可能在其他的地方被主动使用从而被加载，那么这个时候实例化 <code>instance</code> 显然是不合适的。这个时候，这种方式相比第 3 种方式就显得很合理。</p><p><strong>实例：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> SingletonHolder.INSTANCE;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p><strong>JDK 版本：</strong><code>JDK1.5</code> 起</p><p><strong>是否 Lazy 初始化：</strong>否</p><p><strong>是否多线程安全：</strong>是</p><p><strong>实现难度：</strong>易</p><p><strong>描述：</strong>这种实现方式还没有被广泛采用，但这是实现单例模式的最佳方法。它更简洁，自动支持序列化机制，绝对防止多次实例化。<br>这种方式是 <code>Effective Java</code> 作者 <code>Josh Bloch</code> 提倡的方式，它不仅能避免多线程同步问题，而且还自动支持序列化机制，防止反序列化重新创建新的对象，绝对防止多次实例化。不过，由于 <code>JDK1.5</code> 之后才加入 <code>enum</code> 特性，用这种方式写不免让人感觉生疏，在实际工作中，也很少用。<br>不能通过 <code>reflection attack</code> 来调用私有构造方法。</p><p><strong>实例：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">    INSTANCE;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">whateverMethod</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>经验之谈：</strong>一般情况下，不建议使用第 <code>1</code> 种和第 <code>2</code> 种懒汉方式，建议使用第 <code>3</code> 种饿汉方式。只有在要明确实现 <code>lazy loading</code> 效果时，才会使用第 <code>5</code> 种登记方式。如果涉及到反序列化创建对象时，可以尝试使用第 <code>6</code> 种枚举方式。如果有其他特殊的需求，可以考虑使用第 <code>4</code> 种双检锁方式。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Java设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 转载 </tag>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java设计模式之原型模式</title>
      <link href="/blog/2019/02/14/44e9b870.html"/>
      <url>/blog/2019/02/14/44e9b870.html</url>
      
        <content type="html"><![CDATA[<blockquote><p><code>设计模式</code>相关文章，用于整理网络中对应的设计模式的一些解读。</p></blockquote><h2 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h2><p>原型模式（Prototype Pattern）是用于创建重复的对象，同时又能保证性能。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。</p><p>这种模式是实现了一个原型接口，该接口用于创建当前对象的克隆。当直接创建对象的代价比较大时，则采用这种模式。例如，一个对象需要在一个高代价的数据库操作之后被创建。我们可以缓存该对象，在下一个请求时返回它的克隆，在需要的时候更新数据库，以此来减少数据库调用。</p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><strong>意图：</strong>用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。</p><p><strong>主要解决：</strong>在运行期建立和删除原型。</p><p><strong>何时使用：</strong> 1、当一个系统应该独立于它的产品创建，构成和表示时。 2、当要实例化的类是在运行时刻指定时，例如，通过动态装载。 3、为了避免创建一个与产品类层次平行的工厂类层次时。 4、当一个类的实例只能有几个不同状态组合中的一种时。建立相应数目的原型并克隆它们可能比每次用合适的状态手工实例化该类更方便一些。</p><p><strong>如何解决：</strong>利用已有的一个原型对象，快速地生成和原型对象一样的实例。</p><p><strong>关键代码：</strong> 1、实现克隆操作，在 JAVA 继承 Cloneable，重写 clone()，在 .NET 中可以使用 Object 类的 MemberwiseClone() 方法来实现对象的浅拷贝或通过序列化的方式来实现深拷贝。 2、原型模式同样用于隔离类对象的使用者和具体类型（易变类）之间的耦合关系，它同样要求这些”易变类”拥有稳定的接口。</p><p><strong>应用实例：</strong> 1、细胞分裂。 2、JAVA 中的 Object clone() 方法。</p><p><strong>优点：</strong> 1、性能提高。 2、逃避构造函数的约束。</p><p><strong>缺点：</strong> 1、配备克隆方法需要对类的功能进行通盘考虑，这对于全新的类不是很难，但对于已有的类不一定很容易，特别当一个类引用不支持串行化的间接对象，或者引用含有循环结构的时候。 2、必须实现 Cloneable 接口。</p><p><strong>使用场景：</strong> 1、资源优化场景。 2、类初始化需要消化非常多的资源，这个资源包括数据、硬件资源等。 3、性能和安全要求的场景。 4、通过 new 产生一个对象需要非常繁琐的数据准备或访问权限，则可以使用原型模式。 5、一个对象多个修改者的场景。 6、一个对象需要提供给其他对象访问，而且各个调用者可能都需要修改其值时，可以考虑使用原型模式拷贝多个对象供调用者使用。 7、在实际项目中，原型模式很少单独出现，一般是和工厂方法模式一起出现，通过 clone 的方法创建一个对象，然后由工厂方法提供给调用者。原型模式已经与 Java 融为浑然一体，大家可以随手拿来使用。</p><p><strong>注意事项：</strong>与通过对一个类进行实例化来构造新对象不同的是，原型模式是通过拷贝一个现有对象生成新对象的。浅拷贝实现 Cloneable，重写，深拷贝是通过实现 Serializable 读取二进制流。</p><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><blockquote><p>以下实例来源于微信公众号（Java知音）文章，设计模式是什么鬼（原型）</p></blockquote><p>假设我们要做一个打飞机游戏，游戏设定位纵版移动，单打。</p><p><img src="https://github.com/cayzlh/git-img-repository/raw/master/blog/2019/02/14/1.jpg" alt="打飞机"></p><p>既然是单打，那我们的主角飞机当然只有一架，于是我们写一个单例模式，此处我们省略主角代码。那么敌机呢？当然有很多架了，好，为了说明问题我们去繁就简，先写一个敌机类。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EnemyPlane</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> x;<span class="comment">//敌机横坐标</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> y = <span class="number">0</span>;<span class="comment">//敌机纵坐标</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EnemyPlane</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="comment">//构造器</span></span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getX</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getY</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span></span>&#123;<span class="comment">//让敌机飞</span></span><br><span class="line">        y++;<span class="comment">//每调用一次，敌机飞行时纵坐标＋1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码<code>public EnemyPlane(int x) &#123;//构造器....</code>开始，初始化只接收x坐标，因为敌机一开始是从顶部出来所以纵坐标<code>y</code>必然是<code>0</code>。此类只提供<code>getter</code>而没有<code>setter</code>，也就是说只能在初始化时确定敌机的横坐标x，后续是不需要更改坐标了，只要连续调用第17行的fly方法即可让飞机跟雨点一样往下砸。</p><p>好了，我们开始绘制敌机动画了，先实例化出50架吧。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;EnemyPlane&gt; enemyPlanes = <span class="keyword">new</span> ArrayList&lt;EnemyPlane&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//此处随机位置产生敌机</span></span><br><span class="line">            EnemyPlane ep = <span class="keyword">new</span> EnemyPlane(<span class="keyword">new</span> Random().nextInt(<span class="number">200</span>));</span><br><span class="line">            enemyPlanes.add(ep);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意代码<code>EnemyPlane ep = new EnemyPlane(new Random().nextInt(200));</code>，<em>觉不觉得每个迭代都实例化new出一个对象存在性能问题呢？</em>答案是肯定的，这个实例化的过程是得不偿失的，构造方法会被调用50次，cpu被极大浪费了，内存被极大浪费了，尤其对于游戏来说性能瓶颈绝对是大忌，这会造成用户体验问题，谁也不希望玩游戏会卡帧吧。</p><p>那到底什么时候去new？游戏场景初始化就new敌机（如以上代码）？这关会出现500个敌机那我们一次都new出来吧？浪费内存！那我们实时的去new，每到一个地方才new出来一个！浪费CPU！如果敌机线程过多造成CPU资源耗尽，每出一个敌机游戏会卡一下，试想一下这种极端情况下，游戏对象实例很多的话就是在作死。</p><p><img src="https://github.com/cayzlh/git-img-repository/raw/master/blog/2019/02/14/2.jpg" alt="打飞机"></p><p>解决方案到底是什么呢？好，<code>原型模式Prototype</code>！上代码！我们把上面的敌机类改造一下，让它支持原型拷贝。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EnemyPlane</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;<span class="comment">//此处实现克隆接口</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> x;<span class="comment">//敌机横坐标</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> y = <span class="number">0</span>;<span class="comment">//敌机纵坐标</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EnemyPlane</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="comment">//构造器</span></span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getX</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getY</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span></span>&#123;<span class="comment">//让敌机飞</span></span><br><span class="line">        y++;<span class="comment">//每调用一次，敌机飞行时纵坐标＋1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//此处开放setX，为了让克隆后的实例重新修改x坐标</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setX</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//为了保证飞机飞行的连贯性</span></span><br><span class="line">    <span class="comment">//这里我们关闭setY方法，不支持随意更改Y纵坐标</span></span><br><span class="line"><span class="comment">//    public void setY(int y) &#123;</span></span><br><span class="line"><span class="comment">//        this.y = y;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//重写克隆方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> EnemyPlane <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (EnemyPlane)<span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>setX()</code>方法为了保证克隆飞机的个性化，因为它们出现的位置是不同的。<code>克隆方法</code>重写我们调用了父类Object的克隆方法，<strong>这里JVM会进行内存操作直接拷贝原始数据流，</strong>简单粗暴，不会有其他更多的复杂操作（类加载，实例化，初始化等等），速度远远快于实例化操作。OK，我们看怎么克隆这些敌机，做一个造飞机的工厂吧。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EnemyPlaneFactory</span> </span>&#123;</span><br><span class="line">    <span class="comment">//此处用痴汉模式造一个敌机原型</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> EnemyPlane protoType = <span class="keyword">new</span> EnemyPlane(<span class="number">200</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取敌机克隆实例</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> EnemyPlane <span class="title">getInstance</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        EnemyPlane clone = protoType.clone();<span class="comment">//复制原型机</span></span><br><span class="line">        clone.setX(x);<span class="comment">//重新设置克隆机的x坐标</span></span><br><span class="line">        <span class="keyword">return</span> clone;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此处我们省去抓异常，随后的事情就非常简单了，我们只需要很简单地调用<code>EnemyPlaneFactory.getInstance(int x)</code>并声明<code>x坐标</code>位置，一架敌机很快地就做好了，并且我们保证是在敌机出现的时候再去克隆，确保不要一开局就全部克隆出来，如此一来，既保证了实时性节省了内存空间，又保证了敌机实例化的速度，游戏绝不会卡帧！</p><p>最后，还要强调一点就是浅拷贝和深拷贝的问题。假如我们的敌机类里有一颗子弹bullet可以射击我们的主角，如下。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EnemyPlane</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Bullet bullet = <span class="keyword">new</span> Bullet();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> x;<span class="comment">//敌机横坐标</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> y = <span class="number">0</span>;<span class="comment">//敌机纵坐标</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//之后代码省略……</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们都知道<strong>Java中的变量分为原始类型和引用类型，所谓浅拷贝只是拷贝原始类型的指，比如坐标x, y的指会被拷贝到克隆对象中，对于对象bullet也会被拷贝，但是请注意拷贝的只是地址而已，那么多个地址其实真正指向的对象还是同一个bullet。</strong></p><p>由于我们调用父类<code>Object</code>的<code>clone</code>方法进行的是浅拷贝，所以此处的<code>bullet</code>并没有被克隆成功，比如我们每架敌机必须携带的子弹是不同的实例，那么我们就必须进行深拷贝，于是我们的代码就得做这样的改动。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EnemyPlane</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Bullet bullet = <span class="keyword">new</span> Bullet();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBullet</span><span class="params">(Bullet bullet)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.bullet = bullet;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> EnemyPlane <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        <span class="comment">// 先克隆出敌机，其中子弹还未进行克隆。</span></span><br><span class="line">        EnemyPlane clonePlane = (EnemyPlane) <span class="keyword">super</span>.clone();</span><br><span class="line">        <span class="comment">// 对子弹进行深拷贝</span></span><br><span class="line">        clonePlane.setBullet(<span class="keyword">this</span>.bullet.clone());</span><br><span class="line">        <span class="keyword">return</span> clonePlane;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//之后代码省略……</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相信大家看注释就能懂了，这里就不做过多解释，当然对于<code>Bullet</code>类也同样实现了克隆接口，代码不用再写了吧？相信大家都学会了举一反三。至此，我们的每个敌机携带的弹药也同样被克隆完毕了，再也不必担心游戏的流畅性了。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Java设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 转载 </tag>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JDK8特性一览</title>
      <link href="/blog/2019/01/22/1abc3648.html"/>
      <url>/blog/2019/01/22/1abc3648.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>转自：<a href="https://github.com/winterbe/java8-tutorial">https://github.com/winterbe/java8-tutorial</a></p><p>转自：<a href="https://juejin.im/post/5c3d7c8a51882525dd591ac7?utm_source=gold_browser_extension#%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3-Functional-Interface">Java8 新特性指导手册</a></p></blockquote><h2 id="接口内允许添加默认实现的方法"><a href="#接口内允许添加默认实现的方法" class="headerlink" title="接口内允许添加默认实现的方法"></a>接口内允许添加默认实现的方法</h2><p>Java 8 允许我们通过 <code>default</code> 关键字对接口中定义的抽象方法提供一个默认的实现。</p><p>请看下面示例代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义一个公式接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Formula</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 计算</span></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">calculate</span><span class="params">(<span class="keyword">int</span> a)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 求平方根</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">double</span> <span class="title">sqrt</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Math.sqrt(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面这个接口中，我们除了定义了一个抽象方法 <code>calculate</code>，还定义了一个带有默认实现的方法 <code>sqrt</code>。 我们在实现这个接口时，可以只需要实现 <code>calculate</code> 方法，默认方法 <code>sqrt</code> 可以直接调用即可，也就是说我们可以不必强制实现 <code>sqrt</code> 方法。</p><blockquote><p>补充：通过 <code>default</code> 关键字这个新特性，可以非常方便地对之前的接口做拓展，而此接口的实现类不必做任何改动。</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Formula formula = <span class="keyword">new</span> Formula() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">calculate</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sqrt(a * <span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">formula.calculate(<span class="number">100</span>);     <span class="comment">// 100.0</span></span><br><span class="line">formula.sqrt(<span class="number">16</span>);           <span class="comment">// 4.0</span></span><br></pre></td></tr></table></figure><p>上面通过匿名对象实现了 <code>Formula</code> 接口。但是即使是这样，我们为了完成一个 <code>sqrt(a * 100)</code>简单计算，就写了 6 行代码，很是冗余。</p><h2 id="Lamdba表达式"><a href="#Lamdba表达式" class="headerlink" title="Lamdba表达式"></a>Lamdba表达式</h2><p>在学习 <code>Lambda</code> 表达式之前，我们先来看一段老版本的示例代码，其对一个含有字符串的集合进行排序：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; names = Arrays.asList(<span class="string">&quot;peter&quot;</span>, <span class="string">&quot;anna&quot;</span>, <span class="string">&quot;mike&quot;</span>, <span class="string">&quot;xenia&quot;</span>);</span><br><span class="line"></span><br><span class="line">Collections.sort(names, <span class="keyword">new</span> Comparator&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String a, String b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> b.compareTo(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>Collections</code> 工具类提供了静态方法 <code>sort</code> 方法，入参是一个 <code>List</code> 集合，和一个 <code>Comparator</code> 比较器，以便对给定的 <code>List</code> 集合进行 排序。上面的示例代码创建了一个匿名内部类作为入参，这种类似的操作在我们日常的工作中随处可见。</p><p>Java 8 中不再推荐这种写法，而是推荐使用 Lambda 表达：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Collections.sort(names, (String a, String b) -&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> b.compareTo(a);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>正如你看到的，上面这段代码变得简短很多而且易于阅读。但是我们还可以再精炼一点：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Collections.sort(names, (String a, String b) -&gt; b.compareTo(a));</span><br></pre></td></tr></table></figure><p><code>List</code> 集合现在已经添加了 <code>sort</code> 方法。而且 Java 编译器能够根据<strong>类型推断机制</strong>判断出参数类型，这样，连入参的类型都可以省略了！</p><h2 id="函数式接口-Functional-Interface"><a href="#函数式接口-Functional-Interface" class="headerlink" title="函数式接口 Functional Interface"></a>函数式接口 Functional Interface</h2><p>抛出一个疑问：在我们书写一段 Lambda 表达式后（比如上一章节中匿名内部类的 Lambda 表达式缩写形式），Java 编译器是如何进行类型推断的，它又是怎么知道重写的哪个方法的？</p><p>需要说明的是，不是每个接口都可以缩写成 Lambda 表达式。只有那些函数式接口（Functional Interface）才能缩写成 Lambda 表示式。</p><p>那么什么是函数式接口（Functional Interface）呢？</p><p>所谓函数式接口（Functional Interface）就是只包含一个抽象方法的声明。针对该接口类型的所有 Lambda 表达式都会与这个抽象方法匹配。</p><blockquote><p>注意：你可能会有疑问，Java 8 中不是允许通过 defualt 关键字来为接口添加默认方法吗？那它算不算抽象方法呢？答案是：不算。因此，你可以毫无顾忌的添加默认方法，它并不违反函数式接口（Functional Interface）的定义。</p></blockquote><p>总结一下：只要接口中仅仅包含一个抽象方法，我们就可以将其改写为 Lambda 表达式。为了保证一个接口明确的被定义为一个函数式接口（Functional Interface），我们需要为该接口添加注解：<code>@FunctionalInterface</code>。这样，一旦你添加了第二个抽象方法，编译器会立刻抛出错误提示。</p><p>示例代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Converter</span>&lt;<span class="title">F</span>, <span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">T <span class="title">convert</span><span class="params">(F from)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例代码2：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Converter&lt;String, Integer&gt; converter = (from) -&gt; Integer.valueOf(from);</span><br><span class="line">Integer converted = converter.convert(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">System.out.println(converted);    <span class="comment">// 123</span></span><br></pre></td></tr></table></figure><blockquote><p>注意：上面的示例代码，即使去掉 <code>@FunctionalInterface</code> 也是好使的，它仅仅是一种约束而已。</p></blockquote><h2 id="便捷的引用类的构造器及方法"><a href="#便捷的引用类的构造器及方法" class="headerlink" title="便捷的引用类的构造器及方法"></a>便捷的引用类的构造器及方法</h2><p>小伙伴们，还记得上一个章节这段示例代码么：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Converter</span>&lt;<span class="title">F</span>, <span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">T <span class="title">convert</span><span class="params">(F from)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Converter&lt;String, Integer&gt; converter = (from) -&gt; Integer.valueOf(from);</span><br><span class="line">Integer converted = converter.convert(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">System.out.println(converted);    <span class="comment">// 123</span></span><br></pre></td></tr></table></figure><p>上面这段代码，通过 Java 8 的新特性，进一步简化上面的代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Converter&lt;String, Integer&gt; converter = Integer::valueOf;</span><br><span class="line">Integer converted = converter.convert(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">System.out.println(converted);   <span class="comment">// 123</span></span><br></pre></td></tr></table></figure><p>Java 8 中允许你通过 <code>::</code> 关键字来引用类的方法或构造器。上面的代码简单的示例了如何引用静态方法，当然，除了静态方法，我们还可以引用普通方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Something</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">startsWith</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> String.valueOf(s.charAt(<span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Something something = <span class="keyword">new</span> Something();</span><br><span class="line">Converter&lt;String, String&gt; converter = something::startsWith;</span><br><span class="line">String converted = converter.convert(<span class="string">&quot;Java&quot;</span>);</span><br><span class="line">System.out.println(converted);    <span class="comment">// &quot;J&quot;</span></span><br></pre></td></tr></table></figure><p>接下来，我们再来看看如何通过 <code>::</code> 关键字来引用类的构造器。首先，我们先来定义一个示例类，在类中声明两个构造器：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    String firstName;</span><br><span class="line">    String lastName;</span><br><span class="line"></span><br><span class="line">    Person() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    Person(String firstName, String lastName) &#123;</span><br><span class="line">        <span class="keyword">this</span>.firstName = firstName;</span><br><span class="line">        <span class="keyword">this</span>.lastName = lastName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，我们再定义一个工厂接口，用来生成 <code>Person</code> 类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Person 工厂</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">PersonFactory</span>&lt;<span class="title">P</span> <span class="keyword">extends</span> <span class="title">Person</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">P <span class="title">create</span><span class="params">(String firstName, String lastName)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以通过 <code>::</code> 关键字来引用 <code>Person</code> 类的构造器，来代替手动去实现这个工厂接口：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 直接引用 Person 构造器</span></span><br><span class="line">PersonFactory&lt;Person&gt; personFactory = Person::<span class="keyword">new</span>;</span><br><span class="line">Person person = personFactory.create(<span class="string">&quot;Peter&quot;</span>, <span class="string">&quot;Parker&quot;</span>);</span><br></pre></td></tr></table></figure><p><code>Person::new</code> 这段代码，能够直接引用 <code>Person</code> 类的构造器。然后 Java 编译器能够根据上下文选中正确的构造器去实现 <code>PersonFactory.create</code> 方法。</p><h2 id="Lamdba访问外部变量及接口默认方法"><a href="#Lamdba访问外部变量及接口默认方法" class="headerlink" title="Lamdba访问外部变量及接口默认方法"></a>Lamdba访问外部变量及接口默认方法</h2><p>在本章节中，我们将会讨论如何在 lambda 表达式中访问外部变量（包括：局部变量，成员变量，静态变量，接口的默认方法.），它与匿名内部类访问外部变量很相似。</p><h3 id="访问局部变量"><a href="#访问局部变量" class="headerlink" title="访问局部变量"></a>访问局部变量</h3><p>在 Lambda 表达式中，我们可以访问外部的 <code>final</code> 类型变量，如下面的示例代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 转换器</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Converter</span>&lt;<span class="title">F</span>, <span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">T <span class="title">convert</span><span class="params">(F from)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line">Converter&lt;Integer, String&gt; stringConverter =</span><br><span class="line">        (from) -&gt; String.valueOf(from + num);</span><br><span class="line"></span><br><span class="line">stringConverter.convert(<span class="number">2</span>);     <span class="comment">// 3</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>与匿名内部类不同的是，我们不必显式声明 <code>num</code> 变量为 <code>final</code> 类型，下面这段代码同样有效：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line">Converter&lt;Integer, String&gt; stringConverter =</span><br><span class="line">        (from) -&gt; String.valueOf(from + num);</span><br><span class="line"></span><br><span class="line">stringConverter.convert(<span class="number">2</span>);     <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>但是 <code>num</code> 变量必须为隐式的 <code>final</code> 类型，何为隐式的 <code>final</code> 呢？就是说到编译期为止，<code>num</code> 对象是不能被改变的，如下面这段代码，就不能被编译通过：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line">Converter&lt;Integer, String&gt; stringConverter =</span><br><span class="line">        (from) -&gt; String.valueOf(from + num);</span><br><span class="line">num = <span class="number">3</span>;</span><br></pre></td></tr></table></figure><p>在 lambda 表达式内部改变 <code>num</code> 值同样编译不通过，需要注意, 比如下面的示例代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line">Converter&lt;Integer, String&gt; converter = (from) -&gt; &#123;</span><br><span class="line">String value = String.valueOf(from + num);</span><br><span class="line">num = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">return</span> value;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="访问成员变量和静态变量"><a href="#访问成员变量和静态变量" class="headerlink" title="访问成员变量和静态变量"></a>访问成员变量和静态变量</h3><p>上一章节中，了解了如何在 Lambda 表达式中访问局部变量。与局部变量相比，在 Lambda 表达式中对成员变量和静态变量拥有读写权限：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Converter</span>&lt;<span class="title">F</span>, <span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">T <span class="title">convert</span><span class="params">(F from)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lambda4</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 静态变量</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> outerStaticNum;</span><br><span class="line">    <span class="comment">// 成员变量</span></span><br><span class="line">    <span class="keyword">int</span> outerNum;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">testScopes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Converter&lt;Integer, String&gt; stringConverter1 = (from) -&gt; &#123;</span><br><span class="line">            <span class="comment">// 对成员变量赋值</span></span><br><span class="line">            outerNum = <span class="number">23</span>;</span><br><span class="line">            <span class="keyword">return</span> String.valueOf(from);</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Converter&lt;Integer, String&gt; stringConverter2 = (from) -&gt; &#123;</span><br><span class="line">            <span class="comment">// 对静态变量赋值</span></span><br><span class="line">            outerStaticNum = <span class="number">72</span>;</span><br><span class="line">            <span class="keyword">return</span> String.valueOf(from);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="访问接口的默认方法"><a href="#访问接口的默认方法" class="headerlink" title="访问接口的默认方法"></a>访问接口的默认方法</h3><p>还记得第一章节中定义的那个 <code>Formula</code> (公式) 接口吗？</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Formula</span> </span>&#123;</span><br><span class="line"><span class="comment">// 计算</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">calculate</span><span class="params">(<span class="keyword">int</span> a)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求平方根</span></span><br><span class="line"><span class="function"><span class="keyword">default</span> <span class="keyword">double</span> <span class="title">sqrt</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> Math.sqrt(a);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当时，我们在接口中定义了一个带有默认实现的 <code>sqrt</code> 求平方根方法，在匿名内部类中我们可以很方便的访问此方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Formula formula = <span class="keyword">new</span> Formula() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">calculate</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> sqrt(a * <span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>但是在 lambda 表达式中可不行：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Formula formula = (a) -&gt; sqrt(a * <span class="number">100</span>);</span><br></pre></td></tr></table></figure><p>带有默认实现的接口方法，是<strong>不能</strong>在 lambda 表达式中访问的，上面这段代码将无法被编译通过。</p><h2 id="内置的函数式接口"><a href="#内置的函数式接口" class="headerlink" title="内置的函数式接口"></a>内置的函数式接口</h2><p>JDK 1.8 API 包含了很多内置的函数式接口。其中就包括我们在老版本中经常见到的 Comparator 和 Runnable，Java 8 为他们都添加了 @FunctionalInterface 注解，以用来支持 Lambda 表达式。</p><p>值得一提的是，除了 Comparator 和 Runnable 外，还有一些新的函数式接口，它们很多都借鉴于知名的 <a href="https://link.juejin.im/?target=https://github.com/google/guava">Google Guava</a> 库。</p><h3 id="Predicate断言"><a href="#Predicate断言" class="headerlink" title="Predicate断言"></a>Predicate断言</h3><p><code>Predicate</code> 是一个可以指定入参类型，并返回 boolean 值的函数式接口。它内部提供了一些带有默认实现的方法，可以 被用来组合一个复杂的逻辑判断（<code>and</code>, <code>or</code>, <code>negate</code>）：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Predicate&lt;String&gt; predicate = (s) -&gt; s.length() &gt; <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">predicate.test(<span class="string">&quot;foo&quot;</span>);              <span class="comment">// true</span></span><br><span class="line">predicate.negate().test(<span class="string">&quot;foo&quot;</span>);     <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">Predicate&lt;Boolean&gt; nonNull = Objects::nonNull;</span><br><span class="line">Predicate&lt;Boolean&gt; isNull = Objects::isNull;</span><br><span class="line"></span><br><span class="line">Predicate&lt;String&gt; isEmpty = String::isEmpty;</span><br><span class="line">Predicate&lt;String&gt; isNotEmpty = isEmpty.negate();</span><br></pre></td></tr></table></figure><h3 id="Function"><a href="#Function" class="headerlink" title="Function"></a>Function</h3><p><code>Function</code> 函数式接口的作用是，我们可以为其提供一个原料，他给生产一个最终的产品。通过它提供的默认方法，组合,链行处理(<code>compose</code>, <code>andThen</code>)：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Function&lt;String, Integer&gt; toInteger = Integer::valueOf;</span><br><span class="line">Function&lt;String, String&gt; backToString = toInteger.andThen(String::valueOf);</span><br><span class="line"></span><br><span class="line">backToString.apply(<span class="string">&quot;123&quot;</span>);     <span class="comment">// &quot;123&quot;</span></span><br></pre></td></tr></table></figure><h3 id="Supplier生产者"><a href="#Supplier生产者" class="headerlink" title="Supplier生产者"></a>Supplier生产者</h3><p><code>Supplier</code> 与 <code>Function</code> 不同，它不接受入参，直接为我们生产一个指定的结果，有点像生产者模式：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    String firstName;</span><br><span class="line">    String lastName;</span><br><span class="line"></span><br><span class="line">    Person() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    Person(String firstName, String lastName) &#123;</span><br><span class="line">        <span class="keyword">this</span>.firstName = firstName;</span><br><span class="line">        <span class="keyword">this</span>.lastName = lastName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Supplier&lt;Person&gt; personSupplier = Person::<span class="keyword">new</span>;</span><br><span class="line">personSupplier.get();   <span class="comment">// new Person</span></span><br></pre></td></tr></table></figure><p>###Consumer消费者</p><p>对于 <code>Consumer</code>，我们需要提供入参，用来被消费，如下面这段示例代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    String firstName;</span><br><span class="line">    String lastName;</span><br><span class="line"></span><br><span class="line">    Person() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    Person(String firstName, String lastName) &#123;</span><br><span class="line">        <span class="keyword">this</span>.firstName = firstName;</span><br><span class="line">        <span class="keyword">this</span>.lastName = lastName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Consumer&lt;Person&gt; greeter = (p) -&gt; System.out.println(<span class="string">&quot;Hello, &quot;</span> + p.firstName);</span><br><span class="line">greeter.accept(<span class="keyword">new</span> Person(<span class="string">&quot;Luke&quot;</span>, <span class="string">&quot;Skywalker&quot;</span>));</span><br></pre></td></tr></table></figure><h3 id="Comparator"><a href="#Comparator" class="headerlink" title="Comparator"></a>Comparator</h3><p><code>Comparator</code> 在 Java 8 之前是使用比较普遍的。Java 8 中除了将其升级成了函数式接口，还为它拓展了一些默认方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Comparator&lt;Person&gt; comparator = (p1, p2) -&gt; p1.firstName.compareTo(p2.firstName);</span><br><span class="line"></span><br><span class="line">Person p1 = <span class="keyword">new</span> Person(<span class="string">&quot;John&quot;</span>, <span class="string">&quot;Doe&quot;</span>);</span><br><span class="line">Person p2 = <span class="keyword">new</span> Person(<span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;Wonderland&quot;</span>);</span><br><span class="line"></span><br><span class="line">comparator.compare(p1, p2);             <span class="comment">// &gt; 0</span></span><br><span class="line">comparator.reversed().compare(p1, p2);  <span class="comment">// &lt; 0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Optional"><a href="#Optional" class="headerlink" title="Optional"></a>Optional</h2><p>首先，<code>Optional</code> 它不是一个函数式接口，设计它的目的是为了防止空指针异常（<code>NullPointerException</code>），要知道在 Java 编程中， 空指针异常可是臭名昭著的。</p><p>让我们来快速了解一下 <code>Optional</code> 要如何使用！你可以将 <code>Optional</code> 看做是包装对象（可能是 <code>null</code>, 也有可能非 <code>null</code>）的容器。当你定义了 一个方法，这个方法返回的对象可能是空，也有可能非空的时候，你就可以考虑用 <code>Optional</code> 来包装它，这也是在 Java 8 被推荐使用的做法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Optional&lt;String&gt; optional = Optional.of(<span class="string">&quot;bam&quot;</span>);</span><br><span class="line"></span><br><span class="line">optional.isPresent();           <span class="comment">// true</span></span><br><span class="line">optional.get();                 <span class="comment">// &quot;bam&quot;</span></span><br><span class="line">optional.orElse(<span class="string">&quot;fallback&quot;</span>);    <span class="comment">// &quot;bam&quot;</span></span><br><span class="line"></span><br><span class="line">optional.ifPresent((s) -&gt; System.out.println(s.charAt(<span class="number">0</span>)));     <span class="comment">// &quot;b&quot;</span></span><br></pre></td></tr></table></figure><h2 id="Stream流"><a href="#Stream流" class="headerlink" title="Stream流"></a>Stream流</h2><p><em>什么是 Stream 流？</em></p><p>简单来说，我们可以使用 <code>java.util.Stream</code> 对一个包含一个或多个元素的集合做各种操作。这些操作可能是 <em>中间操作</em> 亦或是 <em>终端操作</em>。 终端操作会返回一个结果，而中间操作会返回一个 <code>Stream</code> 流。</p><p>需要注意的是，你只能对实现了 <code>java.util.Collection</code> 接口的类做流的操作。</p><blockquote><p><code>Map</code> 不支持 <code>Stream</code> 流。</p></blockquote><p><code>Stream</code> 流支持同步执行，也支持并发执行。</p><h3 id="Filter过滤"><a href="#Filter过滤" class="headerlink" title="Filter过滤"></a>Filter过滤</h3><p>首先，我们创建一个 <code>List</code> 集合：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; stringCollection = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">stringCollection.add(<span class="string">&quot;ddd2&quot;</span>);</span><br><span class="line">stringCollection.add(<span class="string">&quot;aaa2&quot;</span>);</span><br><span class="line">stringCollection.add(<span class="string">&quot;bbb1&quot;</span>);</span><br><span class="line">stringCollection.add(<span class="string">&quot;aaa1&quot;</span>);</span><br><span class="line">stringCollection.add(<span class="string">&quot;bbb3&quot;</span>);</span><br><span class="line">stringCollection.add(<span class="string">&quot;ccc&quot;</span>);</span><br><span class="line">stringCollection.add(<span class="string">&quot;bbb2&quot;</span>);</span><br><span class="line">stringCollection.add(<span class="string">&quot;ddd1&quot;</span>);</span><br></pre></td></tr></table></figure><p><code>Filter</code> 的入参是一个 <code>Predicate</code>, 上面已经说到，<code>Predicate</code> 是一个断言的中间操作，它能够帮我们筛选出我们需要的集合元素。它的返参同样 是一个 <code>Stream</code> 流，我们可以通过 <code>foreach</code>终端操作，来打印被筛选的元素：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">stringCollection</span><br><span class="line">    .stream()</span><br><span class="line">    .filter((s) -&gt; s.startsWith(<span class="string">&quot;a&quot;</span>))</span><br><span class="line">    .forEach(System.out::println);</span><br><span class="line"></span><br><span class="line"><span class="comment">// &quot;aaa2&quot;, &quot;aaa1&quot;</span></span><br></pre></td></tr></table></figure><blockquote><p>注意：<code>foreach</code> 是一个终端操作，它的返参是 <code>void</code>, 我们无法对其再次进行流操作。</p></blockquote><h3 id="Sorted排序"><a href="#Sorted排序" class="headerlink" title="Sorted排序"></a>Sorted排序</h3><p><code>Sorted</code> 同样是一个中间操作，它的返参是一个 <code>Stream</code> 流。另外，我们可以传入一个 <code>Comparator</code> 用来自定义排序，如果不传，则使用默认的排序规则。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">stringCollection</span><br><span class="line">    .stream()</span><br><span class="line">    .sorted()</span><br><span class="line">    .filter((s) -&gt; s.startsWith(<span class="string">&quot;a&quot;</span>))</span><br><span class="line">    .forEach(System.out::println);</span><br><span class="line"></span><br><span class="line"><span class="comment">// &quot;aaa1&quot;, &quot;aaa2&quot;</span></span><br></pre></td></tr></table></figure><p>需要注意，<code>sorted</code> 不会对 <code>stringCollection</code> 做出任何改变，<code>stringCollection</code> 还是原有的那些个元素，且顺序不变：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(stringCollection);</span><br><span class="line"><span class="comment">// ddd2, aaa2, bbb1, aaa1, bbb3, ccc, bbb2, ddd1</span></span><br></pre></td></tr></table></figure><h3 id="Map转换"><a href="#Map转换" class="headerlink" title="Map转换"></a>Map转换</h3><p>中间操作 <code>Map</code> 能够帮助我们将 <code>List</code> 中的每一个元素做功能处理。例如下面的示例，通过 <code>map</code>我们将每一个 <code>string</code> 转成大写：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">stringCollection</span><br><span class="line">    .stream()</span><br><span class="line">    .map(String::toUpperCase)</span><br><span class="line">    .sorted((a, b) -&gt; b.compareTo(a))</span><br><span class="line">    .forEach(System.out::println);</span><br><span class="line"></span><br><span class="line"><span class="comment">// &quot;DDD2&quot;, &quot;DDD1&quot;, &quot;CCC&quot;, &quot;BBB3&quot;, &quot;BBB2&quot;, &quot;AAA2&quot;, &quot;AAA1&quot;</span></span><br></pre></td></tr></table></figure><p>另外，我们还可以做对象之间的转换，业务中比较常用的是将 <code>DO</code>（数据库对象） 转换成 <code>BO</code>（业务对象） 。</p><h3 id="Match匹配"><a href="#Match匹配" class="headerlink" title="Match匹配"></a>Match匹配</h3><p>顾名思义，<code>match</code> 用来做匹配操作，它的返回值是一个 <code>boolean</code> 类型。通过 <code>match</code>, 我们可以方便的验证一个 <code>list</code> 中是否存在某个类型的元素。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 验证 list 中 string 是否有以 a 开头的, 匹配到第一个，即返回 true</span></span><br><span class="line"><span class="keyword">boolean</span> anyStartsWithA =</span><br><span class="line">    stringCollection</span><br><span class="line">        .stream()</span><br><span class="line">        .anyMatch((s) -&gt; s.startsWith(<span class="string">&quot;a&quot;</span>));</span><br><span class="line"></span><br><span class="line">System.out.println(anyStartsWithA);      <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 验证 list 中 string 是否都是以 a 开头的</span></span><br><span class="line"><span class="keyword">boolean</span> allStartsWithA =</span><br><span class="line">    stringCollection</span><br><span class="line">        .stream()</span><br><span class="line">        .allMatch((s) -&gt; s.startsWith(<span class="string">&quot;a&quot;</span>));</span><br><span class="line"></span><br><span class="line">System.out.println(allStartsWithA);      <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 验证 list 中 string 是否都不是以 z 开头的,</span></span><br><span class="line"><span class="keyword">boolean</span> noneStartsWithZ =</span><br><span class="line">    stringCollection</span><br><span class="line">        .stream()</span><br><span class="line">        .noneMatch((s) -&gt; s.startsWith(<span class="string">&quot;z&quot;</span>));</span><br><span class="line"></span><br><span class="line">System.out.println(noneStartsWithZ);      <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h3 id="Count计数"><a href="#Count计数" class="headerlink" title="Count计数"></a>Count计数</h3><p><code>count</code> 是一个终端操作，它能够统计 <code>stream</code> 流中的元素总数，返回值是 <code>long</code> 类型。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 先对 list 中字符串开头为 b 进行过滤，让后统计数量</span></span><br><span class="line"><span class="keyword">long</span> startsWithB =</span><br><span class="line">    stringCollection</span><br><span class="line">        .stream()</span><br><span class="line">        .filter((s) -&gt; s.startsWith(<span class="string">&quot;b&quot;</span>))</span><br><span class="line">        .count();</span><br><span class="line"></span><br><span class="line">System.out.println(startsWithB);    <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><h3 id="Reduce汇聚"><a href="#Reduce汇聚" class="headerlink" title="Reduce汇聚"></a>Reduce汇聚</h3><p><code>Reduce</code> 中文翻译为：<em>减少、缩小</em>。通过入参的 <code>Function</code>，我们能够将 <code>list</code> 归约成一个值。它的返回类型是 <code>Optional</code> 类型。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Optional&lt;String&gt; reduced =</span><br><span class="line">    stringCollection</span><br><span class="line">        .stream()</span><br><span class="line">        .sorted()</span><br><span class="line">        .reduce((s1, s2) -&gt; s1 + <span class="string">&quot;#&quot;</span> + s2);</span><br><span class="line"></span><br><span class="line">reduced.ifPresent(System.out::println);</span><br><span class="line"><span class="comment">// &quot;aaa1#aaa2#bbb1#bbb2#bbb3#ccc#ddd1#ddd2&quot;</span></span><br></pre></td></tr></table></figure><p>##Parallel Streams并行流</p><p>前面章节我们说过，<code>stream</code> 流是支持<strong>顺序</strong>和<strong>并行</strong>的。顺序流操作是单线程操作，而并行流是通过多线程来处理的，能够充分利用物理机 多核 CPU 的优势，同时处理速度更快。</p><p>首先，我们创建一个包含 1000000 UUID list 集合。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> max = <span class="number">1000000</span>;</span><br><span class="line">List&lt;String&gt; values = <span class="keyword">new</span> ArrayList&lt;&gt;(max);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; max; i++) &#123;</span><br><span class="line">    UUID uuid = UUID.randomUUID();</span><br><span class="line">    values.add(uuid.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分别通过顺序流和并行流，对这个 list 进行排序，测算耗时:</p><h3 id="顺序流排序"><a href="#顺序流排序" class="headerlink" title="顺序流排序"></a>顺序流排序</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 纳秒</span></span><br><span class="line"><span class="keyword">long</span> t0 = System.nanoTime();</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> count = values.stream().sorted().count();</span><br><span class="line">System.out.println(count);</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 纳秒转微秒</span></span><br><span class="line"><span class="keyword">long</span> millis = TimeUnit.NANOSECONDS.toMillis(t1 - t0);</span><br><span class="line">System.out.println(String.format(<span class="string">&quot;顺序流排序耗时: %d ms&quot;</span>, millis));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 顺序流排序耗时: 899 ms</span></span><br></pre></td></tr></table></figure><h3 id="并行流排序"><a href="#并行流排序" class="headerlink" title="并行流排序"></a>并行流排序</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 纳秒</span></span><br><span class="line"><span class="keyword">long</span> t0 = System.nanoTime();</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> count = values.parallelStream().sorted().count();</span><br><span class="line">System.out.println(count);</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 纳秒转微秒</span></span><br><span class="line"><span class="keyword">long</span> millis = TimeUnit.NANOSECONDS.toMillis(t1 - t0);</span><br><span class="line">System.out.println(String.format(<span class="string">&quot;并行流排序耗时: %d ms&quot;</span>, millis));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 并行流排序耗时: 472 ms</span></span><br></pre></td></tr></table></figure><p>正如你所见，同样的逻辑处理，通过并行流，我们的性能提升了近 **50%**。完成这一切，我们需要做的仅仅是将 <code>stream</code> 改成了 <code>parallelStream</code>。</p><h2 id="Map集合"><a href="#Map集合" class="headerlink" title="Map集合"></a>Map集合</h2><p>前面已经提到过 <code>Map</code> 是不支持 <code>Stream</code> 流的，因为 <code>Map</code> 接口并没有像 <code>Collection</code> 接口那样，定义了 <code>stream()</code> 方法。但是，我们可以对其 <code>key</code>, <code>values</code>, <code>entry</code> 使用 流操作，如 <code>map.keySet().stream()</code>, <code>map.values().stream()</code> 和 <code>map.entrySet().stream()</code>.</p><p>另外, JDK 8 中对 <code>map</code> 提供了一些其他新特性:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;Integer, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="comment">// 与老版不同的是，putIfAbent() 方法在 put 之前，</span></span><br><span class="line">    <span class="comment">// 会判断 key 是否已经存在，存在则直接返回 value, 否则 put, 再返回 value</span></span><br><span class="line">    map.putIfAbsent(i, <span class="string">&quot;val&quot;</span> + i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// forEach 可以很方便地对 map 进行遍历操作</span></span><br><span class="line">map.forEach((key, value) -&gt; System.out.println(value));</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>除了上面的 <code>putIfAbsent()</code> 和 <code>forEach()</code> 外，我们还可以很方便地对某个 <code>key</code> 的值做相关操作：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// computeIfPresent(), 当 key 存在时，才会做相关处理</span></span><br><span class="line"><span class="comment">// 如下：对 key 为 3 的值，内部会先判断值是否存在，存在，则做 value + key 的拼接操作</span></span><br><span class="line">map.computeIfPresent(<span class="number">3</span>, (num, val) -&gt; val + num);</span><br><span class="line">map.get(<span class="number">3</span>);             <span class="comment">// val33</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 先判断 key 为 9 的元素是否存在，存在，则做删除操作</span></span><br><span class="line">map.computeIfPresent(<span class="number">9</span>, (num, val) -&gt; <span class="keyword">null</span>);</span><br><span class="line">map.containsKey(<span class="number">9</span>);     <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// computeIfAbsent(), 当 key 不存在时，才会做相关处理</span></span><br><span class="line"><span class="comment">// 如下：先判断 key 为 23 的元素是否存在，不存在，则添加</span></span><br><span class="line">map.computeIfAbsent(<span class="number">23</span>, num -&gt; <span class="string">&quot;val&quot;</span> + num);</span><br><span class="line">map.containsKey(<span class="number">23</span>);    <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 先判断 key 为 3 的元素是否存在，存在，则不做任何处理</span></span><br><span class="line">map.computeIfAbsent(<span class="number">3</span>, num -&gt; <span class="string">&quot;bam&quot;</span>);</span><br><span class="line">map.get(<span class="number">3</span>);             <span class="comment">// val33</span></span><br></pre></td></tr></table></figure><p>关于删除操作，JDK 8 中提供了能够新的 <code>remove()</code> API:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">map.remove(<span class="number">3</span>, <span class="string">&quot;val3&quot;</span>);</span><br><span class="line">map.get(<span class="number">3</span>);             <span class="comment">// val33</span></span><br><span class="line"></span><br><span class="line">map.remove(<span class="number">3</span>, <span class="string">&quot;val33&quot;</span>);</span><br><span class="line">map.get(<span class="number">3</span>);             <span class="comment">// null</span></span><br></pre></td></tr></table></figure><p>如上代码，只有当给定的 <code>key</code> 和 <code>value</code> 完全匹配时，才会执行删除操作。</p><p>关于添加方法，JDK 8 中提供了带有默认值的 <code>getOrDefault()</code> 方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 若 key 42 不存在，则返回 not found</span></span><br><span class="line">map.getOrDefault(<span class="number">42</span>, <span class="string">&quot;not found&quot;</span>);  <span class="comment">// not found</span></span><br></pre></td></tr></table></figure><p>对于 <code>value</code> 的合并操作也变得更加简单：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// merge 方法，会先判断进行合并的 key 是否存在，不存在，则会添加元素</span></span><br><span class="line">map.merge(<span class="number">9</span>, <span class="string">&quot;val9&quot;</span>, (value, newValue) -&gt; value.concat(newValue));</span><br><span class="line">map.get(<span class="number">9</span>);             <span class="comment">// val9</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 若 key 的元素存在，则对 value 执行拼接操作</span></span><br><span class="line">map.merge(<span class="number">9</span>, <span class="string">&quot;concat&quot;</span>, (value, newValue) -&gt; value.concat(newValue));</span><br><span class="line">map.get(<span class="number">9</span>);             <span class="comment">// val9concat</span></span><br></pre></td></tr></table></figure><h2 id="新的日期API"><a href="#新的日期API" class="headerlink" title="新的日期API"></a>新的日期API</h2><p>Java 8 中在包 <code>java.time</code> 下添加了新的日期 API. 它和 <a href="https://link.juejin.im/?target=http://www.joda.org/joda-time/">Joda-Time</a> 库相似，但又不完全相同。</p><h3 id="Clock"><a href="#Clock" class="headerlink" title="Clock"></a>Clock</h3><p><code>Clock</code> 提供对当前日期和时间的访问。我们可以利用它来替代 <code>System.currentTimeMillis()</code> 方法。另外，通过 <code>clock.instant()</code> 能够获取一个 <code>instant</code> 实例， 此实例能够方便地转换成老版本中的 <code>java.util.Date</code> 对象。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Clock clock = Clock.systemDefaultZone();</span><br><span class="line"><span class="keyword">long</span> millis = clock.millis();</span><br><span class="line"></span><br><span class="line">Instant instant = clock.instant();</span><br><span class="line">Date legacyDate = Date.from(instant);   <span class="comment">// 老版本 java.util.Date</span></span><br></pre></td></tr></table></figure><h3 id="Timezones时区"><a href="#Timezones时区" class="headerlink" title="Timezones时区"></a>Timezones时区</h3><p><code>ZoneId</code> 代表时区类。通过静态工厂方法方便地获取它，入参我们可以传入某个时区编码。另外，时区类还定义了一个偏移量，用来在当前时刻或某时间 与目标时区时间之间进行转换。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(ZoneId.getAvailableZoneIds());</span><br><span class="line"><span class="comment">// prints all available timezone ids</span></span><br><span class="line"></span><br><span class="line">ZoneId zone1 = ZoneId.of(<span class="string">&quot;Europe/Berlin&quot;</span>);</span><br><span class="line">ZoneId zone2 = ZoneId.of(<span class="string">&quot;Brazil/East&quot;</span>);</span><br><span class="line">System.out.println(zone1.getRules());</span><br><span class="line">System.out.println(zone2.getRules());</span><br><span class="line"></span><br><span class="line"><span class="comment">// ZoneRules[currentStandardOffset=+01:00]</span></span><br><span class="line"><span class="comment">// ZoneRules[currentStandardOffset=-03:00]</span></span><br></pre></td></tr></table></figure><h3 id="LocalTime"><a href="#LocalTime" class="headerlink" title="LocalTime"></a>LocalTime</h3><p><code>LocalTime</code> 表示一个没有指定时区的时间类，例如，<code>10 p.m</code>.或者 <code>17：30:15</code>，下面示例代码中，将会使用上面创建的 时区对象创建两个 <code>LocalTime</code>。然后我们会比较两个时间，并计算它们之间的小时和分钟的不同。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LocalTime now1 = LocalTime.now(zone1);</span><br><span class="line">LocalTime now2 = LocalTime.now(zone2);</span><br><span class="line"></span><br><span class="line">System.out.println(now1.isBefore(now2));  <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> hoursBetween = ChronoUnit.HOURS.between(now1, now2);</span><br><span class="line"><span class="keyword">long</span> minutesBetween = ChronoUnit.MINUTES.between(now1, now2);</span><br><span class="line"></span><br><span class="line">System.out.println(hoursBetween);       <span class="comment">// -3</span></span><br><span class="line">System.out.println(minutesBetween);     <span class="comment">// -239</span></span><br></pre></td></tr></table></figure><p><code>LocalTime</code> 提供多个静态工厂方法，目的是为了简化对时间对象实例的创建和操作，包括对时间字符串进行解析的操作等。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LocalTime late = LocalTime.of(<span class="number">23</span>, <span class="number">59</span>, <span class="number">59</span>);</span><br><span class="line">System.out.println(late);       <span class="comment">// 23:59:59</span></span><br><span class="line"></span><br><span class="line">DateTimeFormatter germanFormatter =</span><br><span class="line">    DateTimeFormatter</span><br><span class="line">        .ofLocalizedTime(FormatStyle.SHORT)</span><br><span class="line">        .withLocale(Locale.GERMAN);</span><br><span class="line"></span><br><span class="line">LocalTime leetTime = LocalTime.parse(<span class="string">&quot;13:37&quot;</span>, germanFormatter);</span><br><span class="line">System.out.println(leetTime);   <span class="comment">// 13:37</span></span><br></pre></td></tr></table></figure><h3 id="LocalDate"><a href="#LocalDate" class="headerlink" title="LocalDate"></a>LocalDate</h3><p><code>LocalDate</code> 是一个日期对象，例如：<code>2014-03-11</code>。它和 <code>LocalTime</code> 一样是个 <code>final</code> 类型对象。下面的例子演示了如何通过加减日，月，年等来计算一个新的日期。</p><blockquote><p><code>LocalDate</code>, <code>LocalTime</code>, 因为是 <code>final</code> 类型的对象，每一次操作都会返回一个新的时间对象。</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LocalDate today = LocalDate.now();</span><br><span class="line"><span class="comment">// 今天加一天</span></span><br><span class="line">LocalDate tomorrow = today.plus(<span class="number">1</span>, ChronoUnit.DAYS);</span><br><span class="line"><span class="comment">// 明天减两天</span></span><br><span class="line">LocalDate yesterday = tomorrow.minusDays(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2014 年七月的第四天</span></span><br><span class="line">LocalDate independenceDay = LocalDate.of(<span class="number">2014</span>, Month.JULY, <span class="number">4</span>);</span><br><span class="line">DayOfWeek dayOfWeek = independenceDay.getDayOfWeek();</span><br><span class="line">System.out.println(dayOfWeek);    <span class="comment">// 星期五</span></span><br></pre></td></tr></table></figure><p>也可以直接解析日期字符串，生成 <code>LocalDate</code> 实例。（和 <code>LocalTime</code> 操作一样简单）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DateTimeFormatter germanFormatter =</span><br><span class="line">    DateTimeFormatter</span><br><span class="line">        .ofLocalizedDate(FormatStyle.MEDIUM)</span><br><span class="line">        .withLocale(Locale.GERMAN);</span><br><span class="line"></span><br><span class="line">LocalDate xmas = LocalDate.parse(<span class="string">&quot;24.12.2014&quot;</span>, germanFormatter);</span><br><span class="line">System.out.println(xmas);   <span class="comment">// 2014-12-24</span></span><br></pre></td></tr></table></figure><h3 id="LocalDateTime"><a href="#LocalDateTime" class="headerlink" title="LocalDateTime"></a>LocalDateTime</h3><p><code>LocalDateTime</code> 是一个<strong>日期-时间</strong>对象。你也可以将其看成是 <code>LocalDate</code> 和 <code>LocalTime</code> 的结合体。操作上，也大致相同。</p><blockquote><p><code>LocalDateTime</code> 同样是一个 <code>final</code> 类型对象。</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LocalDateTime sylvester = LocalDateTime.of(<span class="number">2014</span>, Month.DECEMBER, <span class="number">31</span>, <span class="number">23</span>, <span class="number">59</span>, <span class="number">59</span>);</span><br><span class="line"></span><br><span class="line">DayOfWeek dayOfWeek = sylvester.getDayOfWeek();</span><br><span class="line">System.out.println(dayOfWeek);      <span class="comment">// 星期三</span></span><br><span class="line"></span><br><span class="line">Month month = sylvester.getMonth();</span><br><span class="line">System.out.println(month);          <span class="comment">// 十二月</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取改时间是该天中的第几分钟</span></span><br><span class="line"><span class="keyword">long</span> minuteOfDay = sylvester.getLong(ChronoField.MINUTE_OF_DAY);</span><br><span class="line">System.out.println(minuteOfDay);    <span class="comment">// 1439</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如果再加上的时区信息，<code>LocalDateTime</code> 还能够被转换成 <code>Instance</code> 实例。<code>Instance</code> 能够被转换成老版本中 <code>java.util.Date</code> 对象。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Instant instant = sylvester</span><br><span class="line">        .atZone(ZoneId.systemDefault())</span><br><span class="line">        .toInstant();</span><br><span class="line"></span><br><span class="line">Date legacyDate = Date.from(instant);</span><br><span class="line">System.out.println(legacyDate);     <span class="comment">// Wed Dec 31 23:59:59 CET 2014</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>格式化 <code>LocalDateTime</code> 对象就和格式化 LocalDate 或者 LocalTime 一样。除了使用预定义的格式以外，也可以自定义格式化输出。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DateTimeFormatter formatter =</span><br><span class="line">    DateTimeFormatter</span><br><span class="line">        .ofPattern(<span class="string">&quot;MMM dd, yyyy - HH:mm&quot;</span>);</span><br><span class="line"></span><br><span class="line">LocalDateTime parsed = LocalDateTime.parse(<span class="string">&quot;Nov 03, 2014 - 07:13&quot;</span>, formatter);</span><br><span class="line">String string = formatter.format(parsed);</span><br><span class="line">System.out.println(string);     <span class="comment">// Nov 03, 2014 - 07:13</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>注意：和 <code>java.text.NumberFormat</code> 不同，新的 <code>DateTimeFormatter</code> 类是 <code>final</code> 类型的，同时也是线程安全的。</p></blockquote><h2 id="Annotations注解"><a href="#Annotations注解" class="headerlink" title="Annotations注解"></a>Annotations注解</h2><p>在 Java 8 中，注解是可以重复的。让我通过下面的示例代码，来看看到底是咋回事。</p><p>首先，我们定义一个包装注解，里面包含了一个有着实际注解的数组：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@interface</span> Hints &#123;</span><br><span class="line">    Hint[] value();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Repeatable(Hints.class)</span></span><br><span class="line"><span class="meta">@interface</span> Hint &#123;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Java 8 中，通过 <code>@Repeatable</code>，允许我们对同一个类使用多重注解：</p><p>第一种形态：使用注解容器（老方法）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Hints(&#123;@Hint(&quot;hint1&quot;), @Hint(&quot;hint2&quot;)&#125;)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>第二种形态：使用可重复注解（新方法）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Hint(&quot;hint1&quot;)</span></span><br><span class="line"><span class="meta">@Hint(&quot;hint2&quot;)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>使用第二种形态，Java 编译器能够在内部自动对 <code>@Hint</code> 进行设置。这对于需要通过反射来读取注解信息时，是非常重要的。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Hint hint = Person.class.getAnnotation(Hint.class);</span><br><span class="line">System.out.println(hint);                   <span class="comment">// null</span></span><br><span class="line"></span><br><span class="line">Hints hints1 = Person.class.getAnnotation(Hints.class);</span><br><span class="line">System.out.println(hints1.value().length);  <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">Hint[] hints2 = Person.class.getAnnotationsByType(Hint.class);</span><br><span class="line">System.out.println(hints2.length);          <span class="comment">// 2</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>尽管我们绝对不会在 <code>Person</code> 类上声明 <code>@Hints</code> 注解，但是它的信息仍然是可以通过 <code>getAnnotation(Hints.class)</code> 来读取的。 并且，<code>getAnnotationsByType</code> 方法会更方便，因为它赋予了所有 <code>@Hints</code> 注解标注的方法直接的访问权限。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE_PARAMETER, ElementType.TYPE_USE&#125;)</span></span><br><span class="line"><span class="meta">@interface</span> MyAnnotation &#123;&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringCloud（分布式链路跟踪）</title>
      <link href="/blog/2019/01/04/a773bf3d.html"/>
      <url>/blog/2019/01/04/a773bf3d.html</url>
      
        <content type="html"><![CDATA[<h2 id="Spring-Cloud-Sleuth"><a href="#Spring-Cloud-Sleuth" class="headerlink" title="Spring Cloud Sleuth"></a>Spring Cloud Sleuth</h2><p>一般的，一个分布式服务跟踪系统主要由三部分构成：</p><ul><li>数据收集</li><li>数据存储</li><li>数据展示</li></ul><p>根据系统大小不同，每一部分的结构又有一定变化。譬如，对于大规模分布式系统，数据存储可分为实时数据和全量数据两部分，实时数据用于故障排查（<code>Trouble Shooting</code>），全量数据用于系统优化；数据收集除了支持平台无关和开发语言无关系统的数据收集，还包括异步数据收集（需要跟踪队列中的消息，保证调用的连贯性），以及确保更小的侵入性；数据展示又涉及到数据挖掘和分析。虽然每一部分都可能变得很复杂，但基本原理都类似。</p><p><img src="https://gitee.com/cayzlh/img-repo/raw/master/uPic/a1.png" alt="分布式服务跟踪"></p><p>服务追踪的追踪单元是从客户发起请求（<code>request</code>）抵达被追踪系统的边界开始，到被追踪系统向客户返回响应（<code>response</code>）为止的过程，称为一个<code>trace</code>。每个 <code>trace</code> 中会调用若干个服务，为了记录调用了哪些服务，以及每次调用的消耗时间等信息，在每次调用服务时，埋入一个调用记录，称为一个<code>span</code>。这样，若干个有序的 <code>span</code> 就组成了一个 <code>trace</code>。在系统向外界提供服务的过程中，会不断地有请求和响应发生，也就会不断生成 <code>trace</code>，把这些带有<code>span</code> 的 <code>trace</code> 记录下来，就可以描绘出一幅系统的服务拓扑图。附带上 <code>span</code> 中的响应时间，以及请求成功与否等信息，就可以在发生问题的时候，找到异常的服务；根据历史数据，还可以从系统整体层面分析出哪里性能差，定位性能优化的目标。</p><p><code>Spring Cloud Sleuth</code>为服务之间调用提供链路追踪。通过<code>Sleuth</code>可以很清楚的了解到一个服务请求经过了哪些服务，每个服务处理花费了多长。从而让我们可以很方便的理清各微服务间的调用关系。此外<code>Sleuth</code>可以帮助我们：</p><ul><li>耗时分析: 通过<code>Sleuth</code>可以很方便的了解到每个采样请求的耗时，从而分析出哪些服务调用比较耗时;</li><li>可视化错误: 对于程序未捕捉的异常，可以通过集成Zipkin服务界面上看到;</li><li>链路优化: 对于调用比较频繁的服务，可以针对这些服务实施一些优化措施。</li></ul><p><code>spring cloud sleuth</code>可以结合<code>zipkin</code>，将信息发送到<code>zipkin</code>，利用<code>zipkin</code>的存储来存储信息，利用<code>zipkin ui</code>来展示数据。</p><p>这是<code>Spring Cloud Sleuth</code>的概念图：</p><p><img src="https://gitee.com/cayzlh/img-repo/raw/master/uPic/a2.png" alt="trace"></p><p>-</p><h2 id="ZipKin"><a href="#ZipKin" class="headerlink" title="ZipKin"></a>ZipKin</h2><p><code>Zipkin</code> 是一个开放源代码分布式的跟踪系统，由<code>Twitter</code>公司开源，它致力于收集服务的定时数据，以解决微服务架构中的延迟问题，包括数据的收集、存储、查找和展现。</p><p>每个服务向<code>zipkin</code>报告计时数据，<code>zipkin</code>会根据调用关系通过<code>Zipkin UI</code>生成依赖关系图，显示了多少跟踪请求通过每个服务，该系统让开发者可通过一个 <code>Web</code> 前端轻松的收集和分析数据，例如用户每次请求服务的处理时间等，可方便的监测系统中存在的瓶颈。</p><p><code>Zipkin</code>提供了可插拔数据存储方式：<code>In-Memory</code>、<code>MySql</code>、<code>Cassandra</code>以及<code>Elasticsearch</code>。</p><h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><p><code>Zipkin</code> 分为两端，一个是 <code>Zipkin</code> 服务端，一个是 <code>Zipkin</code> 客户端，客户端也就是微服务的应用。<br>客户端会配置服务端的 <code>URL</code> 地址，一旦发生服务间的调用的时候，会被配置在微服务里面的 <code>Sleuth</code> 的监听器监听，并生成相应的 <code>Trace</code> 和 <code>Span</code> 信息发送给服务端。<br>发送的方式主要有两种，一种是 <code>HTTP</code> 报文的方式，还有一种是消息总线的方式如 <code>RabbitMQ</code>。</p><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>无论是用<code>HTTP</code>的方式还是<code>消息总线</code>的方式，都需要：</p><ul><li>一个注册中心，用之前的就行</li><li>一个Zipkin服务端</li><li>两个微服务应用，<code>trace-a</code>和<code>trace-b</code>，其中<code>trace-a</code>中有一个 REST 接口<code>/trace-a</code>，调用该接口后将触发对<code>trace-b</code>应用的调用。</li></ul><h4 id="Zipkin服务端"><a href="#Zipkin服务端" class="headerlink" title="Zipkin服务端"></a>Zipkin服务端</h4><p>使用<code>Docker</code>：</p><ol><li><p>pull image</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull openzipkin/zipkin</span><br></pre></td></tr></table></figure></li><li><p>run container</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d -p 9411:9411 openzipkin/zipkin</span><br></pre></td></tr></table></figure></li></ol><p>启动后，访问<a href="http://localhost:9411/zipkin/">http://localhost:9411/zipkin/</a>就能看到如下界面：</p><p><img src="https://gitee.com/cayzlh/img-repo/raw/master/uPic/3.png" alt="zipkin"></p><p>-</p><p>服务端<code>OK</code>。</p><h4 id="微服务应用"><a href="#微服务应用" class="headerlink" title="微服务应用"></a>微服务应用</h4><p>创建两个基本的<code>Spring Boot</code>工程，分别名为<code>trace-a</code>和<code>trace-b</code>。</p><h3 id="pom配置"><a href="#pom配置" class="headerlink" title="pom配置"></a>pom配置</h3><p>两个工程的<code>pom</code>文件配置都引入以下依赖：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-webflux<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-sleuth<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-zipkin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>两者的配置文件也一样（除了<code>spring. application.name</code>和<code>server.port</code>，自行修改）</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">trace-a</span></span><br><span class="line">  <span class="attr">sleuth:</span></span><br><span class="line">    <span class="attr">web:</span></span><br><span class="line">      <span class="attr">client:</span></span><br><span class="line">        <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">sampler:</span></span><br><span class="line">      <span class="attr">probability:</span> <span class="number">1.0</span> <span class="comment"># 将采样比例设置为 1.0，也就是全部都需要。默认是 0.1</span></span><br><span class="line">  <span class="attr">zipkin:</span></span><br><span class="line">    <span class="attr">base-url:</span> <span class="string">http://localhost:9411/</span> <span class="comment"># 指定了 Zipkin 服务器的地址</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">28092</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://localhost:28081/eureka/</span></span><br></pre></td></tr></table></figure><blockquote><p>Spring Cloud Sleuth 有一个 Sampler 策略，可以通过这个实现类来控制采样算法。采样器不会阻碍 span 相关 id 的产生，但是会对导出以及附加事件标签的相关操作造成影响。 Sleuth 默认采样算法的实现是 Reservoir sampling，具体的实现类是 PercentageBasedSampler，默认的采样比例为: 0.1(即 10%)。不过我们可以通过<code>spring.sleuth.sampler.percentage</code>来设置，所设置的值介于 0.0 到 1.0 之间，1.0 则表示全部采集。</p></blockquote><h3 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h3><p>对<code>trace-a</code>和<code>trace-b</code>进行编码。</p><h4 id="trace-a"><a href="#trace-a" class="headerlink" title="trace-a"></a>trace-a</h4><p>配置一个<code>WebClient</code> <strong>Bean</strong>：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TraceAApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(TraceAApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> LoadBalancerExchangeFilterFunction lbFunction;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> WebClient <span class="title">webClient</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> WebClient.builder()</span><br><span class="line">            .baseUrl(<span class="string">&quot;http://trace-b&quot;</span>)</span><br><span class="line">            .filter(lbFunction).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建一个<code>TraceAController</code>：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TraceAController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> WebClient webClient;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/trace-a&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Mono&lt;String&gt; <span class="title">trace</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;call trace-a.&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> webClient.get().uri(<span class="string">&quot;/trace-b&quot;</span>)</span><br><span class="line">            .retrieve().bodyToMono(String.class);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="trace-b"><a href="#trace-b" class="headerlink" title="trace-b"></a>trace-b</h4><p><code>trace-b</code>的启动类如下，使用默认的代码，不需修改：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TraceBApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(TraceBApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建一个<code>TraceBController</code>：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TraceBController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/trace-b&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Mono&lt;String&gt; <span class="title">trace</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;call trace-b.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> Mono.just(<span class="string">&quot;Trace.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，准备工作就完成了。*<code>Spring</code> 应用在监测到 <code>classpath</code> 中有 <code>Sleuth</code> 和 <code>Zipkin</code> 后，会自动在 <code>WebClient</code>（或 <code>RestTemplate</code>）的调用过程中向 <code>HTTP</code> 请求注入追踪信息，并向 <code>Zipkin Server</code> 发送这些信息。*</p><h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>分别启动<code>服务注册中心</code>、<code>trace-a</code>和<code>trace-b</code>，访问<a href="http://localhost:28092/trace-a">http://localhost:28092/trace-a</a>，可以得到返回值<code>Trace.</code>，同时在两个工程的控制台都能看到相关日志输出：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> trace-a工程控制台</span></span><br><span class="line">call trace-a.</span><br><span class="line"><span class="meta">#</span><span class="bash"> trace-b工程控制台</span></span><br><span class="line">call trace-b.</span><br></pre></td></tr></table></figure><p>访问<a href="http://localhost:9411/">http://localhost:9411</a>，点击<code>Find Traces</code>看到有一条记录：</p><p><img src="https://gitee.com/cayzlh/img-repo/raw/master/uPic/a4.png" alt="zipkin"></p><p>-</p><p>点击进去可以看到详细信息：</p><p><img src="https://gitee.com/cayzlh/img-repo/raw/master/uPic/a5.png" alt="zipkin"></p><p>-</p><p><img src="https://gitee.com/cayzlh/img-repo/raw/master/uPic/a6.png" alt="zipkin"></p><h3 id="消息总线-RabbitMQ方式"><a href="#消息总线-RabbitMQ方式" class="headerlink" title="消息总线-RabbitMQ方式"></a>消息总线-RabbitMQ方式</h3><p><code>Zipkin</code> 不再推荐我们来自定义 <code>Server</code> 端了，所以在最新版本的 <code>Spring Cloud</code> 依赖管理里已经找不到 <code>zipkin-server</code> 了。</p><p>通过环境变量让<code>Zipkin</code>从<code>RabbitMQ</code>中读取信息：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">RABBIT_ADDRESSES=localhost java -jar zipkin.jar</span><br></pre></td></tr></table></figure><p>关于 <code>Zipkin</code> 的 <code>Client</code> 端，也就是微服务应用，我们就在之前 <code>trace-a</code>、<code>trace-b</code> 的基础上修改，只要在他们的依赖里都引入<code>spring-cloud-stream-binder-rabbit</code>就好了，别的不用改。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-stream-binder-rabbit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://windmt.com/2018/04/24/spring-cloud-12-sleuth-zipkin/">分布式链路跟踪 Sleuth 与 Zipkin【Finchley 版】</a></li><li><a href="http://www.ityouknow.com/springcloud/2018/02/02/spring-cloud-sleuth-zipkin.html">使用Spring Cloud Sleuth和Zipkin进行分布式链路跟踪</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
          <category> SpringCloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> SpringCloud </tag>
            
            <tag> 微服务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringCloud（服务网关zuul）</title>
      <link href="/blog/2019/01/03/d3f1148e.html"/>
      <url>/blog/2019/01/03/d3f1148e.html</url>
      
        <content type="html"><![CDATA[<h2 id="API-Gateway"><a href="#API-Gateway" class="headerlink" title="API Gateway"></a>API Gateway</h2><p>API Gateway是微服务架构中不可或缺的部分：<a href="http://dockone.io/article/482">http://dockone.io/article/482</a>。</p><p>API Gateway是一个服务器，也可以说是进入系统的唯一节点。这跟面向对象设计模式中的Facade模式很像。API Gateway封装内部系统的架构，并且提供API给各个客户端。它还可能有其他功能，如授权、监控、负载均衡、缓存、请求分片和管理、静态响应处理等。</p><p>API Gateway负责请求转发、合成和协议转换。所有来自客户端的请求都要先经过API Gateway，然后路由这些请求到对应的微服务。API Gateway将经常通过调用多个微服务来处理一个请求以及聚合多个服务的结果。它可以在web协议与内部使用的非Web友好型协议间进行转换，如HTTP协议、WebSocket协议。</p><p>API Gateway可以提供给客户端一个定制化的API。它暴露一个粗粒度API给移动客户端。以产品最终页这个使用场景为例。API Gateway提供一个服务提供点（/productdetails?productid=xxx）使得移动客户端可以在一个请求中检索到产品最终页的全部数据。API Gateway通过调用多个服务来处理这一个请求并返回结果，涉及产品信息、推荐、评论等。</p><p>一个很好的API Gateway例子是<a href="http://techblog.netflix.com/2013/02/rxjava-netflix-api.html">Netfix API Gateway</a>。Netflix流服务提供数百个不同的微服务，包括电视、机顶盒、智能手机、游戏系统、平板电脑等。起初，Netflix视图提供一个<a href="http://www.programmableweb.com/news/why-rest-keeps-me-night/2012/05/15">适用全场景</a>的API。但是，他们发现这种形式不好用，因为涉及到各式各样的设备以及它们独特的需求。现在，他们采用一个API Gateway来提供容错性高的API，针对不同类型设备有相应代码。事实上，一个适配器处理一个请求平均要调用6到8个后端服务。Netflix API Gateway每天处理数十亿的请求。</p><h3 id="API-Gateway的优点和缺点"><a href="#API-Gateway的优点和缺点" class="headerlink" title="API Gateway的优点和缺点"></a>API Gateway的优点和缺点</h3><p>如你所料，采用API Gateway也是优缺点并存的。API Gateway的一个最大好处是封装应用内部结构。相比起来调用指定的服务，客户端直接跟gatway交互更简单点。API Gateway提供给每一个客户端一个特定API，这样减少了客户端与服务器端的通信次数，也简化了客户端代码。</p><p>API Gateway也有一些缺点。它是一个高可用的组件，必须要开发、部署和管理。还有一个问题，它可能成为开发的一个瓶颈。开发者必须更新API Gateway来提供新服务提供点来支持新暴露的微服务。更新API Gateway时必须越轻量级越好。否则，开发者将因为更新Gateway而排队列。但是，除了这些缺点，对于大部分的应用，采用API Gateway的方式都是有效的。</p><p>使用API Gateway后，客户端和微服务之间的网络图变成下图：</p><p><img src="https://gitee.com/cayzlh/img-repo/raw/master/2020/04/17/lzchLT.png" alt="API Gateway"></p><p>通过API Gateway，可以统一向外部系统提供REST API。Spring Cloud中使用Zuul作为API Gateway。Zuul提供了动态路由、监控、回退、安全等功能。</p><h2 id="Zuul"><a href="#Zuul" class="headerlink" title="Zuul"></a>Zuul</h2><p>Netflix开源的微服务网关，核心是一系列过滤器：</p><ul><li>身份认证安全</li><li>审查与监控</li><li>动态路由</li><li>压力测试</li><li>附再分配</li><li>静态响应处理</li><li>多区域弹性</li></ul><h2 id="Zuul过滤器"><a href="#Zuul过滤器" class="headerlink" title="Zuul过滤器"></a>Zuul过滤器</h2><p>Spring Cloud中使用Zuul作为API Gateway。Zuul提供了动态路由、监控、回退、安全等功能。主要为4种标准类型：</p><ul><li>PRE：在请求被路由之前调用</li><li>ROUTING：这种过滤器将请求路由到微服务</li><li>POST：在路由到微服务以后执行</li><li>ERROR：在其他阶段发生错误时自信该过滤器</li></ul><h2 id="Spring-Cloud-Zuul"><a href="#Spring-Cloud-Zuul" class="headerlink" title="Spring Cloud Zuul"></a>Spring Cloud Zuul</h2><p><code>Spring Cloud Zuul</code>路由是微服务架构的不可或缺的一部分，提供动态路由，监控，弹性，安全等的边缘服务。<code>Zuul</code>是<code>Netflix</code>出品的一个基于<code>JVM</code>路由和服务端的负载均衡器。</p><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>新建一个<code>Spring Boot</code>项目，命名为：<code>api-gateway</code>，</p><h3 id="POM配置"><a href="#POM配置" class="headerlink" title="POM配置"></a>POM配置</h3><p>在<code>pom.xml</code>中引入以下依赖：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.cayzlh<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-demos-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>api-gateway<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>api-gateway<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">description</span>&gt;</span>Demo project for Spring Boot<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-zuul<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>在配置文件 <code>application.yml</code> 中加入服务名、端口号、<code>Eureka</code> 注册中心的地址：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">api-gateway</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">28091</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://localhost:28081/eureka/</span></span><br></pre></td></tr></table></figure><h3 id="启动类"><a href="#启动类" class="headerlink" title="启动类"></a>启动类</h3><p>使用<code>@EnableZuulProxy</code>注解开启<code>Zuul</code>功能：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableZuulProxy</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApiGatewayApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(ApiGatewayApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，一个基于<code>Spring Cloud Zuul</code>的服务网关就已经构建完成。分别启动注册中心、服务生产者、服务消费者、<code>API-GATEWAY</code>：</p><p><img src="https://gitee.com/cayzlh/img-repo/raw/master/2020/04/17/zmVnNy.png" alt="api-gateway"></p><p>启动完成后，访问<a href="http://localhost:28081/">http://localhost:208081</a>，可以看到上面的结果。</p><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>由于 <code>Spring Cloud Zuul</code> 在整合了 <code>Eureka</code> 之后，具备默认的服务路由功能，即：<strong>当我们这里构建的<code>api-gateway</code>应用启动并注册到 <code>Eureka</code> 之后，服务网关会发现上面我们启动的两个服务<code>producer</code>和<code>consumer</code>，这时候 <code>Zuul</code> 就会创建两个路由规则。每个路由规则都包含两部分，一部分是外部请求的匹配规则，另一部分是路由的服务 <code>ID</code>。</strong>针对当前示例的情况，<code>Zuul</code> 会创建下面的两个路由规则：</p><ul><li>转发到<code>eureka-producer</code>服务的请求规则为：<code>/eureka-producer/**</code></li><li>转发到<code>eureka-consumer</code>服务的请求规则为：<code>/eureka-consumer/**</code></li></ul><p>最后，我们可以通过访问<code>28091</code>端口的服务网关来验证上述路由的正确性：</p><ul><li><p>比如访问：<a href="http://localhost:28091/eureka-consumer/hello/zhangsan">http://localhost:28091/eureka-consumer/hello/zhangsan</a>，该请求将最终被路由到<code>consumer</code>的<code>/hello</code>接口上：</p><p><img src="https://gitee.com/cayzlh/img-repo/raw/master/2020/04/17/06aKRo.png" alt="api-gateway"></p></li></ul><p>以上结果说明zuul已经开始生效了。</p><h2 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h2><p><code>Zuul</code>还有更多的应用场景，比如：鉴权、流量转发、请求统计等等，这些功能都可以使用<code>Zuul</code>来实现。</p><h3 id="Zuul的核心"><a href="#Zuul的核心" class="headerlink" title="Zuul的核心"></a>Zuul的核心</h3><p><code>Filter</code>是<code>Zuul</code>的核心，用来实现对外服务的控制。Filter的生命周期有4个，分别是<code>PRE</code>、<code>ROUTING</code>、<code>POST</code>、<code>ERROR</code>，整个生命周期可以用下图来表示：</p><p><img src="https://gitee.com/cayzlh/img-repo/raw/master/2020/04/17/8upBZN.png" alt="Filter生命周期"></p><p><code>Zuul</code>大部分功能都是通过过滤器来实现的，这些过滤器类型对应于请求的典型生命周期。</p><ul><li><strong>PRE：</strong> 这种过滤器在请求被路由之前调用。我们可利用这种过滤器实现身份验证、在集群中选择请求的微服务、记录调试信息等。</li><li><strong>ROUTING：</strong>这种过滤器将请求路由到微服务。这种过滤器用于构建发送给微服务的请求，并使用<code>Apache HttpClient</code>或<code>Netfilx Ribbon</code>请求微服务。</li><li><strong>POST：</strong>这种过滤器在路由到微服务以后执行。这种过滤器可用来为响应添加标准的<code>HTTP Header</code>、收集统计信息和指标、将响应从微服务发送给客户端等。</li><li><strong>ERROR：</strong>在其他阶段发生错误时执行该过滤器。 除了默认的过滤器类型，<code>Zuul</code>还允许我们创建自定义的过滤器类型。例如，我们可以定制一种<code>STATIC</code>类型的过滤器，直接在<code>Zuul</code>中生成响应，而不将请求转发到后端的微服务。</li></ul><h3 id="Zuul中默认实现的Filter"><a href="#Zuul中默认实现的Filter" class="headerlink" title="Zuul中默认实现的Filter"></a>Zuul中默认实现的Filter</h3><table><thead><tr><th>类型</th><th>顺序</th><th>过滤器</th><th>功能</th></tr></thead><tbody><tr><td>pre</td><td>-3</td><td>ServletDetectionFilter</td><td>标记处理Servlet的类型</td></tr><tr><td>pre</td><td>-2</td><td>Servlet30WrapperFilter</td><td>包装HttpServletRequest请求</td></tr><tr><td>pre</td><td>-1</td><td>FormBodyWrapperFilter</td><td>包装请求体</td></tr><tr><td>route</td><td>1</td><td>DebugFilter</td><td>标记调试标志</td></tr><tr><td>route</td><td>5</td><td>PreDecorationFilter</td><td>处理请求上下文供后续使用</td></tr><tr><td>route</td><td>10</td><td>RibbonRoutingFilter</td><td>serviceId请求转发</td></tr><tr><td>route</td><td>100</td><td>SimpleHostRoutingFilter</td><td>url请求转发</td></tr><tr><td>route</td><td>500</td><td>SendForwardFilter</td><td>forward请求转发</td></tr><tr><td>post</td><td>0</td><td>SendErrorFilter</td><td>处理有错误的请求响应</td></tr><tr><td>post</td><td>1000</td><td>SendResponseFilter</td><td>处理正常的请求响应</td></tr></tbody></table><p>-</p><h3 id="禁用指定的Filter"><a href="#禁用指定的Filter" class="headerlink" title="禁用指定的Filter"></a>禁用指定的Filter</h3><p>可以在<code>application.xml</code>中配置需要禁用的<code>filter</code>，以<code>zuul.&lt;SimpleClassName&gt;.&lt;filterType&gt;.disable=true</code>这样的格式配置，比如要禁用<code>org.springframework.cloud.netflix.zuul.filters.post.SendResponseFilter</code>就设置：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">zuul:</span></span><br><span class="line">  <span class="attr">SendResponseFilter:</span></span><br><span class="line">    <span class="attr">post:</span></span><br><span class="line">      <span class="attr">disable:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><h3 id="自定义Filter"><a href="#自定义Filter" class="headerlink" title="自定义Filter"></a>自定义Filter</h3><p>我们假设有这样一个场景，因为服务网关应对的是外部的所有请求，为了避免产生安全隐患，我们需要对请求做一定的限制，比如请求中含有 <code>Token</code> 便让请求继续往下走，如果请求不带 <code>Token</code> 就直接返回并给出提示。</p><p>首先自定义一个 <code>Filter</code>，继承 <code>ZuulFilter</code> 抽象类，在 <code>run()</code> 方法中验证参数是否含有 <code>Token</code>，具体如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TokenFilter</span> <span class="keyword">extends</span> <span class="title">ZuulFilter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 过滤器的类型，它决定过滤器在请求的哪个生命周期中执行。</span></span><br><span class="line"><span class="comment">     * 这里定义为pre，代表会在请求被路由之前执行。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">filterType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;pre&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * filter执行顺序，通过数字指定。</span></span><br><span class="line"><span class="comment">     * 数字越大，优先级越低。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">filterOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断该过滤器是否需要被执行。这里我们直接返回了true，因此该过滤器对所有请求都会生效。</span></span><br><span class="line"><span class="comment">     * 实际运用中我们可以利用该函数来指定过滤器的有效范围。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">shouldFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 过滤器的具体逻辑</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        RequestContext ctx = RequestContext.getCurrentContext();</span><br><span class="line">        HttpServletRequest request = ctx.getRequest();</span><br><span class="line"></span><br><span class="line">        String token = request.getParameter(<span class="string">&quot;token&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (token == <span class="keyword">null</span> || token.isEmpty()) &#123;</span><br><span class="line">            ctx.setSendZuulResponse(<span class="keyword">false</span>);</span><br><span class="line">            ctx.setResponseStatusCode(<span class="number">401</span>);</span><br><span class="line">            ctx.setResponseBody(<span class="string">&quot;token is empty&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面实现的过滤器代码中，我们通过继承<code>ZuulFilter</code>抽象类并重写了下面的四个方法来实现自定义的过滤器。这四个方法分别定义了：</p><ul><li><code>filterType()</code>：过滤器的类型，它决定过滤器在请求的哪个生命周期中执行。这里定义为<code>pre</code>，代表会在请求被路由之前执行。</li><li><code>filterOrder()</code>：过滤器的执行顺序。当请求在一个阶段中存在多个过滤器时，需要根据该方法返回的值来依次执行。通过数字指定，数字越大，优先级越低。</li><li><code>shouldFilter()</code>：判断该过滤器是否需要被执行。这里我们直接返回了<code>true</code>，因此该过滤器对所有请求都会生效。实际运用中我们可以利用该函数来指定过滤器的有效范围。</li><li><code>run()</code>：过滤器的具体逻辑。这里我们通过<code>ctx.setSendZuulResponse(false)</code>令 Zuul 过滤该请求，不对其进行路由，然后通过<code>ctx.setResponseStatusCode(401)</code>设置了其返回的错误码，当然我们也可以进一步优化我们的返回，比如，通过<code>ctx.setResponseBody(body)</code>对返回 body 内容进行编辑等。</li></ul><p>在实现了自定义过滤器之后，它并不会直接生效，我们还需要为其创建具体的 <code>Bean</code> 才能启动该过滤器，比如，在应用主类中增加如下内容：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableZuulProxy</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApiGatewayApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(ApiGatewayApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TokenFilter <span class="title">tokenFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TokenFilter();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在对<code>api-gateway</code>服务完成了上面的改造之后，我们可以重新启动它，并发起下面的请求，对上面定义的过滤器做一个验证：</p><ul><li><p>访问 <a href="http://localhost:14000/eureka-consumer/hello/zhangsan">http://localhost:14000/eureka-consumer/hello/zhangsan</a> 返回 401 错误和<code>token is empty</code></p><p><img src="https://gitee.com/cayzlh/img-repo/raw/master/2020/04/17/McjnNy.png" alt="zuul-filter"></p></li><li><p>访问  <a href="http://localhost:14000/eureka-consumer/hello/zhangsan?token=token">http://localhost:14000/eureka-consumer/hello/zhangsan?token=token</a> 正确路由到<code>eureka-consumer</code>的<code>/hello</code>接口，并返回<code>Hello, zhangsan!, 现在时间：1546506130007</code></p><p><img src="https://gitee.com/cayzlh/img-repo/raw/master/2020/04/17/K9vzNb.png" alt="zuul-filter"></p></li></ul><h2 id="路由熔断"><a href="#路由熔断" class="headerlink" title="路由熔断"></a>路由熔断</h2><p>当我们的后端服务出现异常的时候，我们不希望将异常抛出给最外层，期望服务可以自动进行一降级。<code>Zuul</code>给我们提供了这样的支持。当某个服务出现异常时，直接返回我们预设的信息。</p><p>我们通过自定义的<code>fallback</code>方法，并且将其指定给某个<code>route</code>来实现该<code>route</code>访问出问题的熔断处理。主要继承<code>ZuulFallbackProvider</code>接口来实现，<code>ZuulFallbackProvider</code>默认有两个方法，一个用来指明熔断拦截哪个服务，一个定制返回内容。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ZuulFallbackProvider</span> </span>&#123;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The route this fallback will be used for.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> The route the fallback will be used for.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getRoute</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Provides a fallback response.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> The fallback response.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ClientHttpResponse <span class="title">fallbackResponse</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现类通过实现<code>getRoute</code>方法，告诉<code>Zuul</code>它是负责哪个<code>route</code>定义的熔断。而<code>fallbackResponse</code>方法则是告诉 <code>Zuul</code> 断路出现时，它会提供一个什么返回值来处理请求。</p><p>后来<code>Spring</code>又扩展了此类，丰富了返回方式，在返回的内容中添加了异常信息，因此最新版本建议直接继承类<code>FallbackProvider</code> 。</p><h2 id="路由重试"><a href="#路由重试" class="headerlink" title="路由重试"></a>路由重试</h2><p>有时候因为网络或者其它原因，服务可能会暂时的不可用，这个时候我们希望可以再次对服务进行重试，<code>Zuul</code>也帮我们实现了此功能，需要结合<code>Spring Retry</code> 一起来实现。需要添加依赖：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.retry<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-retry<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>开启重试在某些情况下是有问题的，比如当压力过大，一个实例停止响应时，路由将流量转到另一个实例，很有可能导致最终所有的实例全被压垮。说到底，断路器的其中一个作用就是防止故障或者压力扩散。用了<code>retry</code>，断路器就只有在该服务的所有实例都无法运作的情况下才能起作用。这种时候，断路器的形式更像是提供一种友好的错误信息，或者假装服务正常运行的假象给使用者。</p><p>不用<code>retry</code>，仅使用负载均衡和熔断，就必须考虑到是否能够接受单个服务实例关闭和<code>eureka</code>刷新服务列表之间带来的短时间的熔断。如果可以接受，就无需使用<code>retry</code>。</p></blockquote><p>-</p><h2 id="Zuul高可用"><a href="#Zuul高可用" class="headerlink" title="Zuul高可用"></a>Zuul高可用</h2><p>不同的客户端使用不同的负载将请求分发到后端的<code>Zuul</code>，<code>Zuul</code>在通过<code>Eureka</code>调用后端服务，最后对外输出。因此为了保证<code>Zuul</code>的高可用性，前端可以同时启动多个<code>Zuul</code>实例进行负载，在<code>Zuul</code>的前端使用<code>Nginx</code>或者<code>F5</code>进行负载转发以达到高可用性。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://windmt.com/2018/04/23/spring-cloud-10-zuul-router/">服务网关 Zuul（路由）【Finchley 版】</a></li><li><a href="http://www.ityouknow.com/springcloud/2017/06/01/gateway-service-zuul.html">服务网关zuul初级篇</a></li><li><a href="http://www.ityouknow.com/springcloud/2018/01/20/spring-cloud-zuul.html">服务网关Zuul高级篇</a></li><li><a href="https://windmt.com/2018/04/23/spring-cloud-11-zuul-filter/">服务网关 Zuul（过滤器）【Finchley 版】</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
          <category> SpringCloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> SpringCloud </tag>
            
            <tag> 微服务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringCloud（配置中心和消息总线）</title>
      <link href="/blog/2019/01/01/b2f3c839.html"/>
      <url>/blog/2019/01/01/b2f3c839.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>在<a href="/archives/5e7c1be9.html">SpringCloud（Git版配置中心）</a>中有提到过，如果需要客户端获取到最新的配置信息需要执行<code>refresh</code>，我们可以利用webhook的机制每次提交代码发送请求来刷新客户端，当客户端越来越多的时候，需要每个客户端都执行一遍，这种方案就不太适合了。使用Spring Cloud Bus可以完美解决这一问题。</p></blockquote><h2 id="Spring-Cloud-Bus"><a href="#Spring-Cloud-Bus" class="headerlink" title="Spring Cloud Bus"></a>Spring Cloud Bus</h2><p><code>Spring cloud bus</code>通过轻量消息代理连接各个分布的节点。这会用在广播状态的变化（例如配置变化）或者其他的消息指令。<code>Spring bus</code>的一个核心思想是通过分布式的启动器对<code>spring boot</code>应用进行扩展，也可以用来建立一个多个应用之间的通信频道。目前唯一实现的方式是用<code>AMQP</code>消息代理作为通道，同样特性的设置（有些取决于通道的设置）在更多通道的文档中。</p><p><code>Spring cloud bus</code>可以将它理解为管理和传播所有分布式项目中的消息既可，其实本质是利用了<code>MQ</code>的广播机制在分布式的系统中传播消息，目前常用的有<code>Kafka</code>和<code>RabbitMQ</code>。利用<code>bus</code>的机制可以做很多的事情，其中配置中心客户端刷新就是典型的应用场景之一，我们用一张图来描述<code>bus</code>在配置中心使用的机制。</p><p><img src="https://gitee.com/cayzlh/img-repo/raw/master/uPic/2020/04/17/1-cYdy1e.jpg" alt="spring cloud bus"></p><p>根据此图我们可以看出利用<code>Spring Cloud Bus</code>做配置更新的步骤:</p><ul><li>提交代码触发<code>post</code>给客户端<code>A</code>发送<code>bus/refresh</code></li><li>客户端A接收到请求从<code>Server</code>端更新配置并且发送给<code>Spring Cloud Bus</code></li><li><code>Spring Cloud bus</code>接到消息并通知给其它客户端</li><li>其它客户端接收到通知，请求<code>Server</code>端获取最新配置</li><li>全部客户端均获取到最新的配置</li></ul><h2 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h2><p>由于需要用到<code>MQ</code>，这里使用<code>Docker</code>安装<code>RabbitMQ</code>来用作示例，<a href="http://www.runoob.com/docker/docker-tutorial.html">Docker教程</a>。</p><h3 id="Docker中使用RabbitMQ"><a href="#Docker中使用RabbitMQ" class="headerlink" title="Docker中使用RabbitMQ"></a>Docker中使用RabbitMQ</h3><p>RabbitMQ是开源消息代理软件（有时称为面向消息的中间件），它实现了高级消息队列协议（AMQP）。RabbitMQ服务器采用Erlang编程语言编写，构建于Open Telecom Platform框架之上，用于集群和故障转移。与代理接口的客户端库可用于所有主要编程语言。</p><h3 id="拉取rabbitmq镜像"><a href="#拉取rabbitmq镜像" class="headerlink" title="拉取rabbitmq镜像"></a>拉取rabbitmq镜像</h3><p>执行以下命令，拉取<code>latest</code>版官方镜像：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull rabbitmq:management</span><br></pre></td></tr></table></figure><p>使用带管理界面的镜像。</p><p><img src="https://gitee.com/cayzlh/img-repo/raw/master/2020/04/17/pQDSEG.png" alt="docker-rabbitmq"></p><h3 id="使用镜像"><a href="#使用镜像" class="headerlink" title="使用镜像"></a>使用镜像</h3><p>执行以下命令，使用镜像：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d --name rabbitmq --publish 5671:5671 \</span><br><span class="line"> --publish 5672:5672 --publish 4369:4369 \</span><br><span class="line"> --publish 25672:25672 --publish 15671:15671 --publish 15672:15672 \</span><br><span class="line">rabbitmq:management</span><br></pre></td></tr></table></figure><p>启动之后访问<a href="http://localhost:15672/">http://localhost:15672/</a>能够看到<code>Web</code>管理界面，使用<strong>guest / guest</strong>登录之后看到如下界面，说明镜像已经运行。</p><p><img src="https://cdn.jsdelivr.net/gh/cayzlh/git-img-repository@master/2020/04/17/RQYNr2.png" alt="docker-rabbitmq"></p><p>很好， 现在开始改造代码。</p><h2 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h2><h3 id="pom配置"><a href="#pom配置" class="headerlink" title="pom配置"></a>pom配置</h3><p>在<code>pom.xml</code>中添加以下依赖：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-config-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-bus<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-stream-binder-rabbit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>以上四个依赖是必须的</strong></p><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>修改<code>application.yml</code>文件：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">config-server</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">config:</span></span><br><span class="line">      <span class="attr">server:</span></span><br><span class="line">        <span class="attr">git:</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">https://github.com/cayzlh/SpringCloudDemos</span> <span class="comment"># 配置git仓库的地址</span></span><br><span class="line">          <span class="attr">search-paths:</span> <span class="string">config-repo</span> <span class="comment"># git仓库地址下的相对地址，可以配置多个，用,分割。</span></span><br><span class="line">    <span class="attr">bus:</span></span><br><span class="line">      <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">trace:</span></span><br><span class="line">        <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">28088</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://localhost:28081/eureka/</span></span><br><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoints:</span></span><br><span class="line">    <span class="attr">web:</span></span><br><span class="line">      <span class="attr">exposure:</span></span><br><span class="line">        <span class="attr">include:</span> <span class="string">bus-refresh</span></span><br></pre></td></tr></table></figure><p>主要增加的内容有：</p><ul><li>spring.cloud.bus.enable</li><li>spring.cloud.bus.trace.enable</li><li>Management.endpoints.web.exposure.include</li></ul><h3 id="启动类"><a href="#启动类" class="headerlink" title="启动类"></a>启动类</h3><p>添加<code>@EnableConfigServer</code>注解：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="meta">@EnableConfigServer</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigServerGitApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(ConfigServerGitApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><h3 id="pom配置-1"><a href="#pom配置-1" class="headerlink" title="pom配置"></a>pom配置</h3><p>在 <code>pom.xml</code> 里添加以下依赖，前 5 个是必须的，最后一个 <code>webflux</code> 可以用 <code>web</code> 来代替：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-bus<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-stream-binder-rabbit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-webflux<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>如果缺了<code>spring-boot-starter-actuator</code>，当对服务端执行<code>/actuator/bus-refresh</code>的时候，客户端接收不到信息。</p></blockquote><h3 id="配置文件-1"><a href="#配置文件-1" class="headerlink" title="配置文件"></a>配置文件</h3><p>有两个配置文件，<code>application.xml</code>：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">config-client-git</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">bus:</span></span><br><span class="line">      <span class="attr">trace:</span></span><br><span class="line">        <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">28089</span></span><br><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoints:</span></span><br><span class="line">    <span class="attr">web:</span></span><br><span class="line">      <span class="attr">exposure:</span></span><br><span class="line">        <span class="attr">include:</span> <span class="string">refresh</span></span><br></pre></td></tr></table></figure><p>启用<code>spring cloud bus</code>，<code>bootstrap.xml</code>：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">config:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">test-config</span></span><br><span class="line">      <span class="attr">profile:</span> <span class="string">test</span></span><br><span class="line">      <span class="attr">label:</span> <span class="string">master</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">        <span class="attr">service-id:</span> <span class="string">config-server</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://localhost:28081/eureka/</span></span><br></pre></td></tr></table></figure><h3 id="controller"><a href="#controller" class="headerlink" title="controller"></a>controller</h3><p>基本上没有啥改动</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RefreshScope</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;test.hello:error&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String profile;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/info&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Mono&lt;String&gt; <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Mono.justOrEmpty(profile);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>@RefreshScope</code>注解必须加上，否则客户端会受到服务端的更新消息，但是更新不了，因为不知道更新哪里的。</p><h3 id="启动类-1"><a href="#启动类-1" class="headerlink" title="启动类"></a>启动类</h3><p>默认的就可以</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfitClientApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(ConfitClientApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>分别启动<code>注册中心</code>、<code>config-server-git</code>、<code>config-client</code>（其中<code>client</code>分别用不同端口启动两个以上实例，用以模拟多个客户端），启动后，<code>RabbitMQ</code> 中会自动创建一个 <code>topic</code> 类型的 <code>Exchange</code> 和两个以<code>springCloudBus.anonymous.</code>开头的匿名 <code>Queue</code>：</p><p><img src="https://gitee.com/cayzlh/img-repo/raw/master/2020/04/17/GpiLYs.png" alt="Exchange"></p><p>-</p><p><img src="https://gitee.com/cayzlh/img-repo/raw/master/2020/04/17/ZcofUy.png" alt="Queues"></p><p>-</p><p>使用<code>postman</code>请求<a href="http://localhost:28089/info">http://localhost:28089/info</a>，得到结果（各个端口的客户端接口都请求）：</p><p><img src="https://gitee.com/cayzlh/img-repo/raw/master/2020/04/17/2CrYUM.png" alt="postman"></p><p>-</p><p>修改<code>test-config-test.yml</code>，将里面的内容改成：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">test:</span></span><br><span class="line">  <span class="attr">hello:</span> <span class="string">test,</span> <span class="string">are</span> <span class="string">you</span> <span class="string">ok</span> <span class="string">??</span> <span class="string">bus</span> <span class="string">!!</span></span><br></pre></td></tr></table></figure><p>将其<code>push</code>到<code>GitHub</code>，在终端执行以下命令：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -X POST http://localhost:28088/actuator/bus-refresh/   </span><br></pre></td></tr></table></figure><p>再次请求两个客户端的<a href="http://localhost:28089/info">http://localhost:28089/info</a>接口，<strong>都能</strong>得到如下结果，说明成功了：</p><p><img src="https://gitee.com/cayzlh/img-repo/raw/master/2020/04/17/pfz34y.png" alt="postman"></p><p>-</p><blockquote><p><strong>只要开启 <code>Spring Cloud Bus</code> 后，不管是对 <code>config-server</code> 还是 <code>config-client</code> 执行<code>/actuator/bus-refresh</code>都是可以更新配置的。</strong></p></blockquote><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>当使用<code>SpringBoot-2.1.1.RELEASE</code>的时候，启动的时候会报错以下错误：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Failed to introspect Class \[org.springframework.cloud.stream.config.BindingServiceConfiguration] from ClassLoader \[sun.misc.Launcher$AppClassLoader@18b4aac2]</span><br></pre></td></tr></table></figure><p>这个留着以后研究。。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="http://www.ityouknow.com/springcloud/2017/05/26/springcloud-config-eureka-bus.html">配置中心和消息总线（配置中心终结版）</a></li><li><a href="https://windmt.com/2018/04/19/spring-cloud-9-config-eureka-bus/">配置中心（消息总线）【Finchley 版】</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
          <category> SpringCloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> SpringCloud </tag>
            
            <tag> 微服务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringCloud（配置中心服务化与高可用）</title>
      <link href="/blog/2018/12/31/2f34c065.html"/>
      <url>/blog/2018/12/31/2f34c065.html</url>
      
        <content type="html"><![CDATA[<p>使用配置中心的客户端都是直接调用配置中心的<code>server</code>端来获取配置文件信息。这样就存在了一个问题，客户端和服务端的耦合性太高，如果<code>server</code>端要做集群，客户端只能通过原始的方式来路由，<code>server</code>端改变<code>IP</code>地址的时候，客户端也需要修改配置，不符合<code>springcloud</code>服务治理的理念。<code>springcloud</code>提供了这样的解决方案，我们只需要将<code>server</code>端当做一个服务注册到<code>eureka</code>中，<code>client</code>端去<code>eureka</code>中去获取配置中心<code>server</code>端的服务既可。</p><p>在<a href="/archives/5e7c1be9.html">上一篇</a>中，我们主要完成了：</p><ul><li>构建了 <code>config-server</code>，连接到 <code>Git</code> 仓库</li><li>在 <code>Git</code> 上创建了一个 <code>config-repo</code> 目录，用来存储配置信息</li><li>构建了 <code>config-client</code>，来获取 <code>Git</code> 中的配置信息</li><li>在 <code>config-client</code> 中开启了 <code>Refresh</code>，动态刷新配置信息</li></ul><p>接下来，基于配置中心<code>Git</code>版本来进行改造。</p><h2 id="Server端改造"><a href="#Server端改造" class="headerlink" title="Server端改造"></a>Server端改造</h2><h3 id="POM"><a href="#POM" class="headerlink" title="POM"></a>POM</h3><p>在<code>pom.xml</code>文件中添加依赖：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>在<code>application.yml</code>中添加<code>erueka</code>配置：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://localhost:28081/eureka/</span></span><br></pre></td></tr></table></figure><h3 id="启动类"><a href="#启动类" class="headerlink" title="启动类"></a>启动类</h3><p>给启动类加上<code>@EnableDiscoveryClient</code>注解，激活对配置中心的支持：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="meta">@EnableConfigServer</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigServerGitApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(ConfigServerGitApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Server</code>端改造完成，依次启动<code>注册中心</code>、<code>config-server</code>，访问<a href="http://localhost:28081/">http://localhost:28081</a>，就会看到<code>config-server</code>已注册到注册中心。</p><p><img src="https://gitee.com/cayzlh/img-repo/raw/master/2020/04/17/ujqSTV.png" alt="eureka"></p><h2 id="客户端改造"><a href="#客户端改造" class="headerlink" title="客户端改造"></a>客户端改造</h2><h3 id="POM-1"><a href="#POM-1" class="headerlink" title="POM"></a>POM</h3><p>在<code>pom.xml</code>中添加依赖：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="bootstrap-yml"><a href="#bootstrap-yml" class="headerlink" title="bootstrap.yml"></a>bootstrap.yml</h3><p>修改<code>bootstrap.yml</code>配置文件：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">config:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">test-config</span></span><br><span class="line">      <span class="attr">profile:</span> <span class="string">dev</span></span><br><span class="line">      <span class="attr">label:</span> <span class="string">master</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">        <span class="attr">service-id:</span> <span class="string">config-server</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://localhost:28081/eureka/</span></span><br></pre></td></tr></table></figure><p>主要是去掉了<code>spring.cloud.config.uri</code>直接指向 Server 端地址的配置，增加了最后的三个配置：</p><ul><li><code>spring.cloud.config.discovery.enabled</code>：开启 Config 服务发现支持</li><li><code>spring.cloud.config.discovery.serviceId</code>：指定 Server 端的 name, 也就是 Server 端<code>spring.application.name</code>的值</li><li><code>eureka.client.service-url.defaultZone</code>：指向配置中心的地址</li></ul><p>这三个配置文件都需要放到<code>bootstrap.yml</code>的配置中。</p><h3 id="启动类-1"><a href="#启动类-1" class="headerlink" title="启动类"></a>启动类</h3><h3 id="启动类-2"><a href="#启动类-2" class="headerlink" title="启动类"></a>启动类</h3><p>给启动类加上<code>@EnableDiscoveryClient</code>注解，激活对配置中心的支持：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfitClientApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(ConfitClientApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Client</code>端也改造完成，启动<code>Client</code>端，访问<a href="http://localhost:28081/">http://localhost:28081</a>，可以看到<code>Client</code>也已经注册到注册中心:</p><p><img src="https://gitee.com/cayzlh/img-repo/raw/master/2020/04/17/BERfrl.png" alt="eureka"></p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>在<code>postman</code>请求<a href="http://localhost:28089/info">http://localhost:28089/info</a>，得到结果如下，说明改造成功：</p><p><img src="https://gitee.com/cayzlh/img-repo/raw/master/2020/04/17/cTaxB5.png" alt="postman"></p><h2 id="高可用"><a href="#高可用" class="headerlink" title="高可用"></a>高可用</h2><p>启动两个 <code>Server</code> 端，端口分别为 <code>28088</code> 和 <code>28090</code>，提供高可用的 <code>Server</code> 端支持。这样在其中一个<code>Server</code>挂掉的时候，还有另一个<code>Server</code>可以继续提供服务。</p><p>具体实施：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 打包</span></span><br><span class="line">./mvn clean package -Dmaven.test.skip=true</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动两个 Server</span></span><br><span class="line">java -jar target/config-server-git-0.0.1-SNAPSHOT.jar --server.port=28089</span><br><span class="line">java -jar target/config-server-git-0.0.1-SNAPSHOT.jar --server.port=28090</span><br></pre></td></tr></table></figure><p>分别使用<code>postman</code>去请求两个端口的服务端，都能正确返回配置信息，说明高可用集成成功。</p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
          <category> SpringCloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> SpringCloud </tag>
            
            <tag> 微服务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringCloud（Git版配置中心）</title>
      <link href="/blog/2018/12/30/5e7c1be9.html"/>
      <url>/blog/2018/12/30/5e7c1be9.html</url>
      
        <content type="html"><![CDATA[<h2 id="Spring-Cloud-Config"><a href="#Spring-Cloud-Config" class="headerlink" title="Spring Cloud Config"></a>Spring Cloud Config</h2><p>随着线上项目变的日益庞大，每个项目都散落着各种配置文件，如果采用分布式的开发模式，需要的配置文件随着服务增加而不断增多。某一个基础服务信息变更，都会引起一系列的更新和重启，运维苦不堪言也容易出错。配置中心便是解决此类问题的灵丹妙药。**<code>Spring Cloud Config</code>，因为它功能全面强大，可以无缝的和<code>spring</code>体系相结合。**</p><p><code>Spring Cloud Config</code> 是 <code>Spring Cloud</code> 团队创建的一个全新项目，用来为分布式系统中的基础设施和微服务应用提供集中化的外部配置支持，它分为服务端与客户端两个部分。其中服务端也称为分布式配置中心，它是一个独立的微服务应用，用来连接配置仓库并为客户端提供获取配置信息、加密 / 解密信息等访问接口；而客户端则是微服务架构中的各个微服务应用或基础设施，它们通过指定的配置中心来管理应用资源与业务相关的配置内容，并在启动的时候从配置中心获取和加载配置信息。<code>Spring Cloud Config</code> 实现了对服务端和客户端中环境变量和属性配置的抽象映射，所以它除了适用于 <code>Spring</code> 构建的应用程序之外，也可以在任何其他语言运行的应用程序中使用。由于 <code>Spring Cloud Config</code> 实现的配置中心默认采用 <code>Git</code> 来存储配置信息，所以使用 <code>Spring Cloud Config</code> 构建的配置服务器，天然就支持对微服务应用配置信息的版本管理，并且可以通过 <code>Git</code> 客户端工具来方便的管理和访问配置内容。当然它也提供了对其他存储方式的支持，比如：<code>SVN</code> 仓库、本地化文件系统。</p><p><strong>配置中心提供的功能：</strong></p><ul><li>提供服务端和客户端支持</li><li>集中管理各环境的配置文件</li><li>配置文件修改之后，可以快速的生效</li><li>可以进行版本管理</li><li>支持大的并发查询</li><li>支持各种语言</li></ul><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>在 <code>Github</code> 上面创建了一个文件夹 <code>config-repo</code> 用来存放配置文件，创建以下三个配置文件：</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 开发环境</span><br><span class="line">test-config-dev.yml</span><br><span class="line">&#x2F;&#x2F; 测试环境</span><br><span class="line">test-config-test.yml</span><br><span class="line">&#x2F;&#x2F; 生产环境</span><br><span class="line">test-config-prod.yml</span><br></pre></td></tr></table></figure><p>每个文件都写一个<code>test.hello</code>属性，属性值分别是<code>dev</code>、<code>test</code>、<code>prod</code>，如：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">test:</span></span><br><span class="line">  <span class="attr">hello:</span> <span class="string">test</span></span><br></pre></td></tr></table></figure><h2 id="Server端"><a href="#Server端" class="headerlink" title="Server端"></a>Server端</h2><p>创建一个基础的 <code>Spring Boot</code> 工程，命名为：<code>config-server-git</code>。</p><h3 id="POM"><a href="#POM" class="headerlink" title="POM"></a>POM</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">spring-cloud.version</span>&gt;</span>Finchley.RELEASE<span class="tag">&lt;/<span class="name">spring-cloud.version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-config-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring-cloud.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure><p>添加<code>spring-cloud-config-server</code>依赖。</p><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>在配置文件中配置服务的基本信息以及git的地址：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">config-server</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">config:</span></span><br><span class="line">      <span class="attr">server:</span></span><br><span class="line">        <span class="attr">git:</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">https://github.com/cayzlh/SpringCloudDemos</span> <span class="comment"># 配置git仓库的地址</span></span><br><span class="line">          <span class="attr">search-paths:</span> <span class="string">config-repo</span> <span class="comment"># git仓库地址下的相对地址，可以配置多个，用,分割。</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">28088</span></span><br></pre></td></tr></table></figure><p><code>Spring Cloud Config</code> 也提供本地存储配置的方式。我们只需要设置属性<code>spring.profiles.active=native</code>，<code>Config Server</code> 会默认从应用的<code>src/main/resource</code>目录下检索配置文件。也可以通过<code>spring.cloud.config.server.native.searchLocations=file:E:/properties/</code>属性来指定配置文件的位置。虽然 <code>Spring Cloud Config</code> 提供了这样的功能，但是为了支持更好的管理内容和版本控制的功能，还是推荐使用 <code>Git</code> 的方式。</p><blockquote><p>如果我们的 Git 仓库需要权限访问，那么可以通过配置下面的两个属性来实现；<br>spring.cloud.config.server.git.username：访问 Git 仓库的用户名<br>spring.cloud.config.server.git.password：访问 Git 仓库的用户密码</p></blockquote><h3 id="启动类"><a href="#启动类" class="headerlink" title="启动类"></a>启动类</h3><p>启动类添加<code>@EnableConfigServer</code>，激活对配置中心的支持：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableConfigServer</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigServerGitApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(ConfigServerGitApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Server</code>端的配置到此为止</p><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>测试 <code>Server</code> 端是否可以读取到 <code>github</code> 上面的配置信息，通过<code>postman</code>请求<a href="http://localhost:28088/test-config/test">http://localhost:28088/test-config/test</a>，返回如下信息：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;test-config&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;profiles&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;test&quot;</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">&quot;label&quot;</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">&quot;version&quot;</span>: <span class="string">&quot;cd3f7acc23d556b64499d08ea9a14d2ee23c4534&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;state&quot;</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">&quot;propertySources&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;https://github.com/cayzlh/\</span></span><br><span class="line"><span class="string">SpringCloudDemos/config-repo/test-config-test.yml&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;source&quot;</span>: &#123;</span><br><span class="line">                <span class="attr">&quot;test.hello&quot;</span>: <span class="string">&quot;test&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注：</strong>路径中的<code>test-config</code>是指<code>config-repo</code>中的文件名前缀。</p><p>修改<code>test-config-test.yml</code>中的内容，再次在<code>postman</code>请求，发现返回的内容是最新的了，说明<code>Server</code>端会自动读取最新提交的内容。</p><blockquote><p>仓库中的配置文件会被转换成 Web 接口，访问可以参照以下的规则：</p><ul><li>/{application}/{profile}[/{label}]</li><li>/{application}-{profile}.yml</li><li>/{label}/{application}-{profile}.yml</li><li>/{application}-{profile}.properties</li><li>/{label}/{application}-{profile}.properties</li></ul><p>上面的 <code>URL</code> 会映射<code>&#123;application&#125;-&#123;profile&#125;.yml</code>对应的配置文件，其中<code>&#123;label&#125;</code>对应 Git 上不同的分支，默认为 <code>master</code>。以 <code>config-client-dev.yml</code> 为例子，它的 <code>application</code> 是 <code>config-client</code>，<code>profile</code> 是 <code>dev</code>。</p></blockquote><h2 id="Client端"><a href="#Client端" class="headerlink" title="Client端"></a>Client端</h2><p>在微服务应用中获取上述的配置信息。再创建一个基础的 <code>Spring Boot</code> 应用，命名为 <code>config-client</code>。</p><h3 id="POM-1"><a href="#POM-1" class="headerlink" title="POM"></a>POM</h3><p>修改<code>pom</code>文件，引入如下配置：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">spring-cloud.version</span>&gt;</span>Finchley.RELEASE<span class="tag">&lt;/<span class="name">spring-cloud.version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-webflux<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring-cloud.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure><p><em><code>spring-boot-starter-webflux</code> 是为了方便 <code>Web</code> 测试。<code>Spring WebFlux</code> 是随 <code>Spring 5</code> 推出的响应式 <code>Web</code> 框架。</em></p><h3 id="配置文件-1"><a href="#配置文件-1" class="headerlink" title="配置文件"></a>配置文件</h3><p>需要两个配置文件，<code>application.yml</code>和<code>bootstrap.yml</code>。</p><p><code>application.yml</code>：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">config-client-git</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">28089</span></span><br></pre></td></tr></table></figure><p><code>bootstrap.yml</code>：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">config:</span></span><br><span class="line">      <span class="attr">uri:</span> <span class="string">http://localhost:28088</span> <span class="comment"># 配置中心的具体地址，即 config-server</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">test-config</span> <span class="comment"># 对应 &#123;application&#125; 部分</span></span><br><span class="line">      <span class="attr">profile:</span> <span class="string">test</span> <span class="comment"># 对应 &#123;profile&#125; 部分</span></span><br><span class="line">      <span class="attr">label:</span> <span class="string">master</span> <span class="comment"># 对应 &#123;label&#125; 部分，即 Git 的分支。如果配置中心使用的是本地存储，则该参数无用</span></span><br></pre></td></tr></table></figure><ul><li>spring.application.name：对应{application}部分</li><li>spring.cloud.config.profile：对应{profile}部分</li><li>spring.cloud.config.label：对应git的分支。如果配置中心使用的是本地存储，则该参数无用</li><li>spring.cloud.config.uri：配置中心的具体地址</li><li>spring.cloud.config.discovery.service-id：指定配置中心的service-id，便于扩展为高可用配置集群。</li></ul><blockquote><p>上面这些与 <code>Spring Cloud Config</code> 相关的属性必须配置在 <code>bootstrap.yml</code> 中，<code>config</code> 部分内容才能被正确加载。因为 <code>config</code> 的相关配置会先于 <code>application.yml</code>，而 <code>bootstrap.yml</code> 的加载也是先于 <code>application.yml</code>。</p></blockquote><h3 id="启动类-1"><a href="#启动类-1" class="headerlink" title="启动类"></a>启动类</h3><p>不需要修改：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfitClientApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(ConfitClientApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新建<code>HelloController</code>，使用<code>@value</code>注解来获取<code>Server</code>端参数的值</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;test.hello:error&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String profile;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/info&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Mono&lt;String&gt; <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Mono.justOrEmpty(profile);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h3><p>使用<code>postman</code>请求<a href="http://localhost:28089/info">http://localhost:28089/info</a>，返回如下结果，则说明<code>Client</code>端成功获取到了<code>Server</code>端的配置值。</p><p><img src="https://gitee.com/cayzlh/img-repo/raw/master/2020/04/17/h1eyl7.png" alt="postman"></p><p>至此，<code>SpringCloud</code>的<code>Git</code>版配置中心就完成了。</p><h2 id="Refresh"><a href="#Refresh" class="headerlink" title="Refresh"></a>Refresh</h2><p><code>Spring Cloud Config</code>分服务端和客户端，服务端负责将<code>git（svn）</code>中存储的配置文件发布成<code>REST</code>接口，客户端可以从服务端<code>REST</code>接口获取配置。但客户端并不能主动感知到配置的变化，从而主动去获取新的配置。客户端如何去主动获取新的配置信息呢，<code>springcloud</code>已经给我们提供了解决方案，每个客户端通过<code>POST</code>方法触发各自的<code>/refresh</code>。</p><p>仅修改客户端项目，就可以实现 <code>refresh</code> 的功能。</p><h3 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>增加了<code>spring-boot-starter-actuator</code>包，<code>spring-boot-starter-actuator</code>是一套监控的功能，可以监控程序在运行时状态，其中就包括<code>/actuator/refresh</code>的功能。</p><h3 id="开启更新机制"><a href="#开启更新机制" class="headerlink" title="开启更新机制"></a>开启更新机制</h3><p>需要给加载变量的类上面加载<code>@RefreshScope</code>，在客户端执行<code>/actuator/refresh</code>的时候就会更新此类下面的变量值。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RefreshScope</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;test.hello:error&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String profile;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/info&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Mono&lt;String&gt; <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Mono.justOrEmpty(profile);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="配置文件-2"><a href="#配置文件-2" class="headerlink" title="配置文件"></a>配置文件</h3><p><code>SpringBoot1.5</code>以后需要添加以下配置以将<code>/actuator/refresh</code>这个 <code>Endpoint</code> 暴露出来：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoints:</span></span><br><span class="line">    <span class="attr">web:</span></span><br><span class="line">      <span class="attr">exposure:</span></span><br><span class="line">        <span class="attr">include:</span> <span class="string">refresh</span></span><br></pre></td></tr></table></figure><h3 id="测试-2"><a href="#测试-2" class="headerlink" title="测试"></a>测试</h3><p>重启 <code>config-client</code>，我们以 <code>POST</code> 请求的方式来访问<a href="http://localhost:28089/actuator/refresh">http://localhost:28089/actuator/refresh</a>就会更新配置文件至最新版本。</p><ol><li>修改<code>test-config-test.yml</code>文件的内容</li><li>使用<code>postman</code>请求<a href="http://localhost:28089/actuator/refresh">http://localhost:28089/actuator/refresh</a>接口</li><li>再请求<a href="http://localhost:28089/info">http://localhost:28089/info</a>接口</li><li>发现配置内容已经更新到最新了</li></ol><p><img src="https://gitee.com/cayzlh/img-repo/raw/master/2020/04/17/qtrGxR.png" alt="postman"></p><p>至此，配置中心的配置刷新就算完成了，但是这样做有个弊端，就是每次更新了配置之后都要请求<code>refresh</code>接口，这就很麻烦。。</p><h3 id="Webhook"><a href="#Webhook" class="headerlink" title="Webhook"></a>Webhook</h3><p><code>Webhook</code> 是当某个事件发生时，通过发送 <code>HTTP POST</code> 请求的方式来通知信息接收方。<code>Webhook</code> 来监测你在 <code>Github.com</code> 上的各种事件，最常见的莫过于 <code>push</code> 事件。如果你设置了一个监测 <code>push</code> 事件的 <code>Webhook</code>，那么每当你的这个项目有了任何提交，这个 <code>Webhook</code> 都会被触发，这时 <code>Github</code> 就会发送一个 <code>HTTP POST</code> 请求到你配置好的地址。</p><p>如此一来，你就可以通过这种方式去自动完成一些重复性工作，比如，你可以用 <code>Webhook</code> 来自动触发一些持续集成（CI）工具的运作，比如 <code>Travis CI</code>；又或者是通过 <code>Webhook</code> 去部署你的线上服务器。下图就是 <code>Github</code> 上面的 <code>Webhook</code> 配置。</p><p><img src="https://gitee.com/cayzlh/img-repo/raw/master/2020/04/17/ATMvIp.jpg" alt="Webhook"></p><ul><li><code>Payload URL</code> ：触发后回调的 URL</li><li><code>Content type</code> ：数据格式，两种一般使用 json</li><li><code>Secret</code> ：用作给 POST 的 body 加密的字符串。采用 HMAC 算法</li><li><code>events</code> ：触发的事件列表。</li></ul><p>-</p><table><thead><tr><th>events 事件类型</th><th>描述</th></tr></thead><tbody><tr><td>push</td><td>仓库有 push 时触发。默认事件</td></tr><tr><td>create</td><td>当有分支或标签被创建时触发</td></tr><tr><td>delete</td><td>当有分支或标签被删除时触发</td></tr></tbody></table><p>-</p><p>这样我们就可以利用 <code>hook</code> 的机制去触发客户端的更新，但是当客户端越来越多的时候，<code>hook</code> 机制也不够优雅了，另外每次增加客户端都需要改动 <code>hook</code> 也是不现实的。其实，<code>Spring Cloud</code> 给了我们更好解决方案——<code>Spring Cloud Bus</code>。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="http://www.ityouknow.com/springcloud/2017/05/22/springcloud-config-git.html">配置中心git示例</a></li><li><a href="http://www.ityouknow.com/springcloud/2017/05/23/springcloud-config-svn-refresh.html">配置中心svn示例和refresh</a></li><li><a href="https://windmt.com/2018/04/19/spring-cloud-7-config-sample/">Spring Cloud（七）：配置中心（Git 版与动态刷新）【Finchley 版】</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
          <category> SpringCloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> SpringCloud </tag>
            
            <tag> 微服务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringCloud（Hystrix监控数据聚合Turbine）</title>
      <link href="/blog/2018/12/29/9090e9d4.html"/>
      <url>/blog/2018/12/29/9090e9d4.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>在复杂的分布式系统中，相同服务的节点经常需要部署上百甚至上千个，很多时候，运维人员希望能够把相同服务的节点状态以一个整体集群的形式展现出来，这样可以更好的把握整个系统的状态。 为此，Netflix提供了一个开源项目（Turbine）来提供把多个hystrix.stream的内容聚合为一个数据源供Dashboard展示。</p></blockquote><h2 id="创建Turbine"><a href="#创建Turbine" class="headerlink" title="创建Turbine"></a>创建Turbine</h2><p>创建一个名为<code>Turbine</code>的<code>Spring Boot</code>工程</p><h3 id="POM"><a href="#POM" class="headerlink" title="POM"></a>POM</h3><p>在<code>pom.xml</code>中添加如下依赖：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">spring-cloud.version</span>&gt;</span>Finchley.RELEASE<span class="tag">&lt;/<span class="name">spring-cloud.version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-turbine<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring-cloud.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="启动类"><a href="#启动类" class="headerlink" title="启动类"></a>启动类</h3><p>在启动类上使用<code>@EnableTurbine</code>注解开启 <code>Turbine</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableTurbine</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TurbineApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(TurbineApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>在 <code>application.yml</code> 加入 <code>Eureka</code> 和 <code>Turbine</code> 的相关配置</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">hystrix-dashboard-turbine</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">28087</span></span><br><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">28088</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://localhost:28081/eureka/</span></span><br><span class="line"><span class="attr">turbine:</span></span><br><span class="line">  <span class="attr">app-config:</span> <span class="string">eureka-consumer</span></span><br><span class="line">  <span class="attr">cluster-name-expression:</span> <span class="string">new</span> <span class="string">String(&quot;default&quot;)</span></span><br><span class="line">  <span class="attr">combine-host-port:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p><strong>参数：</strong></p><ul><li><code>turbine.app-config</code>参数指定了需要收集监控信息的服务名；</li><li><code>turbine.cluster-name-expression</code> 参数指定了集群名称为 <code>default</code>，当我们服务数量非常多的时候，可以启动多个 Turbine 服务来构建不同的聚合集群，而该参数可以用来区分这些不同的聚合集群，同时该参数值可以在 Hystrix 仪表盘中用来定位不同的聚合集群，只需要在 Hystrix Stream 的 URL 中通过 cluster 参数来指定；</li><li><code>turbine.combine-host-port</code>参数设置为<code>true</code>，可以让同一主机上的服务通过主机名与端口号的组合来进行区分，默认情况下会以 host 来区分不同的服务，这会使得在本地调试的时候，本机上的不同服务聚合成一个服务来统计。</li></ul><p>其中：<code>new String(&quot;default&quot;)</code>这个一定要用 String 来包一下，否则启动的时候会抛出异常：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">org.springframework.expression.spel.SpelEvaluationException: EL1008E: Property or field &#x27;default&#x27; cannot be found on object of type &#x27;com.netflix.appinfo.InstanceInfo&#x27; - maybe not public or not valid?</span><br></pre></td></tr></table></figure><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>启动服务，访问<a href="http://localhost:28086/hystrix">http://localhost:28086/hystrix</a>，开启对<code>http://localhost:28087/turbine.stream</code>的监控，能够看到针对服务<code>eureka-consumer</code>的聚合监控数据。</p><p><img src="https://gitee.com/cayzlh/img-repo/raw/master/2020/04/17/RmKaJd.png" alt="turbine"></p><p>此时的服务架构如下图：</p><p><img src="https://gitee.com/cayzlh/img-repo/raw/master/2020/04/17/vFi62E.jpg" alt="turbine"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://windmt.com/2018/04/17/spring-cloud-6-turbine/">Spring Cloud（六）：Hystrix 监控数据聚合 Turbine【Finchley 版】</a></li><li><a href="http://www.ityouknow.com/springcloud/2017/05/18/hystrix-dashboard-turbine.html">springcloud(五)：熔断监控Hystrix Dashboard和Turbine</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
          <category> SpringCloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> SpringCloud </tag>
            
            <tag> 微服务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringCloud（Hystrix熔断监控面板）</title>
      <link href="/blog/2018/12/23/c10f5abe.html"/>
      <url>/blog/2018/12/23/c10f5abe.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>文章内容部分摘抄自<a href="http://www.ityouknow.com/springcloud/2017/05/18/hystrix-dashboard-turbine.html">springcloud(五)：熔断监控Hystrix Dashboard和Turbine</a></p></blockquote><p>断路器是根据一段时间内的请求来判断并操作断路器的打开和关闭状态的。</p><p><code>Hystrix-dashboard</code>是一款针对<code>Hystrix</code>进行实时监控的工具，通过<code>Hystrix Dashboard</code>我们可以在直观地看到各<code>Hystrix Command</code>的请求响应时间, 请求成功率等数据。但是只使用<code>Hystrix Dashboard</code>的话, 你只能看到单个应用内的服务信息, 这明显不够. 我们需要一个工具能让我们汇总系统内多个服务的数据并显示到<code>Hystrix Dashboard</code>上, 这个工具就是<code>Turbine</code>.</p><h2 id="Hystrix-Dashboard"><a href="#Hystrix-Dashboard" class="headerlink" title="Hystrix Dashboard"></a>Hystrix Dashboard</h2><p>创建一个<code>SpringBoot</code>工程，起名为<code>hystrix-dashboard</code>。</p><h3 id="pom配置"><a href="#pom配置" class="headerlink" title="pom配置"></a>pom配置</h3><p>在<code>pom.xml</code>中引入相关依赖：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">spring-cloud.version</span>&gt;</span>Finchley.RELEASE<span class="tag">&lt;/<span class="name">spring-cloud.version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-hystrix<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-hystrix-dashboard<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring-cloud.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="启动类"><a href="#启动类" class="headerlink" title="启动类"></a>启动类</h3><p>启动类加上<code>@EnableHystrixDashboard</code>注解</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableHystrixDashboard</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HystrixDashboardApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(HystrixDashboardApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>修改配置文件，添加以下内容：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">hystrix-dashboard</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">28086</span></span><br></pre></td></tr></table></figure><h3 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h3><p>启动服务，访问<a href="http://localhost:28086/hystrix">http://localhost:28086/hystrix</a>，看到如下界面：</p><p><img src="https://gitee.com/cayzlh/img-repo/raw/master/2020/04/17/P0aNxz.png" alt="hystrix-dashboard"></p><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><blockquote><p>这段来源：<a href="https://windmt.com/2018/04/16/spring-cloud-5-hystrix-dashboard/">https://windmt.com/2018/04/16/spring-cloud-5-hystrix-dashboard/</a></p></blockquote><p>通过 <code>Hystrix Dashboard</code> 主页面的文字介绍，我们可以知道，<code>Hystrix Dashboard</code> 共支持三种不同的监控方式：</p><ul><li>默认的集群监控：通过 URL：<a href="http://turbine-hostname:port/turbine.stream">http://turbine-hostname:port/turbine.stream</a> 开启，实现对默认集群的监控。</li><li>指定的集群监控：通过 URL：<a href="http://turbine-hostname:port/turbine.stream?cluster=[clusterName]">http://turbine-hostname:port/turbine.stream?cluster=[clusterName]</a> 开启，实现对 <code>clusterName</code> 集群的监控。</li><li>单体应用的监控： <del>通过 URL：<a href="http://hystrix-app:port/hystrix.stream">http://hystrix-app:port/hystrix.stream</a> 开启</del> ，实现对具体某个服务实例的监控。<strong>（现在这里的 URL 应该为 <a href="http://hystrix-app:port/actuator/hystrix.stream，Actuator">http://hystrix-app:port/actuator/hystrix.stream，Actuator</a> 2.x 以后  endpoints 全部在/actuator下，可以通过management.endpoints.web.base-path修改）</strong></li></ul><p>前两者都对集群的监控，需要整合 <code>Turbine</code> 才能实现。这一部分我们先实现对单体应用的监控，这里的单体应用就用我们之前使用 <code>Feign</code> 和 <code>Hystrix</code> 实现的服务消费者——<code>eureka-consumer</code>。</p><p>页面上的另外两个参数：</p><ul><li><code>Delay</code>：控制服务器上轮询监控信息的延迟时间，默认为 <code>2000</code> 毫秒，可以通过配置该属性来降低客户端的网络和 <code>CPU</code> 消耗。</li><li><code>Title</code>：该参数可以展示合适的标题。</li></ul><h2 id="添加endpoint"><a href="#添加endpoint" class="headerlink" title="添加endpoint"></a>添加<code>endpoint</code></h2><p>既然 <code>Hystrix Dashboard</code> 监控单实例节点需要通过访问实例的<code>/actuator/hystrix.stream</code>接口来实现，自然我们需要为服务实例添加这个 <code>endpoint</code>。</p><p>使用前面的<code>eureka-consumer</code>工程；</p><h3 id="修改pom配置"><a href="#修改pom配置" class="headerlink" title="修改pom配置"></a>修改pom配置</h3><p>在<code>dependencies</code>节点下添加以下依赖：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-hystrix<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="启动类-1"><a href="#启动类-1" class="headerlink" title="启动类"></a>启动类</h3><p>修改启动类，添加<code>@EnableCircuitBreaker</code>或者<code>@EnableHystrix</code>注解，开启断路器功能；</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableCircuitBreaker</span></span><br><span class="line"><span class="meta">@EnableFeignClients</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EurekaConsumerApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(EurekaConsumerApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="配置文件-1"><a href="#配置文件-1" class="headerlink" title="配置文件"></a>配置文件</h3><p>在配置文件中添加：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoints:</span></span><br><span class="line">    <span class="attr">web:</span></span><br><span class="line">      <span class="attr">exposure:</span></span><br><span class="line">        <span class="attr">include:</span> <span class="string">hystrix.stream</span></span><br></pre></td></tr></table></figure><p><code>management.endpoints.web.exposure.include</code>这个是用来暴露 <code>endpoints</code> 的。由于 <code>endpoints</code> 中会包含很多敏感信息，除了 <code>health</code> 和 <code>info</code> 两个支持 <code>web</code> 访问外，其他的默认不支持 <code>web</code> 访问。</p><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><ol><li><p>分别再启动注册中心、服务生产者、服务消费者。</p></li><li><p>在<code>Hystrix Dashboard</code>中输入<code>http://localhost:28085/actuator/hystrix.stream</code>，然后点击下方的<code>Monitor Stream</code>按钮，可以看到<code>Loding</code>界面。</p></li><li><p>这个时候访问<a href="http://localhost:28085/hello/zhangsan">http://localhost:28085/hello/zhangsan</a>，访问成功后再回来<code>DashBoard</code>页面，可以看到：</p><p><img src="https://gitee.com/cayzlh/img-repo/raw/master/2020/04/17/gRbwox.png" alt="hystrix-dashboard"></p></li></ol><h3 id="图像解读"><a href="#图像解读" class="headerlink" title="图像解读"></a>图像解读</h3><p>以上图来说明其中各元素的具体含义：</p><ul><li><p>实心圆：它有颜色和大小之分，分别代表实例的监控程度和流量大小。如上图所示，它的健康度从绿色、黄色、橙色、红色递减。通过该实心圆的展示，我们就可以在大量的实例中快速的发现故障实例和高压力实例。</p></li><li><p>曲线：用来记录 2 分钟内流量的相对变化，我们可以通过它来观察到流量的上升和下降趋势。</p></li><li><p>其他数量指标</p><p><img src="https://gitee.com/cayzlh/img-repo/raw/master/2020/04/17/tPK2p4.jpg" alt="图片来源与网络"></p></li></ul><h2 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h2><p>到此，单个服务的熔断监控已经完成。</p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
          <category> SpringCloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> SpringCloud </tag>
            
            <tag> 微服务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringCloud（熔断器Hystrix）</title>
      <link href="/blog/2018/12/22/5a724b6.html"/>
      <url>/blog/2018/12/22/5a724b6.html</url>
      
        <content type="html"><![CDATA[<h2 id="使用Feign-Hystrix做熔断器"><a href="#使用Feign-Hystrix做熔断器" class="headerlink" title="使用Feign Hystrix做熔断器"></a>使用<code>Feign Hystrix</code>做熔断器</h2><p>熔断作用在服务调用的一端，要实现熔断器， 只需在服务消费者（<code>eureka-consumer</code>）上做改动就行。</p><p><em>Feign中已经依赖了Hystrix所以在maven配置上不用做任何改动。</em></p><h3 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">eureka-consumer</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://localhost:28081/eureka/</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">28085</span></span><br><span class="line"><span class="attr">feign:</span></span><br><span class="line">  <span class="attr">hystrix:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><h3 id="创建一个回调方法类"><a href="#创建一个回调方法类" class="headerlink" title="创建一个回调方法类"></a>创建一个回调方法类</h3><p>创建 <code>HelloRemoteHystrix</code> 类实现 <code>HelloRemote</code> 中实现回调的方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloRemoteHystrix</span> <span class="keyword">implements</span> <span class="title">HelloRemote</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">(<span class="meta">@RequestParam(value = &quot;name&quot;)</span> String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello，&quot;</span>+name+<span class="string">&quot; ，当前服务崩了。&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="设置fallback属性"><a href="#设置fallback属性" class="headerlink" title="设置fallback属性"></a>设置fallback属性</h3><p>在<code>HelloRemote</code>类添加指定 fallback 类，在服务熔断的时候返回 fallback 类中的内容。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FeignClient(name = &quot;eureka-producer&quot;, fallback = HelloRemoteHystrix.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HelloRemote</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/hello/&quot;)</span></span><br><span class="line">    <span class="function">String <span class="title">hello</span><span class="params">(<span class="meta">@RequestParam(value = &quot;name&quot;)</span> String name)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码部分，到此为止就ok了。</p><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>启动三个项目（注册中心、服务提供者、服务消费者）</p><p>访问<a href="http://localhost:28085/hello/zhangsan">http://localhost:28085/hello/zhangsan</a>返回结果：</p><p><img src="https://gitee.com/cayzlh/img-repo/raw/master/2020/04/17/egbFqA.png" alt="服务正常返回结果"></p><p>可以看到当前是正常返回结果的，这个时候，把服务提供者的服务<code>kill</code>掉，再次访问<a href="http://localhost:28085/hello/zhangsan">http://localhost:28085/hello/zhangsan</a>，返回结果：</p><p><img src="https://gitee.com/cayzlh/img-repo/raw/master/2020/04/17/C8IGdR.png" alt="服务熔断后的结果"></p><p>说明熔断成功！</p><h2 id="雪崩效应"><a href="#雪崩效应" class="headerlink" title="雪崩效应"></a>雪崩效应</h2><blockquote><p>这段摘自<a href="http://www.ityouknow.com/springcloud/2017/05/16/springcloud-hystrix.html">纯洁的微笑博客</a></p></blockquote><p>在微服务架构中通常会有多个服务层调用，基础服务的故障可能会导致级联故障，进而造成整个系统不可用的情况，这种现象被称为服务雪崩效应。服务雪崩效应是一种因“服务提供者”的不可用导致“服务消费者”的不可用,并将不可用逐渐放大的过程。</p><p>如果下图所示：A作为服务提供者，B为A的服务消费者，C和D是B的服务消费者。A不可用引起了B的不可用，并将不可用像滚雪球一样放大到C和D时，雪崩效应就形成了。</p><p><img src="https://gitee.com/cayzlh/img-repo/raw/master/2020/04/17/5fnF7p.png" alt="雪崩效应"></p><h2 id="熔断器"><a href="#熔断器" class="headerlink" title="熔断器"></a>熔断器</h2><blockquote><p>这段摘自<a href="http://www.ityouknow.com/springcloud/2017/05/16/springcloud-hystrix.html">纯洁的微笑博客</a></p></blockquote><p>熔断器的原理很简单，如同电力过载保护器。它可以实现快速失败，如果它在一段时间内侦测到许多类似的错误，会强迫其以后的多个调用快速失败，不再访问远程服务器，从而防止应用程序不断地尝试执行可能会失败的操作，使得应用程序继续执行而不用等待修正错误，或者浪费CPU时间去等到长时间的超时产生。熔断器也可以使应用程序能够诊断错误是否已经修正，如果已经修正，应用程序会再次尝试调用操作。</p><p>熔断器模式就像是那些容易导致错误的操作的一种代理。这种代理能够记录最近调用发生错误的次数，然后决定使用允许操作继续，或者立即返回错误。 熔断器开关相互转换的逻辑如下图：</p><p><img src="https://gitee.com/cayzlh/img-repo/raw/master/2020/04/17/2S9QD5.png" alt="熔断器"></p><p>熔断器就是保护服务高可用的最后一道防线。</p><h3 id="Hystrix特性"><a href="#Hystrix特性" class="headerlink" title="Hystrix特性"></a>Hystrix特性</h3><h4 id="断路器机制"><a href="#断路器机制" class="headerlink" title="断路器机制"></a>断路器机制</h4><p>断路器很好理解, 当<code>Hystrix Command</code>请求后端服务失败数量超过一定比例(默认<code>50%</code>), 断路器会切换到开路状态(<code>Open</code>). 这时所有请求会直接失败而不会发送到后端服务. 断路器保持在开路状态一段时间后(默认5秒), 自动切换到半开路状态(<code>HALF-OPEN</code>). 这时会判断下一次请求的返回情况, 如果请求成功, 断路器切回闭路状态(<code>CLOSED</code>), 否则重新切换到开路状态(<code>OPEN</code>). <code>Hystrix</code>的断路器就像我们家庭电路中的保险丝, 一旦后端服务不可用, 断路器会直接切断请求链, 避免发送大量无效请求影响系统吞吐量, 并且断路器有自我检测并恢复的能力.</p><h4 id="Fallback"><a href="#Fallback" class="headerlink" title="Fallback"></a>Fallback</h4><p><code>Fallback</code>相当于是降级操作. 对于查询操作, 我们可以实现一个<code>fallback</code>方法, 当请求后端服务出现异常的时候, 可以使用<code>fallback</code>方法返回的值. <code>fallback</code>方法的返回值一般是设置的默认值或者来自缓存.</p><h4 id="资源隔离"><a href="#资源隔离" class="headerlink" title="资源隔离"></a>资源隔离</h4><p>在<code>Hystrix</code>中, 主要通过线程池来实现资源隔离. 通常在使用的时候我们会根据调用的远程服务划分出多个线程池. 例如调用产品服务的<code>Command</code>放入<code>A</code>线程池, 调用账户服务的<code>Command</code>放入B线程池. 这样做的主要优点是运行环境被隔离开了. 这样就算调用服务的代码存在<code>bug</code>或者由于其他原因导致自己所在线程池被耗尽时, 不会对系统的其他服务造成影响. 但是带来的代价就是维护多个线程池会对系统带来额外的性能开销. 如果是对性能有严格要求而且确信自己调用服务的客户端代码不会出问题的话, 可以使用<code>Hystrix</code>的信号模式(<code>Semaphores</code>)来隔离资源.</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过使用 <code>Hystrix</code>，我们能方便的防止雪崩效应，同时使系统具有自动降级和自动恢复服务的效果。</p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
          <category> SpringCloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> SpringCloud </tag>
            
            <tag> 微服务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringCloud（服务提供与发现Eureka）</title>
      <link href="/blog/2018/12/20/b6f15c0c.html"/>
      <url>/blog/2018/12/20/b6f15c0c.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>提供三个角色：服务注册中心、服务提供者、服务消费者。用来模拟<code>Eureka</code>服务提供者与消费者关系。</p></blockquote><h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><ol><li>启动注册中心</li><li>服务提供者生产服务并注册到服务中心中</li><li>消费者从服务中心中获取服务并执行</li></ol><p><img src="https://gitee.com/cayzlh/img-repo/raw/master/2020/04/17/o5a0rW.jpg" alt="服务提供者和消费者流程"></p><center>（图片来源于<a href="https://google.com" target="_blank">网络</a>）</center><h2 id="服务注册中心"><a href="#服务注册中心" class="headerlink" title="服务注册中心"></a>服务注册中心</h2><p>参考另一片笔记《<a href="/archives/b21e91d6.html">SpringCloud（注册中心Eureka）</a>》</p><h2 id="服务提供者"><a href="#服务提供者" class="headerlink" title="服务提供者"></a>服务提供者</h2><p><strong>提供一个<code>hello()</code>方法打印一个字符串。</strong></p><h3 id="新建一个名为spring-cloud-producer的SpringBoot工程"><a href="#新建一个名为spring-cloud-producer的SpringBoot工程" class="headerlink" title="新建一个名为spring-cloud-producer的SpringBoot工程"></a>新建一个名为<code>spring-cloud-producer</code>的<code>SpringBoot</code>工程</h3><h3 id="POM文件部分配置"><a href="#POM文件部分配置" class="headerlink" title="POM文件部分配置"></a>POM文件部分配置</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">spring-cloud.version</span>&gt;</span>Finchley.RELEASE<span class="tag">&lt;/<span class="name">spring-cloud.version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring-cloud.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="application-yml文件配置"><a href="#application-yml文件配置" class="headerlink" title="application.yml文件配置"></a>application.yml文件配置</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">eureka-producer</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://localhost:28081/eureka/</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">28084</span></span><br></pre></td></tr></table></figure><p>通过<code>spring.application.name</code>属性，我们可以指定微服务的名称后续在调用的时候只需要使用该名称就可以进行服务的访问。<code>eureka.client.serviceUrl.defaultZone</code>属性对应服务注册中心的配置内容，指定服务注册中心的位置。为了在本机上测试区分服务提供方和服务注册中心，使用<code>server.port</code>属性设置不同的端口。</p><h3 id="启动类"><a href="#启动类" class="headerlink" title="启动类"></a>启动类</h3><p>保持默认生成的即可， Finchley.RC1 这个版本的 Spring Cloud 已经无需添加<code>@EnableDiscoveryClient</code>注解了。如果引入了相关的jar包，需要禁用服务注册与发现，只需设置<code>eureka.client.enabled=false</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringCloudProducerApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(SpringCloudProducerApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="定义一个简单Controller接口，用来提供hello服务"><a href="#定义一个简单Controller接口，用来提供hello服务" class="headerlink" title="定义一个简单Controller接口，用来提供hello服务"></a>定义一个简单Controller接口，用来提供hello服务</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/hello&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">(<span class="meta">@RequestParam</span> String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello, &quot;</span> + name + <span class="string">&quot;, 现在时间：&quot;</span> + System.currentTimeMillis();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，服务提供者就开发完成了。分别启动服务注册中心和服务提供者，可以在注册<a href="http://localhost:28081/">http://localhost:28081</a>中心看到<code>EUERKA-PRODUCER</code>服务。</p><p><img src="https://gitee.com/cayzlh/img-repo/raw/master/2020/04/17/sV2uml.png" alt="EUERKA-PRODUCER"></p><p>访问<a href="http://localhost:28084/hello/?name=zhangsan">http://localhost:28084/hello/?name=zhangsan</a></p><p>可以看到有返回结果，说明服务提供者已经配置完成。</p><p><img src="https://gitee.com/cayzlh/img-repo/raw/master/2020/04/17/E2lO45.png" alt="Hello Zhangsan"></p><h2 id="服务消费者"><a href="#服务消费者" class="headerlink" title="服务消费者"></a>服务消费者</h2><p>创建服务消费者根据使用 API 的不同，大致分为三种方式（<code>LoadBalancerClient</code>、<code>Spring Cloud Ribbon</code>和<code>Feign</code> 调用实现）。在实际使用中用的应该都是 <code>Feign</code>，这里只记录<code>Feign</code>。</p><h3 id="创建一个名为eureka-consumer的SpringBoot工程"><a href="#创建一个名为eureka-consumer的SpringBoot工程" class="headerlink" title="创建一个名为eureka-consumer的SpringBoot工程"></a>创建一个名为<code>eureka-consumer</code>的<code>SpringBoot</code>工程</h3><h3 id="POM包配置"><a href="#POM包配置" class="headerlink" title="POM包配置"></a>POM包配置</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">spring-cloud.version</span>&gt;</span>Finchley.RELEASE<span class="tag">&lt;/<span class="name">spring-cloud.version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring-cloud.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">eureka-consumer</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://localhost:28081/eureka/</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">28085</span></span><br></pre></td></tr></table></figure><h3 id="启动类-1"><a href="#启动类-1" class="headerlink" title="启动类"></a>启动类</h3><p>在启动类上加上<code>@EnableFeignClients</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableFeignClients</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EurekaConsumerApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(EurekaConsumerApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Feign-调用实现"><a href="#Feign-调用实现" class="headerlink" title="Feign 调用实现"></a>Feign 调用实现</h3><p>创建一个 Feign 的客户端接口定义。使用<code>@FeignClient</code>注解来指定这个接口所要调用的服务名称，接口中定义的各个函数使用 <code>Spring MVC</code> 的注解就可以来绑定服务提供方的 <code>REST</code> 接口，比如下面就是绑定 <code>eureka-producer</code> 服务的<code>/hello/</code>接口的例子：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FeignClient(name = &quot;eureka-producer&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HelloRemote</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/hello/&quot;)</span></span><br><span class="line">    <span class="function">String <span class="title">hello</span><span class="params">(<span class="meta">@RequestParam(value = &quot;name&quot;)</span> String name)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>此类中的方法和远程服务中 <code>Contoller</code> 中的方法名和参数需保持一致。</strong></p><h3 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a>Controller</h3><p>将<code>HelloRemote</code>注入到<code>Controller</code>中，像普通方法一样调用。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/hello&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    HelloRemote helloRemote;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/&#123;name&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">index</span><span class="params">(<span class="meta">@PathVariable(&quot;name&quot;)</span> String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> helloRemote.hello(name + <span class="string">&quot;!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 Spring Cloud Feign 来实现服务调用的方式非常简单，通过<code>@FeignClient</code>定义的接口来统一的声明我们需要依赖的微服务接口。而在具体使用的时候就跟调用本地方法一点的进行调用即可。由于 Feign 是基于 Ribbon 实现的，所以它自带了客户端负载均衡功能，也可以通过 Ribbon 的 IRule 进行策略扩展。另外，Feign 还整合的 Hystrix 来实现服务的容错保护。</p><blockquote><p>在 Finchley.RC1 版本中，Feign 的 Hystrix 默认是关闭的。</p></blockquote><p>启动服务，在注册<a href="http://localhost:28081/">http://localhost:28081</a>中心看到<code>eureka-consumer</code>服务。</p><p><img src="https://gitee.com/cayzlh/img-repo/raw/master/2020/04/17/W5fZJv.png" alt="eureka-consumer"></p><p>访问<a href="http://localhost:28085/hello/zhangsan">http://localhost:28085/hello/zhangsan</a>，得到如下结果，说明消费者成功消费了提供者的服务。</p><p><img src="https://gitee.com/cayzlh/img-repo/raw/master/2020/04/17/mM0iRg.png" alt="eureka-consumer"></p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="要想使用-Feign，至少需要以下三个依赖"><a href="#要想使用-Feign，至少需要以下三个依赖" class="headerlink" title="要想使用 Feign，至少需要以下三个依赖"></a>要想使用 Feign，至少需要以下三个依赖</h3><ul><li>spring-boot-starter-web</li><li>spring-cloud-starter-openfeign</li><li>spring-cloud-starter-netflix-eureka-cli</li></ul><h3 id="HelloRemote类中的方法参数要加上-RequestParam注解"><a href="#HelloRemote类中的方法参数要加上-RequestParam注解" class="headerlink" title="HelloRemote类中的方法参数要加上@RequestParam注解"></a>HelloRemote类中的方法参数要加上<code>@RequestParam</code>注解</h3><p>Get请求的类型， 要加上<code>@RequestParam</code>注解，否则会报错。。</p><blockquote><p>当参数没有被<code>@RequestParam</code>注解修饰时，会自动被当做 request body 来处理。只要有 body，就会被 Feign 认为是 POST 请求，所以整个服务是被当作带有 request parameter 和 body 的 POST 请求发送出去的。</p></blockquote><h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><p>将producer工程打包成Jar包，然后启动两个线程，分别注册到服务注册中心。</p><p>当通过消费者调用的时候，会交替消费两个服务，以此来实现负载均衡。</p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
          <category> SpringCloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> SpringCloud </tag>
            
            <tag> 微服务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringCloud（注册中心Eureka）</title>
      <link href="/blog/2018/12/16/b21e91d6.html"/>
      <url>/blog/2018/12/16/b21e91d6.html</url>
      
        <content type="html"><![CDATA[<blockquote><p><code>Eureka</code>是<code>Netflix</code>开源的一款提供服务注册和发现的产品，它提供了完整的<code>Service Registry</code>和<code>Service Discovery</code>实现。也是<code>springcloud</code>体系中最重要最核心的组件之一。</p></blockquote><h3 id="服务中心"><a href="#服务中心" class="headerlink" title="服务中心"></a>服务中心</h3><p>服务中心又称注册中心，管理各种服务功能包括服务的注册、发现、熔断、负载、降级等，比如<code>dubbo admin</code>后台的各种功能。</p><h3 id="Eureka"><a href="#Eureka" class="headerlink" title="Eureka"></a>Eureka</h3><p>Eureka 是一个基于 <code>REST</code> 的服务，主要在 <code>AWS</code> 云中使用, 定位服务来进行中间层服务器的负载均衡和故障转移。</p><p><code>Spring Cloud</code> 封装了 <code>Netflix</code> 公司开发的 <code>Eureka</code> 模块来实现服务注册和发现。<code>Eureka</code> 采用了 <code>C-S</code> 的设计架构。<code>Eureka Server</code> 作为服务注册功能的服务器，它是服务注册中心。而系统中的其他微服务，使用 <code>Eureka</code> 的客户端连接到 <code>Eureka Server</code>，并维持心跳连接。这样系统的维护人员就可以通过 Eureka Server 来监控系统中各个微服务是否正常运行。<code>Spring Cloud</code> 的一些其他模块（比如<code>Zuul</code>）就可以通过 <code>Eureka Server</code> 来发现系统中的其他微服务，并执行相关的逻辑。</p><p>Eureka由两个组件组成：Eureka服务器和Eureka客户端。Eureka服务器用作服务注册服务器。Eureka客户端是一个java客户端，用来简化与服务器的交互、作为轮询负载均衡器，并提供服务的故障切换支持。Netflix在其生产环境中使用的是另外的客户端，它提供基于流量、资源利用率以及出错状态的加权负载均衡。</p><p><strong>Eureka的基本架构，由3个角色组成：</strong></p><p>1、Eureka Server</p><ul><li>提供服务注册和发现</li></ul><p>2、Service Provider</p><ul><li>服务提供方</li><li>将自身服务注册到Eureka，从而使服务消费方能够找到</li></ul><p>3、Service Consumer</p><ul><li>服务消费方</li><li>从Eureka获取注册服务列表，从而能够消费服务</li></ul><h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><h4 id="Eureka-Server"><a href="#Eureka-Server" class="headerlink" title="Eureka Server"></a>Eureka Server</h4><p><code>spring cloud</code>已经帮我实现了服务注册中心，我们只需要很简单的几个步骤就可以完成。</p><ol><li><p>新建一个<code>SpringBoot</code>工程，取名为<code>eureka-server</code>，<code>springboot</code>使用的版本是<code>2.1.1.RELEASE</code></p></li><li><p>在<code>pom</code>中添加依赖：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">spring-cloud.version</span>&gt;</span>Finchley.RELEASE<span class="tag">&lt;/<span class="name">spring-cloud.version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring-cloud.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>这里<code>spring-cloud</code>的版本用的是<code>Finchley.RELEASE</code>，spring-boot的版本是<code>2.1.1.RELEASE</code>。因此依赖使用的是<code>spring-cloud-starter-netflix-eureka-server</code>.</strong></p></li><li><p>在启动类中加上<code>@EnableEurekaServer</code>注解</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableEurekaServer</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EurekaServerApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(EurekaServerApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>配置文件：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">28081</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">eureka-server</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">fetch-registry:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://localhost:$&#123;server.port&#125;/eureka/</span></span><br></pre></td></tr></table></figure><ul><li><code>eureka.client.register-with-eureka</code> ：表示是否将自己注册到Eureka Server，默认为true。</li><li><code>eureka.client.fetch-registry</code> ：表示是否从Eureka Server获取注册信息，默认为true。</li><li><code>eureka.client.serviceUrl.defaultZone</code> ：设置与Eureka Server交互的地址，查询服务和注册服务都需要依赖这个地址。默认是<a href="http://localhost:8761/eureka">http://localhost:8761/eureka</a> ；多个地址可使用 , 分隔。</li></ul></li><li><p>启动工程后，访问：<a href="http://localhost:28081/">http://localhost:28081</a>，可以看到如下页面，其中还没有发现任何服务。</p><p><img src="https://gitee.com/cayzlh/img-repo/raw/master/2020/04/17/MMWE7h.png" alt="http://localhost:28081"></p></li></ol><h3 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h3><p>注册中心这么关键的服务，如果是单点话，遇到故障就是毁灭性的。在一个分布式系统中，服务注册中心是最重要的基础部分，理应随时处于可以提供服务的状态。为了维持其可用性，使用集群是很好的解决方案。<code>Eureka</code>通过互相注册的方式来实现高可用的部署，所以我们只需要将<code>Eureke Server</code>配置其他可用的<code>serviceUrl</code>就能实现高可用部署。</p><h4 id="三节点注册中心"><a href="#三节点注册中心" class="headerlink" title="三节点注册中心"></a>三节点注册中心</h4><p>尝试一下三节点的注册中心的搭建。</p><ol><li><p>修改<code>application.yml</code>文件：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">    <span class="attr">active:</span> <span class="string">peer1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">28081</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">profiles:</span> <span class="string">peer1</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">eureka-server</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">peer1</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">fetch-registry:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://peer2:28082/eureka/,http://peer3:28083/eureka/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">28082</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">profiles:</span> <span class="string">peer2</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">eureka-server</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">peer2</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">fetch-registry:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://peer1:28081/eureka/,http://peer3:28083/eureka/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">28083</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">profiles:</span> <span class="string">peer3</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">eureka-server</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">peer3</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">fetch-registry:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://peer2:28082/eureka/,http://peer1:28081/eureka/</span></span><br></pre></td></tr></table></figure></li><li><p>修改本机的<code>hosts</code>文件</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo vi /etc/hosts</span><br></pre></td></tr></table></figure><p>添加如下内容：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1 peer1 peer2 peer3</span><br></pre></td></tr></table></figure><p>用来模拟不同的环境。</p></li><li><p>打开<code>idea</code>的<code>Terminal</code>，依次执行下面命令：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 打包</span></span><br><span class="line">mvn clean package  -Dmaven.test.skip=true</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 分别以 peer1 和 peer2 配置信息启动 Eureka</span></span><br><span class="line">java -jar target/eureka-server-0.0.1-SNAPSHOT.jar  --spring.profiles.active=peer1</span><br><span class="line">java -jar target/eureka-server-0.0.1-SNAPSHOT.jar  --spring.profiles.active=peer2</span><br><span class="line">java -jar target/eureka-server-0.0.1-SNAPSHOT.jar  --spring.profiles.active=peer3</span><br></pre></td></tr></table></figure><p>依次启动完成后，访问<a href="http://peer1:28081/">http://peer1:28081</a>，效果如下：</p><p><img src="https://gitee.com/cayzlh/img-repo/raw/master/2020/04/17/KGkg1O.png" alt="http://localhost:28081"></p><p><img src="https://gitee.com/cayzlh/img-repo/raw/master/2020/04/17/P8zCXo.png" alt="http://localhost:28081"></p><p>到此三节点的配置已经完成。</p></li></ol><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>在搭建 <code>Eureka Server</code> 集群的时候，要把<code>eureka.client.register-with-eureka</code>和<code>eureka.client.fetch-registry</code>均改为<code>true</code>（默认）。否则会出现实例列表为空，且 <code>peer2</code> 不在 <code>available-replicas</code> 而在 <code>unavailable-replicas</code> 的情况（这时其实只是启动了两个单点实例）。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
          <category> SpringCloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> SpringCloud </tag>
            
            <tag> 微服务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微服务的优缺点</title>
      <link href="/blog/2018/12/15/ded3e7ee.html"/>
      <url>/blog/2018/12/15/ded3e7ee.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文来自Nginx官方博客，是微服务系列文章的第一篇，主要探讨了传统的单体式应用的不足，以及微服务架构的优势与挑战。正如作者所说，微服务架构更适合用于构建复杂的应用，尽管它也有自己的不足。</p><p>转自：<a href="http://dockone.io/article/394">微服务实战（一）：微服务架构的优势与不足</a></p></blockquote><h2 id="单体式应用的不足"><a href="#单体式应用的不足" class="headerlink" title="单体式应用的不足"></a>单体式应用的不足</h2><p>单体式应用开发简单却有很大的局限性。一个简单的应用会随着时间推移逐渐变大。在每次的<strong>sprint</strong>中，开发团队都会面对新“故事”，然后开发许多新代码。几年后，这个小而简单的应用会变成了一个巨大的怪物。</p><p>一旦你的应用变成一个又大又复杂的怪物，那开发团队肯定很痛苦。敏捷开发和部署举步维艰，其中最主要问题就是这个应用太复杂，以至于任何单个开发者都不可能搞懂它。因此，修正bug和正确的添加新功能变的非常困难，并且很耗时。另外，团队士气也会走下坡路。如果代码难于理解，就不可能被正确的修改。最终会走向巨大的、不可理解的泥潭。</p><p>单体式应用也会降低开发速度。应用越大，启动时间会越长。比如，最近的一个调查表明，有时候应用的启动时间居然超过了12分钟。我还听说某些应用需要40分钟启动时间。如果开发者需要经常重启应用，那么大部分时间就要在等待中渡过，生产效率受到极大影响。</p><p>另外，复杂而巨大的单体式应用也不利于持续性开发。今天，SaaS应用常态就是每天会改变很多次，而这对于单体式应用模式非常困难。另外，这种变化带来的影响并没有很好的被理解，所以不得不做很多手工测试。那么接下来，持续部署也会很艰难。</p><p>单体式应用在不同模块发生资源冲突时，扩展将会非常困难。比如，一个模块完成一个CPU敏感逻辑，应该部署在AWS EC2 Compute Optimized instances，而另外一个内存数据库模块更合适于EC2 Memory-optimized instances。然而，由于这些模块部署在一起，因此不得不在硬件选择上做一个妥协。</p><p>单体式应用另外一个问题是可靠性。因为所有模块都运行在一个进程中，任何一个模块中的一个bug，比如内存泄露，将会有可能弄垮整个进程。除此之外，因为所有应用实例都是唯一的，这个bug将会影响到整个应用的可靠性。</p><p>最后，单体式应用使得采用新架构和语言非常困难。比如，设想你有两百万行采用XYZ框架写的代码。如果想改成ABC框架，无论是时间还是成本都是非常昂贵的，即使ABC框架更好。因此，这是一个无法逾越的鸿沟。你不得不在最初选择面前低头。</p><p><strong>总结一下：</strong>一开始你有一个很成功的关键业务应用，后来就变成了一个巨大的，无法理解的怪物。因为采用过时的，效率低的技术，使得雇佣有潜力的开发者很困难。应用无法扩展，可靠性很低，最终，敏捷性开发和部署变的无法完成。</p><h2 id="微处理架构——处理复杂事物"><a href="#微处理架构——处理复杂事物" class="headerlink" title="微处理架构——处理复杂事物"></a>微处理架构——处理复杂事物</h2><p>许多公司，比如Amazon、eBay和NetFlix，通过采用微处理结构模式解决了上述问题。其思路不是开发一个巨大的单体式的应用，而是将应用分解为小的、互相连接的微服务。</p><p>一个微服务一般完成某个特定的功能，比如下单管理、客户管理等等。每一个微服务都是微型六角形应用，都有自己的业务逻辑和适配器。一些微服务还会发布API给其它微服务和应用客户端使用。其它微服务完成一个Web UI，运行时，每一个实例可能是一个云VM或者是Docker容器。</p><p><img src="https://github.com/cayzlh/git-img-repository/raw/master/blog/2018/12/15/1.png"></p><p>微服务架构模式在上图中对应于代表可扩展Scale Cube的Y轴，这是一个在《The Art of Scalability》书中描述过的三维扩展模型。另外两个可扩展轴，X轴由负载均衡器后端运行的多个应用副本组成，Z轴是将需求路由到相关服务。</p><p>应用基本可以用以上三个维度来表示，Y轴代表将应用分解为微服务。运行时，X轴代表运行多个隐藏在负载均衡器之后的实例，提供吞吐能力。一些应用可能还是用Z轴将服务分区。下面的图演示行程管理服务如何部署在运行于AWS EC2上的Docker上。</p><p><img src="https://github.com/cayzlh/git-img-repository/raw/master/blog/2018/12/15/2.png"></p><p>运行时，行程管理服务由多个服务实例构成。每一个服务实例都是一个Docker容器。为了保证高可用，这些容器一般都运行在多个云VM上。服务实例前是一层诸如NGINX的负载均衡器，他们负责在各个实例间分发请求。负载均衡器也同时处理其它请求，例如缓存、权限控制、API统计和监控。</p><p>这种微服务架构模式深刻影响了应用和数据库之间的关系，<strong>不像传统多个服务共享一个数据库，微服务架构每个服务都有自己的数据库</strong>。另外，这种思路也影响到了企业级数据模式。同时，这种模式意味着多份数据，但是，如果你想获得微服务带来的好处，每个服务独有一个数据库是必须的，因为这种架构需要这种松耦合。下面的图演示示例应用数据库架构。</p><p><img src="https://github.com/cayzlh/git-img-repository/raw/master/blog/2018/12/15/3.png"></p><p>每种服务都有自己的数据库，另外，每种服务可以用更适合自己的数据库类型，也被称作多语言一致性架构。比如，驾驶员管理（发现哪个驾驶员更靠近乘客），必须使用支持地理信息查询的数据库。</p><p>表面上看来，微服务架构模式有点像SOA，他们都由多个服务构成。但是，可以从另外一个角度看此问题，微服务架构模式是一个不包含Web服务（WS-）和ESB服务的SOA。微服务应用乐于采用简单轻量级协议，比如REST，而不是WS-，在微服务内部避免使用ESB以及ESB类似功能。微服务架构模式也拒绝使用canonical schema等SOA概念。</p><h2 id="微服务的好处"><a href="#微服务的好处" class="headerlink" title="微服务的好处"></a>微服务的好处</h2><p>微服务架构模式有很多好处。首先，通过分解巨大单体式应用为多个服务方法解决了复杂性问题。在功能不变的情况下，应用被分解为多个可管理的分支或服务。每个服务都有一个用RPC-或者消息驱动API定义清楚的边界。微服务架构模式给采用单体式编码方式很难实现的功能提供了模块化的解决方案，由此，单个服务很容易开发、理解和维护。</p><p>第二，这种架构使得每个服务都可以有专门开发团队来开发。开发者可以自由选择开发技术，提供API服务。当然，许多公司试图避免混乱，只提供某些技术选择。然后，这种自由意味着开发者不需要被迫使用某项目开始时采用的过时技术，他们可以选择现在的技术。甚至于，因为服务都是相对简单，即使用现在技术重写以前代码也不是很困难的事情。</p><p>第三，微服务架构模式是每个微服务独立的部署。开发者不再需要协调其它服务部署对本服务的影响。这种改变可以加快部署速度。UI团队可以采用AB测试，快速的部署变化。微服务架构模式使得持续化部署成为可能。</p><p>最后，微服务架构模式使得每个服务独立扩展。你可以根据每个服务的规模来部署满足需求的规模。甚至于，你可以使用更适合于服务资源需求的硬件。比如，你可以在EC2 Compute Optimized instances上部署CPU敏感的服务，而在EC2 memory-optimized instances上部署内存数据库。</p><h2 id="微服务的不足"><a href="#微服务的不足" class="headerlink" title="微服务的不足"></a>微服务的不足</h2><p>Fred Brooks在30年前写道，“there are no silver bullets”，像任何其它科技一样，微服务架构也有不足。其中一个跟他的名字类似，『微服务』强调了服务大小，实际上，有一些开发者鼓吹建立稍微大一些的，10-100 LOC服务组。尽管小服务更乐于被采用，但是不要忘了这只是终端的选择而不是最终的目的。微服务的目的是有效的拆分应用，实现敏捷开发和部署。</p><p>另外一个主要的不足是，微服务应用是分布式系统，由此会带来固有的复杂性。开发者需要在RPC或者消息传递之间选择并完成进程间通讯机制。更甚于，他们必须写代码来处理消息传递中速度过慢或者不可用等局部失效问题。当然这并不是什么难事，但相对于单体式应用中通过语言层级的方法或者进程调用，微服务下这种技术显得更复杂一些。</p><p>另外一个关于微服务的挑战来自于分区的数据库架构。商业交易中同时给多个业务分主体更新消息很普遍。这种交易对于单体式应用来说很容易，因为只有一个数据库。在微服务架构应用中，需要更新不同服务所使用的不同的数据库。使用分布式交易并不一定是好的选择，不仅仅是因为CAP理论，还因为今天高扩展性的NoSQL数据库和消息传递中间件并不支持这一需求。最终你不得不使用一个最终一致性的方法，从而对开发者提出了更高的要求和挑战。</p><p>测试一个基于微服务架构的应用也是很复杂的任务。比如，采用流行的Spring Boot架构，对一个单体式web应用，测试它的REST API，是很容易的事情。反过来，同样的服务测试需要启动和它有关的所有服务（至少需要这些服务的stubs）。再重申一次，不能低估了采用微服务架构带来的复杂性。</p><p>另外一个挑战在于，微服务架构模式应用的改变将会波及多个服务。比如，假设你在完成一个案例，需要修改服务A、B、C，而A依赖B，B依赖C。在单体式应用中，你只需要改变相关模块，整合变化，部署就好了。对比之下，微服务架构模式就需要考虑相关改变对不同服务的影响。比如，你需要更新服务C，然后是B，最后才是A，幸运的是，许多改变一般只影响一个服务，而需要协调多服务的改变很少。</p><p>部署一个微服务应用也很复杂，一个分布式应用只需要简单在复杂均衡器后面部署各自的服务器就好了。每个应用实例是需要配置诸如数据库和消息中间件等基础服务。相对比，一个微服务应用一般由大批服务构成。例如，根据Adrian Cockcroft，<a href="https://sudo.hailoapp.com/services/2015/03/09/journey-into-a-microservice-world-part-3/">Hailo有160个不同服务构成</a>，NetFlix有大约600个服务。每个服务都有多个实例。这就造成许多需要配置、部署、扩展和监控的部分，除此之外，你还需要完成一个服务发现机制（后续文章中发表），以用来发现与它通讯服务的地址（包括服务器地址和端口）。传统的解决问题办法不能用于解决这么复杂的问题。接续而来，成功部署一个微服务应用需要开发者有足够的控制部署方法，并高度自动化。</p><p>一种自动化方法是使用PaaS服务，例如<a href="http://www.cloudfoundry.org/">Cloud Foundry</a>。PaaS给开发者提供一个部署和管理微服务的简单方法，它把所有这些问题都打包内置解决了。同时，配置PaaS的系统和网络专家可以采用最佳实践和策略来简化这些问题。另外一个自动部署微服务应用的方法是开发对于你来说最基础的PaaS系统。一个典型的开始点是使用一个集群化方案，比如配合Docker使用Mesos或者Kubernetes。后面的系列我们会看看如何基于软件部署方法例如NGINX，可以方便的在微服务层面提供缓存、权限控制、API统计和监控。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>构建复杂的应用真的是非常困难。单体式的架构更适合轻量级的简单应用。如果你用它来开发复杂应用，那真的会很糟糕。微服务架构模式可以用来构建复杂应用，当然，这种架构模型也有自己的缺点和挑战。</p>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> 转载 </tag>
            
            <tag> SpringCloud </tag>
            
            <tag> 微服务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Cloud中的名词解释</title>
      <link href="/blog/2018/12/02/60e9e95d.html"/>
      <url>/blog/2018/12/02/60e9e95d.html</url>
      
        <content type="html"><![CDATA[<h2 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h2><p>近年来，在软件开发领域关于微服务的讨论呈现出火爆的局面，有人倾向于在系统设计与开发中采用微服务方式实现软件系统的松耦合、跨部门开发，被认为是IT软件架构的未来方向，Martin Fowler也给微服务架构极高的评价；同时，反对之声也很强烈，持反对观点的人表示微服务增加了系统维护、部署的难度，导致一些功能模块或代码无法复用，同时微服务允许使用不同的语言和框架来开发各个系统模块，这又会增加系统集成与测试的难度，而且随着系统规模的日渐增长，微服务在一定程度上也会导致系统变得越来越复杂。尽管一些公司已经在生产系统中采用了微服务架构，并且取得了良好的效果；但更多公司还是处在观望的态度。</p><p>什么是微服务架构呢？简单说就是将一个完整的应用（单体应用）按照一定的拆分规则（后文讲述）拆分成多个不同的服务，每个服务都能独立地进行开发、部署、扩展。服务于服务之间通过注入RESTful api或其他方式调用。</p><h3 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h3><p>版本号包含 英文单词（release train） + SRX（service release）（X：数字）</p><ul><li>release train：按伦敦地铁站名A-Z进行首字母迭代排序</li><li>SR：一般表示当前修复BUG的版本编号<br> 例：Camden SR4、Camden SR5、Dalston SR1<br> 而大多数Spring项目都以“主版本号.次版本号.增量版本号.里程碑版本号”的形式命名版本号，例如 Spring Framework 稳定版本 4.3.5.RELEASE、里程碑版本 5.0.0.M4 等。</li></ul><h2 id="Spring-Cloud"><a href="#Spring-Cloud" class="headerlink" title="Spring Cloud"></a>Spring Cloud</h2><p>Spring Cloud是在Spring Boot的基础上构建的，用于简化分布式系统构建的工具集，为开发人员提供快速建立分布式系统中的一些常见的模式。</p><blockquote><p>例如：配置管理（configuration management），服务发现（service discovery），断路器（circuit breakers），智能路由（ intelligent routing），微代理（micro-proxy），控制总线（control bus），一次性令牌（ one-time tokens），全局锁（global locks），领导选举（leadership election），分布式会话（distributed sessions），集群状态（cluster state）。</p></blockquote><p>Spring Cloud 包含了多个子项目：</p><blockquote><p>例如：Spring Cloud Config、Spring Cloud Netflix等</p></blockquote><p>Spring Cloud 项目主页：<a href="http://projects.spring.io/spring-cloud/">http://projects.spring.io/spring-cloud/</a></p><h2 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h2><p>在微服务架构中，服务发现（Service Discovery）是关键原则之一。手动配置每个客户端或某种形式的约定是很难做的，并且很脆弱。Spring Cloud提供了多种服务发现的实现方式，例如：Eureka、Consul、Zookeeper。</p><h2 id="Eureka"><a href="#Eureka" class="headerlink" title="Eureka"></a>Eureka</h2><p><strong>Eureka是</strong>Netflix开发的服务发现组件，本身<strong>是</strong>一个基于REST的服务。 Spring Cloud将它集成在其子项目spring-cloud-netflix中，以实现Spring Cloud的服务发现功能。</p><h2 id="Consul"><a href="#Consul" class="headerlink" title="Consul"></a>Consul</h2><p>Consul 是 HashiCorp 公司推出的开源工具，用于实现分布式系统的服务发现与配置。与其他分布式服务注册与发现的方案，Consul的方案更“一站式”，内置了服务注册与发现框 架、分布一致性协议实现、健康检查、Key/Value存储、多数据中心方案，不再需要依赖其他工具（比如ZooKeeper等）。使用起来也较 为简单。Consul使用Go语言编写，因此具有天然可移植性(支持Linux、windows和Mac OS X)；安装包仅包含一个可执行文件，方便部署，与Docker等轻量级容器可无缝配合 。</p><h2 id="Ribbon"><a href="#Ribbon" class="headerlink" title="Ribbon"></a>Ribbon</h2><p>Ribbon是Netflix发布的开源项目，主要功能是提供客户端的软件负载均衡算法，将Netflix的中间层服务连接在一起。Ribbon客户端组件提供一系列完善的配置项如连接超时，重试等。简单的说，就是在配置文件中列出Load Balancer后面所有的机器，Ribbon会自动的帮助你基于某种规则（如简单轮询，随机连接等）去连接这些机器。我们也很容易使用Ribbon实现自定义的负载均衡算法。简单地说，Ribbon是一个客户端负载均衡器。</p><p>Ribbon工作时分为两步：第一步先选择 Eureka Server, 它优先选择在同一个Zone且负载较少的Server；第二步再根据用户指定的策略，在从Server取到的服务注册列表中选择一个地址。其中Ribbon提供了多种策略，例如轮询、随机、根据响应时间加权等。</p><h2 id="Feign"><a href="#Feign" class="headerlink" title="Feign"></a>Feign</h2><p>Feign是一个声明式的web service客户端，它使得编写web service客户端更为容易。创建接口，为接口添加注解，即可使用Feign。Feign可以使用Feign注解或者JAX-RS注解，还支持热插拔的编码器和解码器。Spring Cloud为Feign添加了Spring MVC的注解支持，并整合了Ribbon和Eureka来为使用Feign时提供负载均衡。</p><h2 id="熔断器"><a href="#熔断器" class="headerlink" title="熔断器"></a>熔断器</h2><h3 id="雪崩效应"><a href="#雪崩效应" class="headerlink" title="雪崩效应"></a>雪崩效应</h3><p>在微服务架构中通常会有多个服务层调用，基础服务的故障可能会导致级联故障，进而造成整个系统不可用的情况，这种现象被称为服务雪崩效应。服务雪崩效应是一种因“服务提供者”的不可用导致“服务消费者”的不可用,并将不可用逐渐放大的过程。</p><p>如果下图所示：A作为服务提供者，B为A的服务消费者，C和D是B的服务消费者。A不可用引起了B的不可用，并将不可用像滚雪球一样放大到C和D时，雪崩效应就形成了。</p><p><img src="https://gitee.com/cayzlh/img-repo/raw/master/2020/04/17/YmtntU.png" alt="雪崩效应"></p><h3 id="熔断器（CircuitBreaker）"><a href="#熔断器（CircuitBreaker）" class="headerlink" title="熔断器（CircuitBreaker）"></a>熔断器（CircuitBreaker）</h3><p>熔断器的原理很简单，如同电力过载保护器。它可以实现快速失败，如果它在一段时间内侦测到许多类似的错误，会强迫其以后的多个调用快速失败，不再访问远程服务器，从而防止应用程序不断地尝试执行可能会失败的操作，使得应用程序继续执行而不用等待修正错误，或者浪费CPU时间去等到长时间的超时产生。熔断器也可以使应用程序能够诊断错误是否已经修正，如果已经修正，应用程序会再次尝试调用操作。</p><p>熔断器模式就像是那些容易导致错误的操作的一种代理。这种代理能够记录最近调用发生错误的次数，然后决定使用允许操作继续，或者立即返回错误。</p><p>熔断器开关相互转换的逻辑如下图：</p><p><img src="https://gitee.com/cayzlh/img-repo/raw/master/2020/04/17/OSjXSn.png" alt="熔断器"></p><h2 id="Hystrix"><a href="#Hystrix" class="headerlink" title="Hystrix"></a>Hystrix</h2><p>在Spring Cloud中使用了Netflix开发的Hystrix来实现熔断器。</p><h2 id="Hystrix-Dashboard"><a href="#Hystrix-Dashboard" class="headerlink" title="Hystrix Dashboard"></a>Hystrix Dashboard</h2><p><strong>Hystrix监控</strong>，除了隔离依赖服务的调用以外，Hystrix还提供了近实时的监控，Hystrix会实时、累加地记录所有关于HystrixCommand的执行信息，包括每秒执行多少请求多少成功，多少失败等。Netflix通过hystrix-metrics-event-stream项目实现了对以上指标的监控。</p><h2 id="Turbine"><a href="#Turbine" class="headerlink" title="Turbine"></a>Turbine</h2><p>在复杂的分布式系统中，相同服务的节点经常需要部署上百甚至上千个，很多时候，运维人员希望能够把相同服务的节点状态以一个整体集群的形式展现出来，这样可以更好的把握整个系统的状态。 为此，Netflix提供了一个开源项目（Turbine）来提供把多个hystrix.stream的内容聚合为一个数据源供Dashboard展示。 </p><p>和Hystrix Dashboard一样，Turbine也可以下载war包部署到Web容器。</p><h2 id="Zuul"><a href="#Zuul" class="headerlink" title="Zuul"></a>Zuul</h2><p>Netflix开源的微服务网关，核心是一系列过滤器：</p><ul><li>身份认证安全</li><li>审查与监控</li><li>动态路由</li><li>压力测试</li><li>附再分配</li><li>静态响应处理</li><li>多区域弹性</li></ul><h2 id="Zuul过滤器"><a href="#Zuul过滤器" class="headerlink" title="Zuul过滤器"></a>Zuul过滤器</h2><p>Spring Cloud中使用Zuul作为API Gateway。Zuul提供了动态路由、监控、回退、安全等功能。主要为4种标准类型：</p><ul><li>PRE：在请求被路由之前调用</li><li>ROUTING：这种过滤器将请求路由到微服务</li><li>POST：在路由到微服务以后执行</li><li>ERROR：在其他阶段发生错误时自信该过滤器</li></ul><h2 id="Sleuth"><a href="#Sleuth" class="headerlink" title="Sleuth"></a>Sleuth</h2><p>为Spring Cloud 提供了分布式跟踪的解决方案，它大量借助了Google Dapper、Twitter Zipkin 和 Apache HTrace的设计。<br>Sleuth的术语：<strong>span（跨度）</strong>、<strong>trace（跟踪）</strong>、<strong>annotation（标注）</strong></p><h2 id="配置中心"><a href="#配置中心" class="headerlink" title="配置中心"></a>配置中心</h2><p>Spring Cloud Config提供了一种在分布式系统中外部化配置服务器和客户端的支持。配置服务器有一个中心位置，管理所有环境下的应用的外部属性。客户端和服务器映射到相同Spring Eventment 和 PropertySrouce抽象的概念，所以非常适合Spring应用，但也可以在任何语言开发的任何应用中使用。在一个应用从开发、测试到生产的过程中，你可以分别地管理开发、测试、生产环境的配置，并且在迁移的时候获取相应的配置来运行。</p><p>Config Server 存储后端默认使用git存储配置信息，因此可以很容易支持标记配置环境的版本，同时可以使用一个使用广泛的工具管理配置内容。当然添加其他方式的存储实现也是很容易的。</p><h2 id="API-Gateway"><a href="#API-Gateway" class="headerlink" title="API Gateway"></a>API Gateway</h2><p>API Gateway是微服务架构中不可或缺的部分：<a href="http://dockone.io/article/482">http://dockone.io/article/482</a>。</p><p>API Gateway是一个服务器，也可以说是进入系统的唯一节点。这跟面向对象设计模式中的Facade模式很像。API Gateway封装内部系统的架构，并且提供API给各个客户端。它还可能有其他功能，如授权、监控、负载均衡、缓存、请求分片和管理、静态响应处理等。</p><p>API Gateway负责请求转发、合成和协议转换。所有来自客户端的请求都要先经过API Gateway，然后路由这些请求到对应的微服务。API Gateway将经常通过调用多个微服务来处理一个请求以及聚合多个服务的结果。它可以在web协议与内部使用的非Web友好型协议间进行转换，如HTTP协议、WebSocket协议。</p><p>API Gateway可以提供给客户端一个定制化的API。它暴露一个粗粒度API给移动客户端。以产品最终页这个使用场景为例。API Gateway提供一个服务提供点（/productdetails?productid=xxx）使得移动客户端可以在一个请求中检索到产品最终页的全部数据。API Gateway通过调用多个服务来处理这一个请求并返回结果，涉及产品信息、推荐、评论等。</p><p>一个很好的API Gateway例子是<a href="http://techblog.netflix.com/2013/02/rxjava-netflix-api.html">Netfix API Gateway</a>。Netflix流服务提供数百个不同的微服务，包括电视、机顶盒、智能手机、游戏系统、平板电脑等。起初，Netflix视图提供一个<a href="http://www.programmableweb.com/news/why-rest-keeps-me-night/2012/05/15">适用全场景</a>的API。但是，他们发现这种形式不好用，因为涉及到各式各样的设备以及它们独特的需求。现在，他们采用一个API Gateway来提供容错性高的API，针对不同类型设备有相应代码。事实上，一个适配器处理一个请求平均要调用6到8个后端服务。Netflix API Gateway每天处理数十亿的请求。</p><h3 id="API-Gateway的优点和缺点"><a href="#API-Gateway的优点和缺点" class="headerlink" title="API Gateway的优点和缺点"></a>API Gateway的优点和缺点</h3><p>如你所料，采用API Gateway也是优缺点并存的。API Gateway的一个最大好处是封装应用内部结构。相比起来调用指定的服务，客户端直接跟gatway交互更简单点。API Gateway提供给每一个客户端一个特定API，这样减少了客户端与服务器端的通信次数，也简化了客户端代码。</p><p>API Gateway也有一些缺点。它是一个高可用的组件，必须要开发、部署和管理。还有一个问题，它可能成为开发的一个瓶颈。开发者必须更新API Gateway来提供新服务提供点来支持新暴露的微服务。更新API Gateway时必须越轻量级越好。否则，开发者将因为更新Gateway而排队列。但是，除了这些缺点，对于大部分的应用，采用API Gateway的方式都是有效的。</p><p>使用API Gateway后，客户端和微服务之间的网络图变成下图：</p><p><img src="https://gitee.com/cayzlh/img-repo/raw/master/2020/04/17/MGTTqC.png" alt="API Gateway"></p><p>通过API Gateway，可以统一向外部系统提供REST API。Spring Cloud中使用Zuul作为API Gateway。Zuul提供了动态路由、监控、回退、安全等功能。</p><hr><p><strong>图文来源：</strong><a href="https://github.com/eacdy/spring-cloud-book">https://github.com/eacdy/spring-cloud-book</a>、<a href="https://google.com/">Google</a></p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
          <category> SpringCloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> SpringCloud </tag>
            
            <tag> 微服务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程安全与锁优化</title>
      <link href="/blog/2018/09/21/7876bd5d.html"/>
      <url>/blog/2018/09/21/7876bd5d.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>并发处理的广泛应用是使得Amdahl定律代替摩尔定律成为计算机性能发展源动力的根本原因，也是人类压榨计算机运算能力最有力的武器。</p></blockquote><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>在软件业发展的初期，程序编写都是以算法为核心的，程序员会把数据和过程分别作为独立的部分来考虑，数据代表问题空间中的客体，程序代码则用于处理这些数据，这种思维方式是直接站在计算机的角度去抽象问题和解决问题，称为面向过程的编程思想。与此相对，面向对象的编程思想则站在现实世界的角度去抽象和解决问题，它把数据和行为都看作是对象的一部分，这样可以让程序员能以符合现实世界的思维方式来编写和组织程序。</p><p>人们很难想象现实中的对象在一项工作进行器件，会被不停地中断和切换，对象地属性可能会在中断期间被修改和变脏，而这些事件在计算机世界中是很正常地事情。良好地设计原则不得不向现实做出一些让步，我们必须让程序在计算机中正确无误地运行，然后再考虑如何将代码组织得更好，让程序运行得更快。</p><h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><blockquote><p>“当多个线程访问一个对象时，如果不用考虑这些线程在运行时环境下得调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他的协同操作，调用这个对象的行为都可以获得正确的结果，那这个对象就是线程安全的。”</p><p>—— 《Java Concurrency In Practice》的作者Brian Goetz对“线程安全”的定义</p></blockquote><p>这个定义很严谨，它要求了线程安全的代码必须都具备一个特征：<strong>代码本身封装了所有必要的正确性保障手段（如互斥同步等），令调用者无须关系多线程的问题，更无须自己实现任何措施来保证多线程的正确调用。</strong>这点并不容易做到。</p><h3 id="Java语言中的线程安全"><a href="#Java语言中的线程安全" class="headerlink" title="Java语言中的线程安全"></a>Java语言中的线程安全</h3><p>我们讨论线程安全，就限定于多个线程之间存在共享数据访问这个前提，因为如果一段代码根本不会与其他线程共享数据，那么从线程安全的角度上看，程序时串行执行还是多线程执行对它来说是完全没有区别的。</p><p>按照线程安全的“安全程度”由强至弱来排序，可以将Java语言中各种操作共享的数据分为五类：<strong>不可变、绝对线程安全、相对线程安全、县城兼容和线程对立。</strong></p><h4 id="不可变"><a href="#不可变" class="headerlink" title="不可变"></a>不可变</h4><p>在Java语言里面，不可变的对象一定是线程安全的，无论是对象的方法实现还是方法的调用者，都不需要再进行任何的线程安全保障措施，<strong>只要一个不可变的对象被正确的构建出来（没有发生this逃逸的情况），那其外部的可见状态永远不会改变，永远也不会看到它再多个线程之中处于不一致的狂态。</strong>“不可变”带来的安全性是最简单最纯粹的。</p><p>如果共享数据是一个一本数据类型，那么只要再定义时使用<code>final</code>关键字修饰它就可以保证它是不可变的。如果共享数据是一个对象，那就需要保证对象的行为不会对其状态产生任何影响才行。<code>java.lang.String</code>类的对象，是一个典型的不可变对象，我们调用它的<code>substring()</code>、<code>replace()</code>和<code>concat()</code>这些方法都不会影响它原来的值，只会返回一个新构造的字符串对象。</p><blockquote><p>保证对象行为不影响自己状态的途径由很多种，其中最简单的就是把对象中带有状态的变量都声明为<code>final</code>，这样在构造函数结束之后， 它就是不可变的。</p></blockquote><p><code>java.lang.Integer</code>构造函数，它通过将内部状态变量<code>value</code>定义为<code>final</code>来保障状态不变：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * The value of the &#123;<span class="doctag">@code</span> Integer&#125;.</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@serial</span></span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> value;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Constructs a newly allocated &#123;<span class="doctag">@code</span> Integer&#125; object that</span></span><br><span class="line"><span class="comment">  * represents the specified &#123;<span class="doctag">@code</span> int&#125; value.</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span>   value   the value to be represented by the</span></span><br><span class="line"><span class="comment">  *                  &#123;<span class="doctag">@code</span> Integer&#125; object.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">Integer</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">this</span>.value = value;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>在Java API中符合不可变要求的类型，除了<code>String</code>之外，常用的还有枚举类型，以及<code>java.lang.Number</code>的部分子类。</p><h4 id="绝对线程安全"><a href="#绝对线程安全" class="headerlink" title="绝对线程安全"></a>绝对线程安全</h4><p>绝对线程安全完全满足<code>Brian Goetz</code>给出的线程安全的定义，这个定义其实是很严格的，一个类要达到“不管运行时环境如何，调用者都不需要任何额外的同步措施”通常需要付出很大的，甚至是不切实际的代价。在Java API中标注自己是线程安全的类，大多数都不是绝对的线程安全。</p><p><code>java.util.Vector</code>是一个线程安全的容器，因为它的<code>add()</code>、<code>get()</code>和<code>size()</code>这类方法都是被<code>synchronized</code>修饰的，尽管这样效率很低，但确实是安全的。但是，<strong>即使它所有的方法都被修饰成同步，也不意味着调用它的时候永远都不再需要同步手段了。</strong></p><p>代码清单，对Vector线程安全的测试：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.cayzlh.jvmdemo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Vector;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Ant丶</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VectorSaveTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Vector&lt;Integer&gt; vector = <span class="keyword">new</span> Vector&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                vector.add(i);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Thread removeThread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vector.size(); i++) &#123;</span><br><span class="line">                        vector.remove(i);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            Thread printThread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vector.size(); i++) &#123;</span><br><span class="line">                        System.out.println(vector.get(i));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            removeThread.start();</span><br><span class="line">            printThread.start();</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 不要同时产生过多的线程，否则会导致操作系统假死</span></span><br><span class="line">            <span class="keyword">while</span> (Thread.activeCount() &gt; <span class="number">20</span>) &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://gitee.com/cayzlh/img-repo/raw/master/2020/04/19/l0vR4U.png" alt="对Vector线程安全的测试"></p><p>尽管这里使用到的<code>Vector</code>的<code>get()</code>、<code>remove()</code>和<code>size()</code>方法都是同步的，但是在多线程的环境中，如果不在方法调用端做额外的不同措施，使用这段代码仍然是不安全的，因为<strong>如果另一个线程切好在错误的时间里删除了一个元素，导致序号i已经不再可用的话，get()方法就会抛出一个<code>ArrayIndexOutOfBoundsException</code>。</strong></p><p>要保证这段代码能正确地执行下去，要对<code>removeThread</code>和<code>printThread</code>做一些修改：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread removeThread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (vector) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vector.size(); i++) &#123;</span><br><span class="line">                vector.remove(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">Thread printThread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (vector) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vector.size(); i++) &#123;</span><br><span class="line">                System.out.println(vector.get(i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="相对线程安全"><a href="#相对线程安全" class="headerlink" title="相对线程安全"></a>相对线程安全</h4><p>相对线程安全就是我们通常意义上所讲的线程安全， 它需要保证对这个对象单独的操作是线程安全的，我们在调用的时候不需要做额外的保障措施，但是对于一些特定顺序的连续调用，就可能需要在调用端使用额外的同步手段来保证调用的正确性。</p><blockquote><p>在Java语言中，大部分的线程安全类都属于这种类型，例如<code>Vector</code>、<code>HashTable</code>、<code>Collections</code>的<code>synchronizedCollection()</code>方法包装的集合等。</p></blockquote><h4 id="线程兼容"><a href="#线程兼容" class="headerlink" title="线程兼容"></a>线程兼容</h4><p>线程兼容是指对象本身并不是线程安全的，但是可以通过在调用端正确地使用同步手段来保证对象在并发环境中安全地使用，我们平常说一个类不是线程安全的，绝大多数指的都是这种情况。Java API中大部分的类都是线程兼容的，如<code>Vector</code>和<code>Hashtable</code>相对应的集合类<code>ArrayList</code>和<code>HashMap</code>等。</p><h4 id="线程对立"><a href="#线程对立" class="headerlink" title="线程对立"></a>线程对立</h4><p>线程对立是指不管调用端是否采取了同步措施，都无法在多线程环境中并发使用的代码。由于Java语言天生就具备多线程特性，线程对立这种排斥多线程的代码很少出现，而且通常是有害的，应尽量避免。</p><p>一个线程对立的例子是<code>Thread</code>类的<code>suspend()</code>和<code>resume()</code>方法，如果有两个线程同时持有一个线程对象，一个尝试去中断线程，一个尝试去恢复线程，如果并发进行的话， 无论调用时是否进行了同步，目标线程都是存在死锁风险的，如果<code>suspend()</code>中断的线程就是即将要执行<code>resume()</code>的那个线程，那就肯定产生死锁了。</p><h3 id="线程安全的实现方法"><a href="#线程安全的实现方法" class="headerlink" title="线程安全的实现方法"></a>线程安全的实现方法</h3><p>如何实现线程安全与代码的编写有很大的关系，但虚拟机提供的同步和锁机制也起到了非常重要的作用。</p><h4 id="互斥同步"><a href="#互斥同步" class="headerlink" title="互斥同步"></a>互斥同步</h4><p><strong>互斥同步是最常见的一种并发正确性保障手段，同步是指在多个线程并发访问共享数据时，保证共享数据在同一时刻只被一条线程使用。而互斥是实现同步的一种手段，临界区、互斥量和信号量都是主要的互斥实现方式。</strong>互斥是因，同步是果，互斥是方法，同步是目的。</p><p>在Java里面，最基本的互斥同步手段就是<code>synchronized</code>关键字，<code>synchronized</code>关键字经过编译之后，会在同步块的前后分别形成<code>monitorenter</code>和<code>monitorexit</code>这两个字节码指令，这两个字节码都需要一个<code>reference</code>类型的参数来指明要锁定和解锁的对象。如果Java程序中的<code>synchronized</code>明确指定了对象参数，那就是对这个参数的<code>reference</code>；如果没有明确指定，那就根据<code>synchronized</code>修饰的实例方法还是类方法，去取对应的对象实例或Class对象来作为锁对象。</p><blockquote><p>在执行<code>monitorenter</code>指令时，首先要尝试获取对象的锁。如果这个对象没有被锁定，或者当前线程已经拥有了那个对象的锁，把锁的计数器加1，相应地，在执行<code>monitorexit</code>指令时会讲锁计数器减1，当计数器为0时，锁就释放了。如果获取对象锁失败了，那当前线程就要阻塞等待，直到锁被另外一个线程释放为止。</p></blockquote><p>首先<code>synchronized</code>同步块对同一条线程来说是可重入的，不会出现自己把自己锁死的问题。其次，同步块在已进入的线程执行完之前，会阻塞后面其他线程的进入。<strong>Java的线程是映射到操作系统的原声线程上的，如果要阻塞或唤醒一条线程，都需要操作系统来帮忙完成，这就需要从用户态转换到核心态中，因此状态转换需要耗费很多的处理器时间。对于代码简单的同步块，状态转换消耗的时间可能比用户代码执行的时间还要常。所以<code>synchronized</code>是Java语言中的一个重量级的操作，在必要的情况下才使用这种操作。</strong>虚拟机本身也会进行一些优化，譬如在通知操作系统阻塞线程之前加入一段自旋等待过程，避免频繁地切入到核心态之中。</p><h4 id="非阻塞同步"><a href="#非阻塞同步" class="headerlink" title="非阻塞同步"></a>非阻塞同步</h4><p><em>互斥同步最要的问题是进行线程阻塞和唤醒所带来的性能问题，因此这种同步也被称为阻塞同步。另外，它属于一种悲观的并发策略，总是认为只要不去做正确的同步措施，那就肯定会出问题，无论共享数据是否真的会出现竞争，它都要进行加锁、用户态核心态转换、维护锁计数器和检查是否有被阻塞的线程需要被唤醒等操作。</em></p><p>随着硬件指令集的发展，有了另外一个选择：<strong>基于冲突检测的乐观并发策略，通俗地说就是先进行操作，如果没有其他线程争用共享数据，那操作就成功了；如果共享数据有争用，产生了冲突，那就再进行其他的补偿措施（不断地重试，直到成功为止），这种乐观的并发策略的许多首先都不需要把线程挂起，因此这种同步操作被称为非阻塞同步。</strong></p><h4 id="无同步方案"><a href="#无同步方案" class="headerlink" title="无同步方案"></a>无同步方案</h4><p>要保证线程安全，并不是以顶要进行同步，两者没有因果关系。同步只是保障共享数据竞争用时的正确性的手段，如果一个方法本来就不涉及共享数据，那它自然就无需任何同步措施去保证正确性，因此会有一些代码天生就是线程安全的：</p><h5 id="可重入代码"><a href="#可重入代码" class="headerlink" title="可重入代码"></a>可重入代码</h5><p>这种代码也叫纯代码，可以在代码执行的任何时刻中断它，转而去执行另外一段代码，而在控制权返回后，原来的程序出现任何错误。相对线程安全来说， 可重入性是更基本的特性，它可以是线程安全，即所有的可重入的代码都是线程安全的，但是并非所有的线程安全的代码都是可重入的。</p><p>可重入代码有一些共同的特征：例如不依赖存储在堆上的数据和公用的系统资源、用到的状态量都由参数中传入、不调用非可重入的方法等。判断代码是否具备可重入：<strong>如果一个方法，它返回的结果是可以预测的，只要输入了相同的数据，就能返回相同的结果，那它满足可重入性的要求，当然也就是线程安全的。</strong></p><h5 id="线程本地存储"><a href="#线程本地存储" class="headerlink" title="线程本地存储"></a>线程本地存储</h5><p>一段代码中所需要的数据必须与其他代码共享，那就看看能否否正这些共享数据在同一个线程中执行。如果能保证，我们就可以把共享数据的可见范围限制在一个线程之内，这样，无须同步也能保证线程之间不出现数据争用的问题。<strong>最常见的应用就是消费队列的架构模式（生产者-消费者模式），都会讲产品的消费过程尽量在一个线程中消费完，其中最重要的一个应用实例就是Web交互模型中的“一个请求对应一个服务器线程的处理方式，这种处理方式的广泛应用使得Web服务端的很多应用都可以使用线程本地存储来解决线程安全问题。”</strong></p><p>Java语言中，如果一个变量要被多线程访问，可以使用<code>volatile</code>关键字声明它为“易变的”；如果一个变量要被某个线程独享，可以通过<code>java.lang.ThreadLocal</code>类来实现线程本地存储的功能。<strong>每一个线程的<code>Thread</code>对象中都有一个<code>ThreadLocalMap</code>对象，这个对象存储了一组以<code>ThreadLocal.threadLocalHashCode</code>为键，以本地线程变量为值的<code>K-V</code>值对，<code>ThreadLocal</code>对象就是当前线程的<code>ThreadLocalMap</code>的访问入口，每个<code>ThreadLocal</code>对象都包含了一个独一无二的<code>threadLocalHashCode</code>值，使用这个值就可以在线程<code>K-V</code>值对中找回对应的本地线程变量。</strong></p><h2 id="锁优化"><a href="#锁优化" class="headerlink" title="锁优化"></a>锁优化</h2><p>虚拟机开发团队实现各种锁优化技术，如<strong>适应性自旋、锁消除、锁粗化、轻量级锁、偏向锁等，</strong>这些技术都是为了线程之间更高效地共享数据，以及解决竞争问题，从而提高程序的执行效率。</p><h3 id="自旋锁与自适应自旋"><a href="#自旋锁与自适应自旋" class="headerlink" title="自旋锁与自适应自旋"></a>自旋锁与自适应自旋</h3><p>互斥同步对性能最大的影响是阻塞的实现，挂起线程和恢复线程的操作都需要转内核态中完成，这些操作给系统的并发性能带来了很大的压力。同时，共享数据的锁定状态只会持续很短的一段时间，为了这段时间去挂起和恢复线程并不值得。<strong>如果物理机器有一个以上的处理器，能让两个或以上的线程同时执行，就可以让后面请求锁的那个线程“稍等一会儿”，但不放弃处理器的执行时间，看啊可能持有锁是否很快就会释放锁。</strong>为了让线程等待，只须让线程执行一个忙循环（自旋），这项技术就是所谓自旋锁。</p><p>自旋等待不能代替阻塞，先不说对处理器数量的要求，自旋等待本身虽然避免了线程切换的开销，但它是要占用处理器时间的，所以如果锁被占用的时间很短，自旋等待的效果就会非常好，反之如果锁被占用的时间很长，那么自旋的线程只会拜拜消耗处理器资源，而不会做任何游泳的工作，反而会带来性能的浪费。因此自旋等待的时间必须要有一定的限度，如果自旋超过了限定的次数仍然没有成功获得锁，就应当使用传统的方式去挂起线程了。</p><p><strong>自适应自旋锁，</strong>意味着自旋的时间不再是固定的，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也很有可能再次成功，进而它将允许自旋等待持续相对更长的时间。另外一方面，如果对于某个锁，自旋很少成功获得过，那在以后要获取这个锁时将可能省略掉自旋过程，一面浪费处理器资源。</p><p><em>有了自适应自旋，随着程序运行和性能监控信息的不断完善，虚拟机对程序锁的状况预测就会越来越准确，虚拟机就会变得越来越“聪明”。</em></p><h3 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h3><p>锁消除是指虚拟机即时编译器在运行时，对一些代码上要求同步，但是被检测到不可能存在共享数据竞争的锁进行消除。<strong>锁消除的主要判断依据来源于逃逸分析的数据支持，如果判断到一段代码中，在堆上的所有数据都不会逃逸出去被其他线程访问到，那就可以把它们做栈上数据对待，认为它们是线程私有的，同步加锁自然就无须进行。</strong></p><h3 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h3><p>原则上，在编写代码的时候，推荐将同步块的作用范围限制得尽量小——只在共享数据的实际作用域中才进行同步，这样是为了使得需要同步的操作数量尽可能变小，如果存在锁竞争，那等待锁的线程也能尽快拿到锁。</p><p><strong>如果一系列连续操作都对同一个对象反复加锁和解锁，甚至加锁操作是出现在循环体中的，那即使没有线程的竞争，频繁地进行互斥同步操作也会导致不必要的性能损耗。</strong></p><p>如果虚拟机探测到有这样的一串零碎的操作都对同一个对象加锁，将会把加锁同步的范围扩展（粗化）到整个操作序列的外部，在第一个操作之前直至最后一个操作之后，这样只需要加锁一次就可以了。</p><h3 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h3><blockquote><p>轻量级是相对于操作系统互斥量来实现的传统锁而言的，因此传统的锁机制就被称为重量级锁。</p><p>轻量级锁并不是用来代替重量级锁的，它本意是在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗。</p></blockquote><p>在代码进入同步块的时候，如果此同步对象没有被锁定，虚拟机首先将在当前线程的栈帧中建立一个名为锁记录的空间，用于存储锁对象目前的Mark Word的拷贝。然后，虚拟机将使用CAS操作尝试将对象的Mark Word更新为指向Lock Record的指针。如果这个更新动作成功了，那么这个线程就拥有了该对象的锁，并且对象Mark Word的锁标志位将转变为“00”，即表示此对象出于轻量级锁的状态。</p><p><strong>如果这个更新操作失败了，虚拟机首先会检查对象的Mark Word是否指向当前线程的栈帧，如果是就说明当前线程已经拥有了这个对象的锁，可以直接进入同步块继续执行，否则说明这个锁对象已经被其他线程抢占了。</strong>如果有两条以上的线程争用同一个锁，那轻量级锁就不再有效，要膨胀为重量级锁。</p><p><strong>轻量级锁能替身程序同步性能的依据是“对于绝大部分的锁，在整个同步周期内都是不存在竞争的”，这是一个经验数据。如果没有竞争，轻量级锁使用CAS避免了使用互斥量的开销，但如果存在锁竞争，出了互斥量的开销外，还额外发生了CAS操作，因此在有竞争的情况下，轻量级锁回避传统的重量级锁更慢。</strong></p><h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><p>偏向锁的目的是消除数据在无竞争情况下的同步原语，进一步提高程序的运行性能。<strong>如果说轻量级锁是在无竞争的情况下使用CAS操作去消除同步使用的互斥量，那偏向锁就是在无竞争的情况下把整个同步都消除，连CAS操作都不做了。</strong></p><p>偏向锁的“偏”，意思是这个锁会偏向于第一个获得它的线程，如果在接下来的执行过程中，该锁没有被其他线程的获取，则持有偏向锁的线程将永远不需要再进行同步。</p><p>当有另外一个线程去尝试获取这个锁时，偏向模式就宣告结束。根据锁对象目前是否被锁定的状态，撤销偏向后恢复到未锁定或轻量级锁定的状态，后续的同步操作就如轻量级锁那样执行。</p><p><img src="https://gitee.com/cayzlh/img-repo/raw/master/2020/04/19/1l9bkd.png" alt="偏向锁、轻量级锁的状态转化及对象Mark Word的关系"></p><p>偏向锁可以提高带有不同但无竞争的程序性能。它同样是一个带有利益权衡性质的优化，也就是说它不一定总是对程序运行有利，如果程序中大多数锁都总是被多个不同的线程访问，那偏向模式就是多余的。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>介绍了线程安全涉及的概念和分类、同步实现的方式及虚拟机的底层运作原理，并且介绍了虚拟机实现高效并发所作的一系列锁优化措施。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>周志明，深入理解Java虚拟机：JVM高级特性与最佳实践，机械工业出版社</li></ul>]]></content>
      
      
      <categories>
          
          <category> 书籍 </category>
          
          <category> 《深入理解Java虚拟机》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JVM </tag>
            
            <tag> 《深入理解Java虚拟机》 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java内存模型与线程</title>
      <link href="/blog/2018/09/18/badf9669.html"/>
      <url>/blog/2018/09/18/badf9669.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>并发处理的广泛应用是使得Amdahl定律代替摩尔定律成为计算机性能发展源动力的根本原因，也是人类压榨计算机运算能力最有力的武器。</p></blockquote><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>除了充分利用计算机处理器的能力外，一个服务端同时对多个客户端提供服务是一个具体的并发应用的场景。衡量一个服务器性能的高低好坏，每秒事务处理数（Transactions Per Second，TPS）是最重要的指标之一，它代表着一秒内服务端平均能响应的请求总数，二TPS值与程序的并发能力又有非常密切的关系。对于计算量相同的任务，程序线程并发协调得越有条不紊，效率自然就会越高；反之，线程之间频繁阻塞甚至死锁，将会大大降低程序的并发能力。</p><p>服务端是Java语言最擅长的领域之一，这个领取的应用占了Java应用中最大的一块份额，不过如何写好并发应用程序确实程序开发的难点之一，处理好并发方面的问题通常需要更多的经验。<strong>无论语言、中间件和框架如何先进，我们都不能期望它们能独立完成并发处理的所有事情，了解并发的内幕也是不可缺少的课程。</strong></p><h2 id="硬件的效率与一致性"><a href="#硬件的效率与一致性" class="headerlink" title="硬件的效率与一致性"></a>硬件的效率与一致性</h2><p>由于计算机的存储设备与处理器的运算速度之间有着几个数量级的差距，所以现代计算机系统都不得不加入一层读写尽可能接近处理器运算速度的高速缓存（Cache）来作为内存与处理器之间的缓冲：将运算需要使用的数据赋值到缓存中，让运算能快速进行，当运算结束后再从缓存同步回内存之中，这样处理器就无须等待缓慢的内存读写了。</p><p>基于高速缓存的存储交互很好地解决了处理器与内存地速度矛盾，但是也引入了新的问题：<strong>缓存一致性（Cache Coherence）</strong>。每个处理器都有自己地高速缓存，而它们又共享同一主内存（Main Memory）。当多个处理器地运算任务都涉及同一块主内存区域时，将可能导致各自地缓存数据不一致地情况。为了解决一致性地问题，需要各个处理器访问缓存时都遵循一些协议，在读写时要根据协议来进行操作。<strong>Java虚拟机内存模型中定义地内存访问操作与硬件地缓存访问操作时具有可比性地。</strong></p><p><img src="https://gitee.com/cayzlh/img-repo/raw/master/2020/04/19/WEKuAO.png" alt="处理器、高速缓存、主内存之间地交互关系"></p><p><strong>为了使得处理器内部地运算单元能尽量被充分利用，处理器可能会对输入代码进行乱序执行（Out-Of-Order Execution）优化，处理器会在计算之后将乱序执行地结果重组，保证该结果与顺序执行地结果是一致的，但并不保证程序中各个语句计算的先后顺序与输入代码的顺序一致，因此如果存在一个计算任务依赖另一个计算任务的中间结果，那么其顺序性并不能靠代码的先后顺序来保证。与处理器的乱序执行优化类似，Java虚拟机的即时编译器中也有类似的指令重排序（Instruction Reorder）优化。</strong></p><h2 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h2><p>Java虚拟机规范中试图定义一种Java内存模型（Java Memory Model，JMM）来屏蔽掉各种硬件和操作系统的内存访问差异，以<strong>实现Java程序在各种平台下都能达到一致的并发效果。</strong></p><h3 id="主内存与工作内存"><a href="#主内存与工作内存" class="headerlink" title="主内存与工作内存"></a>主内存与工作内存</h3><p>Java内存模型的主要目标是<strong>定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出来变量这样的底层细节。</strong>此处的变量与Java编程中所说的变量有区别，它包括了实例字段、静态字段和构成数组对象的元素，<strong>但是不包括局部变量与方法参数，因为后者是线程私有的，</strong>不会被共享，自然就不存在竞争问题。</p><blockquote><p>为了获得较好的执行效能，Java内存模型并没有限制执行引擎使用处理器的特定寄存器或缓存来和主内存进行交互，也没有限制即时编译器调整代码执行顺序这类权利。</p></blockquote><p><strong>Java内存模型规定了所有变量都存储在主内存（Main Memory）中。</strong>每条线程还有自己的工作内存（Working Menory，类比高速缓存），<strong>线程的工作内存中保存了该线程使用到的变量的主内存副本拷贝，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存中的变量。</strong>不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量的值传递均需要通过主内存来完成。</p><p><img src="https://gitee.com/cayzlh/img-repo/raw/master/2020/04/19/q9VXLj.png" alt="线程、主内存、工作内存三者的交互关系"></p><p>这里所讲的主内存、工作内存与Java内存区域中的Java堆、栈、方法区等并不是同一个层次的内存划分。<strong>从变量、主内存、工作内存的定义来看，主内存主要对应Java堆中对象的实例数据部分，而工作内存则对应于虚拟机栈中的部分区域。</strong>从更低的层次来说，主内存就是硬件的内存，而为了获得更好的运行速度，虚拟机及硬件系统可能会让工作内存优先存储与寄存器和高速缓存中。</p><h3 id="内存间交互操作"><a href="#内存间交互操作" class="headerlink" title="内存间交互操作"></a>内存间交互操作</h3><p>关于主内存与工作内存之间具体的交互协议，即一个变量如何从主内存拷贝到工作内存、如何从工作内存同步回主内存之类的实现细节，Java内存模型顶了八种操作来完成：</p><ul><li>lock（锁定）：作用于主内存的变量，它把一个变量标识为一条线程独占的状态。</li><li>unlock（解锁）：作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。</li><li>read（读取）：作用于主内存的变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的load动作使用。</li><li>load（载入）：作用于工作内存的变量，它把read操作从内主内存得到的变量值放入工作内存的变量副本中。</li><li>use（使用）：作用于工作内存的变量，它把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用到变量的值的字节码指令时将会执行这个操作。</li><li>assign（赋值）：作用于工作内存的变量，它把一个从执行引擎接收到的值赋值给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。</li><li>store（存储）：作用于工作内存的变量，它把工作内存中一个变量的值传递到主内存中，以便随后的write操作使用。</li><li>write（写入）：作用于主内存的变量，它把store操作从工作内存中得到的变量值放入主内存的变量中。</li></ul><p>如果要把一个变量从主内存复制到工作内存，那就要按顺序执行<code>read</code>和<code>load</code>操作，如果要把变量从工作内存同步回主内存，就要按顺序地执行<code>store</code>和<code>write</code>操作。</p><blockquote><p>Java内存模型只要求上述两个操作必须按顺序执行，而没有保证必须连续执行。</p></blockquote><p>Java内存模型还规定了在执行上述八种基本操作时必须满足：</p><ul><li>不允许<code>read</code>和<code>load</code>、<code>store</code>和<code>write</code>操作之一单独出现，即不允许一个变量从主内存读取了但工作内存不接受，或者从工作内存发起回写了但主内存不接受地情况出现。</li><li>不允许一个线程丢弃它最忌你地<code>assign</code>操作，即变量在工作内存中改变了之后必须把该变化同步回主内存。</li><li>不允许一个线程无原因地把数据从线程地工作内存同步回主内存中。</li><li>一个新的变量只能在主内存中诞生，不允许在工作内存中直接使用一个未被初始化（<code>load</code>或<code>assign</code>）的变量，换句话说就是对一个变量实施<code>use</code>和<code>store</code>操作之前，必须先执行过了<code>assign</code>和<code>load</code>操作。</li><li>一个变量在同一个时刻只允许一条线程对其进行<code>lock</code>操作，但lock操作可以被同一条线程重复执行多次，多次执行<code>lock</code>后，只有执行相同次数的<code>unlock</code>操作，变量才会被解锁。</li><li>如果对一个变量执行<code>lock</code>操作，将会晴空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行<code>load</code>或<code>assign</code>操作初始化变量的值。</li><li>如果一个变量事先没有被<code>lock</code>操作锁定，则不允许对它执行<code>unlock</code>操作；也不允许<code>unlock</code>一个被其他线程锁定住的变量。</li><li>对一个变量执行<code>unlock</code>操作之前，必须先把此变量同步回住内存中（执行<code>store</code>和<code>write</code>操作）。</li></ul><h3 id="对于volatile型变量的特殊规则"><a href="#对于volatile型变量的特殊规则" class="headerlink" title="对于volatile型变量的特殊规则"></a>对于volatile型变量的特殊规则</h3><blockquote><p>关键字<code>volatile</code>可以说是Java虚拟机提供的最轻量级的同步机制，但是它并不容易被正确地、完整地理解，以至于很多时候都不去使用它，遇到需要处理多线程数据竞争的时候一律使用<code>synchronize</code>来进行同步。</p></blockquote><p><strong>当一个变量被定义成<code>volatile</code>之后，它将具备两种特性：</strong></p><h4 id="第一"><a href="#第一" class="headerlink" title="第一"></a>第一</h4><p><strong>保证此变量对所有线程的可见性</strong>，这里的“可见性”是指当一条线程修改了这个变量的值，新值对于其他线程来说是可以立即得知的。而普通变量不能做到这一点，变量值在线程间传递均需要通过主内存来完成。</p><p><em><code>volatile</code>变量在各个线程的工作内存中不存在一执行问题（在各个线程的工作内存中<code>volatile</code>变量也可以存在不一致的情况，但是由于每次使用之前都要先刷新，执行引擎看不到不一致的情况，因此可以认为不存在一执行问题），但是Java里面的运算并非原子操作，导致<code>volatile</code>变量的运算在并发下一样不是安全的。</em></p><p>一条字节码指令在解释执行时，解释器将要运行许多行代码才能实现它的语义，如果是编译执行，一条字节码指令也可能转化成若干条本地机器码指令。</p><p><strong>由于<code>volatile</code>变量只能保证可见性，在不符合以下两种规则的运算场景中，仍然要通过枷锁（使用<code>synchronized</code>或<code>java.util.concurrent</code>中的原子类）来保证原子性。</strong></p><ol><li>运算结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值。</li><li>变量不需要与其他的状态变量共同参与不变约束。</li></ol><p>使用使用<code>volatile</code>来控制并发的代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">boolean</span> shutdownRequested;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    shutdownRequested = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doWork</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (!shutdownRequested) &#123;</span><br><span class="line">        <span class="comment">// do stuff</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="第二"><a href="#第二" class="headerlink" title="第二"></a>第二</h4><p><strong>禁止指令重排序优化</strong>，普通的变量仅仅会保证在该方法的执行过程中所有依赖赋值结果的地方都能获取到正确的结果，而不能保证变量赋值操作的顺序与程序代码中的执行顺序一致。<strong>因为在一个线程的方法执行过程中无法感知到这点，这就是Java内存模型中描述的所谓的“线程内存表现为串行的语义”（Within-Thread As-If-Serial Semantics）。</strong></p><p>指令重排序会干扰程序的并罚执行的例子：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map configOptions;</span><br><span class="line"><span class="keyword">char</span>[] configText;</span><br><span class="line"><span class="comment">// 此变量必须定义为volatile</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">boolean</span> initialized = <span class="keyword">false</span>;</span><br><span class="line"><span class="comment">// 假设以下代码在线程A中执行</span></span><br><span class="line"><span class="comment">// 模拟读取配置信息，当读取完成后，将initialized设置为true来通知其他线程配置可用</span></span><br><span class="line">configOptions = <span class="keyword">new</span> HashMap();</span><br><span class="line">configText = readConfigFile(fileName);</span><br><span class="line">processConfigOptions(configText, configOptions);</span><br><span class="line">initialized = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 假设以下代码在线程B中执行</span></span><br><span class="line"><span class="comment">// 等待initialized为true，代表线程A已经把配置信息初始化完成　</span></span><br><span class="line"><span class="keyword">while</span> (!initialized) &#123;</span><br><span class="line">    sleep();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用线程A中初始化好的配置信息</span></span><br><span class="line">doSomethingWithConfig();</span><br></pre></td></tr></table></figure><p>这段伪代码描述的场景十分常见，只是我们在处理配置文件时一般不会出现并发而已。如果<code>initialized</code>没有使用<code>volatile</code>修饰，就可能会由于指令重排序的优化，导致线程A中最后一句中的“initialized = true;”被提前执行，这样线程B中使用配置信息的代码就可能出现错误，而<code>volatile</code>可以避免这类情况的发生。</p><h4 id="Java内存模型中对volatile变量定义的特殊规则。"><a href="#Java内存模型中对volatile变量定义的特殊规则。" class="headerlink" title="Java内存模型中对volatile变量定义的特殊规则。"></a>Java内存模型中对<code>volatile</code>变量定义的特殊规则。</h4><p>假定T表示一个线程，V和W分别表示两个<code>volatile</code>型变量，那么在进行<code>read</code>、<code>load</code>、<code>use</code>、<code>asign</code>、<code>store</code>和<code>write</code>操作时需要满足如下的规则：</p><ul><li>只有当线程T对变量V执行的前一个动作时load的时候，线程T才能对变量V执行<code>use</code>动作；并且，只有线程T对变量V执行的后一个动作时<code>use</code>的时候，线程T才能对V执行<code>load</code>动作。程序T对变量V的<code>use</code>动作可以认为是与线程T对变量V的<code>load</code>和<code>read</code>动作相关联的，必须一起连续出现。（<strong>这条规则要求在工作内存中，每次使用V前都必须从主内存刷新最先的值，用于保证能看见其他线程对变量V所做的修改后的值</strong>）。</li><li>只有当线程T对变量V执行的前一个动作时<code>assign</code>的时候， 线程T才能对变量V执行<code>store</code>动作；并且，只有当线程T对变量执行的后一个动作时<code>store</code>的时候，线程T才能对变量V执行<code>assign</code>动作。线程T对变量V的<code>assign</code>动作可以认为是与线程T对变量V的<code>store</code>和<code>writy</code>动作相关联的，必须一起连续出现（<strong>这条规则要求在工作内存中，每次修改V后都必须立刻同步回主内存中，用于保证其他线程可以看到自己对变量V所做的的修改</strong>）。</li><li>假定动作A是线程T对变量V实施的<code>use</code>或<code>assign</code>动作，假定动作F是与动作A相关联的<code>load</code>和<code>store</code>动作，假定动作P是与动作F相应的对变量V的<code>read</code>或<code>write</code>动作；类似的，假定动作B是线程T对变量W实施的<code>use</code>或<code>assign</code>动作，假定动作G是与动作B相关的<code>load</code>或<code>store</code>动作，假定动作Q是与动作G相应的对变量W的<code>read</code>或<code>write</code>动作。如果A先于B，那么P先于Q（<strong>这条规则要求<code>volatile</code>修饰的变量不回呗指令重排序优化，保证代码的执行顺序与程序的顺序相同</strong>）。</li></ul><h3 id="对于long和double型变量的特殊规则"><a href="#对于long和double型变量的特殊规则" class="headerlink" title="对于long和double型变量的特殊规则"></a>对于long和double型变量的特殊规则</h3><p>Java内存模型要求<code>lock</code>、<code>unlock</code>、<code>read</code>、<code>load</code>、<code>assign</code>、<code>use</code>、<code>store</code>和<code>write</code>这八个操作都具有原子性，但是对于64位的数据类型（<code>long</code>和<code>double</code>），在模型中特别定义了一条宽松的规定：允许虚拟机将没有被<code>volatile</code>修饰的64位数据的读写操作划分为两次32位的操作来进行，即允许虚拟机实现选择可以不保证64位数据类型的<code>load</code>、<code>store</code>、<code>read</code>和<code>write</code>这四个操作的原子性，这点就是所谓的<strong>long和double的非原子性协定</strong>。在编写代码时一般不需要将用到的long和double变量专门声明为<code>volatile</code>。</p><h3 id="原子性、可见性与有序性"><a href="#原子性、可见性与有序性" class="headerlink" title="原子性、可见性与有序性"></a>原子性、可见性与有序性</h3><p>Java内存模型时围绕着在并发过程中如何处理<strong>原子性、可见性和有序性</strong>这三个特征来建立的。</p><h4 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h4><p>由Java内存模型来直接保证的原子性变量操作包括<code>read</code>、<code>load</code>、<code>assign</code>、<code>use</code>、<code>store</code>和<code>write</code>这六个，大致可以认为基本数据类型的访问和读写时具备原子性的。</p><blockquote><p>如果需要一个更大范围的原子性保证，Java内存模型提供了<code>lock</code>和<code>unlock</code>操作来满足这种需求，尽管虚拟机未把<code>lock</code>和<code>unlock</code>操作直接开放给用户使用，但是却提供了更高层次的字节码指令<code>monitorenter</code>和<code>monitorexit</code>来隐式地使用这两个操作，这两个字节码反映到Java代码中就是痛不快——<code>synchronized</code>关键字，因此在<code>synchronized</code>块之间的操作也具备原子性。</p></blockquote><h4 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h4><p>可见性是指当一个线程修改了共享变量的值，其他线程能够立即得知这个修改。<strong>Java内存模型时通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值这种依赖主内存作为传递媒介的方式来实现可见性的，无论是普通的变量还是<code>volatile</code>变量都是如此，普通变量与<code>volatile</code>变量的区别是<code>volatile</code>的特殊规则保证了新值能立即同步到主内存，以及每次使用前立即从主内存刷新。</strong></p><blockquote><p>除了<code>volatile</code>外，Java的<code>synchronized</code>和<code>final</code>关键字也能实现可见性。</p></blockquote><h4 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h4><p><strong>如果在本线程内观察，所有的操作都是有序的；如果在一个线程中观察另一个线程，所有的操作都是无序的。</strong>前半句是指“线程内表现为串行的语义”，后半句是指“指令重排序现象”和“工作内存与主内存同步延迟”现象。</p><blockquote><p>Java语言提供了<code>volatile</code>和<code>synchronized</code>两个关键字来保证线程之间的操作的有序性，<code>volatile</code>关键字本身就包含了禁止指令重排序的语义，而<code>synchronized</code>则是由“一个变量在同一个时刻只允许一条线程对其进行<code>lock</code>操作”这条规则获得的，这个规则决定了持有同一个锁的两个同步块只能串行地进入。</p></blockquote><h3 id="先行发生原则"><a href="#先行发生原则" class="headerlink" title="先行发生原则"></a>先行发生原则</h3><p><strong>先行发生时Java内存模型中定义的两项操作之间的偏序关系，如果说操作A先行发生与操作B，其实就是说在发生操作B之前，操作A产生的影响能呗操作B观察到</strong>，“影响”包括修改了内存中共享变量的值、发送了消息、调用了方法等。</p><h4 id="Java内存模型下一些天然的先行发生关系："><a href="#Java内存模型下一些天然的先行发生关系：" class="headerlink" title="Java内存模型下一些天然的先行发生关系："></a>Java内存模型下一些天然的先行发生关系：</h4><ul><li>程序次序规则：在一个线程内，按照程序代码顺序，书写在前面的操作先行发生与书写在后面的操作。准确的说应该是控制流顺序而不是程序代码顺序，因为要考虑分支、循环等结构。</li><li>管程锁规则：一个unlock操作先行发生于后面对同一个锁的lock操作。这里必须强调的是同一个锁，而后面是指时间上的先后顺序。</li><li><code>volatile</code>变量规则：对一个<code>volatile</code>变量的写操作先行发生于后面对这个变量的毒操作，这里的后面同样是指时间上的先后顺序。</li><li>线程启动规则：<code>Thread</code>对象的<code>start()</code>方法先行发生于此线程的每一个动作。</li><li>线程终止规则：线程的所有操作都先行发生于此线程的终止检测。</li><li>线程中断规则：对线程<code>interrupt()</code>方法的调用先行发生于被中断线程的代码检测到中断事件的发生。</li><li>对象终结规则：一个对象的初始化完成先行发生于它的<code>finalize()</code>方法的开始。</li><li>传递性：如果操作A先行发生于操作B，操作B先行发生于C，那就可以得出A操作先行发生于操作C的结论。</li></ul><p><strong>事件上先后顺序与先行发生原则之间基本没有太大的关系，所以我们衡量并发安全问题时不要收到事件顺序的干扰，一切必须以先行发生原则为准。</strong></p><h2 id="Java与线程"><a href="#Java与线程" class="headerlink" title="Java与线程"></a>Java与线程</h2><p><em>并发不一定要依赖多线程，但是在Java里面谈论并发，大多数都与线程脱不开关系。</em></p><h3 id="线程的实现"><a href="#线程的实现" class="headerlink" title="线程的实现"></a>线程的实现</h3><p>主流的操作系统都提供了线程实现，<strong>Java语言则提供了在不同硬件和操作系统平台下对线程操作的统一处理，每个<code>java.lang.Thread</code>类的实例就代表了一个线程。</strong>不过Thread类与大部分的Java API有着显著的区别，它的所有关键方法都被声明为Native。在Java API中一个Native方法可能就以为着这个方法没有使用或无法使用平台无关的手段来实现。</p><p>实现线程主要有三种方式：<strong>使用内核实现，使用用户线程实现，使用用户线程加轻量级进程混合实现。</strong></p><h4 id="使用内核线程实现"><a href="#使用内核线程实现" class="headerlink" title="使用内核线程实现"></a>使用内核线程实现</h4><p>直接由操作系统内核支持的线程，这种线程由内核线程来完成切换，内核通过操纵调度器对线程进行调度，并负责将线程的任务映射到各个处理器上。<strong>程序一般不会直接去使用内核线程，而是使用内核线程的一种高级接口——轻量级进程，轻量级进程就是我们通常意义上所将的线程，由于每个轻量级进程都由一个内核线程支持，因此只有先支持内核线程，才能有轻量级进程。</strong></p><p><img src="https://gitee.com/cayzlh/img-repo/raw/master/2020/04/19/uzlRTG.png" alt="轻量级进程与内核线程之间1:1的关系"></p><p>由于内核线程的支持，每个轻量级进程都成为一个独立的调度单元，即使有一个轻量级进程在系统调用中阻塞了，也不会影响整个进程继续工作，但是轻量级进程具有它的局限性：<strong>首先，由于是基于内核线程实现的，所以各种进程操作，如创建、析构及同步，都需要进行系统调用。</strong>而系统调用的代价相对较高，需要在用户态和内核态中来回切换。其次，每个轻量级进程都需要有一个内核线程的支持，因此轻量级进程要消耗一定的内核资源，因此一个系统支持轻量级进程的数量是有限的。</p><h4 id="使用用户线程实现"><a href="#使用用户线程实现" class="headerlink" title="使用用户线程实现"></a>使用用户线程实现</h4><p>广义上来讲，一个线程只要不是内核线程，那就可以认为是用户线程，因此从这个定义上来讲轻量级进程也属于用户线程，但轻量级进程的实现始终是建立在内核之上的，许多操作都要进行系统嗲用，因此效率会收到限制。</p><p>狭义上来讲，用户的线程指的是完全建立在用户空间的线程库上，系统内核不能感知到线程存在的实现。<strong>用户线程的建立、同步、销毁和调度完全在用户态中完成，不需要内核的帮助。</strong>如果程序实现得当，这种线程不需要切换到内核态，因此操作可以是非常快且低消耗的，也可以支持规模更大的线程数量，部分高性能数据库中的多线程就是由用户线程实现的。</p><p><img src="https://gitee.com/cayzlh/img-repo/raw/master/2020/04/19/eMtx7A.png" alt="进程与用户线程之间1:N的关系"></p><p><em>使用用户线程的优势在于不需要系统内核支援，劣势在于没有系统内核的支援，所有的线程操作都需要用户程序自己处理。</em>线程的创建、切换和调度都是需要考虑问题。</p><h4 id="混合实现"><a href="#混合实现" class="headerlink" title="混合实现"></a>混合实现</h4><p>线程除了依赖内核线程实现和完全由用户程序自己实现之外，还有一种将内核线程与用户线程一起使用的实现方式。在这种混合实现下，既有用户线程，也存在轻量级进程。用户县城还是完全建立在用户空间中，因此用户线程的创建、切换、析构等操作依然廉价，并且可以支持大规模的用户线程并发。而操作系统提供支持的轻量级进程则作为用户线程和内核线程之间的桥梁，这样可以使用内核提供的线程调度功能及处理器映射，并且用户线程的系统调用要通过轻量级线程来完成，大大降低了进程被阻塞的风险。</p><p><img src="https://gitee.com/cayzlh/img-repo/raw/master/2020/04/19/GMf8rD.png" alt="用户线程与轻量级进程之间M:N的关系"></p><h4 id="Java线程的实现"><a href="#Java线程的实现" class="headerlink" title="Java线程的实现"></a>Java线程的实现</h4><p>操作系统支持怎样的线程模型，在很大成都上就决定了Java虚拟机的线程是怎么样映射的，这点在不同的平台上没有办法达成一致，虚拟机规范中也并未限定Java线程需要使用哪种线程模型来实现。</p><h3 id="Java线程调度"><a href="#Java线程调度" class="headerlink" title="Java线程调度"></a>Java线程调度</h3><p>线程调度是指系统为线程分配处理器使用权的过程，主要调度方式有两种，分别是<strong>协同式线程调度和抢占式线程调度。</strong></p><h4 id="协同式调度"><a href="#协同式调度" class="headerlink" title="协同式调度"></a>协同式调度</h4><p>线程的执行时间由线程本身来控制，线程把自己的工作执行完了之后，要主动通知系统切换到另外一个线程上去。协同式多线程的最大好处是实现简单，而且由于线程要把自己的事情干完后才会进行线程切换，切换操作对线程自己是可知的，所以没有什么线程同步的问题。</p><h4 id="抢占式调度"><a href="#抢占式调度" class="headerlink" title="抢占式调度"></a>抢占式调度</h4><p>每个线程由系统来分配执行时间，线程的切换不由线程本身来决定。在这种实现线程调度的方式下，线程的执行时间是系统可控的，也不会有一个线程导致整个进程阻塞的问题，<strong>Java使用的线程调度方式就是抢占式调度。</strong></p><h3 id="状态转换"><a href="#状态转换" class="headerlink" title="状态转换"></a>状态转换</h3><p>Java定义了5种进程状态，在任意一个时间点中，一个进程只能由且只有一种状态：</p><ul><li>新建：创建后尚未启动的线程处于这种状态</li><li>运行：Runable包括了操作系统线程状态中的Running和Ready，也就是处于此状态的线程有可能正在执行，也有可能正在等待着CPU为它分配执行时间。</li><li>无限期等待：处于这种状态的进程不会被分配CPU执行时间，它们要等待被其他线程显式地唤醒。以下方法会让线程陷入无限期等待状态：<ul><li>没有设置Timeout参数地Object.wait()方法。</li><li>没有设置Timeout参数地Thread.join()方法。</li><li>LockSupport.park()方法。</li></ul></li><li>限期等待：处于这种状态的进程也不会分配CPU执行时间，不过无须等待被其他线程显式唤醒，在一定时间之后他们会由系统自动唤醒。以下方法会让线程进入限期等待状态：<ul><li>Thread.sleep()方法。</li><li>设置了Timeout参数的Object.wait()方法。</li><li>设置了Timeout参数的Thread.join()方法。</li><li>LockSupport.parkNanos()方法。</li><li>LockSupport.parkUntil()方法。</li></ul></li><li>阻塞：进程被阻塞了，阻塞状态在等待着获取到一个排他锁，这个事件将在另外一个线程放弃这个锁的时候发生；等待状态则是在等待一段时间，或者唤醒动作的发生。在程序等待进入同步区域的时候， 线程将进入这种状态。</li><li>结束：已终止线程的线程状态，线程已经结束执行。</li></ul><p>线程状态转换关系：</p><p><img src="https://gitee.com/cayzlh/img-repo/raw/master/2020/04/19/a34Lkz.png" alt="线程状态转换关系"></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>了解了虚拟机Java内存模型的结构及操作，讲解了原子性、可见性、有序性在Java内存模型中的体现，先行发生原则的规则及使用。还有线程在Java语言之中时如何实现的。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>周志明，深入理解Java虚拟机：JVM高级特性与最佳实践，机械工业出版社</li><li><a href="https://www.google.com/imghp?hl=zh-CN&tab=wi">图片来源</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 书籍 </category>
          
          <category> 《深入理解Java虚拟机》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JVM </tag>
            
            <tag> 《深入理解Java虚拟机》 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>虚拟机字节码执行引擎</title>
      <link href="/blog/2018/09/16/4cd43d51.html"/>
      <url>/blog/2018/09/16/4cd43d51.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>代码编译的结果从本地机器码变为字节码，是存储格式发展的一小步，确实编程语言发展的一大步</p></blockquote><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>执行引擎是Java虚拟机最核心的组成部分之一。“虚拟机”是一个相对于“物理机”的概念，这两种机器都有代码执行能力，其区别是物理机的执行引擎是直接建立在处理器、硬件、指令集和操作系统层面上的，而<strong>虚拟机的执行引擎则是由自己实现的，因此可以自行制定指令集与执行引擎的结构体系，并且能够执行哪些不被硬件直接支持的指令集够格式。</strong></p><p>Java虚拟机规范中制定了虚拟机字节码执行引擎的概念模型，这个概念模型成为各种虚拟机执行引擎的统一外观（Facade）。在不同的虚拟机实现里面，执行引擎在执行Java代码的时候可能有<strong>解释执行（通过解释器执行）</strong>和<strong>编译执行（通过即时编译器产生本地代码执行）</strong>两种选择，也可能两者兼备，甚至还可能包含几个不同级别的编译器执行引擎。但从外观上看起来，<strong>所有Java虚拟机的执行引擎都是一致的：输入的是字节码文件，处理过程是字节码解析的等效过程，输出的是执行结果。</strong></p><h2 id="运行时栈帧结构"><a href="#运行时栈帧结构" class="headerlink" title="运行时栈帧结构"></a>运行时栈帧结构</h2><p>栈帧（Stack Frame）是用于支持虚拟机进行方法调用和方法执行的数据结构，它是虚拟机运行时数据区中的虚拟机栈的栈元素。<strong>栈帧存储的方法的的局部变量表、操作数栈、动态连接和方法返回地址等信息。</strong> <em>每一个方法从调用开始到执行完成的过程，就对应着一个栈帧在虚拟机栈里面从入栈道出栈的过程。</em></p><blockquote><p>每一个栈帧都包括了局部变量表、操作数栈、动态连接、方法返回地址和一些额外的附加信息。在编译程序代码的时候，栈帧中需要多大的局部变量表、多深的操作数栈都已经完全确定了，并且写入到方法表的<code>Code</code>属性之中，因此<strong>一个栈帧需要分配多少内存，不会收到程序运行期变量数据的影响，而仅仅取决于具体的虚拟机实现</strong>。</p></blockquote><p>一个线程中的方法调用链可能回很长，很多方法都同事处于执行状态。对于执行引擎来讲，活动线程中，只有栈顶是有效的，称为当前栈帧，这个栈帧所关联的方法称为当前方法。<strong>执行引擎所运行的所有字节码指令都只针对当前栈帧进行操作。</strong></p><p><img src="https://gitee.com/cayzlh/img-repo/raw/master/2020/04/19/EZRTAh.png" alt="栈帧的概念结构"></p><h3 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h3><p><strong>局部变量表是一组变量值存储空间，用于存放方法参数和方法内部定义的局部变量。Java程序被编译为Class文件时，就在方法的Code属性的mac_locals数据项中确定了该方法所需要分配的最大局部变量表的容量。</strong></p><p>局部变量表的容量以变量槽（Variable Slot）为最小单位，虚拟机规范中没有明确指明一个Slot应占内存空间大小，只是说明每个Slot都应该能存放一个boolean、btye、char、short、int、float、reference或returnAddress类型的数据，它允许Slot的长度随着处理器、操作系统或虚拟机的不同而发生变化。<strong>不过无论如何，即使在64位虚拟机中使用了64位长度的内存空间里爱实现一个Slot，虚拟机仍要使用对齐和补白的手段让Slot在外观上看起来与32位虚拟机的一致。</strong></p><blockquote><p>对于64位的数据类型，虚拟机会以高位在前的方式为其分配两个连续的Slot空间。Java语言中明确规定的64位的数据类型只有long和double两种。</p><p><strong>这里把long和double数据类型分割存储的做法与“long和double的非原子性协定”中把long和double数据类型读写分割为两次32位读写的做法类似。不过，由于局部变量表建立在线程的对战上，是线程私有的数据，无论读写两个连续的Slot是否是原子操作，都不会引起数据安全问题。</strong></p></blockquote><p>虚拟机通过索引定位的方式使用局部变量表，索引值的范围是从0开始到局部变量表最大的Slot变量。如果是32位数据类型的变量，索引n就代表了使用第n个Slot，如果是64位数据类型的变量，则说明要使用第n和第n+1两个Slot。</p><h3 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h3><p><strong>操作数栈也常被称为操作栈，是一个后入先出（Last In First Out，LIFO）栈。</strong>同局部变量表一样，操作栈的最大深度也在编译的时候被写入到Code属性的max_stacks数据项中。操作栈的每一个元素可以是任意Java数据类型，包括long和double。32位的数据类型所栈的栈容量为1，64位的数据类型所占的栈容量为2。<strong>在方法执行的任何时候，操作数栈的深度都不会超过在max_stacks数据项中设定的最大值。</strong></p><p>当一个方法刚刚开始执行的时候，这个方法的操作数栈是空的，在方法的执行过程中，会有各种字节码指令向操作数栈中写入和提取内容，也就是入栈出栈操作。</p><blockquote><p>例如，在做算术运算的时候是通过操作数栈来进行的，又或者在调用其他方法的时候是通过操作数栈来进行参数传递的。</p><p>举个例子，整数加法的字节码指令<code>iadd</code>在运行的时候要求操作数栈中最接近栈顶的两个元素已经存入了两个<code>int</code>型的数值，当执行这个指令时，会将这两个<code>int</code>值出栈并相加，然后将相加的结果入栈。</p></blockquote><p>在概念模型中，两个栈帧作为虚拟机栈的元素，相互之间时完全独立的。但是大多数虚拟机的实现里都会做一些优化处理，令两个栈帧出现一部分重叠。让下面栈帧的部分操作数栈与上面栈帧的部分局部变量表重叠在一起，这样在进行方法调用时就可以共用一部分数据，而无须进行额外的参数复制传递了。</p><p><img src="https://gitee.com/cayzlh/img-repo/raw/master/2020/04/19/LMjrzh.png" alt="两个栈帧之间数据共享"></p><p><strong>Java虚拟机的解释执行引擎称为“基于栈的执行引擎”，其中所指的“栈”就是操作数栈。</strong></p><h3 id="动态连接"><a href="#动态连接" class="headerlink" title="动态连接"></a>动态连接</h3><p>每个栈帧都包含一个指向运行时常量池中该栈所属的方法的引用，持有这个引用时为了支持方法调用过程中的动态连接。字节码中的方法调用指令就以常量池中指向方法的符号引用为参数。这些符号引用一部分会在类加载阶段或第一次使用的时候转化为直接引用，这种转化称为静态解析。另外一部分将在每一次的运行期间转化为直接引用，这部分称为动态连接。</p><h3 id="方法返回地址"><a href="#方法返回地址" class="headerlink" title="方法返回地址"></a>方法返回地址</h3><p>当一个方法被执行后，有两种方式退出这个方法。</p><ul><li>执行引擎遇到任意一个方法返回的字节码指令，这个时候可能会有返回值传递给上层的方法调用者，是否有返回值和返回值的类型将根据遇到何种方法返回指令来决定，这种退出方法的方式称为正常完成出口。</li><li>在方法执行过程中遇到了异常，并且这个异常没有在方法体内得到处理，无论是Java虚拟机内部产生的异常，还是代码中使用<code>athrow</code>字节码指令产生的异常，只要在本方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出，这种退出方法的方式称为异常完成出口。一个方法使用异常完成出口的方式退出，是不会给它的上层调用者产生返回值的。</li></ul><p>无论采用何种退出方式，在方法退出之后，都需要返回到方法被调用的位置，程序藏能继续执行，方法返回时可能需要在栈帧中保存一些信息，用来帮助恢复它的上层方法执行状态。一般来说，方法正常退出时，调用者的PC计数器的值就可以作为返回地址，栈帧中很可能会保存这个计数器值。而方法异常退出时，返回地址时要通过异常处理器表来确定的，栈帧中一般不会保存这部分信息。</p><blockquote><p>方法退出的过程实际上等同于把当前栈帧出栈，因此退出时可能执行的操作有：</p><ul><li>恢复上层方法的局部变量表和操作数栈</li><li>把返回值压入调用者栈帧的操作数栈中</li><li>调整PC计数器的值以指向方法调用指令后面的一条指令</li></ul></blockquote><h3 id="附加信息"><a href="#附加信息" class="headerlink" title="附加信息"></a>附加信息</h3><p>虚拟机规范允许具体的虚拟机实现增加一些规范里没有描述的信息到栈帧之中，例如与调试相关的信息，这部分信息完全取决于具体的虚拟机实现。在实际开发中，一般会把动态连接、方法返回地址与其他附加信息全部归位一类，称为栈帧信息。</p><h2 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h2><p><strong>方法调用并不等同于方法执行，方法调用阶段唯一的任务就是确定被调用方法的版本（即调用哪一个方法），暂时还不涉及方法内部的具体运行过程。</strong></p><blockquote><p>在程序运行时，进行方法调用时最普遍、最频繁的操作，但前面已经讲过，Class文件进行编译过程中不包含传统编译中的连续步骤，一切方法调用在Class文件里存储的都只是符号引用，而不是方法在实际运行时内存布局中的入口地址。这个特性给Java带来了更强大的动态扩展能力，但也使得Java方法的调用过程变得相对复杂起来，需要在类加载期间甚至到运行期间才能确定目标方法的直接引用。</p></blockquote><h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>所有方法调用中的目标方法在Class文件里面都是一个常量池的符号引用，在类加载的解析阶段，会将其中的一部分符号引用转化为直接引用，这种解析能成立的前提是：<strong>方法在程序真正执行之前就有一个确定的调用版本，这种解析能成立的前提是：方法在程序真正运行之前就有一个可确定的调用版本，并且这个方法的调用版本在运行期是不可改变的。</strong>换句话说，调用目标在程序代码写好、编译器进行编译时就必须确定下来。这类方法的调用称为解析。</p><blockquote><p>在Java语言中，符合“编译器可知，运行期不可变”这个要求的方法主要有静态方法和私有方法两大类，前者与类型直接关联，后者在外部不可被访问，这两种方法都不可能通过继承或别的方式充血出其他版本，因此它们都适合在类加载阶段进行解析。</p></blockquote><p>解析调用一定是个静态的过程，在编译期间就完全确定，在类装载的解析阶段就会把涉及的符号引用全部转变为可确定的直接引用，不会延迟到运行期再去完成。而分派调用则可能时静态的也可能时动态的，根据分派一句的宗量数可分为单分派和多分派。这两类分派方式两两组合就构成了静态单分派、静态多分派、动态单分派、动态多分派四种分派情况。</p><h3 id="分派"><a href="#分派" class="headerlink" title="分派"></a>分派</h3><p>Java是一门面向对象的程序设计语言，因为Java具备面向对象的三个特征：继承、封装和多态。分派调用过程将会揭示多态特性的一些最基本的体现（如“重载”和“重写”）。</p><h4 id="静态分派"><a href="#静态分派" class="headerlink" title="静态分派"></a>静态分派</h4><p>代码清单（方法静态分派演示）：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.cayzlh.demo;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 方法静态分派演示</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticDispatch</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Human</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Man</span> <span class="keyword">extends</span> <span class="title">Human</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Woman</span> <span class="keyword">extends</span> <span class="title">Human</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(Human guy)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello, guy!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(Man guy)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello, gentleman!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(Woman guy)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello, lady!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Human man = <span class="keyword">new</span> Man();</span><br><span class="line">        Human women = <span class="keyword">new</span> Woman();</span><br><span class="line"></span><br><span class="line">        StaticDispatch sd = <span class="keyword">new</span> StaticDispatch();</span><br><span class="line">        sd.sayHello(man);</span><br><span class="line">        sd.sayHello(women);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Hello, guy!</span><br><span class="line">Hello, guy!</span><br></pre></td></tr></table></figure><p>相信对Java稍微有经验的程序员看完程序后都能得出正确的运行结果，但为什么会选择执行参数类型为human的重载呢？在解决这个问题之前，先按如下代码定义两个重要的概念：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Human man = <span class="keyword">new</span> Man();</span><br></pre></td></tr></table></figure><p>把上面代码中的“Human”称为变量的静态类型（Static Type）或者外观类型（Apparent Type），后面的“Man”则称为变量的实际类型（Actual Type），静态类型和实际类型在程序中都可以发生一些变化，区别是静态类型的变化仅仅在使用时发生，变量本身的静态变量类型不会改变，并且最终的静态类型是在编译期可知的；而实际类型变化的结果在运行期才可确定，编译器在编译程序的时候并不知道一个对象的实际类型是什么。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 实际类型变化</span></span><br><span class="line">Human man = <span class="keyword">new</span> Man();</span><br><span class="line">man = <span class="keyword">new</span> Women();</span><br><span class="line"><span class="comment">// 静态类型变化</span></span><br><span class="line">sd.sayHello((Man) man);</span><br><span class="line">sd.sayHello((Women) women);</span><br></pre></td></tr></table></figure><p>会到代码中，<code>main()</code>里面两次<code>sayHello()</code>方法调用，在方法接收者已经确定是对象<code>sd</code>的前提下，使用哪个重载版本，就完全取决于传入参数的数量和数据类型。<strong>代码中定义了两个静态类型相同、实际类型不同的变量，单虚拟机在重载时是通过参数的静态类型而不是实际类型作为判定依据的。</strong>并且静态类型是编译期可知的，所以在编译阶段，Javac编译器就根据参数的静态类型决定使用哪个重载版本。</p><p><strong>所有依赖静态类型来定位方法执行版本的分派动作，都称为静态分派。</strong>静态分派的最典型应用就是方法重载。静态分派发生在编译阶段，因此静态分派的动作实际上不是由虚拟机来执行的。另外，编译器虽然能确定出方法的重载版本，但在很多情况下这个重载版本并不是“唯一的”，往往只能确定一个“更加适合的”版本。</p><h4 id="动态分派"><a href="#动态分派" class="headerlink" title="动态分派"></a>动态分派</h4><p>动态分派和多态性的另外一个重要体现——重写（Override）有着很密切的关联。</p><p>代码清单：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.cayzlh.demo;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 方法动态分派演示</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicDispatch</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Man</span> <span class="keyword">extends</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;man say hello&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Women</span> <span class="keyword">extends</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;women say hello&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Human man = <span class="keyword">new</span> Man();</span><br><span class="line">        Human women = <span class="keyword">new</span> Women();</span><br><span class="line"></span><br><span class="line">        man.sayHello();</span><br><span class="line">        women.sayHello();</span><br><span class="line"></span><br><span class="line">        man = <span class="keyword">new</span> Women();</span><br><span class="line">        man.sayHello();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">man say hello</span><br><span class="line">women say hello</span><br><span class="line">women say hello</span><br></pre></td></tr></table></figure><p>显然这里是不可能根据静态类型来决定的，因为静态类型都是<code>Human</code>的两个变量<code>man</code>和<code>women</code>在调用<code>sayHello()</code>方法时执行了不同的行为，并且变量<code>man</code>在两次调用中执行了不同的方法。导致这个现象的原因很明显，是这两个变量的实际类型不同。</p><h4 id="单分派与多分派"><a href="#单分派与多分派" class="headerlink" title="单分派与多分派"></a>单分派与多分派</h4><p>方法的接收者与方法的参数统称为方法的宗量。根据分派基于多少种宗量，可以将分派划分为单分派和多分派两种。单分派是根据一个宗量对目标进行选择，多分派则是根据多余一个的宗量对目标进行选择。</p><p>代码清单（列举一个Father和Son一起来做出“一个艰难的决定”的例子）：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.cayzlh.demo;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 单分派与多分派</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dispatch</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">QQ</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">_360</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hardChoice</span><span class="params">(QQ arg)</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;father choose qq&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hardChoice</span><span class="params">(_360 arg)</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;father choose 360&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hardChoice</span><span class="params">(QQ arg)</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;son choose qq&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hardChoice</span><span class="params">(_360 arg)</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;son choose 360&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Father father = <span class="keyword">new</span> Father();</span><br><span class="line">        Father son = <span class="keyword">new</span> Son();</span><br><span class="line">        father.hardChoice(<span class="keyword">new</span> _360());</span><br><span class="line">        son.hardChoice(<span class="keyword">new</span> QQ());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">father choose 360</span><br><span class="line">son choose qq</span><br></pre></td></tr></table></figure><p>编译节点编译期的选择过程，即静态分派的过程。这时候选择目标方法的依据有两点：<strong>一是静态类型是Father还是Son，二是方法参数是QQ还是360。</strong>这次选择结果的最终产物是产生了两条<code>invokevirtual</code>指令，这两条指令的参数分别为常量池中指向<code>Father.hardChoince(360)</code>及<code>Father.hardChoice(QQ)</code>方法的符号引用。<strong>因为是根据两个宗量进行选择，所以Java语言的静态分派属于多分派类型。</strong></p><p>运行阶段虚拟机的选择，即动态分派的过程。在执行”son.hardChoice(new QQ())”这句代码时，更准确的说，在执行这句代码所对应的<code>invokevirtual</code>指令时，由于编译期已经决定目标方法的签名必须为<code>hardChoice(QQ)</code>，虚拟机此时不会关心传递过来的参数是“QQ”到底是“腾讯QQ”还是“奇瑞QQ”，因为这时参数的静态类型、实际类型都不会对方法的选择构成任何影响，<strong>唯一可以影响虚拟机选择的因素只有此方法的接收者的实际类型是<code>Father</code>还是<code>Son</code>。因为只有一个宗量作为选择依据，所以Java语言的动态分派属于单分派类型。</strong></p><h4 id="虚拟机动态分派的实现"><a href="#虚拟机动态分派的实现" class="headerlink" title="虚拟机动态分派的实现"></a>虚拟机动态分派的实现</h4><p>由于动态分派是非常频繁的动作，而且动态分派的方法版本选择过程需要运行时在类的方法元数据中搜索合适的目标方法，因此在虚拟机的实际实现中基于性能的考虑，大部分实现都不会真的进行如此频繁的搜索。</p><p>面对这种情况，最常用的“稳定优化”手段就是**在类的方法区中建立一个徐方法表，使用虚拟方法表索引来代替原数据查找以提高性能。</p><p><img src="https://gitee.com/cayzlh/img-repo/raw/master/2020/04/19/Bt352A.png" alt="方法表结构"></p><p>虚方法表中存放着各个方法的实际入口地址。<strong>如果某个方法在子类中没有被重写，那么子类的虚方法表里面的地址入口和父类相同方法的入口时一致的，都指向父类的实现入口。如果子类中重写了这个方法，子类方法表中的地址将会被替换为指向子嘞实现版本的入口地址。</strong></p><p>为了程序实现上的方便，具有相同签名的方法，在父类、子类的虚方法表中都应当具有一样的索引序号，这样当类型变换时，仅需要变更查找的方法表，就可以从不同的虚方法表中按索引转换出所需的入口地址。</p><p><strong>方法表一般在类加载的连接阶段进行初始化，准备了类的变量初始值后，虚拟机会把该类的方法表也初始化完毕。</strong></p><h2 id="基于栈的字节码解释执行引擎"><a href="#基于栈的字节码解释执行引擎" class="headerlink" title="基于栈的字节码解释执行引擎"></a>基于栈的字节码解释执行引擎</h2><h3 id="解释执行"><a href="#解释执行" class="headerlink" title="解释执行"></a>解释执行</h3><p>不论是解释还是编译，也不论是物理机还是虚拟机，对于应用程序，机器都不可能如人那样阅读和理解，然后几获得了理解能力。大部分的程序代码到物理机的目标代码或虚拟机能执行的指令集之前，都需要经过编译过程。如下图，中下面的那条分支，就是传统编译原理中程序代码到目标机器代码的生成过程，而中间的那条分支自然就是解释执行的过程。</p><p><img src="https://gitee.com/cayzlh/img-repo/raw/master/2020/04/19/bztPYs.png" alt="编译过程"></p><blockquote><p>如今，基于物理机、Java虚拟机或者是非Java的其他高级语言虚拟机的语言，大多都遵循着中基于现代经典编译原理的思路，<strong>在执行前先对程序源码进行词法分析和语法分析处理，把源码转化为抽象语法术。</strong>对于一门具体语言的实现来说，词法和语法分析乃至后面的优化器和目标代码生成器都可以选择独立于执行引擎，形成一个完整意义的编译器去实现，这类代表是C/C++语言，也可以选择把其中的一部分步骤实现为一个半独立的编译器，这类代表是Java语言。又或者把这些步骤和执行引擎全部集中封装在一个封闭的黑夹子之中，如大多数的JavaScript执行器，</p></blockquote><p>Java语言中，<strong>Javac编译器完成了程序代码经过词法分析、语法分析到抽象语法书，再便遍历语法术生成线性的字节码指令的过程。</strong>因为这一部分动作是在Java虚拟机之外进行的，而解释器在虚拟机的内部，所以Java的编译就是半独立的实现。</p><h3 id="基于栈的指令集与基于寄存器的指令集"><a href="#基于栈的指令集与基于寄存器的指令集" class="headerlink" title="基于栈的指令集与基于寄存器的指令集"></a>基于栈的指令集与基于寄存器的指令集</h3><p>Java编译器输出的指令流，基本上是一种基于栈的指令集架构，指令流里面的指令大部分都是零地址指令，它们依赖操作数栈进行工作。<em>与之相对的另外一套常用的指令集架构师基于寄存器的指令集，最典型的就是x86的二地址指令集。</em></p><p>基于栈的指令集最主要的优点就是可移植性，寄存器由硬件直接提供，程序直接以来这些硬件寄存器则不可避免地要受到约束。</p><p>栈架构指令集的主要缺点是执行速度相对来说稍慢一些。所有主流物理机的指令集都是寄存器架构也从侧面印证了这一点。</p><p>栈架构指令集的代码虽然紧凑，但是完成相同功能所需的指令数量一般会比寄存器架构多，因为出栈、入栈操作本身就产生了相当多的指令。<strong>更重要的是栈实现在内存之中，频繁的栈访问也就意味着频繁的内存访问，相对于处理器来说，内存始终是执行速度的瓶颈。</strong>尽管虚拟机可以采取栈顶缓存的手段，把最长用的操作映射到寄存器中以避免直接内存访问，但这也只能是优化措施而不是解决本质问题的方法。因此，**由于指令数量和内存访问的原因，导致了栈架构指令集的执行速度相对较慢。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>分析了虚拟机在执行代码时如何找到正确的方法，如何执行方法内的字节码，以及执行代码时涉及的内存结构。针对Java程序时如何存储的、如何载入（创建）的以及如何执行的问题相关知识讲解了一下。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>周志明，深入理解Java虚拟机：JVM高级特性与最佳实践，机械工业出版社</li></ul>]]></content>
      
      
      <categories>
          
          <category> 书籍 </category>
          
          <category> 《深入理解Java虚拟机》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JVM </tag>
            
            <tag> 《深入理解Java虚拟机》 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>虚拟机类加载机制</title>
      <link href="/blog/2018/09/14/cdffca23.html"/>
      <url>/blog/2018/09/14/cdffca23.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>代码编译的结果从本地机器码变为字节码，是存储格式发展的一小步，确实编程语言发展的一大步</p></blockquote><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><strong>虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的类加载机制。</strong></p><p>与哪些编译时需要进行连接工作的语言不同，在Java语言里面，类型的加载和连接过程都是在程序运行期间完成的，这样会在类加载时稍微增加一些性能开销，但时却能为Java应用程序提供高度的灵活性，Java中天生可以动态扩展的语言特性就是依赖运行期动态加载和动态连接这个特点实现的。例如，<strong>如果编写一个使用接口的应用程序，可以等到运行时再指定其实际的实现。</strong>这种组装应用程序的方式广泛应用于Java程序之中。</p><h2 id="类加载的时机"><a href="#类加载的时机" class="headerlink" title="类加载的时机"></a>类加载的时机</h2><p>类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括了：<strong>加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initialization）、使用（Using）和卸载（Unloading）七个阶段。</strong>其中验证、准备和解析三个部分统称为连接（Linking）。</p><p><img src="https://gitee.com/cayzlh/img-repo/raw/master/2020/04/19/kYqehE.png" alt="类的生命周期"></p><p>加载、验证、准备、初始化和卸载这五个阶段的顺序是确定的，类的加载过程必须按照这种顺序按<strong>部就班地开始，</strong>而解析阶段则不一定：它在某些情况下可以在初始化阶段之后再开始，这是为了支持Java语言的运行时绑定（也称为动态绑定或晚期绑定）。<em>注意这里是按部就班地“开始”，而不是按部就班地“进行”或“完成”，因为这些阶段通常都是互相交叉地混合式进行地，通常会再下一个阶段执行地过程中调用或激活另外一个阶段。</em></p><p>Java虚拟机规范严格规定了有且只有四种情况必须立即对类进行“初始化”（而加载、验证、准备自然需要在此之前开始）：</p><ul><li>遇到new、getstatic、putstatic或invokestatic这4条字节码指令时，如果类没有进行过初始化，则需要先触发其初始化。生成这4条指令地最常见地Java代码场景是：使用new关键字实例化对象地时候、读取或设置一个类字段（被final修饰、已在编译器把结果放入常量池地静态字段除外）地时候，以及调用一个类地静态方法地时候。</li><li>使用java.lang.reflect包地方法对类进行发射调用地时候，如果类没有进行过初始化，则需要先触发其初始化。</li><li>当初始化一个类地时候，如果发现其父类还没有进行过初始化，则需要先触发其父类地初始化。</li><li>当虚拟机启动时，用户需要指定一个要执行地主类（包括main()方法地那个类），虚拟机会先初始化这个主类。</li></ul><h3 id="被动引用地例子之一"><a href="#被动引用地例子之一" class="headerlink" title="被动引用地例子之一"></a>被动引用地例子之一</h3><p>父类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.cayzlh.reference1;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 被动使用类字段演示一</span></span><br><span class="line"><span class="comment"> *  通过子类引用父类的静态字段，不会导致子类初始化</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuperClass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;SuperClass init..&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> value = <span class="number">123</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>子类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.cayzlh.reference1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubClass</span> <span class="keyword">extends</span> <span class="title">SuperClass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;SubClass init..&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.cayzlh.reference1;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 非主动使用类字段演示</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotInitialization</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(SuperClass.value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://gitee.com/cayzlh/img-repo/raw/master/2020/04/19/B2cEYa.png" alt="运行结果"></p><p>上述代码运行之后， 只会输出“SuperClass init..”，而不会输出“SubClass init..”。<strong>对于静态字段，只有直接定义这个字段的类才会被初始化，因此通过子类来引用父类中定义的静态字段，只会触发父类的初始化而不会触发子类的初始化。</strong>至于是否要触发子类的加载和验证，再虚拟机规范中没有明确规定，这点取决于虚拟机的具体实现。</p><h3 id="被动引用的例子之二"><a href="#被动引用的例子之二" class="headerlink" title="被动引用的例子之二"></a>被动引用的例子之二</h3><p>代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.cayzlh.reference2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.cayzlh.reference1.SuperClass;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过数组定义来引用，不会触发此类的初始化</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotInitialization</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SuperClass[] sca = <span class="keyword">new</span> SuperClass[<span class="number">10</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://gitee.com/cayzlh/img-repo/raw/master/2020/04/19/SslBsv.png" alt="运行结果"></p><p>运行之后发现没有输出“SuperClass init..”，说明并没有触发<code>SuperClass</code>类的初始化阶段。</p><h3 id="被动引用的例子之三"><a href="#被动引用的例子之三" class="headerlink" title="被动引用的例子之三"></a>被动引用的例子之三</h3><p>代码1：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.cayzlh.reference3;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 常量在编译阶段会存入调用类的常量池中，</span></span><br><span class="line"><span class="comment"> * 本质上没有直接引用到定义定义常量的类，</span></span><br><span class="line"><span class="comment"> * 因此不能触发定义常量的类的初始化</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConstClass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ConstClass init..&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String HELLOWORLD = <span class="string">&quot;Hello World.&quot;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码2：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.cayzlh.reference3;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 非主动使用类字段演示</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotInitialization</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(ConstClass.HELLOWORLD);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://gitee.com/cayzlh/img-repo/raw/master/2020/04/19/MDhSi7.png" alt="运行结果"></p><p>上述代码运行之后，没有输出“ConstClass init..”，这是因为虽然在Java源码中引用了ConstClass类中的常量HELLOWORLD，但是在编译阶段将此常量的值”Hello World.”存储到了<code>NotInitialization</code>类的常量池中，对常量ConstClass.HELLOWORLD的引用都被转化为NotInitialization类对自身常量池的引用了。<strong>也就是说实际上NotInitialization的Class文件之中并没有ConstClass类的符号引用入口，这两个类在编译成Class之后就不再存在任何联系了。</strong></p><h2 id="类加载的过程"><a href="#类加载的过程" class="headerlink" title="类加载的过程"></a>类加载的过程</h2><p>类加载的的全过程，也就是加载、验证、准备、解析和初始化这五个阶段的过程。</p><h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><p>“加载”（Loading）阶段是“类加载”（Class Loading）过程的一个阶段。在加载阶段，虚拟机需要完成以下三件事情：</p><ul><li>1）<strong>通过一个类的全限定名来获取定义此类的二进制字节流</strong></li><li>2）<strong>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</strong></li><li>3）<strong>在Java堆中生成一个代表这个类的<code>java.lang.Class</code>对象，作为方法区将这些数据的访问入口</strong></li></ul><p>虚拟机规范的这三点要求实际上并不具体，因此虚拟机实现与具体应用的灵活度相当大。<em>相对于类加载过程的其他阶段，加载阶段（加载阶段中获取类的二进制字节流的动作）是开发期可控性最强的阶段，因为加载阶段是既可以使用系统提供的类加载器来完成，也可以由用户自定义的类加载器去完成，开发人员可以通过自己定义的类加载器去控制字节流的获取方式。</em></p><h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><blockquote><p>验证时连接阶段的第一步，这一阶段的目的时为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。</p></blockquote><p><strong>Class文件并不一定要求用Java源码编译而来，可以使用任何途径，包括用十六进制编辑器直接编写来产生Class文件。</strong>如果虚拟机不检查输入的字节流，对其完全信任的话，很可能会因为载入了有害的字节流而导致系统崩溃，所以验证时虚拟机自身保护的一项重要工作。</p><p>虚拟机大致上会完成下面四个阶段的检查过程：<strong>文件格式验证、元数据验证、字节码验证和符号引用验证。</strong></p><h4 id="文件格式验证"><a href="#文件格式验证" class="headerlink" title="文件格式验证"></a>文件格式验证</h4><p>第一阶段要验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理：</p><ul><li>是否以魔数<code>0xCAFEBABE</code>开头</li><li>主、次版本号是否在当前虚拟机处理范围之内</li><li>常量池的常量中是否有不被支持的常量类型</li><li>指向常量的各种索引值是否有只想不存在常量或不符合类型的常量</li><li>CONSTANT_Utf8_info型的常量中是否有不符合UTF8编码的数据</li><li>Class文件中各个部分及文件本身是否有被删除的额或附加的其他信息</li><li>······</li></ul><p>实际上第一阶段的验证还远远不止这些，该验证阶段的主要目的时保证输入的字节流能正确地解析并存储与方法区之内，格式上符合描述一个Java类型信息地要求。<strong>这阶段的验证时基于字节流进行的，经过这个阶段的验证之后，字节流才会流入内存的方法区中进行存储，所以以后的三个验证阶段都是基于方法区存储结构进行的。</strong></p><h4 id="元数据验证"><a href="#元数据验证" class="headerlink" title="元数据验证"></a>元数据验证</h4><p>第二阶段是堆字节码描述的信息进行语义分析，以保证其描述的信息符合Java语言的规范的要求，这个阶段包括：</p><ul><li>这个类是否有父类（除了java.lang.Object，所有的类都应当有父类）</li><li>这个类的父类是否继承了不允许被继承的类（被final修饰的类）</li><li>如果这个类不是抽象类，是否实现了其父类或接口之中要求实现的所有方法</li><li>类中的字段、方法是否与父类产生了矛盾（例如覆盖了父类的final字段，或者出现不符合规则的方法重载，例如方法参数都一致，但返回值类型却不同等）</li><li>······</li></ul><p>第二阶段的主要目的是对类的元数据信息进行语义校验，保证不存在不符合Java语言规范的元数据信息。</p><h4 id="字节码验证"><a href="#字节码验证" class="headerlink" title="字节码验证"></a>字节码验证</h4><p>第三阶段是整个验证过程中最复杂的一个阶段，主要工作是进行数据流和控制流分析。在第二阶段对元数据信息中的数据类型做完校验后，<strong>这阶段对类的方法体进行校验分析。这阶段的任务是保证被校验类的方法在运行时不会做出危害虚拟机安全的行为：</strong></p><ul><li>保证任意时刻<strong>操作数据栈</strong>与指令代码序列都能配合工作，例如不会出现类似的情况：<strong>在操作栈中放置了一个int类型的数据，使用时却按long类型来加载如本地变量表中。</strong></li><li>保证跳转指令不会跳转到方法体意外的字节码指令上。</li><li>保证方法体中的类型转换是有效的，例如<strong>可以把一个子类对象赋值给父类数据类型，这是安全的，但是把父类对象赋值给子类数据类型，甚至把对象赋值给与它毫无关系、完全不相干的数据类型，则是危险和不合法的。</strong></li><li>······</li></ul><p>如果一个类的方法体的字节码没有通过字节码验证，那肯定是有问题的；但如果一个方法体通过了字节码验证，也不能说明其一定就是安全的。即使字节码验证之中进行了大量的检查，也不能保证这一点。<strong>通俗一点讲就是，通过程序去校验程序逻辑是无法做到绝对准确的——不能通过程序准确的检查出程序是否能在有限的时间之内结束运行。</strong></p><h4 id="符号引用验证"><a href="#符号引用验证" class="headerlink" title="符号引用验证"></a>符号引用验证</h4><p>最后一个阶段的校验发生在<strong>虚拟机将符号引用转化直接引用的时候，</strong>这个自动转化将在连接的第三个阶段——解析阶段中发生。符号引用验证可以看作是对类自身以外（<strong>常量池中的各种符号引用</strong>）的信息进行匹配性的校验：</p><ul><li>符号引用中通过符号串描述的全限定名是否能找到对象的类。</li><li>在指定类中是否存在符合方法的字段描述符及简单名称所描述的方法和字段。</li><li>符号引用中的类、字段和方法的访问行（private、protected、public、default）是否可被当前类访问。</li><li>······</li></ul><p>符号引用验证的目的是确保解析动作能正常执行。</p><blockquote><p>验证阶段对于虚拟机的类加载机制来说，是一个非常重要的、但不一定时必要的阶段。如果所运行的全部代码（包括自己写的、第三方包中的代码）都已经被反复使用和验证过，在实施阶段就口可以考虑使用<code>-Xverify:none</code>参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。</p></blockquote><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p><strong>准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在方法区中进行分配。</strong>这个阶段中有两个容易产生混淆的概念需要强调一下，首先是这时候进行内存分配的仅包括<strong>类变量（被<code>static</code>修饰的变量），而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在Java堆中。</strong>其次时这里所说的初始值“通常情况”下时数据类型的零值，假设一个类变量定义为：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> value = <span class="number">123</span>;</span><br></pre></td></tr></table></figure><p>那么变量value在准备阶段过后的初始值是0而不是123，因为这时候尚未开始执行任何Java方法，而把value赋值为123的putstatic指令是程序被编译后，存放于类结构器<clinit>()方法之中，所以value赋值为123的动作将在初始化阶段才会被执行。</p><p>“通常情况”下时数据类型的零值，那相对的会有一些“特殊情况”：如果类字段的字段属性表中存在ConstantValue属性，那在准备阶段变量value就会被初始化为ConstantValue属性所指的值，如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> value = <span class="number">123</span>;</span><br></pre></td></tr></table></figure><p>编译时将会为value生成ConstantValues属性，在准备阶段虚拟机就会根据ConstantValue的设置将value赋值为123。</p><h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p><strong>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。</strong>解析阶段中所说的直接引用与符号引用有什么关联呢？</p><ul><li>符号引用（Symbolic Reference）：符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。富豪引用<strong>与虚拟机实现地内存布局无关</strong>，引用地目标并不一定已经加载到内存中。</li><li>直接引用（Direct Reference）：直接引用可以时直接指向目标地指针、相对偏移量或是一个能间接定位到目标的句柄。直接引用是<strong>与虚拟机实现的内存布局相关</strong>的，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同。<strong>如果有了直接引用，那引用的目标必定已经在内存中存在。</strong></li></ul><blockquote><p>解析动作主要针对类或接口、字段、类方法、接口方法四类符号引用进行，分别对应于常量池中的CONSTANT_Class_info、CONSTANT_Fieldref_info、CONSTANT_Methodref_info及CONSTANT_InterfaceMethodref_info四种常量类型。</p></blockquote><h4 id="类或接口的解析"><a href="#类或接口的解析" class="headerlink" title="类或接口的解析"></a>类或接口的解析</h4><p>要把一个类或者接口的符号引用解析为直接引用，需要以下三个步骤：</p><ol><li>如果该符号引用不是一个数组类型，那么虚拟机将会把该符号代表的全限定名称传递给类加载器去加载这个类。这个过程由于涉及验证过程所以可能会触发其他相关类的加载</li><li>如果该符号引用是一个数组类型，并且该数组的元素类型是对象。我们知道符号引用是存在方法区的常量池中的，该符号引用的描述符会类似”[java/lang/Integer”的形式，将会按照上面的规则进行加载数组元素类型，如果描述符如前面假设的形式，需要加载的元素类型就是java.lang.Integer ,接着由虚拟机将会生成一个代表此数组对象的直接引用</li><li>如果上面的步骤都没有出现异常，那么该符号引用已经在虚拟机中产生了一个直接引用，但是在解析完成之前需要对符号引用进行验证，主要是确认当前调用这个符号引用的类是否具有访问权限，如果没有访问权限将抛出java.lang.IllegalAccess异常</li></ol><h4 id="字段解析"><a href="#字段解析" class="headerlink" title="字段解析"></a>字段解析</h4><p>对字段的解析需要首先对其所属的类进行解析，因为字段是属于类的，只有在正确解析得到其类的正确的直接引用才能继续对字段的解析。对字段的解析主要包括以下几个步骤：</p><ol><li>如果该字段符号引用就包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用，解析结束</li><li>否则，如果在该符号的类实现了接口，将会按照继承关系从下往上递归搜索各个接口和它的父接口，如果在接口中包含了简单名称和字段描述符都与目标相匹配的字段，那么久直接返回这个字段的直接引用，解析结束</li><li>否则，如果该符号所在的类不是Object类的话，将会按照继承关系从下往上递归搜索其父类，如果在父类中包含了简单名称和字段描述符都相匹配的字段，那么直接返回这个字段的直接引用，解析结束</li><li>否则，解析失败，抛出java.lang.NoSuchFieldError异常</li></ol><p>如果最终返回了这个字段的直接引用，就进行权限验证，如果发现不具备对字段的访问权限，将抛出java.lang.IllegalAccessError异常</p><h4 id="类方法解析"><a href="#类方法解析" class="headerlink" title="类方法解析"></a>类方法解析</h4><p>进行类方法的解析仍然需要先解析此类方法的类，在正确解析之后需要进行如下的步骤：</p><ol><li>类方法和接口方法的符号引用是分开的，所以如果在类方法表中发现class_index（类中方法的符号引用）的索引是一个接口，那么会抛出java.lang.IncompatibleClassChangeError的异常</li><li>如果class_index的索引确实是一个类，那么在该类中查找是否有简单名称和描述符都与目标字段相匹配的方法，如果有的话就返回这个方法的直接引用，查找结束</li><li>否则，在该类的父类中递归查找是否具有简单名称和描述符都与目标字段相匹配的字段，如果有，则直接返回这个字段的直接引用，查找结束</li><li>否则，在这个类的接口以及它的父接口中递归查找，如果找到的话就说明这个方法是一个抽象类，查找结束，返回java.lang.AbstractMethodError异常</li><li>否则，查找失败，抛出java.lang.NoSuchMethodError异常</li></ol><p>如果最终返回了直接引用，还需要对该符号引用进行权限验证，如果没有访问权限，就抛出java.lang.IllegalAccessError异常。</p><h4 id="接口方法解析"><a href="#接口方法解析" class="headerlink" title="接口方法解析"></a>接口方法解析</h4><p>同类方法解析一样，也需要先解析出该方法的类或者接口的符号引用，如果解析成功，就进行下面的解析工作：</p><ol><li>如果在接口方法表中发现class_index的索引是一个类而不是一个接口，那么也会抛出java.lang.IncompatibleClassChangeError的异常</li><li>否则，在该接口方法的所属的接口中查找是否具有简单名称和描述符都与目标字段相匹配的方法，如果有的话就直接返回这个方法的直接引用。</li><li>否则，在该接口以及其父接口中查找，直到Object类，如果找到则直接返回这个方法的直接引用</li><li>否则，查找失败</li></ol><p>接口的所有方法都是public，所以不存在访问权限问题</p><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p><strong>初始化阶段才真正开始执行类中定义的java程序代码。</strong></p><p>初始化阶段是执行类构造器<clinit>()方法的过程。在以下四种情况下初始化过程会被触发执行：</p><ol><li><p>遇到new、getstatic、putstatic或invokestatic这4条字节码指令时，如果类没有进行过初始化，则需先触发其初始化。生成这4条指令的最常见的java代码场景是：使用new关键字实例化对象、读取或设置一个类的静态字段(被final修饰、已在编译器把结果放入常量池的静态字段除外)的时候，以及调用类的静态方法的时候。</p></li><li><p>使用java.lang.reflect包的方法对类进行反射调用的时候</p></li><li><p>当初始化一个类的时候，如果发现其父类还没有进行过初始化、则需要先出发其父类的初始化</p></li><li><p>jvm启动时，用户指定一个执行的主类(包含main方法的那个类)，虚拟机会先初始化这个类</p></li></ol><p>在准备阶段，变量已经赋过一次系统要求的初始值，二在初始阶段，则是根据程序员通过程序制定的主观计划去初始化类变量和其他资源。</p><h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><blockquote><p>虚拟机设计团队把类加载阶段中的“通过一个类的全限定名来获取描述此类的二进制字节流”这个动作放到Java虚拟机外部去实现，以便让应用程序自己决定如何去获取所需要的类。实现这个动作的代码模块被称为“类加载器”。</p></blockquote><p>类加载器可以说是Java语言的一项创新，也是Java语言流行的重要原因之一。</p><h3 id="类与类加载器"><a href="#类与类加载器" class="headerlink" title="类与类加载器"></a>类与类加载器</h3><p>类加载器虽然只用于实现类的加载动作，但它在Java程序中起到的作用却远远不限于类加载阶段。<strong>对于任意一个类，都需要由加载它的类加载器和这个类本身一同确定其在Java虚拟机中的唯一性。</strong>通俗一点：比较两个类是否“相等”，只有在这两个类是由同一个类加载器加载的前提之下才有意义，否则，即使这两个类来源同一个Class文件，只要记载他们的类加载器不同，那这两个类就必定不相等。</p><h3 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h3><p>站在Java虚拟机的角度看，只存在两种不同的类加载器：<strong>一种是启动类加载器（Bootstrap ClassLoader），这个类加载器使用<code>C++</code>语言实现，是虚拟机自身的一部分；另外一种就是所有其他的类加载器，这些类加载器都由Java语言实现，独立于虚拟机外部，并且全部都继承自抽象类<code>java.lang.ClassLoader</code>。</strong></p><p>绝大部分Java程序都会使用到以下三种系统提供的类加载器：</p><ul><li>启动类加载器（Bootstrap ClassLoader）：负责将存放在<code>bin</code>目录中的，或者被<code>-Xbootclasspath</code>参数所指定的路径中的，并且是虚拟机识别的类库加载到虚拟机内存中。启动类加载器无法被Java程序直接引用。</li><li>扩展类加载器（Extension ClassLoader）：负责加载<code>lib\ext</code>目录中，或者被<code>java.ext.dirs</code>系统变量所指定的路径中的所有类库，开发者可以直接使用扩展类加载器。</li><li>应用程序加载器（Application ClassLoader）：由于这个类加载器是ClassLoader中的<code>getSystemClassLoader()</code>方法的返回值，所以一般也称为系统类加载器。<strong>负责加载用户类路径上所指定的类库，开发者可以直接使用这个类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。</strong></li></ul><p>我们的应用程序都是由这三种类加载器互相配合进行加载的，如果有必要，还可以加入自己定义的类加载器。这些类加载器之间的关系一般如图所示：</p><p><img src="https://gitee.com/cayzlh/img-repo/raw/master/2020/04/19/Kg9O8N.png" alt="类加载器双亲委派模型"></p><p>双亲委派模型除了要求顶层的启动类加载器外，其余的类加载器都应当有自己的父类加载器。这里类加载器之间的父子关系一般不会以继承的关系实现，而是都使用组合关系来复用父类加载器的代码。</p><blockquote><p>双亲委派模型的工作过是：<strong>如果一个类加载器收到了类加的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当附加在七反馈自己无法完成这个加载请求（<em>它的搜索范围中没有找到所需的类</em>）时，子加载器才会尝试自己去加载。</strong></p></blockquote><p>使用双亲委派模型来组织类加载器之间的关系，好处就是Java类随着它的类加载器一起具备了一种带有优先级的层次关系。<strong>双亲委派模型对于保证Java程序的稳定运行很重要，但它的实现却非常简单，</strong>实现双亲委派的代码都集中在<code>java.lang.ClassLoader</code>的<code>loadClass()</code>方法之中。先检查是否已经被加载过，若没有加载则调用父类加载器的<code>loadClass()</code>方法，若父类加载器为空则默认使用启动类加载器作为父类加载器。如果父类加载失败，则在抛出<code>ClassNotFoundException</code>异常后，再调用自己的<code>findClass()</code>方法进行加载。</p><h3 id="破坏双亲委派模型"><a href="#破坏双亲委派模型" class="headerlink" title="破坏双亲委派模型"></a>破坏双亲委派模型</h3><h4 id="第一次破坏"><a href="#第一次破坏" class="headerlink" title="第一次破坏"></a>第一次破坏</h4><p>由于双亲委派模型是在JDK1.2之后才被引入的，而类加载器和抽象类java.lang.ClassLoader则在JDK1.0时代就已经存在，面对已经存在的用户自定义类加载器的实现代码，Java设计者引入双亲委派模型时不得不做出一些妥协。在此之前，用户去继承java.lang.ClassLoader的唯一目的就是为了重写loadClass()方法，因为虚拟机在进行类加载的时候会调用加载器的私有方法loadClassInternal()，而这个方法唯一逻辑就是去调用自己的loadClass()。</p><h4 id="第二次破坏"><a href="#第二次破坏" class="headerlink" title="第二次破坏"></a>第二次破坏</h4><p>双亲委派模型的第二次“被破坏”是由这个模型自身的缺陷所导致的，双亲委派很好地解决了各个类加载器的基础类的同一问题（越基础的类由越上层的加载器进行加载），基础类之所以称为“基础”，是因为它们总是作为被用户代码调用的API，但世事往往没有绝对的完美。</p><h4 id="如果基础类又要调用回用户的代码，那该么办？"><a href="#如果基础类又要调用回用户的代码，那该么办？" class="headerlink" title="如果基础类又要调用回用户的代码，那该么办？"></a>如果基础类又要调用回用户的代码，那该么办？</h4><p>一个典型的例子就是JNDI服务，JNDI现在已经是Java的标准服务，<br> 它的代码由启动类加载器去加载（在JDK1.3时放进去的rt.jar），但JNDI的目的就是对资源进行集中管理和查找，它需要调用由独立厂商实现并部署在应用程序的ClassPath下的JNDI接口提供者的代码，但启动类加载器不可能“认识”这些代码。</p><p><strong>为了解决这个问题，Java设计团队只好引入了一个不太优雅的设计：线程上下文类加载器(Thread Context ClassLoader)。这个类加载器可以通过java.lang.Thread类的setContextClassLoader()方法进行设置，如果创建线程时还未设置，他将会从父线程中继承一个，如果在应用程序的全局范围内都没有设置过的话，那这个类加载器默认就是应用程序类加载器。</strong></p><p>有了线程上下文加载器，JNDI服务就可以使用它去加载所需要的SPI代码，也就是父类加载器请求子类加载器去完成类加载的动作，这种行为实际上就是打通了双亲委派模型层次结构来逆向使用类加载器，实际上已经违背了双亲委派模型的一般性原则，但这也是无可奈何的事情。Java中所有涉及SPI的加载动作基本上都采用这种方式，例如JNDI、JDBC、JCE、JAXB和JBI等。</p><h4 id="第三次破坏"><a href="#第三次破坏" class="headerlink" title="第三次破坏"></a>第三次破坏</h4><p>双亲委派模型的第三次“被破坏”是由于用户对程序动态性的追求导致的，这里所说的“动态性”指的是当前一些非常“热门”的名词：代码热替换、模块热部署等，简答的说就是机器不用重启，只要部署上就能用。<br> OSGi实现模块化热部署的关键则是它自定义的类加载器机制的实现。每一个程序模块(Bundle)都有一个自己的类加载器，当需要更换一个Bundle时，就把Bundle连同类加载器一起换掉以实现代码的热替换。在OSGi幻境下，类加载器不再是双亲委派模型中的树状结构，而是进一步发展为更加复杂的网状结构，当受到类加载请求时，OSGi将按照下面的顺序进行类搜索：<br> 1）将java.＊开头的类委派给父类加载器加载。<br> 2）否则，将委派列表名单内的类委派给父类加载器加载。<br> 3）否则，将Import列表中的类委派给Export这个类的Bundle的类加载器加载。<br> 4）否则，查找当前Bundle的ClassPath，使用自己的类加载器加载。<br> 5）否则，查找类是否在自己的Fragment Bundle中，如果在，则委派给Fragment Bundle的类加载器加载。<br> 6）否则，查找Dynamic Import列表的Bundle，委派给对应Bundle的类加载器加载。<br> 7）否则，类加载器失败。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>介绍了类加载过程的<strong>加载、验证、准备、解析和初始化</strong>五个阶段中虚拟机进行了哪些动作，还介绍了类加载器的工作原理及其堆虚拟机的意义</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>周志明，深入理解Java虚拟机：JVM高级特性与最佳实践，机械工业出版社 </li><li><a href="https://www.jianshu.com/p/166c5360a40b">破坏双亲委派模型</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 书籍 </category>
          
          <category> 《深入理解Java虚拟机》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JVM </tag>
            
            <tag> 《深入理解Java虚拟机》 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>虚拟机性能监控与故障处理工具</title>
      <link href="/blog/2018/09/13/fea7515.html"/>
      <url>/blog/2018/09/13/fea7515.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>Java与C++之间有一堵由内存动态分配和垃圾收集围城的高墙，墙外面的人想进来，墙里面的人却想出去.</p></blockquote><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>经常使用适当的虚拟机监控和分析的工具可以加快我们分析数据和定位问题的速度，但我们在学习工具前，也应当意识到工具永远都是知识技能的一层包装，没有什么工具是“秘密武器”，学会了就能包治百病。</p><h2 id="JDK的命令行工具"><a href="#JDK的命令行工具" class="headerlink" title="JDK的命令行工具"></a>JDK的命令行工具</h2><p>Java开发人员肯定都知道JDK的bin目录下有“java.exe”和“javac.exe”这两个命令行工具，但并非所有程序员都了解过JDK的bin目录之中其他命令行程序的作用。</p><p><img src="https://gitee.com/cayzlh/img-repo/raw/master/2020/04/18/uk8XLj.png" alt="Sun JDK中的工具目录"></p><p>这些工具中包含了用于监视虚拟机和公章处理的工具。这些工具都非常稳定而且功能强大，能在处理应用程序应能问题、定位故障时发挥很大的作用。</p><blockquote><p>JDK开发团队选择采用Java代码来实现这些监控工具时有特别用意的：当用用程序部署到生产环境后，无论是直接解除物理服务器还是远程Telnet到服务器上都可能会收到限制。借助tools.jar类库里面的接口，我们可以直接在应用程序中实现强大的监控分析功能。</p></blockquote><h3 id="jps：虚拟机进程状况工具"><a href="#jps：虚拟机进程状况工具" class="headerlink" title="jps：虚拟机进程状况工具"></a>jps：虚拟机进程状况工具</h3><p>JDK的很多小工具的名字都参考了Unix命令的命名方式，jps（JVM Process Status Tool）是其中的典型。可以列出真该运行的虚拟机进程，并显示虚拟机执行主类（Main Class，main() 函数所在的类）的名称，以及这些进程的本地虚拟机的唯一ID（LVMID，Local Virtual Machine Identifier）。<strong>对于本地虚拟机进程来说，LVMID与操作系统的进程ID（PID，Process Identifier）是一致的，</strong>使用Windows的任务管理器或Unix的ps命令也可以查询到虚拟机进程的LVMID，但<strong>如果同时启动了多个虚拟机进程，无法根据进程名称定为时，那就只能以来jps命令显示主类的功能才能区分了。</strong></p><p><strong>jps命令格式：</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">jps [ options ] [ hostid ]</span><br></pre></td></tr></table></figure><p><strong>样例：</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">jps -l</span><br></pre></td></tr></table></figure><p>jps可以通过RMI协议查询开启了RMI服务器的远程虚拟机进程状态，hostid为RMI注册表中注册的主机名。</p><p><em>jps工具主要选项</em></p><table><thead><tr><th align="center">选项</th><th align="left">作用</th></tr></thead><tbody><tr><td align="center">-q</td><td align="left">只输出LVMID，省略主类的名称</td></tr><tr><td align="center">-m</td><td align="left">输出虚拟机进程启动时传递给主类main()函数的参数</td></tr><tr><td align="center">-l</td><td align="left">输出主类的全名，如果进程执行的是Jar包，输出Jar路径</td></tr><tr><td align="center">-v</td><td align="left">输出虚拟机进程启动时JVM参数</td></tr></tbody></table><p>–</p><h3 id="jstat：虚拟机统计信息监视工具"><a href="#jstat：虚拟机统计信息监视工具" class="headerlink" title="jstat：虚拟机统计信息监视工具"></a>jstat：虚拟机统计信息监视工具</h3><p>jstat（JVM Statistics Monitoring Tool）是用于监视虚拟机<strong>各种运行状态信息</strong>的命令行工具。它可以<strong>显示本地或远程虚拟机进程中的类加载、内存、垃圾收集、JIT编译等运行数据，</strong>在没有GUI图形界面，只提供了纯文本控制台环境的服务器上，它将是<strong>运行期定位虚拟机性能问题的首选工具。</strong></p><p><strong>jstat命令格式：</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">jstat [ option vmid [ interval[s|ms] [ count ] ] ]</span><br></pre></td></tr></table></figure><p><strong>参数interval和count代表查询间隔和次数，如果省略这两个参数，说明只查询一次。</strong>假设需要每250毫秒查询一次进程2764垃圾收集的状况，一共查询20此，那命令应当是：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">jstat -gc 2764 250 20</span><br></pre></td></tr></table></figure><p>选项option代表着用户希望查询的虚拟机信息，主要分3类：<strong>类装载、垃圾收集和运行期编译状况，</strong>具体选项及作用参考下表：</p><table><thead><tr><th align="center">选项</th><th>作用</th></tr></thead><tbody><tr><td align="center">-class</td><td>监视类装载、卸载数量、总空间及类装载所耗费的时间</td></tr><tr><td align="center">-gc</td><td>监视Java堆状况，包括Eden区、2个Survivor区、老年代、<br />永久代等的容量、已用空间、GC时间合计等信息</td></tr><tr><td align="center">-gccapacity</td><td>监视内容与-gc基本相同，<br />但输出主要关注Java堆各个区域使用到的最大和最小空间</td></tr><tr><td align="center">-gcutil</td><td>监视内容与-gc基本相同，<br />但输出主要关注已使用空间占总空间的百分比</td></tr><tr><td align="center">-gccause</td><td>与-gcutil的功能一样，但是会额外输出导致上一次GC产生的原因</td></tr><tr><td align="center">-gcnew</td><td>监视新生代GC的状况</td></tr><tr><td align="center">-gcnewcapacity</td><td>监视内容与-gcnew基本相同，<br />输出主要关注使用到的最大和最小空间</td></tr><tr><td align="center">-gcold</td><td>监视老年代GC的状况</td></tr><tr><td align="center">-gcoldcapacity</td><td>监视内容与-gcold基本相同，<br />输出主要关注使用到的最大和最小空间</td></tr><tr><td align="center">-gcpermcapacity</td><td>输出永久代使用的最大和最小空间</td></tr><tr><td align="center">-compiler</td><td>输出JIT编译器编译过的方法、耗时等信息</td></tr><tr><td align="center">-printcompilation</td><td>输出已经被JIT编译的方法</td></tr></tbody></table><p>–</p><h3 id="jinfo：Java配置信息工具"><a href="#jinfo：Java配置信息工具" class="headerlink" title="jinfo：Java配置信息工具"></a>jinfo：Java配置信息工具</h3><p>jinfo（Configuration Info for Java）的作用是<strong>实时地查看和调整虚拟机的各项参数。</strong></p><p><strong>格式：</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">jinfo [ option ] pid</span><br></pre></td></tr></table></figure><p><strong>样例：</strong>查询CMSInitiatingOccupancyFraction参数值。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">jinfo -flag CMSInitiatingOccupancyFraction 1444</span><br></pre></td></tr></table></figure><h3 id="jmap：Java内存映像工具"><a href="#jmap：Java内存映像工具" class="headerlink" title="jmap：Java内存映像工具"></a>jmap：Java内存映像工具</h3><p>jmap（Memory Map for Java）命令<strong>用于生成堆转储快照（一般称为heapdump或dump文件）。</strong>jmap的作用并不仅仅是为了获取dump文件，<strong>它还可以查询finalize执行队列，Java堆和永久代的详细信息，如空间使用率、当前用的是哪种收集器等。</strong></p><p><strong>格式：</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">jmap [ option ] vmid</span><br></pre></td></tr></table></figure><p>参数表：</p><table><thead><tr><th align="center">选项</th><th>作用</th></tr></thead><tbody><tr><td align="center">-dump</td><td>生成Java堆转储快照，<br />格式：-dump:[live,]format=b,file=filename,<br />其中live子参数说明是否只dump出存活的对象</td></tr><tr><td align="center">-finalizerinfo</td><td>显示在F-Queue中等待Finalizer线程执行finalize方法的对象。<br />只在Liux/Solaris平台有效</td></tr><tr><td align="center">-heap</td><td>显示Java堆详细信息， <br />如使用那种回收器、参数配置分代状况等。<br />只在Liux/Solaris平台有效</td></tr><tr><td align="center">-histo</td><td>显示堆中对象统计信息，包括类、实例数量和合计容量</td></tr><tr><td align="center">-permstat</td><td>以ClassLoader为统计口径显示永久代的内存状态。<br />只在Liux/Solaris平台有效</td></tr><tr><td align="center">-F</td><td>当虚拟机进程堆-dump选项没有响应时，可使用这个选项强制生成dump快照。<br />只在Liux/Solaris平台有效</td></tr></tbody></table><p>–</p><h3 id="jhat：虚拟机堆转储快照分析工具"><a href="#jhat：虚拟机堆转储快照分析工具" class="headerlink" title="jhat：虚拟机堆转储快照分析工具"></a>jhat：虚拟机堆转储快照分析工具</h3><p>与jmap搭配使用，来<strong>分析jmap生成的堆转储快照。</strong></p><h3 id="jstack：Java堆栈跟踪工具"><a href="#jstack：Java堆栈跟踪工具" class="headerlink" title="jstack：Java堆栈跟踪工具"></a>jstack：Java堆栈跟踪工具</h3><p>jstack（Stack Trace for Java）命令用于<strong>生成虚拟机当前时刻快照。线程快照就是当前虚拟机内每一条线程正在执行的方法堆栈的集合，</strong>生成线程快照的主要目的是<strong>定位线程出现长时间停顿的原因，</strong>如线程间死锁、死循环、请求外部资源导致的长时间等待都是导致线程长时间停顿的常见原因。</p><p><strong>格式：</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">jstack [ option ] vmid</span><br></pre></td></tr></table></figure><p>参数表：</p><table><thead><tr><th align="center">选项</th><th>作用</th></tr></thead><tbody><tr><td align="center">-F</td><td>当正常输出请求不被响应时，强制输出线程堆栈</td></tr><tr><td align="center">-l</td><td>除堆栈外，显示关于锁的附加信息</td></tr><tr><td align="center">-m</td><td>如果调用到本地方法的话，可以显示C/C++的堆栈</td></tr></tbody></table><p>–</p><h2 id="JDK的可视化工具"><a href="#JDK的可视化工具" class="headerlink" title="JDK的可视化工具"></a>JDK的可视化工具</h2><p>JDK中除了提供大量的命令行工具外，还有两个功能强大的可视化工具：<strong>JConsole和VisualVM，</strong>这两个工具时JDK的正式成员。</p><h3 id="JConsole：Java监视与管理控制台"><a href="#JConsole：Java监视与管理控制台" class="headerlink" title="JConsole：Java监视与管理控制台"></a>JConsole：Java监视与管理控制台</h3><p>JConsole是一款基于JMX的可视化监视管理的工具。它管理部分的功能时针对JMX MBean进行管理，MBean可以使用代码、中间件服务器的管理控制台或者所有符合JMX规范的软件进行访问。</p><p>参考文献：</p><ul><li><a href="https://docs.oracle.com/javase/8/docs/technotes/guides/management/jconsole.html">官方文档</a></li><li><a href="http://jiajun.iteye.com/blog/810150">如何利用 JConsole观察分析Java程序的运行，进行排错调优</a></li><li><a href="https://www.jianshu.com/p/290489f0a495">JVM检测分析JConsole</a></li></ul><h3 id="VisualVM：多合一故障处理工具"><a href="#VisualVM：多合一故障处理工具" class="headerlink" title="VisualVM：多合一故障处理工具"></a>VisualVM：多合一故障处理工具</h3><p>VisualVM是到目前为止，随JDK发布的功能最强大的运行监视和故障处理程序，并且可以预见在未来一段时间内都是官方主力发展的虚拟机故障处理工具。</p><p>参考文献：</p><ul><li><a href="https://visualvm.github.io/">https://visualvm.github.io/</a></li><li><a href="https://www.ibm.com/developerworks/cn/java/j-lo-visualvm/index.html">使用 VisualVM 进行性能分析及调优</a></li><li><a href="https://www.jianshu.com/p/9b0283fead2b">学习Java VisualVM的使用</a></li></ul><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>介绍了随JDK发布的6个命令行工具和2个可视化的故障处理工具，灵活使用这些工具，可以给处理问题带来很大的便利。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>周志明，深入理解Java虚拟机：JVM高级特性与最佳实践，机械工业出版社 </li></ul>]]></content>
      
      
      <categories>
          
          <category> 书籍 </category>
          
          <category> 《深入理解Java虚拟机》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JVM </tag>
            
            <tag> 《深入理解Java虚拟机》 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>垃圾收集器与内存分配策略</title>
      <link href="/blog/2018/09/11/ddb92a08.html"/>
      <url>/blog/2018/09/11/ddb92a08.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>Java与C++之间有一堵由内存动态分配和垃圾收集围城的高墙，墙外面的人想进来，墙里面的人却想出去.</p></blockquote><h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><p>垃圾收集需要完成的三件事情：</p><ul><li>哪些内存需要回收？</li><li>什么时候回收？</li><li>如何回收？</li></ul><p><em>内存的动态分配和内存回收技术已经相当成熟，为什么还需要去了解GC和内存分配呢？</em></p><p>答案很简单：<strong>当需要排查各种内存溢出、内存泄漏问题时，当垃圾收集成为系统达到更高并发量的瓶颈时，我们对这些“自动化”的技术实施必要的监控和调节。</strong></p><p>Java运行时区域的各个部分中，<strong>程序计数器、虚拟机栈、本地方法栈</strong>三个区域随线程而生，随线程而灭；栈中的栈帧随着方法的进入和退出而有条不紊的执行着出栈和入栈操作。每个栈帧中分配多少内存基本上是在类结构确定下来时就是已经知道的，因此这几个区域的内存分配和回收都具备确定性，在这几个区域内不需要过多考虑回收问题，因为在方法结束或线程结束的时候，内存自然就跟着回收了。</p><p><strong>Java堆和方法区</strong>则不一样，一个接口中的多个实现类需要的内存可能不一样，一个方法中的多个分支需要的内存也可能不一样，我们只有在程序处于运行期间时才能知道会创建哪些对象，这部分的分配和回收都是动态的，垃圾收集器所关注的是这部分内存。</p><h2 id="二、对象已死？"><a href="#二、对象已死？" class="headerlink" title="二、对象已死？"></a>二、对象已死？</h2><blockquote><p>堆中几乎存放这Java世界中所有的对象实例，垃圾收集器在对堆进行回收前，第一件事就是要确定这些对象有哪些还“活着”，哪些已经“死去”。</p></blockquote><h3 id="1、引用计数算法"><a href="#1、引用计数算法" class="headerlink" title="1、引用计数算法"></a>1、引用计数算法</h3><p>给对象添加一个引用计数器，每当有一个地方引用它时，计数器就加1；当引用消失时，计数器值就减1；任何时刻计数器都为0的对象就是不可能再被使用的。</p><p><strong>Java语言中没有选用引用计数算法来管理内存，其中最主要的原因是它很难解决对象之间相互循环引发的问题。</strong></p><p>例：当两个对象互相引用对方，除此之外两个对象再无任何引用，实际上这两个对象已经不可能再被访问，但是他们因为<strong>互相引用着对方，导致他们的引用计数都不为0，</strong>于是引用计数算法无法通知GC收集器回收它们。</p><h3 id="2、根搜索算法"><a href="#2、根搜索算法" class="headerlink" title="2、根搜索算法"></a>2、根搜索算法</h3><p>在主流的商用程序语言中（Java和C#）都使用根搜索算法（GC Roots Tracing）判断对象是否存活的。这个算法的基本思路就是<strong>通过一系列名为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所有走过的路径成为引用链（Reference Chain），当一个对象到GC Roots没有任何引用链相连（用图论的话来说就是从GC Roots到这个对象不可达）时，则证明此对象是不可用的。</strong></p><p>在Java语言里，可作为GC Roots的对象包括下面几种：</p><ul><li>虚拟机栈（<strong>栈帧中的本地变量表</strong>）中的引用的对象</li><li>方法区中的<strong>类静态属性</strong>引用的对象</li><li>方法区中的<strong>常量</strong>引用的对象</li><li>本地方法栈中<strong>JNI</strong>（即一般说的Native方法）的引用的对象</li></ul><p><img src="https://cdn.jsdelivr.net/gh/cayzlh/git-img-repository@master/uPic/1.jpg" alt="跟搜索算法判定对象是否可回收"></p><h3 id="3、引用"><a href="#3、引用" class="headerlink" title="3、引用"></a>3、引用</h3><p>无论是通过引用计数算法判断对象的引用数量，还是 通过根搜索算法判断对象的引用链是否可达，判定对象是否存活都与“引用”有关。</p><blockquote><p><strong>在JDK1.2之前，Java中的引用的定义很传统：如果reference类型的数据中存储的数值代表的是另外一块内存的起始地址，就称这块内存代表着一个引用。</strong></p></blockquote><p>这种定义很存粹，但是太过狭隘，一个对象在这种定义下只有被引用或者没有被引用两种状态。希望能描述这样一类对象：<strong>当内存空间还足够时，则能保留在内存之中；如果内存在进行垃圾收集后还是非常进场，则可以抛弃这些对象。</strong></p><p>Java堆引用的概念进行了扩充，将引用分为：<strong>强引用（Strong Reference）、软引用（Soft Reference）、弱引用（Weak Reference）、虚引用（Phantom Reference）</strong>四种，这四种引用的强度一次组建减弱。</p><ul><li><strong>强引用：</strong>在程序代码之间普遍存在的，类似“Object obj = new Object()”这类的引用，<strong>只要强引用还存在，垃圾收集器永远不会回收调被引用的对象。</strong></li><li><strong>软引用：</strong>用来描述一些还用，但并非必须的对象。对于软引用关联着的对象，在<strong>系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中并进行第二次回收。</strong>如果这次回收还是没有足够的内存，才会抛出内存溢出异常。</li><li><strong>弱引用：</strong>用来描述非必须的对象的，它的强度比软引用更弱一些，<strong>被弱引用关联的对象只能生存到下一次垃圾收集发生之前。</strong>当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。</li><li><strong>xu虚引用：</strong>又称为幽灵引用或者幻影引用，它是最弱的一种引用关系。<strong>一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。</strong>为一个对象设置虚引用关联的唯一目的就是希望能在这个对象被收集器回收时受到一个系统通知。</li></ul><h3 id="4、生存还是死亡"><a href="#4、生存还是死亡" class="headerlink" title="4、生存还是死亡"></a>4、生存还是死亡</h3><p>在跟搜索算法中不可达的对象，也并非时“非死不可”的，这个时候他们处于“缓刑”阶段，要真正宣告一个对象死亡，至少要经历<strong>两次标记过程：</strong> <em>如果对象在进行跟搜索后发现没有与GC Roots相连接的引用链，那它将会被第一次标记并且进行一次筛选，筛选的条件时此对象是否有必要执行<code>finalize()</code>方法。</em></p><blockquote><p>当对象没有覆盖<code>finalize()</code>方法，或者<code>finalize()</code>方法已经被虚拟机用过，虚拟机将这两种情况都视为“没有必要执行”。</p></blockquote><p>如果这个对象被判定为有必要执行<code>finalize()</code>方法，那么这个对象将会被放置在一个名为<code>F-Queue</code>的队列之中，并在稍后由一条由虚拟机自动建立的、低优先级的Finalizer线程去执行。</p><p><strong>任何一个对象的<code>finalize()</code>方法都只会被系统自动调用一次，如果对象面临下一次回收，它的<code>finalize()</code>方法不会再次执行</strong></p><blockquote><p><code>finalize()</code>能做的所有工作，使用<code>try-finally</code>或者其他方式都可以做得更好、更及时。<strong>完全可以忘掉Java语言中还有这个方法存在。</strong></p></blockquote><h3 id="5、回收方法区（永久代）"><a href="#5、回收方法区（永久代）" class="headerlink" title="5、回收方法区（永久代）"></a>5、回收方法区（永久代）</h3><blockquote><p>Java虚拟机规范中说过可以不要求虚拟机再方法区实现垃圾收集，而且再方法区进行垃圾收集的“性价比”一般比较低：再堆中，尤其是再新生代中，常规应用进行一次垃圾收集一般可以回收70%~95%的空间，而永久代的垃圾收集效率远低于此。</p></blockquote><p>永久代的垃圾收集主要回收两部分内容：<strong>废弃常量和无用的类。</strong></p><p>判定一个常量是否是“<strong>废弃常量</strong>”比较简单，而要判定一个类是否是“无用的类”的条件则相对苛刻许多。类需要满足3个条件才能算是“<strong>无用的类：</strong>”</p><ul><li><strong>该类所有的实例都已经被回收，也就是Java堆中不存在该类的任何实例</strong></li><li><strong>加载该类的ClassLoader已经被回收</strong></li><li><strong>该类对应的java.lang.Class对象没在任何地方被引用，无法在任何地方通过反射访问该类的方法。</strong></li></ul><p>虚拟机可以堆满足上述3个条件的无用类进行回收，这里说的仅仅是“可以”，而不是和对象一样，不使用了就必然会被回收。</p><p><em>在大量使用反射、动态代理、CGLib等bytecode框架的场景，以及动态生成JSP和OSGi这类频繁自定义ClassLoader的场景都需要虚拟机具备类卸载的功能，以保证永久代不会溢出。</em></p><h2 id="三、垃圾收集算法"><a href="#三、垃圾收集算法" class="headerlink" title="三、垃圾收集算法"></a>三、垃圾收集算法</h2><p>介绍几种算法的思想及其发展过程。</p><h3 id="1、标记-清除算法"><a href="#1、标记-清除算法" class="headerlink" title="1、标记-清除算法"></a>1、标记-清除算法</h3><p>最基础的收集算法是“标记-清除（Mark-Sweep）”算法：<strong>首先标记出所有需要回收的对象，在标记完成后统一回收调所有被标记的对象。</strong>它主要缺点有两个：一个是<strong>效率问题</strong>，标记和清除过程的效率都不高；另外一个是<strong>空间问题</strong>，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致，当程序在以后的运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。</p><p><img src="https://cdn.jsdelivr.net/gh/cayzlh/git-img-repository@master/uPic/2.jpg" alt="&quot;标记-清除&quot;算法"></p><h3 id="2、复制算法"><a href="#2、复制算法" class="headerlink" title="2、复制算法"></a>2、复制算法</h3><p>为了解决效率问题，于是就有了“复制（Copying）”算法。<strong>它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。</strong>这样使得每次都是堆其中的一块进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动栈顶指针，按顺序分配内存即可，实现简单，运行高效。<strong>但是这种算法的代价时将内存缩小为原来的一般。</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cayzlh/git-img-repository@master/uPic/3.jpg" alt="复制算法"></p><blockquote><p>现在的商业虚拟机都采用这种收集算法来回收新生代，IBM的专门研究表明，新生代中的对象98%是朝生夕死的，所以并不需要按照1:1的比例来划分内存空间，而是<strong>将内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中的一块Survivor。当回收时，将Eden和Survivor中还活着的对象一次性拷贝到另外一块Survivor空间上，最后清理调Eden和刚才用过的Survivor的空间。</strong></p><p>Hotspot虚拟机默认Eden和Survivor的大小比例时8:1，也就是每次新生代中可用内存空间为整个新生代容量的90%(80%+10%)，只有10%的内存是会被“浪费”的。</p></blockquote><h3 id="3、标记-整理算法"><a href="#3、标记-整理算法" class="headerlink" title="3、标记-整理算法"></a>3、标记-整理算法</h3><p>复制收集算法在对象存活率较高时就要执行较多的复制操作，效率将会变低。更关键的是，如果不想浪费50%的空间，就需要有额外的空间进行分配担保，以应对被使用的内存中所有对象都100%存活的极端情况，所以在老年代一般不能直接选用这种算法。</p><p>根据老年代的特点，提出了”标记-整理（Mark-Compact）“算法，标记过程仍然与”标记-清除“算法一样，但后续步骤不是直接堆可回收对象进行清理，而是<strong>让所有存活的对象都向一端移动，然后直接清理调端边界意外的内存。</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cayzlh/git-img-repository@master/uPic/4.jpg" alt="标记-整理(Mark-Compact)"></p><h3 id="4、分代收集算法"><a href="#4、分代收集算法" class="headerlink" title="4、分代收集算法"></a>4、分代收集算法</h3><p>当前商业虚拟机的垃圾收集都采用”分代收集“（Generational Collection）算法，这种算法并没有什么新的思想，只是<strong>根据对象存活周期的不同将内存划分为几块。一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适合的收集算法。</strong></p><ul><li>在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存货对象的复制成本就可以完成收集。</li><li>在老年代中因为对象存活率高、没有额外空间堆它进行分配担保，就必须使用”标记-清理“或”标记-整理“算法来进行回收。</li></ul><h2 id="四、内存分配与回收策略"><a href="#四、内存分配与回收策略" class="headerlink" title="四、内存分配与回收策略"></a>四、内存分配与回收策略</h2><blockquote><p>Java计数习题中所提倡的自动内存管理最终可以归结为自动化地解决两个问题：<strong>给对象分配内存以及回收分配给对象的内存。</strong></p></blockquote><p>对象的那内存分配，往大方向上讲，就是在堆上分配，<strong>对象主要分配在新生代的Eden区上，</strong>如果启动了本地线程分配缓冲，将按线程优先在TLAB上分配。少数情况下也可能会直接分配在老年代中，分配的规则并不是百分之百固定的，其细节取决于当前使用的时哪一种垃圾收集器组合，还有虚拟机中与内存相关的参数的设置。</p><h3 id="1、对象优先在Eden分配"><a href="#1、对象优先在Eden分配" class="headerlink" title="1、对象优先在Eden分配"></a>1、对象优先在Eden分配</h3><p>大多数情况下， 对象字新生代Eden区中分配。当Eden区没有足够的空间进行分配时，虚拟机将发起一次Minor GC。</p><p><em>Minor GC和Full GC的区别？</em></p><ul><li>新生代GC（Minor GC）：指发生在新生代的垃圾收集动作，因为Java对象大多都具备朝生夕灭的特性，所以Minor GC非常频繁，一般回收速度也比较快。</li><li>老年代GC（Major GC / Full GC）：指发生在老年代的GC，出现了Major GC，经常会伴随至少一次的Minor GC（但非绝对的）。Major GC的速度一般会比Minor GC慢10杯以上。</li></ul><h3 id="2、大对象直接进入老年代"><a href="#2、大对象直接进入老年代" class="headerlink" title="2、大对象直接进入老年代"></a>2、大对象直接进入老年代</h3><p>所谓大对象是指，需要大量连续内存空间的Java对象，最经典的大对象就是那种很长的字符串及数组。</p><blockquote><p>大对象堆虚拟机的内存分配来说就是一个坏消息，经常出现大对象容易导致内存还有不少空间时就提前触发垃圾收集以获取足够的连续空间来“安置”它们。</p></blockquote><h3 id="3、长期存活的对象将进入老年代"><a href="#3、长期存活的对象将进入老年代" class="headerlink" title="3、长期存活的对象将进入老年代"></a>3、长期存活的对象将进入老年代</h3><p>虚拟机既然采用了分代收集的思想来管理内存，那内存回收时就必须能识别哪些对象应当放在新生代，哪些对象应放在老年代中。为了做到这点，虚拟机给每个对象定义了一个<strong>对象年龄（Age）计数器。</strong>如果对象在Eden出生并经过第一次Minor GC后仍然存活，并且能被Survivor容纳的话， 将被移动到Survivor空间中，并将对象年龄设为1。对象在Survivor区中每熬过一次Minor GC，年龄就增加1岁，当它的年龄增加到一定程度（15）时，就会被晋升到老年代中。</p><h3 id="4、动态对象年龄判定"><a href="#4、动态对象年龄判定" class="headerlink" title="4、动态对象年龄判定"></a>4、动态对象年龄判定</h3><p>为了能更好的地适应不同程序的内存状况，虚拟机并不能总是要求对象的年龄必须达到<code>MaxTenuringThreshold</code>才能晋升老年代，<strong>如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代。</strong></p><h3 id="5、空间分配担保"><a href="#5、空间分配担保" class="headerlink" title="5、空间分配担保"></a>5、空间分配担保</h3><p>在发生Minor GC时，虚拟机会检测之前每次晋升到老年代的平均大小是否大于老年代的生于空间大小，如果大于，则改为直接进行一次Full GC。如果小于，则查看HandlePromotionFailure设置是否允许担保时报；如果允许，那指挥进行Minor GC；如果不允许，则也要改为进行一次Full GC。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>内存回收与垃圾收集器在很多时候都时影响系统性能、并发能力的主要因素之一，虚拟机之所以提供多种不同的垃圾收集器及大量的调节参数，是因为只有根据实际应用需要、实现方式选择最优的收集方式才能获取最好的性能。</p><p><strong>没有固定收集器、参数组合，也没有最优的调优方法，虚拟机也没有什么必然的内存回收行为。</strong></p><p>因此学习虚拟机内存只是，如果要到实践调优阶段，必须了解每个具体收集器的行为，优势和劣势、调节参数。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>图片来源，<a href="https://my.oschina.net/winHerson/blog/114391">jvm垃圾收集（标记-清除,复制，标记-整理，分代）算法</a></li><li>周志明，深入理解Java虚拟机：JVM高级特性与最佳实践，机械工业出版社 </li></ul>]]></content>
      
      
      <categories>
          
          <category> 书籍 </category>
          
          <category> 《深入理解Java虚拟机》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JVM </tag>
            
            <tag> 《深入理解Java虚拟机》 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java内存区域内存溢出异常</title>
      <link href="/blog/2018/09/08/bc3decee.html"/>
      <url>/blog/2018/09/08/bc3decee.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>Java与C++之间有一堵由内存动态分配和垃圾收集围城的高墙，墙外面的人想进来，墙里面的人却想出去.</p></blockquote><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>对于从事<code>C</code>和<code>C++</code>程序开发的开发人员来说，在内存管理领域，他们既是拥有最高权力的皇帝，又是从事最基础工作的劳动人民——既拥有每一个对象的“所有权”，又担负着每一个对象的生命开始到中积极而的维护责任。</p><p>但对于Java程序员来说，在虚拟机的自动内存管理机制的帮助下，不再需要为每一个<code>new</code>操作去写配对的delete/free代码，而且不容易出现内存溢出和内存泄漏的问题，看起来由虚拟机管理内存一切都很美好。</p><p>不过，也正是因为Java程序员把内存控制的权力交给了Java虚拟机，一旦出现内存泄漏和溢出方面的问题，如果不了解虚拟机是怎么样使用内存的，那排查错误将会成为一项异常艰难的工作。</p><h2 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h2><blockquote><p>Java虚拟机在<strong>执行Java程序的过程中</strong>会把<strong>它所管理的内存</strong>划分为若干不同的数据区域。这些区域都有各自的用途，以及创建和销毁的时间，有的区域随着虚拟机进程的启动而存在，有些区域则依赖用户线程的启动和结束而建立和销毁。</p></blockquote><p><img src="https://gitee.com/cayzlh/img-repo/raw/master/uPic/1.png" alt="1"></p><h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><p>程序计数器（<code>Program Counter Register</code>）是一块较小的内存空间，它的作用可以看成是<strong>当前线程所执行的字节码的行号指示器。</strong>在虚拟机的<em>概念模型</em>里，字节码解释器工作时通过改变这个计数器的值来选取吓一跳需要执行的字节码指令，<code>分支</code>、<code>循环</code>、<code>跳转</code>、<code>异常处理</code>、<code>线程恢复</code>等基础功能都需要依赖这个计数器来完成。</p><p>由于Java虚拟机的多线程是通过<strong>线程轮流切换并分配处理器执行时间</strong>的方式来实现的，在任何一个确定的时刻，一个处理器（对于多核处理器来说是一个内核）只会执行一条线程中的命令。因此，为了<strong>线程切换后能恢复到正确的执行位置</strong>，每条线程都需要有一个独立的程序计数器，各条线程之间的计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。</p><p>如果线程正在执行的是一个Java方法， 这个计数器记录的是正在执行的虚拟机字节码指令地址；如果正在执行的是<strong>Natvie</strong>方法， 这个计数器值则为空（<code>Undefined</code>）。此内存区域是<strong>唯一</strong>一个在Java虚拟机规范中没有规定任何<strong>OOM</strong>情况的区域。</p><h3 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h3><p><strong>Java虚拟机栈（Java Virtual Machine Stacks）也是线程私有的，它的生命周期与线程相同。</strong></p><p>虚拟机栈描述的是Java方法执行的<strong>内存模型</strong>：每个方法被执行的时候都会同事创建一个<code>栈帧（Stack Frame）</code><strong>用于存储局部变量表、操作栈、动态链接、方法出口等信息。</strong></p><blockquote><p>每个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机中从入栈道出栈的过程。</p></blockquote><p><strong>经常所说的堆内存（Heap）和栈内存（Stack）是种比较粗糙的分发，Java内存区域的划分实际上会复杂很多。</strong>这里所指的“<code>栈</code>”就是虚拟机栈，或者说虚拟机栈中的<code>局部变量表</code>部分。</p><p><strong>局部变量表</strong>存放了编译期可知的各种基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference类型，它不等同于对象本身，根据不同的虚拟机实现，可能是指向一个对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与对象相关的位置）和<code>returnAddress</code>类型（指向一条字节码指令的地址）。</p><blockquote><p>64位长度的long和double类型的数据会占用2个局部变量空间（Slot），其余的数据只占用一个。</p><p><strong>局部变量表所需要的内存空间在<code>编译期间</code>完成分配</strong>。当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。</p></blockquote><h4 id="这个区域规定了两种异常状况："><a href="#这个区域规定了两种异常状况：" class="headerlink" title="这个区域规定了两种异常状况："></a>这个区域规定了两种异常状况：</h4><ul><li>如果线程请求的<strong>栈深度</strong>大于虚拟机所允许的深度，将抛出<code>StackOverflowError</code>异常；</li><li>如果虚拟机栈可以动态扩展，当扩展到无法申请到足够的内存时会抛出<code>OutOfMemoryError</code>异常；</li></ul><p><em>当前大部分的Java虚拟机都可以动态扩展，只不过Java虚拟机规范中也允许固定长度的虚拟机栈。</em></p><h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><p><strong>本地方法栈（Native Method Stacks）</strong>与虚拟机栈所发挥的作用时非常相似的。</p><h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><ul><li>虚拟机栈为虚拟机执行Java方法（也就是字节码）服务</li><li>本地方法栈则是为虚拟机使用到的Native服务。</li></ul><p>虚拟机规范中对本地方法栈中的方法使用的语言、使用方式与数据结构并没有强制规定，因此具体的虚拟机可以自由实现它。<em>有些虚拟机（Sun Hotspot）</em>直接把本地方法栈与虚拟机栈合二为一。</p><p>与虚拟机栈一样，本地方法栈区域也会抛出<code>StackOverflowError</code>和<code>OutOfMemoryError</code>异常。</p><h3 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h3><blockquote><p>对于大多数应用来说，Java堆（Java Heap）是Java虚拟机所管理的内存中最大的一块。</p><p>Java虚拟机规范中描述：所有对象实例以及数组都要在堆上分配。</p></blockquote><ol><li>Java堆事被<strong>所有线程</strong>共享的一块内存区域，在<strong>虚拟机启动时</strong>创建。</li><li>此内存区域的唯一目的就是<strong>存放对象实例</strong>，几乎所有的对象实例都是在这里分配内存。</li><li>Java堆事垃圾收集器管理的主要区域，因此很多时候也称作“GC堆”（Garbage Collected Heap）。</li><li>Java堆可以处于<strong>物理上不连续</strong>的内存空间中，只要逻辑上是连续的即可，就像我们的磁盘空间一样。</li></ol><p>从内存回收角度看，由于现在收集齐基本都是采用分代手机算法，所以Java堆中还可以细分为：新生代和老年代；再细分有Eden空间、From Survivor空间、To Survivor空间等。</p><p>从内存分配的角度看，线程共享的Java堆中可能划分出多个线程私有的分配缓冲区。</p><p><strong>无论如何划分，都与存放内容无关，无论哪个区域，存储的都仍然是对象实例，进一步划分是为了更好的回收内存，或者更快的分配内存。</strong>主流的虚拟机都是按照可扩展来实现的（通过<code>-Xmx</code>和<code>-Xms</code>控制）。如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出<code>OutOfMemoryError</code>异常。</p><h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><p>方法区（Method Area）和Java堆一样，是各个<strong>线程共享的内存区域</strong>，它用于存储已被虚拟机家在的类信息、常量、静态变量、即时编译后的代码等数据。</p><blockquote><p>虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它有一个别名叫NonHeap（非堆），目的应该是与Java堆区分开来。</p><p>Java虚拟机规范堆这个区域的限制非常宽松，除了和Java堆一样不需要连续的内存和可以选择固定大小或者可扩展外，还可以选择不实现垃圾收集。</p><p><em>相对而言，垃圾收集行为在这个区域是比较少出现的，但并非数据进入了方法区就如永久代的名字一样“永久”存在了。</em></p></blockquote><p>这个区域的内存回收目标主要是针对<strong>常量池的回收</strong>和对<strong>类型的卸载</strong>，这个区域的回收“成绩”比较难以令人满意，尤其是类型的卸载，条件相当苛刻，但是这部分区域的回收的确是有必要的。</p><p><strong>根据Java虚拟机规范的规定，当方法区无法满足内存分配需求时，将会抛出OutOfMemoryError异常。</strong></p><h3 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h3><p><strong>运行时常量池（Runtime Constant Pool）是方法区的一部分。</strong>Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息时常量池（Constant Pool Table），<strong>用于存放编译期生成的各种字面亮和符号饮用</strong>，这部分内容将在类加载后存放到方法区运行时常量池中。</p><p>Java虚拟机对Class的每一部分的格式都有严格的规定，每一个字节用于存储哪种数据都必须符合规范上的要求，这样才会被虚拟机认可、装载和执行。但是对于常量池，Java虚拟机规范没有做任何细节的要求。一般来说，除了保存Class文件中描述的<strong>符号引用</strong>外，还会把翻译出来的直接饮用也存储在运行时常量池中。</p><p>运行时常量池对于Class文件常量池的另外一个重要特征是具有动态性，Java语言并不要求常量一定只能在编译期产生，也就是并非预置入Class文件中常量池的内容才能进入方法区运行时的常量池，<strong>运行期间也可能将新的常量放入池中，</strong>这种特性被开发人员利用的比较多的便是**String类的intern()**方法。</p><blockquote><p>public String <strong>intern</strong>();</p><p>返回字符串对象的规范化表示形式。</p><p>一个初始时为空的字符串池，它由类 String 私有地维护。</p><p>当调用 intern 方法时，如果池已经包含一个等于此 String 对象的字符串（该对象由 equals(Object) 方法确定），则返回池中的字符串。否则，将此 String 对象添加到池中，并且返回此 String 对象的引用。</p><p>它遵循对于任何两个字符串 s 和 t，当且仅当 s.equals(t) 为 true 时，s.intern() == t.intern() 才为 true。</p><p>所有字面值字符串和字符串赋值常量表达式都是内部的。</p><p><strong>返回：</strong></p><p>一个字符串，内容与此字符串相同，但它保证来自字符串池中。</p></blockquote><p>运行时常量池是方法区的一部分，自然会收到方法区内的限制，当常量池无法再申请到内存时会抛出OutOfMemoryError异常。</p><h3 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h3><p>直接内存（Direct Memory）<strong>并不是</strong>虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用，而且也可能导致<code>OutOfMemoryError</code>异常出现。</p><p>本机内存的分配不会收到Java堆大小的限制，但是，既然是内存，则肯定还是会收到本机总内存（RAM及SWAP区或者分页文件）的大小及处理器寻址空间的限制。分配虚拟机参数时，容易忽略掉直接内存，使得各个内存区域的总和大于物理内存限制，从而导致动态扩展时出现OutOfMemoryError异常。</p><h2 id="对象访问"><a href="#对象访问" class="headerlink" title="对象访问"></a>对象访问</h2><p>对象的访问在<code>Java</code>语言中无处不在，时最普通的程序行为，但即使时最简单的访问，也会去涉及Java栈、Java堆、方法区这三个最重要的内存区域之间的关联关系，如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object obj = <span class="keyword">new</span> Object();</span><br></pre></td></tr></table></figure><p>假设这句代码出现在方法体中：</p><ul><li><strong>“Object obj”</strong>这部分的语义将会反映到<strong>Java栈的本地变量表</strong>中，作为一个<code>reference</code>类型数据出现。</li><li><strong>“new Object( )”</strong>这部分语义将会反映到<strong>Java堆</strong>中</li></ul><p>形成一块存储了Object类型所有实例数据值（<em>Instance Data，对象中各个实例字段的数据</em>）的结构化内存，根据具体类型以及虚拟机实现的对象内存布局的不同，这块内存的长度时不固定的。Java堆中还必须包含能查找到此对象类型数据（<em>如对象类型、父类、实现的接口、方法等</em>）的地址信息，这些类型数据则存储在方法区中。</p><p>不同虚拟机实现的对象访问方式会有所不同。主流的访问方式有两种：</p><ul><li><p>使用句柄</p><p>Java堆中会划分出一块内存作为句柄池，reference中存储的就是<strong>对象的句柄地址</strong>，而句柄中包含了对象实例数据和类型数据各自的<strong>具体地址信息</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/cayzlh/git-img-repository@master/uPic/2.png" alt="2">/2.png)</p><blockquote><p>句柄访问方式最大的好处就是**<code>reference</code>中存储的事稳定的句柄地址，在对象被移动<strong>（垃圾收集时移动对象时非常普遍的行为）</strong>只会改变句柄中的实例数据指针，而<code>reference</code>本身不需要被修改。**</p></blockquote></li><li><p>直接指针</p><p>Java堆对象的布局中必须考虑<strong>如何放置访问类型数据的相关信息，reference中直接存储的就是对象地址</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/cayzlh/git-img-repository@master/uPic/3.png" alt="3"></p><blockquote><p>指针访问方式在最大好处就是速度更快，它节省了一次<strong>指针定位</strong>的时间开销，由于对象的访问在Java中非常频繁，因此这类开销积少成多后也是一项非常可观的执行成本。</p></blockquote></li></ul><h2 id="重现OOM异常"><a href="#重现OOM异常" class="headerlink" title="重现OOM异常"></a>重现OOM异常</h2><p>在Java虚拟机规范的描述中，<strong>除了程序计数器外，虚拟机内存的其他几个运行时区域都有发生OOM异常的可能。</strong></p><h3 id="Java堆溢出"><a href="#Java堆溢出" class="headerlink" title="Java堆溢出"></a>Java堆溢出</h3><p>Java堆用于存储对象实例，我们只要不断的创建对象，并<strong>保证GC Roots到对象之间有可达路径来避免垃圾回收机制清除这些对象</strong>，就会在对象数量达到最大堆容量限制后产生内存溢出异常。</p><blockquote><p>在IDE（如IDEA）里设置JVM参数：</p><p>-Xms20m -Xmx20m -XX:+HeapDumpOnOutOfMemoryError</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapOOM</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">OOMObject</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(Stringp[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;OOMObject&gt; list = <span class="keyword">new</span> ArrayList&lt;OOMObject&gt;;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">            list.add(<span class="keyword">new</span> OOMObject());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行代码将会抛出：<strong>java.lang.OutOfMemoryError: Java heap space</strong>.</p><p>要解决这些问题，重点是确认内存中的对象是否时必要的，也就是要先分清楚到底时出现了内存泄漏还是内存溢出。</p><p>如果时内存泄漏，可进一步通过工具查看泄漏对象到GC Roots的引用链。于是就能找到泄漏对象是通过怎样的路径与GC Roots相关联并导致垃圾收集器无法自动回收它们的。</p><p>如果不存在内存泄漏，那就应该检查<strong>虚拟机堆参数（-Xmx 和 -Xms）</strong>与机器无力内存对比是否还可以调大，从代码上检查是否存在<strong>某些对象的生命周期过长、持有状态时间过长的情况。</strong>尝试减少程序运行期的内存消耗。</p><h3 id="虚拟机栈和本地方法栈溢出"><a href="#虚拟机栈和本地方法栈溢出" class="headerlink" title="虚拟机栈和本地方法栈溢出"></a>虚拟机栈和本地方法栈溢出</h3><blockquote><p>对于HotSpot来说，**-Xoss参数（设置本地方法栈大小）虽然存在，但实际上是无效的**，栈容量只由-Xss参数设定。</p></blockquote><ul><li>如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出StackOverflowError异常。</li><li>如果虚拟机在拓展栈时无法申请到足够的内存空间，则抛出OutOfMemoryError异常。</li></ul><blockquote><p>在IDE（如IDEA）里设置JVM参数：</p><p>-Xss128k</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaVMStackSOF</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> stackLength = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stackLeak</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stackLength++;</span><br><span class="line">        stackLeak();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        JavaVMStackSOF oom = <span class="keyword">new</span> JavaVMStackSOF();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            oom.stackLeak();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;stack length:&quot;</span> + ooo.stackLength);</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果：</strong></p><p>Stack length:2402</p><p>Exception in thread “main” java.lang.StackOverflowError</p><p> ··········后续异常栈信息省略。</p><p><strong>结果证明：</strong>在单个线程下，无论是由于栈帧太大，还是虚拟机栈容量太小，当内存无法分配的时候， 虚拟机抛出的都是StackOverflowError异常。</p><blockquote><p>在IDE（如IDEA）里设置JVM参数：</p><p>-Xss2M</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaVMStackOOM</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dontStop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stackLeakThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">                    dontStop();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        JavaVMStackOOM oom = <span class="keyword">new</span> JavaVMStackOOM();</span><br><span class="line">        oom.stackLeakThread();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注：如果要运行这顿啊代码，记得要先保存当前的工作，由于在Windows平台的虚拟机中，Java的线程是映射到操作系统的内核线程上的，所以上述代码执行时有较大的风险，可能会导致操作系统假死。</strong></p><p><strong>运行结果：</strong></p><p>Exception in thread “main” java.lang.OutOfMemoryError: unable to create new native thread</p><p><strong>实验证明：</strong></p><p>通过不断的建立线程的方式可以产生内存溢出异常，但是，这样产生的内存溢出异常与栈空间是否足够大并不存在任何联系，或者准确的说，<strong>在这种情况下，给每个线程的栈分配的内存越大，反而越容易产生内存溢出异常。</strong></p><blockquote><p>如果是建立过多线程导致的内存溢出，在不能减少线程数或者更换64位虚拟机的情况下，就只能通过减少最大堆和减少栈容量来换取更多的线程。如果没有这方面的经验，这种通过“减少内存”的手段来解决内存溢出的方式会比较难以想到。</p></blockquote><h3 id="运行时常量池溢出"><a href="#运行时常量池溢出" class="headerlink" title="运行时常量池溢出"></a>运行时常量池溢出</h3><p>如果要向运行时常量池中添加内容， 嘴贱的做法就是使用String.intern()这个Native方法。<strong>该方法的作用是：如果池中已经包含一个等于此String对象的字符串，则返代表池中这个字符串的String对象；否则，将此String对象包含的字符串的添加到常量池中，并且返回此String对象的引用。</strong></p><blockquote><p>在IDE（如IDEA）里设置JVM参数：</p><p>-XXPermSize=10M -XX:MaxPermSize=10M</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RuntimeConstantPoolOOM</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 使用List保存着常量池引用，避免Full GC回收常量池行为</span></span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            list.add(String.valueOf(i++).intern());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果：</strong></p><p>Exception in thread “main” java.lang.OutOfMemoryError: <strong>PermGen space</strong></p><p><strong>实验结果：</strong></p><p>运行时常量池溢出，在OOM后面跟随着的提示信息是<strong>PermGen space</strong>，说明<strong>运行时常量池属于方法区</strong>（HotSpot虚拟机中的永久代）的一部分。</p><h3 id="方法区溢出"><a href="#方法区溢出" class="headerlink" title="方法区溢出"></a>方法区溢出</h3><p><strong>方法区用于存放Class的相关信息，</strong>如类名、访问修饰符、常量池、字段描述、方法描述等。这个实验需要通过生成大量的动态类来实现，使用CGLib这类字节码技术，增强的类越多，就需要越大的方法区来保证动态生成的Class可以加载如内存。</p><blockquote><p>在IDE（如IDEA）里设置JVM参数：</p><p>-XX:PermSize=10M -XX:MaxPermSize=10M</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaMethodAreaOOM</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">            enhancer.setSuperclass(OOMObject.class);</span><br><span class="line">            enhancer.setUseCache(<span class="keyword">false</span>);</span><br><span class="line">            enhancer.setCallback(<span class="keyword">new</span> MethodInterceptor() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object object, Method method, </span></span></span><br><span class="line"><span class="function"><span class="params">                                        Object[] args, MethodProxy mhodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> proxy.invokeSuper(obj, args);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            enhancer.create();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">static</span> class <span class="title">OOMObject</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果：</strong></p><p>Caused by:  java.lang.OutOfMemoryError: <strong>PermGen space</strong></p><p><strong>实验结果：</strong></p><p>方法区溢出也是一种常见的内存溢出异常，一个类如果被垃圾收集器回收掉，判断条件是非常苛刻的。<strong>在经常动态生成大量Class的应用中，需要特别注意类的回收状态。</strong></p><h3 id="本机直接内存溢出"><a href="#本机直接内存溢出" class="headerlink" title="本机直接内存溢出"></a>本机直接内存溢出</h3><p>通过反射获取Unsafe实例进行内存分配（Unsafe类的getUnSafe()方法限制了只有引导类加载器才会返回实例，也就是设计者希望只有rt.jar中的类可以使用Unsafe的功能）。因为，虽然使用DirectByteBuffer分配内存也会抛出内存溢出异常，但它抛出异常时并没有真正向操作系统申请分配内存，而是<strong>通过计算得知内存无法分配</strong>，于是手动抛出异常，真正申请分配内存的方法是unsafe.allocateMemory()。</p><blockquote><p>在IDE（如IDEA）里设置JVM参数：</p><p>-Xmx20M -XX:MaxDirectMemorySize=10M</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DirectMemoryOOM</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _1MB = <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Field unsafeField = Unsafe.class.getDeclaredFields()[<span class="number">0</span>];</span><br><span class="line">        unsafeField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        Unsafe unsafe = (Unsafe) unsafeField.get(<span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            unsafe.allocateMemory(_1MB);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果：</strong></p><p>Exception in thread “main” java.lang.OutOfMemoryError</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul><li>内存是如何划分的</li><li>哪部分区域、什么样的代码和操作可能导致内存溢出异常</li></ul><p>虽然Java有垃圾收集机制，但内存溢出异常离我们并不遥远，本章讲解了解了各个区域出现内存溢出异常的原因。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>周志明，深入理解Java虚拟机：JVM高级特性与最佳实践，机械工业出版社 </li></ul>]]></content>
      
      
      <categories>
          
          <category> 书籍 </category>
          
          <category> 《深入理解Java虚拟机》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JVM </tag>
            
            <tag> 《深入理解Java虚拟机》 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring事务管理</title>
      <link href="/blog/2018/09/03/762945f0.html"/>
      <url>/blog/2018/09/03/762945f0.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>事务是逻辑上的一组操作，要么都执行，要么都不执行.</p></blockquote><h3 id="事务的特性-ACID"><a href="#事务的特性-ACID" class="headerlink" title="事务的特性(ACID)"></a>事务的特性(ACID)</h3><p><img src="https://github.com/cayzlh/git-img-repository/raw/master/blog/2018090301/1.png" alt="ACID"></p><p><strong>原子性：</strong> 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；</p><p><strong>一致性：</strong> 执行事务前后，数据保持一致；</p><p><strong>隔离性：</strong> 并发访问数据库时，一个用户的事物不被其他事物所干扰，各并发事务之间数据库是独立的；</p><p><strong>持久性:</strong>  一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。</p><h3 id="Spring事务管理接口"><a href="#Spring事务管理接口" class="headerlink" title="Spring事务管理接口"></a>Spring事务管理接口</h3><h4 id="PlatformTransactionManager：-（平台）事务管理器"><a href="#PlatformTransactionManager：-（平台）事务管理器" class="headerlink" title="PlatformTransactionManager： （平台）事务管理器"></a><strong>PlatformTransactionManager：</strong> （平台）事务管理器</h4><p><strong>Spring并不直接管理事务，而是提供了多种事务管理器</strong> ，他们将事务管理的职责委托给Hibernate或者JTA等持久化机制所提供的相关平台框架的事务来实现。 Spring事务管理器的接口是： <strong>org.springframework.transaction.PlatformTransactionManager</strong> ，通过这个接口，Spring为各个平台如JDBC、Hibernate等都提供了对应的事务管理器，但是具体的实现就是各个平台自己的事情了。</p><p>PlatformTransactionManager接口中定义了三个方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Public interface <span class="title">PlatformTransactionManager</span><span class="params">()</span>...</span>&#123;  </span><br><span class="line">    <span class="comment">// Return a currently active transaction or create a new one, according to the specified propagation behavior（根据指定的传播行为，返回当前活动的事务或创建一个新事务。）</span></span><br><span class="line">    <span class="function">TransactionStatus <span class="title">getTransaction</span><span class="params">(TransactionDefinition definition)</span> <span class="keyword">throws</span> TransactionException</span>; </span><br><span class="line">    <span class="comment">// Commit the given transaction, with regard to its status（使用事务目前的状态提交事务）</span></span><br><span class="line">    <span class="function">Void <span class="title">commit</span><span class="params">(TransactionStatus status)</span> <span class="keyword">throws</span> TransactionException</span>;  </span><br><span class="line">    <span class="comment">// Perform a rollback of the given transaction（对执行的事务进行回滚）</span></span><br><span class="line">    <span class="function">Void <span class="title">rollback</span><span class="params">(TransactionStatus status)</span> <span class="keyword">throws</span> TransactionException</span>;  </span><br><span class="line">    &#125; </span><br></pre></td></tr></table></figure><blockquote><p>Spring中PlatformTransactionManager根据不同持久层框架所对应的接口实现类</p></blockquote><p><img src="https://github.com/cayzlh/git-img-repository/raw/master/blog/2018090301/2.png" alt="ACID"></p><h4 id="TransactionDefinition：-事务定义信息-事务隔离级别、传播行为、超时、只读、回滚规则"><a href="#TransactionDefinition：-事务定义信息-事务隔离级别、传播行为、超时、只读、回滚规则" class="headerlink" title="TransactionDefinition： 事务定义信息(事务隔离级别、传播行为、超时、只读、回滚规则)"></a><strong>TransactionDefinition：</strong> 事务定义信息(事务隔离级别、传播行为、超时、只读、回滚规则)</h4><p>事务管理器接口 <strong>PlatformTransactionManager</strong> 通过 <strong>getTransaction(TransactionDefinition definition)</strong> 方法来得到一个事务，这个方法里面的参数是 <strong>TransactionDefinition类</strong> ，这个类就定义了一些基本的事务属性。</p><p><strong>那么什么是事务属性呢？</strong></p><p>事务属性可以理解成事务的一些基本配置，描述了事务策略如何应用到方法上。事务属性包含了5个方面。</p><p><img src="https://github.com/cayzlh/git-img-repository/raw/master/blog/2018090301/3.png" alt="ACID"></p><p>TransactionDefinition接口中的方法如下：</p><p>TransactionDefinition接口中定义了5个方法以及一些表示事务属性的常量比如隔离级别、传播行为等等的常量。</p><p>我下面只是列出了TransactionDefinition接口中的方法而没有给出接口中定义的常量</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TransactionDefinition</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 返回事务的传播行为</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getPropagationBehavior</span><span class="params">()</span></span>; </span><br><span class="line">    <span class="comment">// 返回事务的隔离级别，事务管理器根据它来控制另外一个事务可以看到本事务内的哪些数据</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getIsolationLevel</span><span class="params">()</span></span>; </span><br><span class="line">    <span class="comment">// 返回事务必须在多少秒内完成</span></span><br><span class="line">    <span class="comment">//返回事务的名字</span></span><br><span class="line">    <span class="function">String <span class="title">getName</span><span class="params">()</span>；</span></span><br><span class="line"><span class="function">    <span class="keyword">int</span> <span class="title">getTimeout</span><span class="params">()</span></span>;  </span><br><span class="line">    <span class="comment">// 返回是否优化为只读事务。</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isReadOnly</span><span class="params">()</span></span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h4 id="TransactionStatus：-事务运行状态"><a href="#TransactionStatus：-事务运行状态" class="headerlink" title="TransactionStatus： 事务运行状态"></a><strong>TransactionStatus：</strong> 事务运行状态</h4><p>TransactionStatus接口用来记录事务的状态 该接口定义了一组方法,用来获取或判断事务的相应状态信息.</p><p>PlatformTransactionManager.getTransaction(…) 方法返回一个 TransactionStatus 对象。返回的TransactionStatus 对象可能代表一个新的或已经存在的事务（如果在当前调用堆栈有一个符合条件的事务）。</p><p>TransactionStatus接口接口内容如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TransactionStatus</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isNewTransaction</span><span class="params">()</span></span>; <span class="comment">// 是否是新的事物</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">hasSavepoint</span><span class="params">()</span></span>; <span class="comment">// 是否有恢复点</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setRollbackOnly</span><span class="params">()</span></span>;  <span class="comment">// 设置为只回滚</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isRollbackOnly</span><span class="params">()</span></span>; <span class="comment">// 是否为只回滚</span></span><br><span class="line">    <span class="keyword">boolean</span> isCompleted; <span class="comment">// 是否已完成</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p><strong>所谓事务管理，其实就是“按照给定的事务规则来执行提交或者回滚操作”</strong>。</p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://juejin.im/post/5b00c52ef265da0b95276091">https://juejin.im/post/5b00c52ef265da0b95276091</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> 转载 </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>volatile</title>
      <link href="/blog/2018/08/30/fe4c9cb6.html"/>
      <url>/blog/2018/08/30/fe4c9cb6.html</url>
      
        <content type="html"><![CDATA[<h3 id="volatile的用法"><a href="#volatile的用法" class="headerlink" title="volatile的用法"></a>volatile的用法</h3><p><code>volatile</code>通常被比喻成”轻量级的<code>synchronized</code>“，也是Java并发编程中比较重要的一个关键字。和<code>synchronized</code>不同，<code>volatile</code>是一个变量修饰符，只能用来修饰变量。无法修饰方法及代码块等。</p><p><code>volatile</code>的用法比较简单，只需要在声明一个可能被多线程同时访问的变量时，使用<code>volatile</code>修饰就可以了。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton singleton;  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getSingleton</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;  </span><br><span class="line">        <span class="keyword">synchronized</span> (Singleton.class) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;  </span><br><span class="line">            singleton = <span class="keyword">new</span> Singleton();  </span><br><span class="line">        &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> singleton;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>如以上代码，是一个比较典型的使用双重锁校验的形式实现单例的，其中使用<code>volatile</code>关键字修饰可能被多个线程同时访问到的singleton。</p><h3 id="volatile的原理"><a href="#volatile的原理" class="headerlink" title="volatile的原理"></a>volatile的原理</h3><blockquote><p>为了提高处理器的执行速度，在处理器和内存之间增加了多级缓存来提升。但是由于引入了多级缓存，就存在缓存数据不一致问题。</p><p>但是，对于<code>volatile</code>变量，当对<code>volatile</code>变量进行写操作的时候，JVM会向处理器发送一条lock前缀的指令，将这个缓存中的变量回写到系统主存中。</p><p>但是就算写回到内存，如果其他处理器缓存的值还是旧的，再执行计算操作就会有问题，所以在多处理器下，为了保证各个处理器的缓存是一致的，就会实现<code>缓存一致性协议</code></p></blockquote><h4 id="缓存一致性协议"><a href="#缓存一致性协议" class="headerlink" title="缓存一致性协议"></a>缓存一致性协议</h4><p>每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，当处理器要对这个数据进行修改操作的时候，会强制重新从系统内存里把数据读到处理器缓存里。</p><p>所以，如果一个变量被<code>volatile</code>所修饰的话，在每次数据变化之后，其值都会被强制刷入主存。而其他处理器的缓存由于遵守了缓存一致性协议，也会把这个变量的值从主存加载到自己的缓存中。这就保证了一个<code>volatile</code>在并发编程中，其值在多个缓存中是可见的。</p><h3 id="volatile与可见性"><a href="#volatile与可见性" class="headerlink" title="volatile与可见性"></a>volatile与可见性</h3><p><strong>可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。</strong></p><p><a href="https://blog.cayzlh.com/2018/08/28/2018082801/">Java内存模型</a>规定了所有的变量都存储在主内存中，每条线程还有自己的工作内存，线程的工作内存中保存了该线程中是用到的变量的主内存副本拷贝，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存。不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量的传递均需要自己的工作内存和主存之间进行数据同步进行。所以，就可能出现线程1改了某个变量的值，但是线程2不可见的情况。</p><blockquote><p>Java中的<code>volatile</code>关键字提供了一个功能，那就是被其修饰的变量在被修改后可以立即同步到主内存，被其修饰的变量在每次是用之前都从主内存刷新。因此，可以使用<code>volatile</code>来保证多线程操作时变量的可见性。</p></blockquote><p>volatile对于可见性的实现，<strong>内存屏障</strong>也起着至关重要的作用。因为内存屏障相当于一个数据同步点，他要保证在这个同步点之后的读写操作必须在这个点之前的读写操作都执行完之后才可以执行。并且在遇到内存屏障的时候，缓存数据会和主存进行同步，或者把缓存数据写入主存、或者从主存把数据读取到缓存。</p><p><em>内存一致性模型的实现可以通过缓存一致性协议来实现。同时，留了一个问题：已经有了缓存一致性协议，为什么还需要volatile？</em></p><blockquote><p>1、并不是所有的硬件架构都提供了相同的一致性保证，Java作为一门跨平台语言，JVM需要提供一个统一的语义。</p><p>2、操作系统中的缓存和JVM中线程的本地内存并不是一回事，通常我们可以认为：MESI可以解决缓存层面的可见性问题。使用volatile关键字，可以解决JVM层面的可见性问题。</p><p>3、缓存可见性问题的延伸：由于传统的MESI协议的执行成本比较大。所以CPU通过Store Buffer和Invalidate Queue组件来解决，但是由于这两个组件的引入，也导致缓存和主存之间的通信并不是实时的。也就是说，<strong>缓存一致性模型只能保证缓存变更可以保证其他缓存也跟着改变，但是不能保证立刻、马上执行。</strong></p></blockquote><p><em>写内存屏障（Store Memory Barrier）</em>可以促使处理器将当前store buffer（存储缓存）的值写回主存。</p><p><em>读内存屏障（Load Memory Barrier）</em>可以促使处理器处理invalidate queue（失效队列）。</p><p><strong>所以，内存屏障也是保证可见性的重要手段，操作系统通过内存屏障保证缓存间的可见性，JVM通过给volatile变量加入内存屏障保证线程之间的可见性。</strong>进而避免由于Store Buffer和Invalidate Queue的非实时性带来的问题。</p><h4 id="内存屏障"><a href="#内存屏障" class="headerlink" title="内存屏障"></a>内存屏障</h4><p>Java中的内存屏障：用于控制特定条件下的重排序和内存可见性问题。Java编译器也会根据内存屏障的规则禁止重排序。</p><h3 id="volatile与有序性"><a href="#volatile与有序性" class="headerlink" title="volatile与有序性"></a>volatile与有序性</h3><blockquote><p>有序性即程序执行的顺序按照代码的先后顺序执行。 </p></blockquote><p><a href="https://blog.cayzlh.com/2018/08/28/2018082801/">除了引入了时间片以外，由于处理器优化和指令重排等，CPU还可能对输入代码进行乱序执行，比如<code>load-&gt;add-&gt;save</code> 有可能被优化成<code>load-&gt;save-&gt;add</code> 。这就是可能存在有序性问题</a>。</p><p>而<code>volatile</code>除了可以保证数据的可见性之外，还有一个强大的功能，那就是他可以<strong>禁止指令重排优化</strong>等。</p><p>普通的变量仅仅会保证在该方法的执行过程中所依赖的赋值结果的地方都能获得正确的结果，而不能保证变量的赋值操作的顺序与程序代码中的执行顺序一致。</p><p>volatile可以禁止指令重排，这就保证了代码的程序会严格按照代码的先后顺序执行。这就保证了有序性。被<code>volatile</code>修饰的变量的操作，会严格按照代码顺序执行，<code>load-&gt;add-&gt;save</code> 的执行顺序就是：load、add、save。</p><p><strong>volatile是通过<em>内存屏障</em>来来禁止指令重排的。</strong></p><p><strong>内存屏障（Memory Barrier）</strong>是一类同步屏障指令，是CPU或编译器在对内存随机访问的操作中的一个同步点，使得此点之前的所有读写操作都执行后才可以开始执行此点之后的操作。下表描述了和volatile有关的指令重排禁止行为：</p><p><img src="https://github.com/cayzlh/git-img-repository/raw/master/blog/2018083001/1.png" alt="内存屏障"></p><p>可以看出：</p><blockquote><p>当第二个操作是volatile写时，不管第一个操作是什么，都不能重排序。这个规则确保volatile写之前的操作不会被编译器重排序到volatile写之后。</p><p>当第一个操作是volatile读时，不管第二个操作是什么，都不能重排序。这个规则确保volatile读之后的操作不会被编译器重排序到volatile读之前。</p><p>当第一个操作是volatile写，第二个操作是volatile读时，不能重排序。</p></blockquote><p>具体实现方式是在编译期生成字节码时，会在指令序列中增加内存屏障来保证，下面是基于保守策略的JMM内存屏障插入策略：</p><ul><li><p>在每个volatile写操作的前面插入一个<code>StoreStore</code>屏障。</p></li><li><ul><li>对于这样的语句Store1; StoreLoad; Store2，在Store2及后续写入操作执行前，保证Store1的写入操作对其它处理器可见。</li></ul></li><li><p>在每个volatile写操作的后面插入一个<code>StoreLoad</code>屏障。</p></li><li><ul><li>对于这样的语句Store1; StoreLoad; Load2，在Load2及后续所有读取操作执行前，保证Store1的写入对所有处理器可见。</li></ul></li><li><p>在每个volatile读操作的后面插入一个<code>LoadLoad</code>屏障。</p></li><li><ul><li>对于这样的语句Load1;LoadLoad; Load2，在Load2及后续读取操作要读取的数据被访问前，保证Load1要读取的数据被读取完毕。</li></ul></li><li><p>在每个volatile读操作的后面插入一个<code>LoadStore</code>屏障。</p></li><li><ul><li>对于这样的语句Load1; LoadStore; Store2，在Store2及后续写入操作被刷出前，保证Load1要读取的数据被读取完毕。</li></ul></li></ul><p><img src="https://github.com/cayzlh/git-img-repository/raw/master/blog/2018083001/2.png" alt="内存屏障"></p><p>所以，volatile通过在volatile变量的操作前后插入内存屏障的方式，来禁止指令重排，进而保证多线程情况下对共享变量的有序性。</p><h3 id="volatile与原子性"><a href="#volatile与原子性" class="headerlink" title="volatile与原子性"></a>volatile与原子性</h3><blockquote><p>原子性是指一个操作是不可中断的，要全部执行完成，要不就都不执行。 </p></blockquote><p><strong>线程是CPU调度的基本单位。CPU有时间片的概念，会根据不同的调度算法进行线程调度。当一个线程获得时间片之后开始执行，在时间片耗尽之后，就会失去CPU使用权。所以在多线程场景下，由于时间片在线程间轮换，就会发生原子性问题。</strong></p><p><a href="https://blog.cayzlh.com/2018/08/28/2018082802/">synchronized</a>提到过，为了保证原子性，需要通过字节码指令<code>monitorenter</code>和<code>monitorexit</code>，但是<code>volatile</code>和这两个指令之间是没有任何关系的。</p><p><strong>所以，volatile是不能保证原子性的。</strong></p><p>在以下两个场景中可以使用<code>volatile</code>来代替<code>synchronized</code>：</p><blockquote><p>1、运算结果并不依赖变量的当前值，或者能够确保只有单一的线程会修改变量的值。</p><p>2、变量不需要与其他状态变量共同参与不变约束。</p></blockquote><p>除以上场景外，都需要使用其他方式来保证原子性，如<code>synchronized</code>或者<code>concurrent包</code>。 </p><p>看如下代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increase</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Test test = <span class="keyword">new</span> Test();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">1000</span>;j++)</span><br><span class="line">                        test.increase();</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;.start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(Thread.activeCount()&gt;<span class="number">1</span>)  <span class="comment">//保证前面的线程都执行完</span></span><br><span class="line">            Thread.yield();</span><br><span class="line">        System.out.println(test.i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码比较简单，就是创建10个线程，然后分别执行1000次<code>i++</code>操作。正常情况下，程序的输出结果应该是10000，但是，多次执行的结果都小于10000。这其实就是<code>volatile</code>无法满足原子性的原因。</p><p>为什么会出现这种情况呢，那就是因为虽然volatile可以保证<code>i</code>在多个线程之间的可见性。但是无法保证<code>i++</code>的原子性。</p><p><code>i++</code>操作，一共有三个步骤：<code>load i</code> ，<code>add i</code> ,<code>save i</code>。在多线程场景中，如果这三个步骤无法按照顺序执行的话，那么就会出现问题。</p><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p>由于CPU按照时间片来进行线程调度的，只要是包含多个步骤的操作的执行，天然就是无法保证原子性的。因为这种线程执行，又不像数据库一样可以回滚。如果一个线程要执行的步骤有5步，执行完3步就失去了CPU了，失去后就可能再也不会被调度，这怎么可能保证原子性呢。</p><p>为什么<code>synchronized</code>可以保证原子性 ，因为被<code>synchronized</code>修饰的代码片段，在进入之前加了锁，只要他没执行完，其他线程是无法获得锁执行这段代码片段的，就可以保证他内部的代码可以全部被执行。进而保证原子性。</p><p>但是<code>synchronized</code>对原子性保证也不绝对，一旦代码运行异常，也没办法回滚。所以呢，在并发编程中，原子性的定义不应该和事务中的原子性一样。他应该定义为：<strong>一段代码，或者一个变量的操作，在没有执行完之前，不能被其他线程执行。</strong></p><p>那么，为什么<code>volatile</code>不能保证原子性呢？因为他不是锁，他没做任何可以保证原子性的处理。当然就不能保证原子性了。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>synchronized</title>
      <link href="/blog/2018/08/28/edea11bc.html"/>
      <url>/blog/2018/08/28/edea11bc.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>Java语言为了解决并发编程中存在的原子性、可见性和有序性问题，提供了一系列和并发处理相关的关键字，比如synchronized、volatile、final、concurren包等。</p></blockquote><p>在《深入理解Java虚拟机》中，有这样一段话：</p><blockquote><p><code>synchronized</code>关键字在需要原子性、可见性和有序性这三种特性的时候都可以作为其中一种解决方案，看起来是“万能”的。的确，大部分并发控制操作都能使用synchronized来完成。</p></blockquote><p><code>synchronized</code>只是个关键字而已，用起来很简单。之所以我们可以在处理多线程问题时可以不用考虑太多，就是因为这个关键字帮我们屏蔽了很多细节。</p><p>本文主要介绍<code>synchronized</code>的用法、原理，以及如何提供原子性、可见性和有序性保障的等。</p><h3 id="synchronized的用法"><a href="#synchronized的用法" class="headerlink" title="synchronized的用法"></a>synchronized的用法</h3><p><code>synchronized</code>是Java提供的一个并发控制的关键字。主要有两种用法，分别是同步方法和同步代码块。</p><p>也就是说，<code>synchronized</code>既可以修饰方法也可以修饰代码块。代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedDemo</span> </span>&#123;</span><br><span class="line">     <span class="comment">//同步方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">doSomeThing</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//同步代码块</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doOtherThing</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (SynchronizedDemo.class)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>被<code>synchronized</code>修饰的代码块及方法，在同一时间，只能被单个线程访问。 </p><h3 id="synchronized的实现原理"><a href="#synchronized的实现原理" class="headerlink" title="synchronized的实现原理"></a>synchronized的实现原理</h3><blockquote><p><code>synchronized</code>，是Java中用于解决并发情况下数据同步访问的一个很重要的关键字。当我们想要保证一个共享资源在同一时间只会被一个线程访问到时，我们可以在代码中使用<code>synchronized</code>关键字对类或者对象加锁。</p></blockquote><p>我们对上面的代码进行反编译，可以得到如下代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">cayzlh</span>.<span class="title">SynchronizedDemo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> com.cayzlh.SynchronizedDemo();</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0</span><br><span class="line">       1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">       <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">doSomeThing</span><span class="params">()</span></span>;</span><br><span class="line">    Code:</span><br><span class="line">       0: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">       3: ldc           #3                  // String Hello World</span><br><span class="line">       5: invokevirtual #4                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">       <span class="number">8</span>: <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doOtherThing</span><span class="params">()</span></span>;</span><br><span class="line">    Code:</span><br><span class="line">       0: ldc           #5                  // class com/cayzlh/SynchronizedDemo</span><br><span class="line">       <span class="number">2</span>: dup</span><br><span class="line">       <span class="number">3</span>: astore_1</span><br><span class="line">       <span class="number">4</span>: monitorenter</span><br><span class="line">       5: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">       8: ldc           #3                  // String Hello World</span><br><span class="line">      10: invokevirtual #4                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">      <span class="number">13</span>: aload_1</span><br><span class="line">      <span class="number">14</span>: monitorexit</span><br><span class="line">      <span class="number">15</span>: goto          <span class="number">23</span></span><br><span class="line">      <span class="number">18</span>: astore_2</span><br><span class="line">      <span class="number">19</span>: aload_1</span><br><span class="line">      <span class="number">20</span>: monitorexit</span><br><span class="line">      <span class="number">21</span>: aload_2</span><br><span class="line">      <span class="number">22</span>: athrow</span><br><span class="line">      <span class="number">23</span>: <span class="keyword">return</span></span><br><span class="line">    Exception table:</span><br><span class="line">       from    to  target type</span><br><span class="line">           <span class="number">5</span>    <span class="number">15</span>    <span class="number">18</span>   any</span><br><span class="line">          <span class="number">18</span>    <span class="number">21</span>    <span class="number">18</span>   any</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出：</p><p>对于同步方法，JVM采用<code>ACC_SYNCHRONIZED</code>标记符来实现同步。 </p><p>对于同步代码块。JVM采用<code>monitorenter</code>、<code>monitorexit</code>两个指令来实现同步。</p><p>在The Java® Virtual Machine Specification中有关于同步方法和同步代码块的实现原理的介绍:</p><blockquote><p>Method-level synchronization is performed implicitly, as part of method invocation and return. A synchronized method is distinguished in the run-time constant pool’s method<em>info structure by the ACC</em>SYNCHRONIZED flag, which is checked by the method invocation instructions. When invoking a method for which ACC_SYNCHRONIZED is set, the executing thread enters a monitor, invokes the method itself, and exits the monitor whether the method invocation completes normally or abruptly. During the time the executing thread owns the monitor, no other thread may enter it. If an exception is thrown during invocation of the synchronized method and the synchronized method does not handle the exception, the monitor for the method is automatically exited before the exception is rethrown out of the synchronized method.</p><p>方法级的同步是隐式的。同步方法的常量池中会有一个<code>ACC_SYNCHRONIZED</code>标志。当某个线程要访问某个方法的时候，会检查是否有<code>ACC_SYNCHRONIZED</code>，如果有设置，则需要先获得监视器锁，然后开始执行方法，方法执行之后再释放监视器锁。这时如果其他线程来请求执行方法，会因为无法获得监视器锁而被阻断住。值得注意的是，<strong>如果在方法执行过程中，发生了异常，并且方法内部并没有处理该异常，那么在异常被抛到方法外面之前监视器锁会被自动释放。</strong></p><p>同步代码块使用<code>monitorenter</code>和<code>monitorexit</code>两个指令实现。可以把执行<code>monitorenter</code>指令理解为加锁，执行<code>monitorexit</code>理解为释放锁。 每个对象维护着一个记录着被锁次数的计数器。未被锁定的对象的该计数器为0，当一个线程获得锁（执行<code>monitorenter</code>）后，该计数器自增变为 1 ，当同一个线程再次获得该对象的锁的时候，计数器再次自增。当同一个线程释放锁（执行<code>monitorexit</code>指令）的时候，计数器再自减。当计数器为0的时候。锁将被释放，其他线程便可以获得锁。</p></blockquote><p>无论是<code>ACC_SYNCHRONIZED</code>还是<code>monitorenter</code>、<code>monitorexit</code>都是基于Monitor实现的，在Java虚拟机(HotSpot)中，Monitor是基于C++实现的，由ObjectMonitor实现。</p><p><code>ObjectMonitor</code>类中提供了几个方法，如<code>enter</code>、<code>exit</code>、<code>wait</code>、<code>notify</code>、<code>notifyAll</code>等。<code>sychronized</code>加锁的时候，会调用<code>objectMonitor</code>的<code>enter</code>方法，解锁的时候会调用<code>exit</code>方法。</p><h3 id="synchronized与有序性"><a href="#synchronized与有序性" class="headerlink" title="synchronized与有序性"></a>synchronized与有序性</h3><p>有序性即程序执行的顺序按照代码的先后顺序执行。</p><blockquote><p>由于处理器优化和指令重排等，CPU还可能对输入代码进行乱序执行，比如load-&gt;add-&gt;save 有可能被优化成load-&gt;save-&gt;add 。这就是可能存在有序性问题。</p></blockquote><p>这里需要注意的是，<code>synchronized</code>是无法禁止指令重排和处理器优化的。也就是说，<code>synchronized</code>无法避免上述提到的问题。</p><p><em>那么，为什么还说<code>synchronized</code>也提供了有序性保证呢？</em></p><p><strong>Java程序中天然的有序性可以总结为一句话：如果在本线程内观察，所有操作都是天然有序的。如果在一个线程中观察另一个线程，所有操作都是无序的。</strong></p><p>以上这句话也是《深入理解Java虚拟机》中的原句，这和<code>as-if-serial语义</code>有关。</p><p><code>as-if-serial</code>语义的意思指：不管怎么重排序（编译器和处理器为了提高并行度），单线程程序的执行结果都不能被改变。编译器和处理器无论如何优化，都必须遵守<code>as-if-serial</code>语义。</p><p>简单说就是，<code>as-if-serial语义</code>保证了单线程中，指令重排是有一定的限制的，而只要编译器和处理器都遵守了这个语义，那么就可以认为单线程程序是按照顺序执行的。当然，实际上还是有重排的，只不过我们无须关心这种重排的干扰。</p><p><strong>所以呢，由于synchronized修饰的代码，同一时间只能被同一线程访问。那么也就是单线程执行的。所以，可以保证其有序性。</strong></p><h3 id="synchronized与锁优化"><a href="#synchronized与锁优化" class="headerlink" title="synchronized与锁优化"></a><strong>synchronized与锁优化</strong></h3><p><code>synchronized</code>其实是借助Monitor实现的，在加锁时会调用objectMonitor的<code>enter</code>方法，解锁的时候会调用<code>exit</code>方法。事实上，只有在JDK1.6之前，synchronized的实现才会直接调用ObjectMonitor的<code>enter</code>和<code>exit</code>，这种锁被称之为重量级锁。</p><p>所以，在JDK1.6中出现对锁进行了很多的优化，进而出现轻量级锁，偏向锁，锁消除，适应性自旋锁，锁粗化(自旋锁在1.4就有，只不过默认的是关闭的，jdk1.6是默认开启的)，这些操作都是为了在线程之间更高效的共享数据 ，解决竞争问题。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java内存模型的实现</title>
      <link href="/blog/2018/08/28/2e82a2db.html"/>
      <url>/blog/2018/08/28/2e82a2db.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>在Java中提供了一系列和并发处理相关的关键字，比如<code>volatile</code>、<code>synchronized</code>、<code>final</code>、<code>concurren</code>包等。其实这些就是Java内存模型封装了底层的实现后提供给程序员使用的一些关键字。</p></blockquote><h3 id="什么是内存模型-？"><a href="#什么是内存模型-？" class="headerlink" title="什么是内存模型 ？"></a>什么是内存模型 ？</h3><p>缓存一致性问题、处理器器优化的指令重排问题是硬件的不断升级导致的。那么，有没有什么机制可以很好的解决上面的这些问题呢？</p><p>最简单直接的做法就是废除处理器和处理器的优化技术、废除CPU缓存，让CPU直接和主存交互。但是，这么做虽然可以保证多线程下的并发问题。但是，这就有点因噎废食了。</p><p>所以，为了保证并发编程中可以满足原子性、可见性及有序性。有一个重要的概念，那就是——内存模型。</p><p><strong>为了保证共享内存的正确性（可见性、有序性、原子性），内存模型定义了共享内存系统中多线程程序读写操作行为的规范。</strong>通过这些规则来规范对内存的读写操作，从而保证指令执行的正确性。它与处理器有关、与缓存有关、与并发有关、与编译器也有关。他解决了CPU多级缓存、处理器优化、指令重排等导致的内存访问问题，保证了并发场景下的一致性、原子性和有序性。</p><hr><p>在开发多线程的代码的时候，可以直接使用<code>synchronized</code>等关键字来控制并发，从来就不需要关心底层的编译器优化、缓存一致性等问题。所以，<strong>Java内存模型，除了定义了一套规范，还提供了一系列原语，封装了底层实现后，供开发者直接使用。</strong></p><h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h3><blockquote><p>在一个操作中就是cpu不可以在中途暂停然后再调度，既不被中断操作，要不执行完成，要不就不执行</p></blockquote><p>在Java中，为了保证原子性，提供了两个高级的字节码指令<code>monitorenter</code>和<code>monitorexit</code>。这两个字节码，在Java中对应的关键字就是<code>synchronized</code>。</p><p>因此，在Java中可以使用<code>synchronized</code>来保证方法和代码块内的操作是原子性的。</p><h3 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h3><blockquote><p>当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值</p></blockquote><p>Java内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值的这种依赖主内存作为传递媒介的方式来实现的。</p><p>Java中的<code>volatile</code>关键字提供了一个功能，那就是<strong>被其修饰的变量在被修改后可以立即同步到主内存</strong>，被其修饰的变量在每次是用之前都从主内存刷新。因此，可以使用<code>volatile</code>来保证多线程操作时变量的可见性。</p><p>除了<code>volatile</code>，Java中的<code>synchronized</code>和<code>final</code>两个关键字也可以实现可见性。只不过实现方式不同，这里不再展开了。</p><h3 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h3><blockquote><p>程序执行的顺序按照代码的先后顺序执行</p></blockquote><p>在Java中，可以使用<code>synchronized</code>和<code>volatile</code>来保证多线程之间操作的有序性。实现方式有所区别：</p><p><code>volatile</code>关键字会禁止指令重排。<code>synchronized</code>关键字保证同一时刻只允许一条线程操作。</p><h3 id="END"><a href="#END" class="headerlink" title="END"></a>END</h3><p><a href="https://blog.cayzlh.com/2018/08/28/2018082802/">synchronized的一些记录</a>。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 转载 </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM (内存区域控制参数及对应溢出异常)</title>
      <link href="/blog/2018/08/19/95c0309a.html"/>
      <url>/blog/2018/08/19/95c0309a.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>开发过程中，或程序运行过程中每次遇到OutOfMemory异常或GC异常或StackOverflowError异常我们都是一堆参数乱配，<br>都把值调大，只是大体知道是跟jvm内存分配有关, 具体应该怎么调，对应的异常应该调整那些参数，<br>或者换句话说，jvm内存分配区域中都分别对应那些参数大多数情况下都是不知道的，只是把相关的参数跳上去，预期结果都是应该起作用，到底能不能起作用，自己心里也没底。<br>下面就来说一下jvm堆、栈、方法区等内存区域对应的参数，及每个区域可能抛出的异常类型，发生异常的场景分析。 </p></blockquote><h3 id="参数类型"><a href="#参数类型" class="headerlink" title="参数类型"></a>参数类型</h3><ul><li>堆空间参数</li><li>栈空间参数</li><li>方法区空间参数</li><li>本机直接内存参数</li></ul><h3 id="异常类型"><a href="#异常类型" class="headerlink" title="异常类型"></a>异常类型</h3><ul><li>1.OutOfMemory异常</li><li>2.StackOverflowError异常</li></ul><h3 id="辅助参数说明"><a href="#辅助参数说明" class="headerlink" title="辅助参数说明"></a>辅助参数说明</h3><ul><li>-XX:+HeapDumpOnOutOfMemoryError 打印堆内存异常时打印出快照信息</li><li>-XX:+HeapDumpPath 快照输出路径</li><li>-Xmn指定eden区的大小</li><li>-XX:SurvirorRation来调整幸存区的大小</li><li>-XX:PretenureSizeThreshold设置进入老年代的阀值</li></ul><h3 id="参数说明、对应场景的异常"><a href="#参数说明、对应场景的异常" class="headerlink" title="参数说明、对应场景的异常"></a>参数说明、对应场景的异常</h3><h4 id="堆内存参数"><a href="#堆内存参数" class="headerlink" title="堆内存参数"></a>堆内存参数</h4><p>-Xms：堆最小值（新生代和老年代之和）</p><p>-Xmx：堆最大值（新生代和老年代之和）</p><p>当最小值=最大值时，这时堆内存是不可扩展的。</p><p>例：-Xms80M -Xmx80M</p><p>通常将-Xmx和-Xms设置为一样的大小来减少gc的次数，堆内存不足时抛出OutOfMemoryError异常。</p><h4 id="栈内存参数"><a href="#栈内存参数" class="headerlink" title="栈内存参数"></a>栈内存参数</h4><p>-Xss</p><p>例：-Xss128k</p><p>单线程下无论栈帧太大还是栈容量太小，及引用深度超过虚拟机允许深度都会抛出StackOverflowError每个方法压入栈的帧大小是不一致的。<br>多线程下当每个线程分配栈帧太大内存不能够扩展时抛出OutOfMemoryError异常线程栈帧越大，可创建的线程越少。</p><h4 id="方法区参数"><a href="#方法区参数" class="headerlink" title="方法区参数"></a>方法区参数</h4><p>-XX:PermSize方法区内存最小值</p><p>-XX:MaxPermSize 方法区内存最大值</p><p>各个线程共享的内存区域，主要用来存储类的元数据、常量、静态变量、即时编译器编译后的代码等数据</p><p>例：-XX:PermSize=20M -XX:MaxPermSize=20M</p><p>异常类型 OutOfMemoryError :</p><p>原因：常量过多，或代理反射等使用频繁</p><h4 id="本机直接内存参数"><a href="#本机直接内存参数" class="headerlink" title="本机直接内存参数"></a>本机直接内存参数</h4><p>-XX:MaxDirectMemorySize</p><p>例：-XX:MaxDirectMemorySize=10M</p><p>不足时抛出OutOfMemory异常</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM (对象访问内部实现过程)</title>
      <link href="/blog/2018/08/19/e43d0ef1.html"/>
      <url>/blog/2018/08/19/e43d0ef1.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>对象访问 涉及到对象的地址变更状态变更，内存地址移动，变量、接口、实现类、方法、父类型等。</p></blockquote><h3 id="句柄方式-访问"><a href="#句柄方式-访问" class="headerlink" title="句柄方式 (访问)"></a>句柄方式 (访问)</h3><p><img src="https://github.com/cayzlh/git-img-repository/raw/master/blog/jubing.png" alt="句柄方式"></p><h3 id="指针方式-访问"><a href="#指针方式-访问" class="headerlink" title="指针方式 (访问)"></a>指针方式 (访问)</h3><p><img src="https://github.com/cayzlh/git-img-repository/raw/master/blog/zhizhen.png" alt="指针方式"></p><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p>句柄访问方式：reference中存储的是稳定的地址，对象变更时只会改变句柄实例数据指针，引用本身不需要修改。</p><p>指针访问方式：优点速度快，节省了指针定位时间开销。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM (垃圾收集)</title>
      <link href="/blog/2018/08/19/99ebe472.html"/>
      <url>/blog/2018/08/19/99ebe472.html</url>
      
        <content type="html"><![CDATA[<h2 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h2><p>经典的垃圾回收算法以下几种：</p><h3 id="标记–清除算法-Mark-Sweep"><a href="#标记–清除算法-Mark-Sweep" class="headerlink" title="标记–清除算法(Mark-Sweep)"></a>标记–清除算法(Mark-Sweep)</h3><p>回收前状态：</p><p><img src="https://github.com/cayzlh/git-img-repository/raw/master/blog/before.png" alt="回收前"></p><p>回收后状态：</p><p><img src="https://github.com/cayzlh/git-img-repository/raw/master/blog/before.png" alt="回收后"></p><h4 id="优缺点："><a href="#优缺点：" class="headerlink" title="优缺点："></a>优缺点：</h4><p>优点：算法执行分为两个阶段标记与清除，所有的回收算法，基本都基于标记回收算法做了深度优化</p><p>缺点：效率问题，内存空间碎片（不连续的空间）</p><h3 id="复制算法-Copying"><a href="#复制算法-Copying" class="headerlink" title="复制算法(Copying)"></a>复制算法(Copying)</h3><p>回收前状态：</p><p>Eden内存空间 8</p><p><img src="https://github.com/cayzlh/git-img-repository/raw/master/blog/Eden8.png" alt="Eden内存空间 8"></p><p>Survivor1空间（From空间）1</p><p><img src="https://github.com/cayzlh/git-img-repository/raw/master/blog/Survivor1.png" alt="Survivor1空间（From空间）1"></p><p>Survivor2空间(To空间) 1</p><p><img src="https://github.com/cayzlh/git-img-repository/raw/master/blog/Survivor2.png" alt="Survivor2空间(To空间) 1"></p><p>Eden内存空间与Survivor空间 8:1</p><p><img src="https://github.com/cayzlh/git-img-repository/raw/master/blog/Eden_Survivor_8-1.png" alt="Eden内存空间与Survivor空间 8:1"></p><p>回收后状态：</p><p><img src="https://github.com/cayzlh/git-img-repository/raw/master/blog/aftergc.png" alt="回收后状态"></p><p>Survivor1空间（From空间）1</p><p><img src="https://github.com/cayzlh/git-img-repository/raw/master/blog/Survivor11.png" alt="Survivor1空间（From空间）1"></p><p>Eden内存空间与Survivor空间 8:1</p><p><img src="https://github.com/cayzlh/git-img-repository/raw/master/blog/EdenSurvivor8-1.png" alt="Eden内存空间与Survivor空间 8:1"></p><h4 id="优缺点：-1"><a href="#优缺点：-1" class="headerlink" title="优缺点："></a>优缺点：</h4><p>优点比较标记清除算法，避免了回收造成的内存碎片问题</p><p>缺点：以局部的内存空间牺牲为代价，不过空间的浪费比较小，默认8:1的比例1是浪费的。复制也有一定的效率与空间成本</p><h3 id="标记整理算法-Mark-Compact"><a href="#标记整理算法-Mark-Compact" class="headerlink" title="标记整理算法(Mark-Compact)"></a>标记整理算法(Mark-Compact)</h3><p>回收前状态：</p><p><img src="https://github.com/cayzlh/git-img-repository/raw/master/blog/201808190401.png" alt="回收前状态"></p><p>回收后状态：</p><p><img src="https://github.com/cayzlh/git-img-repository/raw/master/blog/201808190402.png" alt="回收前状态"></p><h4 id="优缺点：-2"><a href="#优缺点：-2" class="headerlink" title="优缺点："></a>优缺点：</h4><p>优点：避免了，空间的浪费，与内存碎片问题。</p><p>缺点：整理时复制有效率成本。<br>​     </p><h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h2><h3 id="七种垃圾收集器"><a href="#七种垃圾收集器" class="headerlink" title="七种垃圾收集器"></a>七种垃圾收集器</h3><ul><li>1、 Serial（串行GC）-XX:+UseSerialGC</li><li>2、 ParNew（并行GC）-XX:+UseParNewGC</li><li>3、 Parallel Scavenge（并行回收GC）</li><li>4、 Serial Old（MSC）（串行GC）-XX:+UseSerialGC</li><li>5、 CMS（并发GC）-XX:+UseConcMarkSweepGC</li><li>6、 Parallel Old（并行GC）-XX:+UseParallelOldGC</li><li>7、 G1（JDK1.7update14才可以正式商用）</li></ul><p><img src="https://github.com/cayzlh/git-img-repository/raw/master/blog/201808190403.png" alt="七种垃圾收集器"></p><h3 id="调优方法"><a href="#调优方法" class="headerlink" title="调优方法"></a>调优方法</h3><h4 id="新对象预留新生代"><a href="#新对象预留新生代" class="headerlink" title="新对象预留新生代"></a>新对象预留新生代</h4><p>由于fullGC(老年代)的成本远比minorGC（新生代和老年代）的成本大，所以给应用分配一个合理的新生代空间，尽量将对象分配到新生代减小fullGC的频率</p><h4 id="大对象进入老年代"><a href="#大对象进入老年代" class="headerlink" title="大对象进入老年代"></a>大对象进入老年代</h4><p>将大对象直接分配到老年代，保持新生代对象的结构的完整性，以提高GC效率， 以通过-XX:PretenureSizeThreshold设置进入老年代的阀值</p><h4 id="稳定与震荡的堆大小"><a href="#稳定与震荡的堆大小" class="headerlink" title="稳定与震荡的堆大小"></a>稳定与震荡的堆大小</h4><p>稳定的对大小是对垃圾回收有利的，方法将-Xms和-Xmx的大小一致</p><h4 id="吞吐量优先"><a href="#吞吐量优先" class="headerlink" title="吞吐量优先"></a>吞吐量优先</h4><p>尽可能减少系统执行垃圾回收的总时间，故采用并行垃圾回收器</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-XX:+UseParallelGC或使用-XX:+UseParallelOldGC</span><br></pre></td></tr></table></figure><h4 id="降低停顿"><a href="#降低停顿" class="headerlink" title="降低停顿"></a>降低停顿</h4><p>使用CMS回收器,同时减少fullGC的次数</p><h3 id="获取gc信息的方法"><a href="#获取gc信息的方法" class="headerlink" title="获取gc信息的方法"></a>获取gc信息的方法</h3><ul><li> <code>-verbose:gc或者-XX:+PrintGC</code>　　获取gc信息</li><li> <code>-XX:+PrintGCDetails</code>　　获取更加详细的gc信息</li><li> <code>-XX:+PrintGCTimeStamps</code>　　获取GC的频率和间隔</li><li> <code>-XX:+PrintHeapAtGC</code>　　获取堆的使用情况</li><li> <code>-Xloggc:D:\gc.log</code>　　指定日志情况的保存路径</li></ul><h3 id="jvm调优实战-tomcat启动加速"><a href="#jvm调优实战-tomcat启动加速" class="headerlink" title="jvm调优实战-tomcat启动加速"></a>jvm调优实战-tomcat启动加速</h3><p>在tomcat的bin/catalina.bat文件的开头添加相关的配置</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM (虚拟机内存)</title>
      <link href="/blog/2018/08/19/b8276f2d.html"/>
      <url>/blog/2018/08/19/b8276f2d.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>JAVA程序运行与虚拟机之上，运行时需要内存空间。虚拟机执行JAVA程序的过程中会把它管理的内存划分为不同的数据区域方便管理。</p></blockquote><p>虚拟机管理内存数据区域划分如下图：</p><p><img src="https://github.com/cayzlh/git-img-repository/raw/master/blog/Runtime-data-area.png" alt="虚拟机管理内存数据区域划分"></p><h3 id="数据区域分类"><a href="#数据区域分类" class="headerlink" title="数据区域分类:"></a>数据区域分类:</h3><ul><li>方法区：(Method Area)</li><li>虚拟机栈：(VM Stack)</li><li>本地方法栈 ：(Native Method Stack)</li><li>堆：(Heap)</li><li>程序计数器 ：(Program Counter Register)</li><li>直接内存：(Direct Memory)</li></ul><p>说明：</p><h4 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h4><p>行号指示器，字节码指令的分支、循环、跳转、异常处理、线程恢复(CPU切换)，每条线程都需要一个独立的计数器，线程私有内存互不影响,该区域不会发生内存溢出异常。</p><h4 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h4><p>是线程私有的，声明周期与线程相同，虚拟机栈是Java方法执行的内存模型，每个方法被执行时都会创建一个栈帧，即方法运行期间的基础数据结构。<br>栈帧用于存储：局部变量表、操作数栈、动态链接、方法出口等，每个方法执行中都对应虚拟机栈帧从入栈到处栈的过程。</p><p>是一种数据结构，是虚拟机中的局部变量表，对应物理层之上的程序数据模型。</p><p>局部变量表，是一种程序运行数据模型，存放了编译期可知的各种数据类型例如：</p><p>Boolean、byte、char、short、int、float、long、double、对象引用类型(对象内存地址变量，指针或句柄)。<br>程序运行时，根据局部变量表分配栈帧空间大小，在运行中，大小是不变的异常类型：stackOverFlowError 线程请求栈深度大于虚拟机允许深度 OutOfMemory 内存空间耗尽无法进行扩展。</p><h4 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h4><p>与虚拟机栈类似，虚拟机栈为Java程序服务，本地方法栈支持虚拟机的运行服务，具体实现由虚拟机厂商决定，也会抛出 stackOverFlowError、OutOfMemory异常。</p><h4 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h4><p>是虚拟机管理内存中最大的一部分，被所有线程共享，用于存放对象实例(对象、数组)，物理上不连续的内存空间，由于GC收集器，分代收集。<br>所以划分为：新生代 Eden、From SurVivor空间、To SurVivor空间，allot buffer(分配空间)，可能会划分出多个线程私有的缓冲区，老年代。</p><h4 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h4><p>与堆一样属于线程共享的内存区域，用于存储虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码（动态加载OSGI）等数据。理论上属于java虚拟机的一部分，为了区分开来叫做 Non-Heap非堆。</p><p>这个区域可以选择不进行垃圾回收，该区域回收目的主要是常量池的回收，及类型的卸载class,内存区不足时会抛出OutOfMemory异常</p><p>运行时常量池：</p><p>方法区的一部分，Class的版本、字段、接口、方法等，及编译期生成的各种字面量、符号引用，编译类加载后存放在该区域。会抛出OutOfMemory异常。</p><h4 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h4><p>直接内存不属于虚拟内存区域，是一种基于通道与缓冲区的IO方式，可以使用本地函数直接分配堆外内存，在堆中存储引用的外部内存地址，通过引用完成对直接引用内存的操作。<br>1.4之后提供的NIO显著提高效率，避免了堆内存与Native内存的来回复制操作，不受虚拟机内存控制，会抛出OUtOfMemory异常。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
