<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="utf-8">
    <meta name="keywords" content="深入理解Java虚拟机, Java虚拟机, 虚拟机类加载机制">
    <meta name="description" content="Ant丶的网络日志, CAYZLH网络日志, CAYZLH, CAYZLH主页, Ant丶空间">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <!-- Global site tag (gtag.js) - Google Analytics -->

    <meta name="google-site-verification" content="VrcbMTVpFGlHkIERHBt753dAtXKF4qirjnDweuXSRJw">


    <!-- Global site tag (gtag.js) - Google Analytics -->

<script async src="https://www.googletagmanager.com/gtag/js?id=UA-129095667-1"></script>
<script>
    window.dataLayer = window.dataLayer || [];
    function gtag() {
        dataLayer.push(arguments);
    }

    gtag('js', new Date());
    gtag('config', 'UA-129095667-1');
</script>


    <title>虚拟机类加载机制 | BLOG | CAYZLH</title>

    
    <!-- Third-Party CSS -->
    

        <link rel="shortcut icon" href="/blog/image/favicon.ico">
        <link rel="icon" type="image/png" href="/blog/image/favicon-192x192.png" sizes="192x192">
        <link rel="apple-touch-icon" sizes="180x180" href="/blog/image/apple-touch-icon.png">

        <link rel="stylesheet" href="/blog/css/thirdparty/bootstrap.min.css">
        <link rel="stylesheet" href="/blog/css/thirdparty/octicons.css">
        <link rel="stylesheet" href="/blog/css/thirdparty/hover-min.css">
        <link rel="stylesheet" href="/blog/css/thirdparty/user-content.min.css">
        <link rel="stylesheet" href="/blog/css/thirdparty/syntax.css">
        <link rel="stylesheet" href="/blog/css/thirdparty/gitalk.css">

        <!-- My CSS -->
        <link rel="stylesheet" href="/blog/css/common.css">

        <link rel="stylesheet" href="/blog/css/sidebar-post-nav.css">

        <link rel="stylesheet" href="/blog/css/blog-page.css">
        <!-- CSS set in page -->

        
        <link rel="stylesheet" href="/blog/css/sidebar-popular-repo.css">
    

    <!-- CSS set in layout -->
    <link rel="stylesheet" type="text/css" href="//cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css">

    
        <script type="text/javascript" src="/blog/js/thirdparty/jquery.min.js"></script>
        <script type="text/javascript" src="/blog/js/thirdparty/bootstrap.min.js"></script>
        <script type="text/javascript" src="/blog/js/lock.js"></script>
    

    
        <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
        <script src="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>

        <link rel="stylesheet" href="//imsun.github.io/gitment/style/default.css">
        <script src="//imsun.github.io/gitment/dist/gitment.browser.js"></script>

        <script src="//unpkg.com/valine/dist/Valine.min.js"></script>
        <script src="//cdn.jsdelivr.net/npm/twikoo@1.2.0/dist/twikoo.all.min.js"></script>

    

    <link rel="stylesheet" href="//cdn.bootcss.com/highlight.js/9.2.0/styles/github.min.css">
    <script src="//cdn.bootcss.com/highlight.js/9.2.0/highlight.min.js"></script>
<meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/blog/atom.xml" title="BLOG | CAYZLH" type="application/atom+xml">
</head>

<body>
<header class="site-header">
    <div class="site-header-topbar">
        <div class="container">
            <div class="topbar-menu">

    
        <div class="item">
            <a href="https://www.cayzlh.com" title="导航">
                导航
            </a>
        </div>
    
        <div class="item">
            <a href="/blog/categories/" title="分类">
                分类
            </a>
        </div>
    
        <div class="item">
            <a href="/blog/tags/" title="标签">
                标签
            </a>
        </div>
    
        <div class="item">
            <a href="/blog/links/" title="链接">
                链接
            </a>
        </div>
    
        <div class="item">
            <a href="/blog/about" title="关于">
                关于
            </a>
        </div>
    

</div>
        </div>
    </div>
    <div class="container">
        <a id="site-header-brand" href="/blog/" title="BLOG | CAYZLH">
            <span class="octicon octicon-watch"></span>
            BLOG | CAYZLH
        </a>

        <nav class="site-header-nav" role="navigation">
    
        <div class=" site-header-nav-item hvr-underline-from-center">
            <a href="/blog/" title="Home">
                Home
            </a>
            
        </div>
    
        <div class=" site-header-nav-item hvr-underline-from-center">
            <a href="/blog/archives" title="Archives">
                Archives
            </a>
            
        </div>
    
        <div class=" site-header-nav-item hvr-underline-from-center">
            <a href="/blog/" title="Learning">
                Learning
            </a>
            
                <ul class="submenu">
                    

                        <li>
                            <a href="/blog/categories/%E4%B9%A6%E7%B1%8D/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8B/">
                                <span>深入理解Java虚拟机</span>
                            </a>
                        </li>

                    

                        <li>
                            <a href="/blog/categories/%E4%B9%A6%E7%B1%8D/%E3%80%8AMyBatis%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95%E3%80%8B/">
                                <span>MyBatis技术内幕</span>
                            </a>
                        </li>

                    

                        <li>
                            <a href="/blog/categories/Java/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">
                                <span>Java设计模式</span>
                            </a>
                        </li>

                    
                </ul>
            
        </div>
    
</nav>
    </div>
</header>

<main class="content">
    <!-- 标题部分 -->
<section class="jumbotron geopattern" data-pattern-id="虚拟机类加载机制">
    <div class="container">
        <div id="jumbotron-meta-info">
            <h1>虚拟机类加载机制</h1>
            <span class="meta-info">
                <a><span class="octicon octicon-calendar"></span> 2018-09-14</a>
                
                    <a><span class="octicon octicon-book"></span></a>
                    
                        <a href="/blog/categories/%E4%B9%A6%E7%B1%8D/">书籍</a>
                    
                        <a href="/blog/categories/%E4%B9%A6%E7%B1%8D/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8B/">《深入理解Java虚拟机》</a>
                    
                
                
                    
                
            </span>
        </div>

    </div>
</section>
<script>
    $(document).ready(function(){

        $('.geopattern').each(function(){
            $(this).geopattern($(this).data('pattern-id'));
        });

    });
</script>
<!-- 文章内容部分 -->
<article class="post container " itemscope itemtype="http://schema.org/BlogPosting" id="openwrite-container">
    <div class="row">
        <div class="col-md-9 markdown-body">
            <!-- 文章开始部分 -->
            <!--<div style="text-align:center">-->
<!--    <img style="display:inline-block" width="130" height="27"-->
<!--         src="https://cdn.jsdelivr.net/gh/cayzlh/git-img-repository@master/uPic/640-3.gif"-->
<!--         data-loaded="true">-->
<!--    <img style="display:inline-block" width="41" height="35"-->
<!--         src="https://cdn.jsdelivr.net/gh/cayzlh/git-img-repository@master/uPic/640-4.gif"-->
<!--         data-loaded="true">-->
<!--    <img style="display:inline-block"-->
<!--         width="130" height="27"-->
<!--         src="https://cdn.jsdelivr.net/gh/cayzlh/git-img-repository@master/uPic/640-5.gif"-->
<!--         data-loaded="true">-->
<!--</div>-->
            <blockquote>
<p>代码编译的结果从本地机器码变为字节码，是存储格式发展的一小步，确实编程语言发展的一大步</p>
</blockquote>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><strong>虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的类加载机制。</strong></p>
<p>与哪些编译时需要进行连接工作的语言不同，在Java语言里面，类型的加载和连接过程都是在程序运行期间完成的，这样会在类加载时稍微增加一些性能开销，但时却能为Java应用程序提供高度的灵活性，Java中天生可以动态扩展的语言特性就是依赖运行期动态加载和动态连接这个特点实现的。例如，<strong>如果编写一个使用接口的应用程序，可以等到运行时再指定其实际的实现。</strong>这种组装应用程序的方式广泛应用于Java程序之中。</p>
<h2 id="类加载的时机"><a href="#类加载的时机" class="headerlink" title="类加载的时机"></a>类加载的时机</h2><p>类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括了：<strong>加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initialization）、使用（Using）和卸载（Unloading）七个阶段。</strong>其中验证、准备和解析三个部分统称为连接（Linking）。</p>
<p><img src="https://gitee.com/cayzlh/img-repo/raw/master/2020/04/19/kYqehE.png" alt="类的生命周期"></p>
<p>加载、验证、准备、初始化和卸载这五个阶段的顺序是确定的，类的加载过程必须按照这种顺序按<strong>部就班地开始，</strong>而解析阶段则不一定：它在某些情况下可以在初始化阶段之后再开始，这是为了支持Java语言的运行时绑定（也称为动态绑定或晚期绑定）。<em>注意这里是按部就班地“开始”，而不是按部就班地“进行”或“完成”，因为这些阶段通常都是互相交叉地混合式进行地，通常会再下一个阶段执行地过程中调用或激活另外一个阶段。</em></p>
<p>Java虚拟机规范严格规定了有且只有四种情况必须立即对类进行“初始化”（而加载、验证、准备自然需要在此之前开始）：</p>
<ul>
<li>遇到new、getstatic、putstatic或invokestatic这4条字节码指令时，如果类没有进行过初始化，则需要先触发其初始化。生成这4条指令地最常见地Java代码场景是：使用new关键字实例化对象地时候、读取或设置一个类字段（被final修饰、已在编译器把结果放入常量池地静态字段除外）地时候，以及调用一个类地静态方法地时候。</li>
<li>使用java.lang.reflect包地方法对类进行发射调用地时候，如果类没有进行过初始化，则需要先触发其初始化。</li>
<li>当初始化一个类地时候，如果发现其父类还没有进行过初始化，则需要先触发其父类地初始化。</li>
<li>当虚拟机启动时，用户需要指定一个要执行地主类（包括main()方法地那个类），虚拟机会先初始化这个主类。</li>
</ul>
<h3 id="被动引用地例子之一"><a href="#被动引用地例子之一" class="headerlink" title="被动引用地例子之一"></a>被动引用地例子之一</h3><p>父类：</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>cayzlh<span class="token punctuation">.</span>reference1<span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">/**
 * 被动使用类字段演示一
 *  通过子类引用父类的静态字段，不会导致子类初始化
 */</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SuperClass</span> <span class="token punctuation">{</span>

    <span class="token keyword">static</span> <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"SuperClass init.."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> value <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span>

<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>子类：</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>cayzlh<span class="token punctuation">.</span>reference1<span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SubClass</span> <span class="token keyword">extends</span> <span class="token class-name">SuperClass</span> <span class="token punctuation">{</span>

    <span class="token keyword">static</span> <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"SubClass init.."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>执行：</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>cayzlh<span class="token punctuation">.</span>reference1<span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">/**
 * 非主动使用类字段演示
 */</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">NotInitialization</span> <span class="token punctuation">{</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>SuperClass<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>运行结果：</p>
<p><img src="https://gitee.com/cayzlh/img-repo/raw/master/2020/04/19/B2cEYa.png" alt="运行结果"></p>
<p>上述代码运行之后， 只会输出“SuperClass init..”，而不会输出“SubClass init..”。<strong>对于静态字段，只有直接定义这个字段的类才会被初始化，因此通过子类来引用父类中定义的静态字段，只会触发父类的初始化而不会触发子类的初始化。</strong>至于是否要触发子类的加载和验证，再虚拟机规范中没有明确规定，这点取决于虚拟机的具体实现。</p>
<h3 id="被动引用的例子之二"><a href="#被动引用的例子之二" class="headerlink" title="被动引用的例子之二"></a>被动引用的例子之二</h3><p>代码：</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>cayzlh<span class="token punctuation">.</span>reference2<span class="token punctuation">;</span>

<span class="token keyword">import</span> com<span class="token punctuation">.</span>cayzlh<span class="token punctuation">.</span>reference1<span class="token punctuation">.</span>SuperClass<span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">/**
 * 通过数组定义来引用，不会触发此类的初始化
 */</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">NotInitialization</span> <span class="token punctuation">{</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        SuperClass<span class="token punctuation">[</span><span class="token punctuation">]</span> sca <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SuperClass</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>运行结果：</p>
<p><img src="https://gitee.com/cayzlh/img-repo/raw/master/2020/04/19/SslBsv.png" alt="运行结果"></p>
<p>运行之后发现没有输出“SuperClass init..”，说明并没有触发<code>SuperClass</code>类的初始化阶段。</p>
<h3 id="被动引用的例子之三"><a href="#被动引用的例子之三" class="headerlink" title="被动引用的例子之三"></a>被动引用的例子之三</h3><p>代码1：</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>cayzlh<span class="token punctuation">.</span>reference3<span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">/**
 * 常量在编译阶段会存入调用类的常量池中，
 * 本质上没有直接引用到定义定义常量的类，
 * 因此不能触发定义常量的类的初始化
 */</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConstClass</span> <span class="token punctuation">{</span>

    <span class="token keyword">static</span> <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"ConstClass init.."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> String HELLOWORLD <span class="token operator">=</span> <span class="token string">"Hello World."</span><span class="token punctuation">;</span>

<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>代码2：</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>cayzlh<span class="token punctuation">.</span>reference3<span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">/**
 * 非主动使用类字段演示
 */</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">NotInitialization</span> <span class="token punctuation">{</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>ConstClass<span class="token punctuation">.</span>HELLOWORLD<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>运行结果：</p>
<p><img src="https://gitee.com/cayzlh/img-repo/raw/master/2020/04/19/MDhSi7.png" alt="运行结果"></p>
<p>上述代码运行之后，没有输出“ConstClass init..”，这是因为虽然在Java源码中引用了ConstClass类中的常量HELLOWORLD，但是在编译阶段将此常量的值”Hello World.”存储到了<code>NotInitialization</code>类的常量池中，对常量ConstClass.HELLOWORLD的引用都被转化为NotInitialization类对自身常量池的引用了。<strong>也就是说实际上NotInitialization的Class文件之中并没有ConstClass类的符号引用入口，这两个类在编译成Class之后就不再存在任何联系了。</strong></p>
<h2 id="类加载的过程"><a href="#类加载的过程" class="headerlink" title="类加载的过程"></a>类加载的过程</h2><p>类加载的的全过程，也就是加载、验证、准备、解析和初始化这五个阶段的过程。</p>
<h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><p>“加载”（Loading）阶段是“类加载”（Class Loading）过程的一个阶段。在加载阶段，虚拟机需要完成以下三件事情：</p>
<ul>
<li>1）<strong>通过一个类的全限定名来获取定义此类的二进制字节流</strong></li>
<li>2）<strong>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</strong></li>
<li>3）<strong>在Java堆中生成一个代表这个类的<code>java.lang.Class</code>对象，作为方法区将这些数据的访问入口</strong></li>
</ul>
<p>虚拟机规范的这三点要求实际上并不具体，因此虚拟机实现与具体应用的灵活度相当大。<em>相对于类加载过程的其他阶段，加载阶段（加载阶段中获取类的二进制字节流的动作）是开发期可控性最强的阶段，因为加载阶段是既可以使用系统提供的类加载器来完成，也可以由用户自定义的类加载器去完成，开发人员可以通过自己定义的类加载器去控制字节流的获取方式。</em></p>
<h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><blockquote>
<p>验证时连接阶段的第一步，这一阶段的目的时为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。</p>
</blockquote>
<p><strong>Class文件并不一定要求用Java源码编译而来，可以使用任何途径，包括用十六进制编辑器直接编写来产生Class文件。</strong>如果虚拟机不检查输入的字节流，对其完全信任的话，很可能会因为载入了有害的字节流而导致系统崩溃，所以验证时虚拟机自身保护的一项重要工作。</p>
<p>虚拟机大致上会完成下面四个阶段的检查过程：<strong>文件格式验证、元数据验证、字节码验证和符号引用验证。</strong></p>
<h4 id="文件格式验证"><a href="#文件格式验证" class="headerlink" title="文件格式验证"></a>文件格式验证</h4><p>第一阶段要验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理：</p>
<ul>
<li>是否以魔数<code>0xCAFEBABE</code>开头</li>
<li>主、次版本号是否在当前虚拟机处理范围之内</li>
<li>常量池的常量中是否有不被支持的常量类型</li>
<li>指向常量的各种索引值是否有只想不存在常量或不符合类型的常量</li>
<li>CONSTANT_Utf8_info型的常量中是否有不符合UTF8编码的数据</li>
<li>Class文件中各个部分及文件本身是否有被删除的额或附加的其他信息</li>
<li>······</li>
</ul>
<p>实际上第一阶段的验证还远远不止这些，该验证阶段的主要目的时保证输入的字节流能正确地解析并存储与方法区之内，格式上符合描述一个Java类型信息地要求。<strong>这阶段的验证时基于字节流进行的，经过这个阶段的验证之后，字节流才会流入内存的方法区中进行存储，所以以后的三个验证阶段都是基于方法区存储结构进行的。</strong></p>
<h4 id="元数据验证"><a href="#元数据验证" class="headerlink" title="元数据验证"></a>元数据验证</h4><p>第二阶段是堆字节码描述的信息进行语义分析，以保证其描述的信息符合Java语言的规范的要求，这个阶段包括：</p>
<ul>
<li>这个类是否有父类（除了java.lang.Object，所有的类都应当有父类）</li>
<li>这个类的父类是否继承了不允许被继承的类（被final修饰的类）</li>
<li>如果这个类不是抽象类，是否实现了其父类或接口之中要求实现的所有方法</li>
<li>类中的字段、方法是否与父类产生了矛盾（例如覆盖了父类的final字段，或者出现不符合规则的方法重载，例如方法参数都一致，但返回值类型却不同等）</li>
<li>······</li>
</ul>
<p>第二阶段的主要目的是对类的元数据信息进行语义校验，保证不存在不符合Java语言规范的元数据信息。</p>
<h4 id="字节码验证"><a href="#字节码验证" class="headerlink" title="字节码验证"></a>字节码验证</h4><p>第三阶段是整个验证过程中最复杂的一个阶段，主要工作是进行数据流和控制流分析。在第二阶段对元数据信息中的数据类型做完校验后，<strong>这阶段对类的方法体进行校验分析。这阶段的任务是保证被校验类的方法在运行时不会做出危害虚拟机安全的行为：</strong></p>
<ul>
<li>保证任意时刻<strong>操作数据栈</strong>与指令代码序列都能配合工作，例如不会出现类似的情况：<strong>在操作栈中放置了一个int类型的数据，使用时却按long类型来加载如本地变量表中。</strong></li>
<li>保证跳转指令不会跳转到方法体意外的字节码指令上。</li>
<li>保证方法体中的类型转换是有效的，例如<strong>可以把一个子类对象赋值给父类数据类型，这是安全的，但是把父类对象赋值给子类数据类型，甚至把对象赋值给与它毫无关系、完全不相干的数据类型，则是危险和不合法的。</strong></li>
<li>······</li>
</ul>
<p>如果一个类的方法体的字节码没有通过字节码验证，那肯定是有问题的；但如果一个方法体通过了字节码验证，也不能说明其一定就是安全的。即使字节码验证之中进行了大量的检查，也不能保证这一点。<strong>通俗一点讲就是，通过程序去校验程序逻辑是无法做到绝对准确的——不能通过程序准确的检查出程序是否能在有限的时间之内结束运行。</strong></p>
<h4 id="符号引用验证"><a href="#符号引用验证" class="headerlink" title="符号引用验证"></a>符号引用验证</h4><p>最后一个阶段的校验发生在<strong>虚拟机将符号引用转化直接引用的时候，</strong>这个自动转化将在连接的第三个阶段——解析阶段中发生。符号引用验证可以看作是对类自身以外（<strong>常量池中的各种符号引用</strong>）的信息进行匹配性的校验：</p>
<ul>
<li>符号引用中通过符号串描述的全限定名是否能找到对象的类。</li>
<li>在指定类中是否存在符合方法的字段描述符及简单名称所描述的方法和字段。</li>
<li>符号引用中的类、字段和方法的访问行（private、protected、public、default）是否可被当前类访问。</li>
<li>······</li>
</ul>
<p>符号引用验证的目的是确保解析动作能正常执行。</p>
<blockquote>
<p>验证阶段对于虚拟机的类加载机制来说，是一个非常重要的、但不一定时必要的阶段。如果所运行的全部代码（包括自己写的、第三方包中的代码）都已经被反复使用和验证过，在实施阶段就口可以考虑使用<code>-Xverify:none</code>参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。</p>
</blockquote>
<h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p><strong>准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在方法区中进行分配。</strong>这个阶段中有两个容易产生混淆的概念需要强调一下，首先是这时候进行内存分配的仅包括<strong>类变量（被<code>static</code>修饰的变量），而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在Java堆中。</strong>其次时这里所说的初始值“通常情况”下时数据类型的零值，假设一个类变量定义为：</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> value <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>那么变量value在准备阶段过后的初始值是0而不是123，因为这时候尚未开始执行任何Java方法，而把value赋值为123的putstatic指令是程序被编译后，存放于类结构器<clinit>()方法之中，所以value赋值为123的动作将在初始化阶段才会被执行。</clinit></p>
<p>“通常情况”下时数据类型的零值，那相对的会有一些“特殊情况”：如果类字段的字段属性表中存在ConstantValue属性，那在准备阶段变量value就会被初始化为ConstantValue属性所指的值，如：</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> value <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>编译时将会为value生成ConstantValues属性，在准备阶段虚拟机就会根据ConstantValue的设置将value赋值为123。</p>
<h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p><strong>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。</strong>解析阶段中所说的直接引用与符号引用有什么关联呢？</p>
<ul>
<li>符号引用（Symbolic Reference）：符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。富豪引用<strong>与虚拟机实现地内存布局无关</strong>，引用地目标并不一定已经加载到内存中。</li>
<li>直接引用（Direct Reference）：直接引用可以时直接指向目标地指针、相对偏移量或是一个能间接定位到目标的句柄。直接引用是<strong>与虚拟机实现的内存布局相关</strong>的，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同。<strong>如果有了直接引用，那引用的目标必定已经在内存中存在。</strong></li>
</ul>
<blockquote>
<p>解析动作主要针对类或接口、字段、类方法、接口方法四类符号引用进行，分别对应于常量池中的CONSTANT_Class_info、CONSTANT_Fieldref_info、CONSTANT_Methodref_info及CONSTANT_InterfaceMethodref_info四种常量类型。</p>
</blockquote>
<h4 id="类或接口的解析"><a href="#类或接口的解析" class="headerlink" title="类或接口的解析"></a>类或接口的解析</h4><p>要把一个类或者接口的符号引用解析为直接引用，需要以下三个步骤：</p>
<ol>
<li>如果该符号引用不是一个数组类型，那么虚拟机将会把该符号代表的全限定名称传递给类加载器去加载这个类。这个过程由于涉及验证过程所以可能会触发其他相关类的加载</li>
<li>如果该符号引用是一个数组类型，并且该数组的元素类型是对象。我们知道符号引用是存在方法区的常量池中的，该符号引用的描述符会类似”[java/lang/Integer”的形式，将会按照上面的规则进行加载数组元素类型，如果描述符如前面假设的形式，需要加载的元素类型就是java.lang.Integer ,接着由虚拟机将会生成一个代表此数组对象的直接引用</li>
<li>如果上面的步骤都没有出现异常，那么该符号引用已经在虚拟机中产生了一个直接引用，但是在解析完成之前需要对符号引用进行验证，主要是确认当前调用这个符号引用的类是否具有访问权限，如果没有访问权限将抛出java.lang.IllegalAccess异常</li>
</ol>
<h4 id="字段解析"><a href="#字段解析" class="headerlink" title="字段解析"></a>字段解析</h4><p>对字段的解析需要首先对其所属的类进行解析，因为字段是属于类的，只有在正确解析得到其类的正确的直接引用才能继续对字段的解析。对字段的解析主要包括以下几个步骤：</p>
<ol>
<li>如果该字段符号引用就包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用，解析结束</li>
<li>否则，如果在该符号的类实现了接口，将会按照继承关系从下往上递归搜索各个接口和它的父接口，如果在接口中包含了简单名称和字段描述符都与目标相匹配的字段，那么久直接返回这个字段的直接引用，解析结束</li>
<li>否则，如果该符号所在的类不是Object类的话，将会按照继承关系从下往上递归搜索其父类，如果在父类中包含了简单名称和字段描述符都相匹配的字段，那么直接返回这个字段的直接引用，解析结束</li>
<li>否则，解析失败，抛出java.lang.NoSuchFieldError异常</li>
</ol>
<p>如果最终返回了这个字段的直接引用，就进行权限验证，如果发现不具备对字段的访问权限，将抛出java.lang.IllegalAccessError异常</p>
<h4 id="类方法解析"><a href="#类方法解析" class="headerlink" title="类方法解析"></a>类方法解析</h4><p>进行类方法的解析仍然需要先解析此类方法的类，在正确解析之后需要进行如下的步骤：</p>
<ol>
<li>类方法和接口方法的符号引用是分开的，所以如果在类方法表中发现class_index（类中方法的符号引用）的索引是一个接口，那么会抛出java.lang.IncompatibleClassChangeError的异常</li>
<li>如果class_index的索引确实是一个类，那么在该类中查找是否有简单名称和描述符都与目标字段相匹配的方法，如果有的话就返回这个方法的直接引用，查找结束</li>
<li>否则，在该类的父类中递归查找是否具有简单名称和描述符都与目标字段相匹配的字段，如果有，则直接返回这个字段的直接引用，查找结束</li>
<li>否则，在这个类的接口以及它的父接口中递归查找，如果找到的话就说明这个方法是一个抽象类，查找结束，返回java.lang.AbstractMethodError异常</li>
<li>否则，查找失败，抛出java.lang.NoSuchMethodError异常</li>
</ol>
<p>如果最终返回了直接引用，还需要对该符号引用进行权限验证，如果没有访问权限，就抛出java.lang.IllegalAccessError异常。</p>
<h4 id="接口方法解析"><a href="#接口方法解析" class="headerlink" title="接口方法解析"></a>接口方法解析</h4><p>同类方法解析一样，也需要先解析出该方法的类或者接口的符号引用，如果解析成功，就进行下面的解析工作：</p>
<ol>
<li>如果在接口方法表中发现class_index的索引是一个类而不是一个接口，那么也会抛出java.lang.IncompatibleClassChangeError的异常</li>
<li>否则，在该接口方法的所属的接口中查找是否具有简单名称和描述符都与目标字段相匹配的方法，如果有的话就直接返回这个方法的直接引用。</li>
<li>否则，在该接口以及其父接口中查找，直到Object类，如果找到则直接返回这个方法的直接引用</li>
<li>否则，查找失败</li>
</ol>
<p>接口的所有方法都是public，所以不存在访问权限问题</p>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p><strong>初始化阶段才真正开始执行类中定义的java程序代码。</strong></p>
<p>初始化阶段是执行类构造器<clinit>()方法的过程。在以下四种情况下初始化过程会被触发执行：</clinit></p>
<ol>
<li><p>遇到new、getstatic、putstatic或invokestatic这4条字节码指令时，如果类没有进行过初始化，则需先触发其初始化。生成这4条指令的最常见的java代码场景是：使用new关键字实例化对象、读取或设置一个类的静态字段(被final修饰、已在编译器把结果放入常量池的静态字段除外)的时候，以及调用类的静态方法的时候。</p>
</li>
<li><p>使用java.lang.reflect包的方法对类进行反射调用的时候</p>
</li>
<li><p>当初始化一个类的时候，如果发现其父类还没有进行过初始化、则需要先出发其父类的初始化</p>
</li>
<li><p>jvm启动时，用户指定一个执行的主类(包含main方法的那个类)，虚拟机会先初始化这个类</p>
</li>
</ol>
<p>在准备阶段，变量已经赋过一次系统要求的初始值，二在初始阶段，则是根据程序员通过程序制定的主观计划去初始化类变量和其他资源。</p>
<h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><blockquote>
<p>虚拟机设计团队把类加载阶段中的“通过一个类的全限定名来获取描述此类的二进制字节流”这个动作放到Java虚拟机外部去实现，以便让应用程序自己决定如何去获取所需要的类。实现这个动作的代码模块被称为“类加载器”。</p>
</blockquote>
<p>类加载器可以说是Java语言的一项创新，也是Java语言流行的重要原因之一。</p>
<h3 id="类与类加载器"><a href="#类与类加载器" class="headerlink" title="类与类加载器"></a>类与类加载器</h3><p>类加载器虽然只用于实现类的加载动作，但它在Java程序中起到的作用却远远不限于类加载阶段。<strong>对于任意一个类，都需要由加载它的类加载器和这个类本身一同确定其在Java虚拟机中的唯一性。</strong>通俗一点：比较两个类是否“相等”，只有在这两个类是由同一个类加载器加载的前提之下才有意义，否则，即使这两个类来源同一个Class文件，只要记载他们的类加载器不同，那这两个类就必定不相等。</p>
<h3 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h3><p>站在Java虚拟机的角度看，只存在两种不同的类加载器：<strong>一种是启动类加载器（Bootstrap ClassLoader），这个类加载器使用<code>C++</code>语言实现，是虚拟机自身的一部分；另外一种就是所有其他的类加载器，这些类加载器都由Java语言实现，独立于虚拟机外部，并且全部都继承自抽象类<code>java.lang.ClassLoader</code>。</strong></p>
<p>绝大部分Java程序都会使用到以下三种系统提供的类加载器：</p>
<ul>
<li>启动类加载器（Bootstrap ClassLoader）：负责将存放在<code>bin</code>目录中的，或者被<code>-Xbootclasspath</code>参数所指定的路径中的，并且是虚拟机识别的类库加载到虚拟机内存中。启动类加载器无法被Java程序直接引用。</li>
<li>扩展类加载器（Extension ClassLoader）：负责加载<code>lib\ext</code>目录中，或者被<code>java.ext.dirs</code>系统变量所指定的路径中的所有类库，开发者可以直接使用扩展类加载器。</li>
<li>应用程序加载器（Application ClassLoader）：由于这个类加载器是ClassLoader中的<code>getSystemClassLoader()</code>方法的返回值，所以一般也称为系统类加载器。<strong>负责加载用户类路径上所指定的类库，开发者可以直接使用这个类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。</strong></li>
</ul>
<p>我们的应用程序都是由这三种类加载器互相配合进行加载的，如果有必要，还可以加入自己定义的类加载器。这些类加载器之间的关系一般如图所示：</p>
<p><img src="https://gitee.com/cayzlh/img-repo/raw/master/2020/04/19/Kg9O8N.png" alt="类加载器双亲委派模型"></p>
<p>双亲委派模型除了要求顶层的启动类加载器外，其余的类加载器都应当有自己的父类加载器。这里类加载器之间的父子关系一般不会以继承的关系实现，而是都使用组合关系来复用父类加载器的代码。</p>
<blockquote>
<p>双亲委派模型的工作过是：<strong>如果一个类加载器收到了类加的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当附加在七反馈自己无法完成这个加载请求（<em>它的搜索范围中没有找到所需的类</em>）时，子加载器才会尝试自己去加载。</strong></p>
</blockquote>
<p>使用双亲委派模型来组织类加载器之间的关系，好处就是Java类随着它的类加载器一起具备了一种带有优先级的层次关系。<strong>双亲委派模型对于保证Java程序的稳定运行很重要，但它的实现却非常简单，</strong>实现双亲委派的代码都集中在<code>java.lang.ClassLoader</code>的<code>loadClass()</code>方法之中。先检查是否已经被加载过，若没有加载则调用父类加载器的<code>loadClass()</code>方法，若父类加载器为空则默认使用启动类加载器作为父类加载器。如果父类加载失败，则在抛出<code>ClassNotFoundException</code>异常后，再调用自己的<code>findClass()</code>方法进行加载。</p>
<h3 id="破坏双亲委派模型"><a href="#破坏双亲委派模型" class="headerlink" title="破坏双亲委派模型"></a>破坏双亲委派模型</h3><h4 id="第一次破坏"><a href="#第一次破坏" class="headerlink" title="第一次破坏"></a>第一次破坏</h4><p>由于双亲委派模型是在JDK1.2之后才被引入的，而类加载器和抽象类java.lang.ClassLoader则在JDK1.0时代就已经存在，面对已经存在的用户自定义类加载器的实现代码，Java设计者引入双亲委派模型时不得不做出一些妥协。在此之前，用户去继承java.lang.ClassLoader的唯一目的就是为了重写loadClass()方法，因为虚拟机在进行类加载的时候会调用加载器的私有方法loadClassInternal()，而这个方法唯一逻辑就是去调用自己的loadClass()。</p>
<h4 id="第二次破坏"><a href="#第二次破坏" class="headerlink" title="第二次破坏"></a>第二次破坏</h4><p>双亲委派模型的第二次“被破坏”是由这个模型自身的缺陷所导致的，双亲委派很好地解决了各个类加载器的基础类的同一问题（越基础的类由越上层的加载器进行加载），基础类之所以称为“基础”，是因为它们总是作为被用户代码调用的API，但世事往往没有绝对的完美。</p>
<h4 id="如果基础类又要调用回用户的代码，那该么办？"><a href="#如果基础类又要调用回用户的代码，那该么办？" class="headerlink" title="如果基础类又要调用回用户的代码，那该么办？"></a>如果基础类又要调用回用户的代码，那该么办？</h4><p>一个典型的例子就是JNDI服务，JNDI现在已经是Java的标准服务，<br> 它的代码由启动类加载器去加载（在JDK1.3时放进去的rt.jar），但JNDI的目的就是对资源进行集中管理和查找，它需要调用由独立厂商实现并部署在应用程序的ClassPath下的JNDI接口提供者的代码，但启动类加载器不可能“认识”这些代码。</p>
<p><strong>为了解决这个问题，Java设计团队只好引入了一个不太优雅的设计：线程上下文类加载器(Thread Context ClassLoader)。这个类加载器可以通过java.lang.Thread类的setContextClassLoader()方法进行设置，如果创建线程时还未设置，他将会从父线程中继承一个，如果在应用程序的全局范围内都没有设置过的话，那这个类加载器默认就是应用程序类加载器。</strong></p>
<p>有了线程上下文加载器，JNDI服务就可以使用它去加载所需要的SPI代码，也就是父类加载器请求子类加载器去完成类加载的动作，这种行为实际上就是打通了双亲委派模型层次结构来逆向使用类加载器，实际上已经违背了双亲委派模型的一般性原则，但这也是无可奈何的事情。Java中所有涉及SPI的加载动作基本上都采用这种方式，例如JNDI、JDBC、JCE、JAXB和JBI等。</p>
<h4 id="第三次破坏"><a href="#第三次破坏" class="headerlink" title="第三次破坏"></a>第三次破坏</h4><p>双亲委派模型的第三次“被破坏”是由于用户对程序动态性的追求导致的，这里所说的“动态性”指的是当前一些非常“热门”的名词：代码热替换、模块热部署等，简答的说就是机器不用重启，只要部署上就能用。<br> OSGi实现模块化热部署的关键则是它自定义的类加载器机制的实现。每一个程序模块(Bundle)都有一个自己的类加载器，当需要更换一个Bundle时，就把Bundle连同类加载器一起换掉以实现代码的热替换。在OSGi幻境下，类加载器不再是双亲委派模型中的树状结构，而是进一步发展为更加复杂的网状结构，当受到类加载请求时，OSGi将按照下面的顺序进行类搜索：<br> 1）将java.＊开头的类委派给父类加载器加载。<br> 2）否则，将委派列表名单内的类委派给父类加载器加载。<br> 3）否则，将Import列表中的类委派给Export这个类的Bundle的类加载器加载。<br> 4）否则，查找当前Bundle的ClassPath，使用自己的类加载器加载。<br> 5）否则，查找类是否在自己的Fragment Bundle中，如果在，则委派给Fragment Bundle的类加载器加载。<br> 6）否则，查找Dynamic Import列表的Bundle，委派给对应Bundle的类加载器加载。<br> 7）否则，类加载器失败。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>介绍了类加载过程的<strong>加载、验证、准备、解析和初始化</strong>五个阶段中虚拟机进行了哪些动作，还介绍了类加载器的工作原理及其堆虚拟机的意义</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li>周志明，深入理解Java虚拟机：JVM高级特性与最佳实践，机械工业出版社 </li>
<li><a href="https://www.jianshu.com/p/166c5360a40b" target="_blank" rel="external nofollow noopener noreferrer">破坏双亲委派模型</a></li>
</ul>

            <!-- 文章结尾部分 -->
            
                
<div style="text-align:center;width:100%">
    <span class="octicon octicon-tag-add"></span>
    
        <a style="color: #24292e;" href="/blog/tags/Java/">Java</a>
    
        <a style="color: #24292e;" href="/blog/tags/JVM/">JVM</a>
    
        <a style="color: #24292e;" href="/blog/tags/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8B/">《深入理解Java虚拟机》</a>
    
</div>



    <div style="text-align:center;width:100%">
        <img src="https://cdn.jsdelivr.net/gh/cayzlh/git-img-repository@master/uPic/640-2.gif">
    </div>




<div>
    <h4>相关推荐</h4>
    <ul class="post-copyright">
        
        <li class="post-copyright-author">
            <a href="/blog/2018/09/08/bc3decee.html">Java内存区域内存溢出异常</a>
        </li>
        
        <li class="post-copyright-author">
            <a href="/blog/2018/09/18/badf9669.html">Java内存模型与线程</a>
        </li>
        
        <li class="post-copyright-author">
            <a href="/blog/2018/09/11/ddb92a08.html">垃圾收集器与内存分配策略</a>
        </li>
        
        <li class="post-copyright-author">
            <a href="/blog/2018/09/21/7876bd5d.html">线程安全与锁优化</a>
        </li>
        
        <li class="post-copyright-author">
            <a href="/blog/2018/09/16/4cd43d51.html">虚拟机字节码执行引擎</a>
        </li>
        
        <li class="post-copyright-author">
            <a href="/blog/2018/09/13/fea7515.html">虚拟机性能监控与故障处理工具</a>
        </li>
        
    </ul>
    <br><br>
</div>



<div>
    <h4>版权声明</h4>
    <blockquote>
        <ul class="post-copyright">
            <li class="post-copyright-author">
                <strong>本文来源： </strong>
                
                <a href="https://www.cayzlh.com/blog" title="🐳Ant丶" rel="noopener external nofollow noreferrer" target="_blank">🐳Ant丶</a></li>
            <li class="post-copyright-link">
                <strong>本文链接：</strong>
                <a href="https://www.cayzlh.com/2018/09/14/cdffca23.html" title="/blog/%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6">https://www.cayzlh.com/2018/09/14/cdffca23.html</a>
            </li>
            <li class="post-copyright-license">
                <strong>版权声明： </strong>
                
                    文章内容仅用作学习和分享，如有雷同，纯属拷贝。
                
            </li>
        </ul>
    </blockquote>
</div>


            
            
                <div class="comment">
    <br><br><br>
    
        

        

        

        
                <h4>留言区</h4>
                <div id="tcomment"></div>
                <script src="https://cdn.jsdelivr.net/npm/twikoo@1.2.0/dist/twikoo.all.min.js"></script>
                <script>
                twikoo.init({
                        envId: 'cayzlh-7g0jcpd31a34ccaf',
                        el: '#tcomment',
                        region: 'ap-guangzhou', // 环境地域，默认为 ap-shanghai，如果您的环境地域不是上海，需传此参数
                        // path: 'window.location.pathname', // 用于区分不同文章的自定义 js 路径，如果您的文章路径不是 location.pathname，需传此参数
                })
                </script>
        

    
</div>

            
        </div>
        <div class="col-md-3 markdown-body">
            <h4>文章目录</h4>
            <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#概述"><span class="toc-text">概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#类加载的时机"><span class="toc-text">类加载的时机</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#被动引用地例子之一"><span class="toc-text">被动引用地例子之一</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#被动引用的例子之二"><span class="toc-text">被动引用的例子之二</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#被动引用的例子之三"><span class="toc-text">被动引用的例子之三</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#类加载的过程"><span class="toc-text">类加载的过程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#加载"><span class="toc-text">加载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#验证"><span class="toc-text">验证</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#文件格式验证"><span class="toc-text">文件格式验证</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#元数据验证"><span class="toc-text">元数据验证</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#字节码验证"><span class="toc-text">字节码验证</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#符号引用验证"><span class="toc-text">符号引用验证</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#准备"><span class="toc-text">准备</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#解析"><span class="toc-text">解析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#类或接口的解析"><span class="toc-text">类或接口的解析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#字段解析"><span class="toc-text">字段解析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#类方法解析"><span class="toc-text">类方法解析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#接口方法解析"><span class="toc-text">接口方法解析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#初始化"><span class="toc-text">初始化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#类加载器"><span class="toc-text">类加载器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#类与类加载器"><span class="toc-text">类与类加载器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#双亲委派模型"><span class="toc-text">双亲委派模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#破坏双亲委派模型"><span class="toc-text">破坏双亲委派模型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#第一次破坏"><span class="toc-text">第一次破坏</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#第二次破坏"><span class="toc-text">第二次破坏</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#如果基础类又要调用回用户的代码，那该么办？"><span class="toc-text">如果基础类又要调用回用户的代码，那该么办？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#第三次破坏"><span class="toc-text">第三次破坏</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#小结"><span class="toc-text">小结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#参考"><span class="toc-text">参考</span></a></li></ol>
        </div>
    </div>
    
</article>


<script>
    hljs.initHighlightingOnLoad();
</script>
</main>
<footer class="container">
    <div class="site-footer">
        
    <div class="card text-center">
        <ul class="list-inline" style="margin-left: 0;">
            
                <li>
                    <a target="_blank" href="https://github.com/cayzlh" rel="external nofollow noopener noreferrer">
                          <span class="fa-stack fa-lg">
                            <i class="fa fa-circle fa-stack-2x"></i>
                            <i class="fa fa-github fa-stack-1x fa-inverse">
                                
                            </i>
                          </span>
                    </a>
                </li>
            
                <li>
                    <a target="_blank" href="https://telegram.me/cayzlh" rel="external nofollow noopener noreferrer">
                          <span class="fa-stack fa-lg">
                            <i class="fa fa-circle fa-stack-2x"></i>
                            <i class="fa fa-rocket fa-stack-1x fa-inverse">
                                
                            </i>
                          </span>
                    </a>
                </li>
            
                <li>
                    <a target="_blank" href="mailto:chenanyu@cayzlh.com">
                          <span class="fa-stack fa-lg">
                            <i class="fa fa-circle fa-stack-2x"></i>
                            <i class="fa fa-envelope fa-stack-1x fa-inverse">
                                
                            </i>
                          </span>
                    </a>
                </li>
            
        </ul>
    </div>


        <div class="site-footer-links mobile-hidden">
            
                
                
            
        </div>

        <div class="site-footer-links mobile-hidden">
        
            <span class="meta-info-index hvr-grow">
                
                    <a href="https://www.cayzlh.com">
                        🐳Ant丶 &copy; 2020
                    </a>
                
            </span>
        
        
            <span class="meta-info-index hvr-grow">
                <a href="http://beian.miit.gov.cn" target="_blank" rel="external nofollow noopener noreferrer">粤ICP备20058712号-1</a>
            </span>
        
        </div>

        

        
    </div>
    

    
        <!-- Third-Party JS -->
        <script type="text/javascript" src="/blog/js/thirdparty/geopattern.min.js"></script>
        <!-- My JS -->
        <script type="text/javascript" src="/blog/js/script.js"></script>
    

    
        <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js">
        </script>
    
</footer>
</body>
</html>